<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>わたしろぐ on わたしろぐ</title>
    <link>http://tatamo.81.la/blog/</link>
    <description>Recent content in わたしろぐ on わたしろぐ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Fri, 09 Feb 2018 19:30:00 +0900</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>JavaScript/TypeScriptで競技プログラミングをするには 後編</title>
      <link>http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-02/</link>
      <pubDate>Fri, 09 Feb 2018 19:30:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-02/</guid>
      <description>
        &lt;p&gt;主要コンテストサイトのJavaScript対応状況、および私がJavaScript/TypeScriptで競技プログラミングをする時に気をつけていることなどを書きます。
今回は後者についてです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-01/&#34;&gt;前回の記事&lt;/a&gt;ではコンテストサイトのJavaScript対応状況をメインに書きました。
この記事では、実際にJavaScript/TypeScriptで競技プログラミングをする際に気をつけている点について書いていきます。&lt;/p&gt;

&lt;h2 id=&#34;競技プログラミングにおけるjavascriptの致命的な問題点&#34;&gt;競技プログラミングにおけるJavaScriptの致命的な問題点&lt;/h2&gt;

&lt;p&gt;残念ながら、JavaScriptが競技プログラミングに向いていない理由となる仕様がいくつか存在します。&lt;/p&gt;

&lt;h3 id=&#34;末尾再帰最適化が実装されていない上にコールスタック上限が小さく-変更できない&#34;&gt;末尾再帰最適化が実装されていない上にコールスタック上限が小さく、変更できない&lt;/h3&gt;

&lt;p&gt;JavaScriptではPythonの&lt;code&gt;sys.setrecursionlimit()&lt;/code&gt;のように再帰呼び出し回数の最大値を変更することができません。
コールスタックの上限は処理系に依存しますが、たとえばnode.js v5.12.0 (x64)では15712です。
また、末尾再帰最適化はES2015の仕様に盛り込まれていた内容ですが、現在においてもこれを実装している処理系は非常に少ないのが現状です。&lt;/p&gt;

&lt;p&gt;これらの要因のため、要素数が数万程度の何かに対して手っ取り早く再帰でDFSを書こうとすると、ほぼ間違いなくMaximum call stack size exceededで落ちます。
自分で配列をスタックとして使ってBFSと同じような書き方で書くか、DFS専用のイテレータでも自作しましょう。&lt;/p&gt;

&lt;h3 id=&#34;64bit整数値を扱う手段が存在しない&#34;&gt;64bit整数値を扱う手段が存在しない&lt;/h3&gt;

&lt;p&gt;JavaScriptのすべての数値は、いわゆるdouble型で保持されています。
&lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt;で確認できますが、整数値としての精度が保証される最大値は2^53-1までです。
これはおよそ9.0*10^15程度なので、入力中に10^18ぐらいの数値が与えられるとその時点で詰みです。&lt;/p&gt;

&lt;p&gt;まあ&lt;a href=&#34;https://github.com/broofa/node-int64&#34;&gt;Int64&lt;/a&gt;とか&lt;a href=&#34;https://github.com/silentmatt/javascript-biginteger&#34;&gt;biginteger&lt;/a&gt;的なものを使う・作るしかないです。&lt;/p&gt;

&lt;p&gt;余談ですが、JavaScriptは歴史的経緯から複数のJavaScriptファイルをまとめて一つのソースコードとすることが頻繁に行われているため、browserifyやwebpackといったツールを使えばサードパーティのライブラリを使うことは割と平気で可能です(ソースコード上限を越えなければ)。
しかし競技プログラミング的にどうなのかよくわからないので、私は今のところ自作以外のライブラリを使ったことはないです。&lt;/p&gt;

&lt;p&gt;まあできないことを気にしても仕方がありませんので、以上のような問題点が存在することを把握しておく、ということが大切です。&lt;/p&gt;

&lt;h2 id=&#34;入出力テンプレート&#34;&gt;入出力テンプレート&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import * as fs from &amp;quot;fs&amp;quot;;

const input = (fs.readFileSync(&amp;quot;/dev/stdin&amp;quot;, &amp;quot;utf8&amp;quot;) as string).split(&amp;quot;\n&amp;quot;);
const n = +input[0];
// const [n] = input[0].split(&amp;quot; &amp;quot;).map((x: string): number =&amp;gt; +x);
const a = [];
for(let i=0;i&amp;lt;n;i++){
	a.push(input[i+1].split(&amp;quot; &amp;quot;).map((x:string):number=&amp;gt;+x));
}

console.log(input);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;入力部分は多少長くなってしまうので、テンプレートを用意しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;N M
A1 A2 ... A3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような入力に対しては、少し書き換えて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;const [n, m] = input[0].split(&amp;quot; &amp;quot;).map((x: string): number =&amp;gt; +x);
const a = input[1].split(&amp;quot; &amp;quot;).map((x: string): number =&amp;gt; +x);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすれば対応できます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fs.readFileSync(&amp;quot;/dev/stdin&amp;quot;, &amp;quot;utf8&amp;quot;)&lt;/code&gt;部分がWindowsでは動かない気がするので、適当にUNIX環境を用意しましょう。&lt;/p&gt;

&lt;p&gt;package.jsonやtsconfig.jsonについては、&lt;a href=&#34;https://github.com/Tatamo/comp/tree/master/template/ts&#34;&gt;このへん&lt;/a&gt;に上げています。&lt;/p&gt;

&lt;h2 id=&#34;typescript-複数のプログラムを同時にコンパイルする際の注意&#34;&gt;(TypeScript) 複数のプログラムを同時にコンパイルする際の注意&lt;/h2&gt;

&lt;p&gt;npm scripts等で自動コンパイルを行っている場合などに、&lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/modules.html&#34;&gt;モジュール&lt;/a&gt;でない複数のTypeScriptプログラムを同時にコンパイルすると、すべてのプログラムの変数が同一スコープ上で扱われるため、&lt;code&gt;input&lt;/code&gt;などの変数が衝突してエラーになります。&lt;/p&gt;

&lt;p&gt;これは、それぞれのプログラムがモジュールであると認識されれば解決されます。
そのためのワークアラウンドとして、1行目でfsを取得する際に&lt;code&gt;require()&lt;/code&gt;ではなく&lt;code&gt;import&lt;/code&gt;文を使うようにしています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import * as fs from &amp;quot;fs&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;export&lt;/code&gt;を行っていなくても、TypeScript的にはこれだけでモジュールとして扱われるようなので、複数のプログラムを同時にコンパイルすることができるようになります。&lt;/p&gt;

&lt;h2 id=&#34;array-prototype-shift-の計算量はo-n&#34;&gt;Array.prototype.shift()の計算量はO(n)&lt;/h2&gt;

&lt;p&gt;JavaScriptで計算量について触れられている資料は少ないので、下手をすると&lt;a href=&#34;http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.shift&#34;&gt;仕様書&lt;/a&gt;まで見に行かないと気付けないのですが、&lt;code&gt;shift()&lt;/code&gt;の計算量はO(n)です。
inputに10万行程度の入力を入れて、先頭から1行ずつ&lt;code&gt;shift()&lt;/code&gt;で取り出すと、それだけで2秒が過ぎます。
&lt;code&gt;push()&lt;/code&gt;および&lt;code&gt;pop()&lt;/code&gt;は高速でできるので、普通の配列はスタックとしてのみ使用し、キューは自前で実装する必要があります。&lt;/p&gt;

&lt;p&gt;参考までに、私は次のようなコードを使用しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;export default class Queue&amp;lt;T&amp;gt; {
	private _in: Array&amp;lt;T&amp;gt;;
	private _out: Array&amp;lt;T&amp;gt;;

	get length(): number {
		return this._in.length + this._out.length;
	}

	constructor(iterable?: Iterable&amp;lt;T&amp;gt;) {
		this._in = iterable === undefined ? new Array&amp;lt;T&amp;gt;() : [...iterable];
		this._out = new Array&amp;lt;T&amp;gt;();
	}

	private _fix() {
		this._out = this._in.reverse().concat(this._out);
		this._in = new Array&amp;lt;T&amp;gt;();
	}

	push(...values: Array&amp;lt;T&amp;gt;): void {
		this._in.push(...values);
	}

	shift(): T | undefined {
		if (this._out.length === 0) this._fix();
		return this._out.pop();
	}

	toArray(): Array&amp;lt;T&amp;gt; {
		this._fix();
		return this._out.slice().reverse();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;array-prototype-fill-は同一オブジェクトで埋められる&#34;&gt;Array.prototype.fill()は同一オブジェクトで埋められる&lt;/h2&gt;

&lt;p&gt;まあこれは気付かなかった私がよくないという例ですが、一応。&lt;/p&gt;

&lt;p&gt;0埋めされた3×3の二次元配列を用意しようとして、次のようなコードを書いたとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const a = new Array(3).fill(new Array(3).fill(0));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあ確かに0埋めされた3×3の二次元配列は得られますが、a[0]とa[1]とa[2]は同じ一次元配列を参照しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;a[0][0] = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすると、aの中身は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[[1,0,0]
 [1,0,0]
 [1,0,0]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となってしまいます。
そのため、多次元配列を初期化するときは横着せずにforで回すようにするか、適当な要素を入れてからmapで埋めます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const a = new Array(3);
for(let i=0; i&amp;lt;3; i++){
	a[i].push(new Array(3).fill(0));
}

const a = new Array(3).fill([]).map(()=&amp;gt;new Array(3).fill());
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;以上が、私がJavaScript/TypeScriptで競技プログラミングをする際に気をつけている点です。&lt;/p&gt;

&lt;p&gt;こうして書き出してみると、数値が大きくなると詰むとか再帰がろくに使えないだとかでろくな言語じゃないなという感じですね。
競技プログラミングの問題自体がC/C++で解くことを想定されている節があるので、仕方のないことではあります。&lt;/p&gt;

&lt;p&gt;とはいえ、以上のことさえ気に留めていれば、JavaScript/TypeScriptを使っていることが原因で詰むことはほとんどないと思います。
JavaScriptそのものは非常に書きやすい言語なので、ハマりどころを把握した上で選択肢にしていただける方が増えればいいなと思っています。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>JavaScript/TypeScriptで競技プログラミングをするには 前編</title>
      <link>http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-01/</link>
      <pubDate>Fri, 09 Feb 2018 17:25:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-01/</guid>
      <description>
        &lt;p&gt;主要コンテストサイトのJavaScript対応状況、および私がJavaScript/TypeScriptで競技プログラミングをする時に気をつけていることなどを書きます。
今回は前者についてです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;追記：&lt;a href=&#34;http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-02/&#34;&gt;後編&lt;/a&gt;書きました。&lt;/p&gt;

&lt;p&gt;競技プログラミングをやるのにC++を選択しない時点で物好きという気はしますが、私は普段からTypeScriptをメインに使って問題を解いています。
この前AtCoder Problemsに&lt;a href=&#34;http://kenkoooo.com/atcoder/?kind=lang&#34;&gt;Language Owners Ranking&lt;/a&gt;ができていたので見てみたらTypeScriptで1位を取っていました(2018年2月時点)。
ちなみにJavaScriptランカーのAC数と比較すると3位にも入れていません。&lt;/p&gt;

&lt;p&gt;AtCoderレーティングは水色、コンテスト参加回数もぎりぎり二桁に達する程度で、あまり真面目にやっているほうではないので参考になるかどうかはわかりませんが、JavaScriptまたはTypeScriptで競技プログラミングをするときに気をつけるべき点などを書いていきます。&lt;/p&gt;

&lt;h2 id=&#34;javascriptで競技プログラミングをすることについて&#34;&gt;JavaScriptで競技プログラミングをすることについて&lt;/h2&gt;

&lt;p&gt;こんな記事を書いていて言うのもどうかと思いますが、他の言語ではなくJavaScriptを競技プログラミングに使用することに、何かメリットはあるのか？と聞かれれば、おそらく目立った利点を挙げることはできないと思います。&lt;/p&gt;

&lt;p&gt;とはいえ、&lt;code&gt;function&lt;/code&gt;だらけの黒魔術のようなコードとスクリプト言語特有の遅さは、ここ数年のJavaScriptの目覚ましい進化によって克服されてきています。
現在のJavaScript処理系はJITコンパイルが主流のため、C++やJavaのような言語には敵わないとはいえ、PythonやRubyのようなスクリプト言語よりも圧倒的に高速です。
またECMAScript2015の登場により、もはや&lt;code&gt;function&lt;/code&gt;と書く必要はなくなりました。&lt;/p&gt;

&lt;p&gt;もっとも、JavaScriptが競技プログラミングに不向きな理由もいくつか存在することは事実です(次の記事で紹介します)。
ですが、近年のJavaScriptが以前とは見違えるほどに書きやすい言語になったことから、決して選択肢に入らない言語ではないと私は考えています。&lt;/p&gt;

&lt;p&gt;JavaScriptを使用する最大のモチベーションは、それが書きやすい・手慣れた言語であるからという点に尽きると思いますが、これは重要なことです。&lt;/p&gt;

&lt;h2 id=&#34;コンテストサイトのモダンjavascriptやtypescript対応状況&#34;&gt;コンテストサイトのモダンJavaScriptやTypeScript対応状況&lt;/h2&gt;

&lt;p&gt;JavaScript/TypeScriptで競技プログラミングをするためには、コンテストサイトのオンラインジャッジシステムが少なくともJavaScriptに対応している必要があります。
特にJavaScriptという言語は、ECMAScript2015の策定によって言語仕様が大きく拡張され、その後もECMAScript2016, ECMAScript2017と機能追加が進んでおり、ここ数年間での移り変わりが非常に激しい言語であるため、言語環境が整備されていることの重要性は大きいです。&lt;/p&gt;

&lt;p&gt;ACM-ICPCではC/C++, Java, Python2/3しか使えないのは周知の事実ですが、比較的多くの言語に対応しているコンテストサイトであってもJavaScriptの対応が行き届いていないのが現状です。&lt;/p&gt;

&lt;p&gt;まずは、日本である程度知名度がある(と思われる)コンテストサイトについて、2018年2月現在でのJavaScriptの対応状況を見ていきたいと思います。
なおTopCoderはJavaScript非対応のため除外しています。&lt;/p&gt;

&lt;h3 id=&#34;atcoder-http-atcoder-jp&#34;&gt;&lt;a href=&#34;http://atcoder.jp/&#34;&gt;AtCoder&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript node v5.12.0&lt;/li&gt;
&lt;li&gt;TypeScript 2.1.6&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TypeScriptについてはnode.jsのバージョンが記載されていなかったのですが、おそらく5.12.0であると思われます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://node.green&#34;&gt;node.green&lt;/a&gt;によると、5.12.0ではES2015の対応率は59%程度となっており、次の項目の6.4.0で対応率が95%まで上昇していることを見ると残念な感じです。
しかしAtCoderで注目するべきは、オンラインジャッジ系のサイトでは非常に珍しく、TypeScriptに対応していることです。
たとえば、分割代入構文はnode.js v5.12.0では未対応のため、以下のコードはシンタックスエラーとなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const [a, b, ...c] = [1, 2, 3, 4, 5];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかしこれをTypeScript2.1.6に食わせると、勝手にES5(= Bad Old DaysのJavaScript)仕様にpolyfillしてトランスパイルしてくれるため、以下のJavaScriptコードが生成されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var _a = [1, 2, 3, 4, 5], a = _a[0], b = _a[1], c = _a.slice(2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;つまり言語欄でTypeScriptを選択することで、ES2015の仕様をもう少し多く使うことができるようになります。&lt;/p&gt;

&lt;p&gt;もっともProxyなんかは全く使うことができないのですが、とはいえSet・Map、class、アロー関数および分割代入が使えるので、競技プログラミングで用いる範囲内なら十分にモダンなJavaScriptを書くことができます。
コンパイラオプションなしでTypeScript2.1.6にSetやMapを食わせると&lt;code&gt;Cannot find name &#39;Map&#39;.&lt;/code&gt;等のエラーが出たような気もするのですが、AtCoder上だと特にエラーメッセージは表示されずに無理矢理動かしてくれます。&lt;/p&gt;

&lt;p&gt;TypeScriptはJavaScriptの完全なスーパーセットであるため、すべてのJavaScriptコードはTypeScriptコードとみなすことができます。
TypeScriptの仕様を全く使っていないJavaScriptを書いたとしても、AtCoderではTypeScriptとして提出することをおすすめします。&lt;/p&gt;

&lt;p&gt;なんともいえない感じですが、これでもモダンJavaScriptの対応状況としてはよっぽどマシなほうです。&lt;/p&gt;

&lt;h3 id=&#34;yukicoder-https-yukicoder-me&#34;&gt;&lt;a href=&#34;https://yukicoder.me/&#34;&gt;yukicoder&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;(正直ここがどれくらいの知名度があるのかあまり把握していませんが)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript node v9.2.1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;調べた中で最も最新バージョンに近く、ES2017までのほぼすべての機能が使用可能なJavaScript環境が用意されています。
モダンなJavaScriptを書きながら競技プログラミングを楽しみたいなら、このサイトはおすすめといえます。
TypeScriptには対応していませんが、まあトランスパイルされた.jsファイルを提出すれば済む話でしょう。&lt;/p&gt;

&lt;h3 id=&#34;aizu-online-judge-http-judge-u-aizu-ac-jp-onlinejudge&#34;&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/&#34;&gt;AIZU ONLINE JUDGE&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript node 0.10.36&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/AOJ_tutorial.pdf&#34;&gt;http://judge.u-aizu.ac.jp/onlinejudge/AOJ_tutorial.pdf&lt;/a&gt; に書いてありました。&lt;/p&gt;

&lt;p&gt;ほぼ完全なES5時代の遺物です。
どうしてもJavaScriptが書きたいなら、babel-polyfillあたりをかませてJavaScriptからさらに古い時代のJavaScriptにトランスパイルして提出するのがいいでしょう。&lt;/p&gt;

&lt;h3 id=&#34;codeforces-http-codeforces-com&#34;&gt;&lt;a href=&#34;http://codeforces.com/&#34;&gt;Codeforces&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript V8 4.8.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;node.jsを使っていただきたいところです。
V8 4.8.0はnode.jsでは5.12と6.0.0の間ぐらいなので、ES2015の対応状況ではAtCoderのやや上といったところです。古いことにかわりはありませんが。&lt;/p&gt;

&lt;p&gt;最大の問題点は、標準入出力の方法がnode.jsとは全く異なるという点です。
node.jsでは&lt;code&gt;console.log()&lt;/code&gt;で出力しますが、V8の場合は&lt;code&gt;print()&lt;/code&gt;か&lt;code&gt;write()&lt;/code&gt;になります。&lt;/p&gt;

&lt;p&gt;JavaScriptの処理系としてnode.jsを使わずにわざわざV8を生で叩いている人間ってどれくらいいるんでしょうか？
ちょっと怖いのであまり触れたくない感じです。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;ここまで書いていて思った以上に分量が膨らんでしまいました。
&lt;a href=&#34;http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-02/&#34;&gt;後編&lt;/a&gt;では、実際にJavaScript/TypeScriptで問題を解く上で気をつけている点を書いていきます。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>Freecivの操作、右ドラッグの活用について</title>
      <link>http://tatamo.81.la/blog/2018/02/08/freeciv-right-drag/</link>
      <pubDate>Thu, 08 Feb 2018 00:30:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/02/08/freeciv-right-drag/</guid>
      <description>
        &lt;p&gt;数年前に某所で書いた記事ですが、埋もれていて参照しづらくなっていたので手を加えて再掲することにしました。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Freecivに慣れてくると、迅速な操作のために都市タブを使うと便利だということに気付くでしょう。
このとき、ゲーム画面での右ドラッグと都市タブを併用するとさらに都市タブを使いやすくすることができます。
とはいえ、どうも右ドラッグという動作は癖が強く、使いどころが限られたものであるという印象が強いと思われています。
その特性を理解し、使いどころを見極めるとより効率的な帝国運営が可能になるでしょう。&lt;/p&gt;

&lt;p&gt;右ドラッグの基本的な使い方については、ヘルプの「操作」を参照します。&lt;/p&gt;

&lt;blockquote&gt;右クリック後にドラッグ: エリアごとユニットあるいは都市を選択する&lt;br&gt;
Shift+右クリック後にドラッグ: エリアの内容を既存の選択に追加する&lt;/blockquote&gt;

&lt;p&gt;Shiftキーとの併用は、既に選択されているものに追加が可能になるという効果があるようです。
では、右ドラッグ時の動作をいくつかの場合に分けて見てみましょう。&lt;/p&gt;

&lt;h3 id=&#34;1-都市外のユニットの選択&#34;&gt;(1) 都市外のユニットの選択&lt;/h3&gt;

&lt;p&gt;迎撃によるスタックキルを避けるため、艦隊を分散させて敵国領海に突入させることはよくある例です。
このような場合、右ドラッグで全部隊を選択し、テンキー移動をすることによって、陣形を保持したまま艦隊を前進させることができます。便利。&lt;/p&gt;

&lt;h3 id=&#34;2-都市の選択&#34;&gt;(2) 都市の選択&lt;/h3&gt;

&lt;p&gt;右ドラッグで、複数の都市を範囲に含めます。
そうしたら、都市タブを開きましょう。
都市の選択が保持された状態になっているので、本土の都市を全て選択する場合など、首都を選択→「選択」→「同じ島」よりも簡単です。
本土から同じ方向にある複数の海外領土をまとめて選択することもできます。+Shiftも組み合わせてとても便利。&lt;/p&gt;

&lt;p&gt;また、都市を含めて選択を行うと、インターフェイスが都市選択のモードに切り替わります。
都市を左クリックすることによって都市の選択/非選択の切り替えができるので、右ドラッグ選択の微調整に使用できて便利です。
このモードは、右クリックで視点を移動させたり、都市を含めずに再度右ドラッグするなどして解除できます。&lt;/p&gt;

&lt;h3 id=&#34;3-都市内外のユニットの選択&#34;&gt;(3) 都市内外のユニットの選択&lt;/h3&gt;

&lt;p&gt;都市内に待機しているユニット、都市外に駐留しているユニット、それらをまとめて選択できます。
とはいえ、都市内の防御ユニットもすべて選択されてしまうという欠点はあります。
同一タイル内の全ユニットを選択するショートカットであるVキーがあまり使われていないことを考えても、このやり方はあまり便利ではなさそうです。
また、必然的に都市選択も同時に行われます。&lt;/p&gt;

&lt;p&gt;さて、(3)はともかく、(1)や(2)は使いどころによっては結構便利そうです。ではどうして右クリックが癖の強い操作だと思われているのでしょうか。
最大の問題は、都市とユニットが同時に選択されることにあります。
③でユニットを一括選択する場合、都市選択も同時に行われるわけですが、やはりUIが都市選択モードになってしまうのです。
ユニットを選択後、マウスドラッグでユニットを移動させようとしても、一度右クリックなどで都市選択モードを解除しないとユニットは動きません。(※ショートカットキーでの操作は可能です)
また、(2)の操作を行うにしても、選択しようと思った都市とその範囲内にユニットが1つもいないといった状況はまずないでしょう。結果として(3)の状態になります。
都市を選択するためだけに、防御体勢をとっていたり見張りをしたりしているユニットを全て起こしてしまうのは便利とはいえません。&lt;/p&gt;

&lt;p&gt;結局、この性質のせいで装甲艦ラッシュのお供かノーガード野郎になるくらいしか使い道が見出せそうにありません。右ドラッグなんかをするよりも他の操作をしたほうが明らかに簡単だからです。では一体どうすればいいのか？&lt;/p&gt;

&lt;p&gt;そこで、オプション→ローカルクライアント→インターフェイス→「都市をユニットより優先して選択」にチェックを入れてみましょう。&lt;/p&gt;

&lt;p&gt;もし右ドラッグ範囲内に都市が含まれない場合、従来どおり(1)の使い方が可能です。
そしてもし都市が含まれている場合、&lt;strong&gt;範囲内のユニットは選択されず&lt;/strong&gt;に都市のみが選択され、都市選択モードに切り替わります。
これによって元々誰も使わない(3)の使い方はできなくなりますが、(2)の使い方をするときにユニットを起こすことがないため、より便利に都市の選択が可能になるのです。
結構便利なので試してみてもいいんじゃないでしょうか。&lt;/p&gt;

&lt;p&gt;ヘルプ→「操作」は読んでみるといろいろな発見がありそうです。
生産物のコピーアンドペーストやユニットの追加選択などは慣れると使い勝手が良いかもしれませんね。
ショートカットを駆使してfreecivを快適に操作して、より強大な帝国を作っていきましょう。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>ThinkPad X1 Carbonを購入しました</title>
      <link>http://tatamo.81.la/blog/2017/12/18/intro-new-moblie-pc/</link>
      <pubDate>Mon, 18 Dec 2017 21:00:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/12/18/intro-new-moblie-pc/</guid>
      <description>
        &lt;p&gt;この記事は&lt;a href=&#34;https://adventar.org/calendars/2491&#34;&gt;Kobe University Advent Calendar 2017&lt;/a&gt;の19日の記事です。
なお私は当該大学の学部3年(2017年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;新しいモバイルPCが先週届いたので、それについて書きます。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;購入したpc&#34;&gt;購入したPC&lt;/h2&gt;

&lt;p&gt;Lenovo ThinkPad X1 Carbon(2017モデル)を買いました。
基本的なスペックは以下の通りです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CPU: Core i7-7500U&lt;/li&gt;
&lt;li&gt;メモリ: 16GB 1866MHz&lt;/li&gt;
&lt;li&gt;ストレージ: 512GB SSD&lt;/li&gt;
&lt;li&gt;WWANなし&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;液晶サイズは14型、本体重量はおよそ1.13kgです。
お値段は約161kでした。&lt;/p&gt;

&lt;h2 id=&#34;新pc購入のモチベーション&#34;&gt;新PC購入のモチベーション&lt;/h2&gt;

&lt;p&gt;とにかく元々持っていたラップトップが重すぎたというのが大きな要因です。
大学に行くときなどかなり頻繁にPCを持って出るのですが、サイズが大きくて鞄に入れにくい上に重量が2.5kg以上と決して持ち運びに適したPCではなかったのです。&lt;/p&gt;

&lt;p&gt;実際のところスペック的にはまだまだ使えるマシンなのですが、今後大学院の修士課程まで行くことを考えると少なくとも3年以上はノートPCを頻繁に持ち運ぶ機会があることが想定され、その間ずっとPCを変えずに使い続けるのはつらいのではないかと感じました。&lt;/p&gt;

&lt;p&gt;そしていずれPCを変えることになるなら早いほうがいいに決まっているので、タンスに挟まっていた成人祝いの札束などを引っ張り出して新しいPCの購入に踏み切りました。&lt;/p&gt;

&lt;h2 id=&#34;pc選定の条件&#34;&gt;PC選定の条件&lt;/h2&gt;

&lt;p&gt;タンス預金の中身を検めると諭吉氏が16枚あったので、これに財布の中の一万円を加えた17万円を予算上限としました。&lt;/p&gt;

&lt;p&gt;その上で、新しいPCに求めるスペックを想定しました。
以下はその優先度の高い順に並べています。&lt;/p&gt;

&lt;h3 id=&#34;携帯性&#34;&gt;携帯性&lt;/h3&gt;

&lt;p&gt;今回のPC買い替えの動機でもあるので、軽くて持ち運びやすい、いわゆるモバイルPCにすることにしました。
とはいえ元のPCがあまりに重いため、ちょっとぐらいの差はわからないので極限まで軽さを求めることはしません。&lt;/p&gt;

&lt;p&gt;大きさについては、鞄に入れやすい程度には小さく収まってほしいですが、あまり小さくて液晶が見難くなっても困るので、やはり一般的なモバイルPCの範疇に収まっていることを条件としました。&lt;/p&gt;

&lt;h3 id=&#34;ストレージ&#34;&gt;ストレージ&lt;/h3&gt;

&lt;p&gt;私はデスクトップ機とノートPCで同じ環境を構築し、出先でも開発ができるようにしています。
これはつまり、WindowsとLinux(Debian)のデュアルブートを行うことを意味します。
ストレージ容量が256GBの場合、単純にOSごとに半分ずつ割り当てるとそれぞれ128GBしか使えず、これではやや不安が残ります。
というか、手元のラップトップを見たところWindowsだけで128GBなんて軽く越えていたので不安しかありません。
そのため、ストレージには512GB SSDを使用したいと考えました(SSDなのは前提条件として当然です)。&lt;/p&gt;

&lt;h3 id=&#34;メモリ&#34;&gt;メモリ&lt;/h3&gt;

&lt;p&gt;経験上、Chromeを立ち上げまくったりメモリを食うことをたくさんした場合、メモリの消費量がぴったり8GB前後になるという印象があります。
基本的には8GBで何の問題もありませんが、メモリをたくさん食っている状況下では、メモリが8GBだとちょうど溢れてしまう可能性があります。
なので16GBあると嬉しいですが、それによって値段が上がりすぎてしまうのであれば8GBのほうが良い、という想定になりました。&lt;/p&gt;

&lt;h3 id=&#34;cpu&#34;&gt;CPU&lt;/h3&gt;

&lt;p&gt;Core i3はさすがにどうかと思いますが、動画処理や画像処理等はしないですし、ゲームはノートPCなんて使わずに家のデスクトップでやるので高い性能はあまり必要ありません。
なのでCore i5でも積んでいれば十分と考えました。&lt;/p&gt;

&lt;h3 id=&#34;os&#34;&gt;OS&lt;/h3&gt;

&lt;p&gt;先述したようにデスクトップとノートPCで環境を揃える予定なので、macOSだと環境が違ってきてしまうのでやや評価が下がります。
デュアルブート自体Windows+Linuxよりは相性が悪い印象ですし、そもそもMacだとLinuxを入れるまでもなく普通にMac上に環境構築するので、結局デスクトップ機との環境統一が望めません。&lt;/p&gt;

&lt;p&gt;macOSは悪い選択肢ではありませんが、今回の使用目的ではWindowsのほうが優先されます。&lt;/p&gt;

&lt;h3 id=&#34;拡張性-端子類&#34;&gt;拡張性(端子類)&lt;/h3&gt;

&lt;p&gt;モバイルPCは往々にしてUSBポートが1個しか付いていなかったりすることが多いですが、個人的には2個以上あったほうが良いのではないかという考えです。&lt;/p&gt;

&lt;p&gt;また今の状況を考えると、USB Type-AかType-Cかというのも悩みどころです。
手元にType-Cの機器はないですが、今後のことを考えると欲しさはあります。
とはいえ変換ケーブルを持ち運ぶのも面倒なので、両方ついていれば長く使えそうだなと考えていました。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;全体的には、モバイルPCでかつ512GBのストレージを積めることを前提条件として考えました。
またOfficeについてはあまり使う予定がないため、選択可能なら非搭載とすることにしました。&lt;/p&gt;

&lt;h2 id=&#34;候補に上がったもの&#34;&gt;候補に上がったもの&lt;/h2&gt;

&lt;p&gt;結局どのPCを買うか悩んでいるときが一番楽しい&lt;/p&gt;

&lt;h3 id=&#34;surface-pro&#34;&gt;Surface Pro&lt;/h3&gt;

&lt;p&gt;2in1は目新しいので気になりましたが、液晶を自立させるために後ろにスタンドを必要とすることから、「新幹線・飛行機の小さいテーブルで使いにくい」「膝上で使いにくい」ということで候補から外しました。&lt;/p&gt;

&lt;h3 id=&#34;surface-laptop&#34;&gt;Surface Laptop&lt;/h3&gt;

&lt;p&gt;だったらクラムシェルにしようということで候補に上げました。
しかしCore i7+メモリ16GBまで積まないと512GBのストレージを選択することができず、しかもその場合のお値段なんと28万円を越えるためこれも除外しました。&lt;/p&gt;

&lt;h3 id=&#34;vaio-z&#34;&gt;VAIO Z&lt;/h3&gt;

&lt;p&gt;これも2in1ですが、天板が半分ぐらいのところで折り曲がってモード変更できるようになっており、通常使用時は普通のクラムシェルとして使えるので膝上性能ばっちりです。
非常にハイスペックなだけあって高いので、Core i5+メモリ8GB+SSD256GBの時点で20万円を越えることを確認して候補から外しました。&lt;/p&gt;

&lt;h3 id=&#34;macbook-air-macbook-pro&#34;&gt;Macbook Air, Macbook Pro&lt;/h3&gt;

&lt;p&gt;Core i5+メモリ8GB+SSD 512GBの構成で139k、Core i7の場合は155kと、予算的にはいい感じです。
しかし最大の問題として、そもそも積んでいるCPUが第5世代のものです。
単純に動作周波数で見ても、MBAのCore i7の動作周波数2.2GHzは現行の第7世代Core i3にすら劣ります。&lt;/p&gt;

&lt;p&gt;お値段が安いのは利点ですがCPUの古さのために相殺されてしまい、やはりモデルとして古すぎて今買うべきかと言われると疑問符が付くので保留とし、結局候補から外れました。&lt;/p&gt;

&lt;p&gt;MBPは第七世代CPUを使用可能ですが、Core i5(2.3GHz)+メモリ8GB+512GBで187kとなるので予算オーバーです。&lt;/p&gt;

&lt;h3 id=&#34;matebook-x&#34;&gt;Matebook X&lt;/h3&gt;

&lt;p&gt;華為のモバイルPCで、メモリは8GBのみ、512GB SSDを積むためにはCore i7モデルを選択する必要があります。
この場合の基本価格は174k程度で予算の上限を越えますが、実際にはもう少し安い価格で買えるようです。&lt;/p&gt;

&lt;p&gt;欠点があるとすれば、デザインがあまりにMacbookに似ているのでちょっと複雑な気持ちになりそうなところでしょうか。&lt;/p&gt;

&lt;h3 id=&#34;thinkpad-x1-carbon-thinkpad-x270&#34;&gt;Thinkpad X1 Carbon, Thinkpad X270&lt;/h3&gt;

&lt;p&gt;LenovoのThinkpadは常に割引されている状態で、日時によって割引率がどんどん変わっていくのでちゃんとした値段を出すのが難しいです。
一度割引率43%までは確認したので、とりあえず40%の割引がなされるものとして計算しました。&lt;/p&gt;

&lt;p&gt;Core i5+メモリ8GB+512GB SSDで159kとなり、予算に収まります。
なおCore i7+メモリ16GB+512GB SSDだと177kでした。&lt;/p&gt;

&lt;p&gt;X1 Carbonは14型液晶ですがサイズは13型PCとほぼ同等で、その上軽量化が図られているのでとても使いやすそうに感じました。
端子類もType-A USB端子が2つにType-C端子が2つ(電源込み)と十分な数があり、長く使い続けられそうです。&lt;/p&gt;

&lt;p&gt;また12.5型のThinkpad X270も候補に上げました。
これはX1 Carbonよりも重い一方でサイズは12.5型のため小さく、また同スペックでも1万円から2万円ほど安く買うことができます。&lt;/p&gt;

&lt;h2 id=&#34;thinkpad-x1-carbon購入&#34;&gt;Thinkpad X1 Carbon購入&lt;/h2&gt;

&lt;p&gt;最終的な候補としてMatebook X, Thinkpad X1 Carbon, Thinkpad X270が残りました。
デザイン的にはThinkpadが好みだったり、また知名度からの安心感もあるのでMatebookは除外し、X1 CarbonとX270のどちらかを買うことに決めました。&lt;/p&gt;

&lt;p&gt;とはいえこの2つは大きさと重さの違いが重要なので、実際に店頭で確かめることにしました。
ちょうど大阪に行く用事があったのでヨドバシ梅田に寄って実機を確かめましたが、X270は画面が小さすぎる印象があり、X1 Carbonを購入することに決めました。
ネットの情報ではX1 Carbonは従来機種よりも薄いためにトラックポイントの背が低く、操作性が落ちているということが書かれていましたが、Thinkpadを使ったことのない自分が店頭で触り比べてみた程度では違いが全くわからなかったので気にしないことにしました。&lt;/p&gt;

&lt;p&gt;価格を聞いてみたところ、販売店では常に直近のネット最安価格よりも1%程度割引率が高くなるらしく、44%の割引率が適用されたのでそのまま買うことにしました。&lt;/p&gt;

&lt;p&gt;この割引率ではi5+8GB+512GB SSDで148kと思った以上に安く、どうせならメモリを16GBに増やそうと思ったのですが、その場合はCPUもCore i7に上げなければならないということを伝えられました。
この場合のお値段は165kで、予算内には十分収まっています。&lt;/p&gt;

&lt;p&gt;ここに来てCore i5+メモリ8GBとi7+16GBのどちらにするかで非常に迷うことになってしまったのですが、高い買い物をするときは多少余計に払ってでも良いものを買えという親の教えを思い出し、Core i7+メモリ16GBにすることに決めました。&lt;/p&gt;

&lt;h2 id=&#34;使用感など&#34;&gt;使用感など&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/blog/2017/12/18/intro-new-moblie-pc/&#34;&gt;ICPC参加&lt;/a&gt;のためにつくばに行く2日ほど前に届きました。
とても軽い上に鞄に入れやすいサイズのため、持ち運びは明らかに便利になりました。
Xfceを入れたDebian 9.3とWindows10とのデュアルブート(ブートローダはGRUB)にしましたが、どちらも起動・終了が非常に速いので快適です。
Linuxとの相性は悪くなく、無線LANドライバなども全く問題なく動作していますが、搭載されている指紋センサだけはドライバが対応せず使えないようです。&lt;/p&gt;

&lt;p&gt;全体的に非常に使いやすいのでとても満足していますが、一点だけ挙げるとすればキーボードの右上にHome/Endキーが搭載されているため、Fnキー+左/右キーの組み合わせではHome/Endキーが使えません。
キー配置の慣れの問題かもしれませんが、HomeキーとEndキーは頻繁に使用するキーのため今の所やや不便です。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>ACM-ICPC2017アジアつくば大会に参加しました</title>
      <link>http://tatamo.81.la/blog/2017/12/18/icpc-2017-asia/</link>
      <pubDate>Mon, 18 Dec 2017 01:30:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/12/18/icpc-2017-asia/</guid>
      <description>
        &lt;p&gt;この記事は&lt;a href=&#34;https://adventar.org/calendars/2491&#34;&gt;Kobe University Advent Calendar 2017&lt;/a&gt;の18日の記事です。
なお私は当該大学の学部3年(2017年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://icpc.iisf.or.jp/2017-tsukuba/results/&#34;&gt;ICPC国内予選39位&lt;/a&gt;で神戸大学の第2チームとしてぎりぎり予選通過できたので、&lt;a href=&#34;https://icpc.iisf.or.jp/2017-tsukuba/&#34;&gt;アジア大会&lt;/a&gt;に参加しました。&lt;/p&gt;

&lt;p&gt;結果としては3問通して&lt;a href=&#34;http://icpc2017.yamagula.ic.i.u-tokyo.ac.jp/standings/&#34;&gt;39位&lt;/a&gt;でした。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;実績「座っているだけのお仕事」&lt;br&gt;解除条件：ICPCで一度たりとも競技用マシンに触れない&lt;br&gt;を達成しました💺💤&lt;/p&gt;&amp;mdash; Tatamo@Super-Srups (@&lt;strong&gt;tatamo&lt;/strong&gt;) &lt;a href=&#34;https://twitter.com/__tatamo__/status/942290374382383104?ref_src=twsrc%5Etfw&#34;&gt;2017年12月17日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
なにもしないをしました&lt;/p&gt;

&lt;h2 id=&#34;チーム構成-方針&#34;&gt;チーム構成・方針&lt;/h2&gt;

&lt;p&gt;私の所属するチームであるSuper-Srupsのメンバー構成は以下の通りです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/mmxsrup&#34;&gt;@mmxsrup&lt;/a&gt;氏

&lt;ul&gt;
&lt;li&gt;学部2年&lt;/li&gt;
&lt;li&gt;リーダー&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/kurenai3110&#34;&gt;@kurenai3110&lt;/a&gt;氏

&lt;ul&gt;
&lt;li&gt;学部2年&lt;/li&gt;
&lt;li&gt;実装担当&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/__tatamo__&#34;&gt;@__tatamo__&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;わたし 学部3年&lt;/li&gt;
&lt;li&gt;座っている担当&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;私は3人の中で最も実力が低く、かつここ数ヶ月のあいだ全くC++を書いていないという状態です。
つまり論理的結論として、私は一行もコードを書くべきではありません。
そのため私は英語で与えられる問題文の読解、他メンバーの補助および考察少しを担当しました。
他の2人はUSキーボードのEnterキーが空振りするとかgeditがつらいとかubuntuの使い方がわからないとか大変そうでした。&lt;/p&gt;

&lt;h2 id=&#34;解いた問題&#34;&gt;解いた問題&lt;/h2&gt;

&lt;p&gt;問題の内容については&lt;a href=&#34;https://storage.googleapis.com/icpcsec/icpc2017-regional/problems.pdf&#34;&gt;問題文&lt;/a&gt;を参照してください。&lt;/p&gt;

&lt;h3 id=&#34;a&#34;&gt;A&lt;/h3&gt;

&lt;p&gt;やるだけ問です。
問題文を読んで&lt;a href=&#34;https://twitter.com/kurenai3110&#34;&gt;@kurenai3110&lt;/a&gt;氏に投げたらよろしくやってくれました。&lt;/p&gt;

&lt;h3 id=&#34;c&#34;&gt;C&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/mmxsrup&#34;&gt;@mmxsrup&lt;/a&gt;氏と考察を担当し、実装は&lt;a href=&#34;https://twitter.com/kurenai3110&#34;&gt;@kurenai3110&lt;/a&gt;氏にやってもらいました。
値が負になるときの特殊ケースや変数の更新タイミングのミス等のちょっとした考察漏れ・実装ミスを3つほど同時に仕込んでしまって数十分ほど無駄に消費してしまったので反省点が多いです。&lt;/p&gt;

&lt;h3 id=&#34;i&#34;&gt;I&lt;/h3&gt;

&lt;p&gt;B問題・C問題で無限に時間を費やしているうちに他チームは問題をたくさん解いていたので、風船の浮かんでいる状況を見てI,F,G問題に解く対象を絞りました。
なお今年の問題の並び順は、A,B,C問題までが易しい順に並んでおりそれ以降の問題はランダムになっています。&lt;/p&gt;

&lt;p&gt;I問題は問題文を読んで&lt;a href=&#34;https://twitter.com/kurenai3110&#34;&gt;@kurenai3110&lt;/a&gt;氏に丸投げしたら見事に解いてくれました。&lt;/p&gt;

&lt;h2 id=&#34;解けなかった問題&#34;&gt;解けなかった問題&lt;/h2&gt;

&lt;h3 id=&#34;b&#34;&gt;B&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/mmxsrup&#34;&gt;@mmxsrup&lt;/a&gt;氏がメインで担当しました。
制限実行時間10秒の問題ですが、最初にすべての可能な傾きの同じ線分の集合を持ったりしていたらハマってしまって通せませんでした。
普通に全探索すれば解けるなどということを終了後に聞きましたが、全然通らなかったのでいっそ早めに放り投げるべきだったのかもしれません。&lt;/p&gt;

&lt;h3 id=&#34;f&#34;&gt;F&lt;/h3&gt;

&lt;p&gt;私はグラフは最短経路の超典型問ぐらいしか解けないので、問題を訳すだけして他の２人に投げました。
実装の最後の方まで行っていたようなのですが間に合いませんでした。&lt;/p&gt;

&lt;h3 id=&#34;g&#34;&gt;G&lt;/h3&gt;

&lt;p&gt;考察を担当しました。
座標変換で簡単になるというのは気付きませんでしたが、極座標→XY座標への変換をしてからdX=正三角形の辺の長さの半分, dY=正三角形の高さ で区切って場合分け2回ほどで数学的に求めて終わりです。&lt;/p&gt;

&lt;h2 id=&#34;結果&#34;&gt;結果&lt;/h2&gt;

&lt;p&gt;A問題解いた直後に沼にはまって時間を無為に費やし、終盤になってB,F,Gの解法が出揃ったが実装時間が圧倒的に足りないという状況に陥り、結局4問目を通せず3完でした。
予選と全く同じ順位の39位です。&lt;/p&gt;

&lt;p&gt;ICPCはやはりマシン1台のチーム戦ということで、特有の難しさがあるので事前の慣らしはもっとしておいたほうがよかったような気がします。
あとUSキーボードは思った以上に慣れない(らしい)のでこちらも事前準備が必要そうです。&lt;/p&gt;

&lt;p&gt;とはいえ、そもそも私は自力で問題を解けないので、問題文の和訳と考察補助とただ座っているぐらいしか仕事がない感じです。
こういう場にカジュアル勢が紛れ込んでしまって肩身が狭いというか申し訳無さです。&lt;/p&gt;

&lt;h2 id=&#34;雑事&#34;&gt;雑事&lt;/h2&gt;

&lt;p&gt;1日目は昼過ぎに集合で、参加受付+開会式+練習+懇親会だけで、解放される時間がなぜか20時です。
思うところがないでもありません。&lt;/p&gt;

&lt;p&gt;2日目についても、終了後の懇親会で2時間拘束されます。
こちらでは企業ブースがいくつかあり、物をもらったり話を聞いたりすることができました。&lt;a href=&#34;2017/09/17/indeed-austin-tour/&#34;&gt;ツアー&lt;/a&gt;で一緒だった某r(i)社の方々とまた会ったりしました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://proc-cpuinfo.fixstars.com/2017/12/in-house-procon-06-announcement/&#34;&gt;量子リバーシ&lt;/a&gt;なるクイズが出題されており、こういうのは&lt;a href=&#34;http://shogitter.com/rule/108&#34;&gt;量子将棋&lt;/a&gt;とか&lt;a href=&#34;http://uhyo.hatenablog.com/entry/2016/04/22/161011&#34;&gt;量子人狼&lt;/a&gt;とか&lt;a href=&#34;https://uhyohyo.net/quantum2048/&#34;&gt;量子2048&lt;/a&gt;とか作ってる人たちが周りにいるから見慣れてるんだよなあなどと思いつつ、順に確定させてから普通のオセロをシミュレートするだけのやるだけ問を3分ぐらいで解いたら驚かれました。&lt;/p&gt;

&lt;p&gt;また他のブースではよくわからないクイズを解くだけでANKERの10000mAhモバイルバッテリー(自分が持っている物の一つ下のモデル)をもらうことができました。&lt;/p&gt;

&lt;h2 id=&#34;つくば&#34;&gt;つくば&lt;/h2&gt;

&lt;p&gt;交通費補助が新幹線代程度出るものの、宿泊施設の提供なしで宿泊補助費は5000円しか出ないので新幹線で行くと大赤字です。
そこでLCCで飛んでいくことで交通費を浮かせて2泊するための宿泊費に充てました(これって書いていいんでしょうか)。&lt;/p&gt;

&lt;p&gt;宿泊施設が用意されなくなったのは今年からとのことですが、ICPC協賛の某企業の方に聞いた話によると、どうもスポンサー費用は例年上がっていく一方らしいです。
よくわかりません。&lt;/p&gt;

&lt;p&gt;そこそこ移動がつらく、朝6時頃には家を出て空港まで行ったかと思えば移動の間に2時間ぐらい待機する必要があったりしました。
また宿はできるだけ安いところを取りましたが、1日目は浴場の給湯器が故障していて使えず、2日目は浴場に入ることはできたものの、あまりにお湯がぬるいので仕方なくサウナで温まるなどすることになりました。&lt;/p&gt;

&lt;p&gt;1日目は部屋に備え付けの浴室を使いましたが、湯を張るために蛇口を開くと汚れの混じった赤っぽい水が出てきたので、無心でシャワーを浴びてそのまま何も考えずに寝ました。&lt;/p&gt;

&lt;h2 id=&#34;3日目&#34;&gt;3日目&lt;/h2&gt;

&lt;p&gt;エクスカーションや企業見学に参加する人に合わせて飛行機を取ったので、3日目は夜まで暇です。
ほとんどの人は企業見学に行ったので、残りの3人で東京観光に行きました。
大洗は非常に遠かったのでやめておいて、VRの体験や靖国神社に行ったりして所々で先輩におごってもらいました。
大荷物を持って長距離を移動した上に懇親会等で立ちっぱなしで疲労が蓄積していたので、夕方はカフェで休憩しながら時間を潰していました。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>Web技術ではじめるレポート・論文制作</title>
      <link>http://tatamo.81.la/blog/2017/12/06/web-dtp/</link>
      <pubDate>Wed, 06 Dec 2017 18:30:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/12/06/web-dtp/</guid>
      <description>
        &lt;p&gt;この記事は&lt;a href=&#34;https://adventar.org/calendars/2491&#34;&gt;Kobe University Advent Calendar 2017&lt;/a&gt;の6日の記事です。
なお私は当該大学の学部3年(2017年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;http://vivliostyle.com/ja/products/&#34;&gt;Vivliostyle&lt;/a&gt;やその他のWeb技術を用いて、HTMLとCSSで課題のレポートを書くための環境を作る話です。
あと「&lt;a href=&#34;https://pentapod.github.io/c92/&#34;&gt;CSSではじめる同人誌制作&lt;/a&gt;」を勝手に販促する記事でもあります。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;html-cssによる組版&#34;&gt;HTML+CSSによる組版&lt;/h2&gt;

&lt;p&gt;個人的にはWordもTeXもあまり得意ではない、というか、HTML+CSSで似たようなことができそうなのにわざわざWordやTeXを使うのが大変だと感じています(InDesignはよく知りません)。
文書構造の明確化という観点においては、構造と見た目が明確に分離しているHTML+CSSに勝るものはありません(筆者個人の主観です)。&lt;/p&gt;

&lt;p&gt;そこでWeb技術を用いてレポートや論文を書きたいなあと思っていたのですが、ちょうど&lt;a href=&#34;http://tatamo.81.la/blog/2017/08/27/seccamp-2017/&#34;&gt;セキュキャンの事前準備で行けなかった&lt;/a&gt;ときのコミケで、pentapodさんより「&lt;a href=&#34;https://pentapod.github.io/c92/&#34;&gt;CSSではじめる同人誌制作&lt;/a&gt;」が頒布されていたので、友人に頼んで確保しておいてもらいました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote&gt;内容については同人誌制作だけをターゲットに絞らず， できるだけ色々な場面で使えるような説明を心がけています．&lt;/blockquote&gt;
というあとがきの記述通り、CSS組版全般、また単にCSSの解説本としても読めるようになっており、本書を参考にしてレポートを書くための環境を整えることができました。
同人誌でもレポートでも論文でも、やりたいことは結局同じ組版であるため、整えるべき環境は変わりません。&lt;/p&gt;

&lt;h2 id=&#34;この記事で書くこと&#34;&gt;この記事で書くこと&lt;/h2&gt;

&lt;p&gt;CSSを用いた組版については、「&lt;a href=&#34;https://pentapod.github.io/c92/&#34;&gt;CSSではじめる同人誌制作&lt;/a&gt;」を直接読んでいただくのが一番早いため、今回はあまり詳しくは書きません。
&lt;a href=&#34;https://pentapod.booth.pm/items/601017&#34;&gt;300円というお手頃価格で電子版も出ている&lt;/a&gt;ので買ってください。
これは販促です。&lt;/p&gt;

&lt;p&gt;そこでこの記事では、本書を参考にしながら行った環境構築を中心に書いていきます。
構築した環境は &lt;a href=&#34;https://github.com/Tatamo/htmldtp&#34;&gt;https://github.com/Tatamo/htmldtp&lt;/a&gt; に上げていますが、「そもそもボイラープレートという単語を数日前にはじめて知った」レベルのためディレクトリ構成ひとつとっても正直褒められたものではないと感じています。
なのでまたちゃんと体裁を整えたいと思います。&lt;/p&gt;

&lt;h2 id=&#34;vivliostyle&#34;&gt;Vivliostyle&lt;/h2&gt;

&lt;p&gt;とはいえ、&lt;a href=&#34;http://vivliostyle.com/ja/products/&#34;&gt;Vivliostyle&lt;/a&gt;については触れておかないと話が始まりません。
これはWeb技術による組版を目的としたプロジェクトで、CSSの将来的な仕様を先取りすることで、より多彩なレイアウトを実現できるようにしているものです。
&lt;a href=&#34;http://vivliostyle.com/ja/samples/&#34;&gt;サンプル&lt;/a&gt;が充実しており、実際にCSSによってデザインされた本と、その生のHTMLを閲覧することができます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://vivliostyle.github.io/vivliostyle.js/samples/css-secrets-long/viewer/vivliostyle-viewer.html#x=../doc/&#34;&gt;こういうレベルのこと&lt;/a&gt;がCSSで既に可能となっているのです。&lt;/p&gt;

&lt;p&gt;Vivliostyleを用いた印刷を行う方法は何種類かありますが、&lt;a href=&#34;https://chrome.google.com/webstore/detail/vivliostyle/ffeiildjegeigkbobbakjjmfeacadbne&#34;&gt;Chrome拡張&lt;/a&gt;を用いるのが最も簡単だと思われます。
目的のHTMLファイルを表示した状態で拡張機能を有効化するとレイアウトが紙面向けのものに変換されるので、これをChromeの印刷機能を用いて紙面やPDFに印刷します。&lt;/p&gt;

&lt;p&gt;そのため、Vivliostyleに対応したCSSファイルと、それを適用するための原稿となるHTMLファイルを用意することが目的となります。
HTMLとCSSの状態からPDFを生成する作業を自動化する方法についても「&lt;a href=&#34;https://pentapod.github.io/c92/&#34;&gt;CSSではじめる同人誌制作&lt;/a&gt;」では解説されていますが、今回は省略するので本書を購入してください。&lt;/p&gt;

&lt;p&gt;恥ずかしい話ですが、最近のCSS3の仕様をしっかり追いかけているわけではないため、どこからどこまでがVivliostyleによって実現されている機能で、どこまでがブラウザの標準機能で既にサポートされている部分なのかがよくわかっていません。
このあたりは書けば書くほどボロが出るに違いないので適当にごまかします。&lt;/p&gt;

&lt;h2 id=&#34;フレームワーク選定&#34;&gt;フレームワーク選定&lt;/h2&gt;

&lt;p&gt;書籍ではPug+marked+Stylus+Prism.js+MathJax+Browsersync+Gulpの構成が紹介されていましたが、このあたりは好みだと思うので適当に選んでいきました。&lt;/p&gt;

&lt;p&gt;結論としては、Nunjucks+nunjucks-markdown+PostCSS(cssnext+stylelint)+highlight.js+MathJax+Browsersync+Gulpという構成になりました。&lt;/p&gt;

&lt;h3 id=&#34;nunjucks&#34;&gt;Nunjucks&lt;/h3&gt;

&lt;p&gt;まずはHTMLテンプレートエンジンを選びます。
変数を用いた操作や別のHTMLの継承などの機能を取り入れることで、HTMLをより書きやすくして開発の高速化・再利用の促進を図ります。&lt;/p&gt;

&lt;p&gt;今回は&lt;a href=&#34;https://mozilla.github.io/nunjucks/&#34;&gt;Nunjucks&lt;/a&gt;を使うことにしました。
昔Djangoを触ったことがあるので見慣れたテンプレートであるという点などが採用理由です。
他には以前使ったことのあるEJS、紹介されていたPug(Jade)なども候補に上がりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- template/_base.njk --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;ja&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;{{ title }}&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
{% block content %}
    &amp;lt;section&amp;gt;
        &amp;lt;p&amp;gt;default content&amp;lt;/p&amp;gt;
    &amp;lt;/section&amp;gt;
{% endblock %}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- index.njk --&amp;gt;
{% extends &amp;quot;template/_base.njk&amp;quot; %}
{% set title = &amp;quot;awesome-report&amp;quot; %}
{% block content %}
&amp;lt;section&amp;gt;
    &amp;lt;!-- awesome-report-content --&amp;gt;
&amp;lt;/section&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のような感じでHTMLにいろいろなものをくっつけていきながら書けるようになります。
Nunjucksで記述したHTMLは、.htmlのほかに.njkなどの拡張子を使ったりするらしいです。&lt;/p&gt;

&lt;h3 id=&#34;nunjucks-markdown&#34;&gt;nunjucks-markdown&lt;/h3&gt;

&lt;p&gt;ひたすら文章を書くのにいちいち&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;タグを書いたりしていられないので、Markdownを使えるようにすることが必要です。
Nunjucksを使うことにしたので、markedのNunjucks向けプラグインである&lt;a href=&#34;https://www.npmjs.com/package/nunjucks-markdown&#34;&gt;nunjucks-markdown&lt;/a&gt;を使うことにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% block content %}
&amp;lt;section&amp;gt;
    {% markdown %}
    ## PPAP
    I have a pen.
    I have an apple.
    ```js
    console.log(&amp;quot;Apple pen!&amp;quot;);
    ```
    {% endmarkdown %}
&amp;lt;/section&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように、&lt;code&gt;{% markdown %}&lt;/code&gt;で囲った部分をMarkdownとして書くことができようになります。&lt;/p&gt;

&lt;h3 id=&#34;postcss-cssnext-stylelint&#34;&gt;PostCSS(cssnext+stylelint)&lt;/h3&gt;

&lt;p&gt;HTMLだけでなくCSSも次世代仕様を使用できるようにしておくと便利です。
SassやStylusという選択肢もありますが、この次世代CSS過渡期において独自記法マシマシのcoffeeとあくまでES2015をもとにしたtsならどちらを使うかという話です。
一通り必要な機能が入ったプラグイン集である&lt;a href=&#34;http://cssnext.io/&#34;&gt;cssnext&lt;/a&gt;と、lintをしてくれる&lt;a href=&#34;https://stylelint.io/&#34;&gt;stylelint&lt;/a&gt;を入れていますが、この構成だとSassのように&lt;code&gt;@import&lt;/code&gt;できない点で不便さがあるので、CSSをモジュール化できるようにするためにpostcss-importも入れたほうが良いかもしれません。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;gulp-postcssを使っている際にstylelintでインデント幅をlintするよう指定している状態でAutoprefixerなどで右寄せしたprefixが追加された場合、なぜかsrc側のCSSのインデントが崩れているとしてstylelintに怒られてしまうので、plugin設定にはstylelintを一番先に置くべきという知見を得ました &lt;a href=&#34;https://t.co/IMnmqibetC&#34;&gt;pic.twitter.com/IMnmqibetC&lt;/a&gt;&lt;/p&gt;&amp;mdash; たたもさん@がんばらない (@&lt;strong&gt;tatamo&lt;/strong&gt;) &lt;a href=&#34;https://twitter.com/__tatamo__/status/928286264914145280?ref_src=twsrc%5Etfw&#34;&gt;2017年11月8日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
これは余談です。&lt;/p&gt;

&lt;h3 id=&#34;highlight-js&#34;&gt;highlight.js&lt;/h3&gt;

&lt;p&gt;プログラムリストを貼り付けることが求められることもあるので、シンタックスハイライターを用意します。
他の候補としてはPrism.jsなどがあります。
今回はこのブログで使ったりして使い慣れている&lt;a href=&#34;https://highlightjs.org/&#34;&gt;highlight.js&lt;/a&gt;を用いました。&lt;/p&gt;

&lt;h3 id=&#34;mathjax&#34;&gt;MathJax&lt;/h3&gt;

&lt;p&gt;TeX形式で書いた数式を表示するために必須です。
&lt;a href=&#34;https://www.mathjax.org/&#34;&gt;MathJax&lt;/a&gt;以外の選択肢は特にないと言っていいでしょう。
適当なスニペットを&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;タグ内に追加し、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;p&amp;gt;MathJax test: $E = mc^2$&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などと書くだけで数式部分が整形されて表示されます。&lt;/p&gt;

&lt;p&gt;どうでもいい余談ですが、個人的にはMicrosoft Officeの数式エディタは見た目もきれいですし非常に使いやすいと思っています。
これについてはあまり同意されたことがない気がします。&lt;/p&gt;

&lt;h3 id=&#34;browsersync&#34;&gt;Browsersync&lt;/h3&gt;

&lt;p&gt;ソースコードが更新され(、そしてそれを検知してビルドが走って&lt;code&gt;dist/&lt;/code&gt;ディレクトリが更新され)たことを検知し、&lt;a href=&#34;https://www.browsersync.io/&#34;&gt;Browsersync&lt;/a&gt;が自動でブラウザを再読み込みしてくれるようにします。
わざわざF5を押さなくても変更が反映され、ビルド結果がすぐにブラウザ上で見れて便利…… なのですが、今回はブラウザを更新したあとVivliostyleのChrome拡張を有効化しなければならず、結局F5相当の動作を手で行わなければならないという難点があります。&lt;/p&gt;

&lt;h3 id=&#34;gulp&#34;&gt;Gulp&lt;/h3&gt;

&lt;p&gt;ビルドを自動化してくれるようにするためのタスクランナーです。
&lt;a href=&#34;https://gulpjs.com/&#34;&gt;Gulp&lt;/a&gt;は使っていますがGruntは使ったことがないです。
タスクランナーとは、&lt;code&gt;hoge&lt;/code&gt;というパッケージと一緒に&lt;code&gt;gulp-hoge&lt;/code&gt;を入れなければならなくなってpackage.jsonの依存パッケージ数が2倍近くに膨れ上がるという、とても素敵なものです。&lt;/p&gt;

&lt;p&gt;最近は何でもかんでもnpm-scriptsでやろうという話があって、確かに一理あるなあという感じなのでGulpじゃなくてもよかったかもしれません。&lt;/p&gt;

&lt;h2 id=&#34;全部突っ込む&#34;&gt;全部突っ込む&lt;/h2&gt;

&lt;p&gt;JavaScriptから利用するためのパッケージを一つも入れていない、というかJavaScriptを書くつもりがない(gulpfile除く)のに依存パッケージ数が10を越えるのはどういうことなんだ、という感じですが、とりあえず上記のツールを全部組み合わせます。
highlight.jsとMathJaxに関しては、&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;タグで読み込むだけでいいので&lt;code&gt;npm install&lt;/code&gt;は不要です。
Nunjucksのテンプレート継承機能を用いて、これらの読み込み用のスニペットをモジュール化しておくのがいいでしょう。&lt;/p&gt;

&lt;p&gt;Nunjucks(+nunjucks-markdown)とPostCSSを用いて、それぞれHTMLファイルとCSSファイルを生成する処理が行われるので、これをGulpのタスクとしてまとめてしまいます。
あとはソースコードの更新を検知して自動的にこのビルド処理が走るようにしたり、ビルド完了のタイミングでBrowsersyncに更新を伝えたりする処理を&lt;a href=&#34;https://github.com/Tatamo/htmldtp/blob/master/gulpfile.js&#34;&gt;gulpfile.js&lt;/a&gt;に書いて終わりです。&lt;/p&gt;

&lt;h2 id=&#34;使ってみた&#34;&gt;使ってみた&lt;/h2&gt;

&lt;p&gt;大学でパーセプトロンの出力を求めるだけのレポート課題が出たので、構築した環境を用いてレポートを書いてみました。&lt;/p&gt;

&lt;p&gt;以下に、Vivliostyleを用いて出力されたPDF(のスクリーンショットにモザイクかけたただの画像)を示します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2017/12/06/output_report.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2017/12/06/output_report.png&#34; alt=&#34;PDFに出力されたレポート&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;図はLibreOffice Drawで用意しましたがそのあたりは適当です。&lt;/p&gt;

&lt;p&gt;これに用いたCSSは、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;@page {
  size: A4;
  margin: 20mm;
  @bottom-center {
    content: counter(page);
  }
}

figcaption {
  counter-increment: fig;
}

figcaption::before {
  content: &amp;quot;図&amp;quot; counter(fig) &amp;quot;. &amp;quot;;
}

/* うまく動かない(後述) */
a.figref::after {
  content: &amp;quot;図&amp;quot; target-counter(attr(href), fig);
}

img {
  max-width: 100%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;だけであり、非常に簡潔なCSSで十分に見た目の整ったレポートを書くことができます。&lt;/p&gt;

&lt;p&gt;そういえば指定するのを忘れていましたが、当然&lt;code&gt;font-size&lt;/code&gt;でフォントサイズをポイント指定することも可能です。&lt;/p&gt;

&lt;h3 id=&#34;相互参照と問題点&#34;&gt;相互参照と問題点&lt;/h3&gt;

&lt;p&gt;図を示している部分のHTMLを抜粋すると、以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;section&amp;gt;
    {% markdown %}
    ## パーセプトロンの提示
    まず、パーセプトロンの修正後の重みを&amp;lt;a class=&amp;quot;figref&amp;quot; href=&amp;quot;#fig-nn&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;に示す。
    &amp;lt;figure&amp;gt;
        &amp;lt;img src=&amp;quot;perceptron.png&amp;quot;&amp;gt;
        &amp;lt;figcaption id=&amp;quot;fig-nn&amp;quot;&amp;gt;パーセプトロン&amp;lt;/figcaption&amp;gt;
    &amp;lt;/figure&amp;gt;
    簡単のため、パーセプトロンのそれぞれのノードに番号を付与した。
    {% endmarkdown %}
&amp;lt;/section&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;figcaption::before&lt;/code&gt;の&lt;code&gt;content&lt;/code&gt;に&lt;code&gt;counter(fig)&lt;/code&gt;を用いることで、自動的に図表番号を振ることができます。&lt;/p&gt;

&lt;p&gt;それに加えて、&lt;code&gt;figcaption&lt;/code&gt;の持つidに対するリンクのcontentに&lt;code&gt;target-counter(attr(href), fig)&lt;/code&gt;を指定しています。
これは&lt;code&gt;attr(href)&lt;/code&gt;&amp;mdash;つまりhrefの属性値、&lt;code&gt;&amp;quot;#fig-nn&amp;quot;&lt;/code&gt;&amp;mdash;の地点での&lt;code&gt;counter(fig)&lt;/code&gt;のカウンタの値を取得しており、つまりその図表に割り当てられた番号が得られます。&lt;/p&gt;

&lt;p&gt;これによって相互参照が実現できます。&lt;/p&gt;

&lt;p&gt;と言ってドヤ顔したいところなのですが、ここで致命的な問題が発生します。
なぜかChrome拡張のVivliostyleでは、この&lt;code&gt;target-counter()&lt;/code&gt;がうまく動かず、図表番号が&lt;code&gt;??&lt;/code&gt;で表示されます。&lt;/p&gt;

&lt;p&gt;他の手段であるVivliostyle FormatterやVivliostyle Viewerを使えば動かせはするのですが、その場合highlight.jsによるシンタックスハイライトが効かなかったり、MathJaxは対応しているもののMathML以外の記法を使えない、などの別の問題が生じてきます。&lt;/p&gt;

&lt;p&gt;なので現状、&lt;code&gt;a.figref::after&lt;/code&gt;に対するスタイル指定を削除し、&lt;code&gt;&amp;lt;a class=&amp;quot;figref&amp;quot; href=&amp;quot;#fig-nn&amp;quot;&amp;gt;図1&amp;lt;/a&amp;gt;&lt;/code&gt;などと直接書くしかないという本末転倒感があります。&lt;/p&gt;

&lt;p&gt;これについては今のところ解決策を見つけられていないので、もう少し調べてみて必要ならissueを飛ばすなりしようと思っています。&lt;/p&gt;

&lt;h2 id=&#34;おわり&#34;&gt;おわり&lt;/h2&gt;

&lt;p&gt;レポート・論文程度ならそこまで凝ったデザインである必要がないので、非常に短いCSSでそれなりの印刷が可能になります。
HTML+CSSを用いてレポートを書くというのは十分に実用の範囲内だと思ったので、これからも試していこうと思っています。&lt;/p&gt;

&lt;p&gt;しかしながら、やはり現状で相互参照が実現できないというのはレポート・論文執筆には致命的なところがあります。
&lt;code&gt;target-counter()&lt;/code&gt;は策定中の次期CSS仕様であることから、解決は時間の問題だとは思っているのですが、なんとかしたいところです。&lt;/p&gt;

&lt;p&gt;今の時代のCSSは、もはやWebページだけでなく紙面上のレイアウトも自在に操れるようになってきています。「&lt;a href=&#34;https://pentapod.github.io/c92/&#34;&gt;CSSではじめる同人誌制作&lt;/a&gt;」はCSSを使ったさまざまな紙面レイアウトについて書かれており、とてもおすすめなのでぜひ購入してみてください。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>ゲーム「じゃぱりうぉっち」を作りました</title>
      <link>http://tatamo.81.la/blog/2017/12/01/japari-watch/</link>
      <pubDate>Fri, 01 Dec 2017 17:35:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/12/01/japari-watch/</guid>
      <description>
        &lt;p&gt;この記事は&lt;a href=&#34;https://adventar.org/calendars/2491&#34;&gt;Kobe University Advent Calendar 2017&lt;/a&gt;の1日の記事です。
なお私は当該大学の学部3年(2017年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;ブラウザ上で動作するゲーム「&lt;a href=&#34;https://tatamo.github.io/japari-watch/&#34;&gt;じゃぱりうぉっち&lt;/a&gt;」を作ったので、開発記を書きます。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;じゃぱりうぉっち&#34;&gt;じゃぱりうぉっち&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://tatamo.github.io/japari-watch/&#34;&gt;https://tatamo.github.io/japari-watch/&lt;/a&gt; で公開しており、PCとモバイル端末のどちらでも遊ぶことができます。&lt;/p&gt;

&lt;h3 id=&#34;発端&#34;&gt;発端&lt;/h3&gt;

&lt;p&gt;期末試験前に現実逃避のためにTLを眺めていたところ、以下のツイートが流れてきました。
&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;フェネック「アライさんに似合いそうな帽子を見つけてきたよー」&lt;br&gt;アライグマ「ありがとうなのだ！」&lt;a href=&#34;https://twitter.com/hashtag/%E3%81%91%E3%82%82%E3%81%AE%E3%83%95%E3%83%AC%E3%83%B3%E3%82%BA?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#けものフレンズ&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/%E3%83%89%E3%83%83%E3%83%88%E7%B5%B5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#ドット絵&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/pixelart?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#pixelart&lt;/a&gt; &lt;a href=&#34;https://t.co/1VueMavObQ&#34;&gt;pic.twitter.com/1VueMavObQ&lt;/a&gt;&lt;/p&gt;&amp;mdash; 鬼雷 昇炎 (@kirai_s) &lt;a href=&#34;https://twitter.com/kirai_s/status/934412479597199361?ref_src=twsrc%5Etfw&#34;&gt;2017年11月25日&lt;/a&gt;&lt;/blockquote&gt;&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Version Upgrade Nanoda!! &lt;a href=&#34;https://t.co/IXSjV6A1PN&#34;&gt;pic.twitter.com/IXSjV6A1PN&lt;/a&gt;&lt;/p&gt;&amp;mdash; 鬼雷 昇炎 (@kirai_s) &lt;a href=&#34;https://twitter.com/kirai_s/status/934695920414765056?ref_src=twsrc%5Etfw&#34;&gt;2017年11月26日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;作品としての完成度が高く、実際にゲームとして遊べそうに見えたので、これをゲーム化してみました。&lt;/p&gt;

&lt;h3 id=&#34;素材&#34;&gt;素材&lt;/h3&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;原寸(128*128px)なのだ &lt;a href=&#34;https://twitter.com/hashtag/%E3%81%91%E3%82%82%E3%81%AE%E3%83%95%E3%83%AC%E3%83%B3%E3%82%BA?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#けものフレンズ&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/%E3%83%89%E3%83%83%E3%83%88%E7%B5%B5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#ドット絵&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/pixelart?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#pixelart&lt;/a&gt; &lt;a href=&#34;https://t.co/BJ0Mc27vR5&#34;&gt;pic.twitter.com/BJ0Mc27vR5&lt;/a&gt;&lt;/p&gt;&amp;mdash; 鬼雷 昇炎 (@kirai_s) &lt;a href=&#34;https://twitter.com/kirai_s/status/934699058542678016?ref_src=twsrc%5Etfw&#34;&gt;2017年11月26日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;元画像が上がっていたので使わせていただきました。&lt;/p&gt;

&lt;p&gt;背景に相当する部分の画像がなかったので自分で加工したり、そのまま矩形状にスプライトを切り出すと被ってしまう部分があったのでいくつかのパーツに分けたりしました。&lt;/p&gt;

&lt;h2 id=&#34;製作期間&#34;&gt;製作期間&lt;/h2&gt;

&lt;p&gt;ゲーム本体の作成(アセットの用意・環境構築含む)： 一晩&lt;br /&gt;
公開のためのWebページデザインやTwitterカード、faviconの用意：半日&lt;br /&gt;
公開後の難易度調整+自動モード機能の追加：半日&lt;/p&gt;

&lt;h2 id=&#34;フレームワーク選定&#34;&gt;フレームワーク選定&lt;/h2&gt;

&lt;p&gt;ブラウザで動作するゲームを作ろうと思ったため、基本的にはNode環境で開発を進めていくことになります。
高速に開発するためにTypeScriptで記述することとしたうえで、使用するツールを選定していきました。&lt;/p&gt;

&lt;h3 id=&#34;pixi-js&#34;&gt;PIXI.js&lt;/h3&gt;

&lt;p&gt;PC・モバイル両方のブラウザで動作するゲームという方針のため、HTML5 Canvas系のライブラリを使うことにしました。
npm上で型定義が用意されているものを使いたかったので、今回は&lt;a href=&#34;http://www.pixijs.com/&#34;&gt;PIXI.js&lt;/a&gt;を選択しました。&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;shell&#34;&gt;$ npm install --save-dev @types/pixi.js&lt;/code&gt;で型定義ファイルをインストールし、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import * as PIXI from &amp;quot;pixi.js&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でPIXI.jsの型情報を使用可能になります。&lt;/p&gt;

&lt;h4 id=&#34;ビルドシステム&#34;&gt;ビルドシステム&lt;/h4&gt;

&lt;p&gt;また、今回はブラウザを動作対象とするため、jsファイルのバンドルとBabel化のためにwebpackを使用しました。
実際のところwebpackもBabelもこれまで使ったことがなかったのですが、なんとかts-loaderとbabel-loaderでTypeScriptのソースコードをBabel化してバンドルするところまでやりました。&lt;/p&gt;

&lt;p&gt;期末試験直前であまり学習コストをかけられず、これ以上webpackであれこれするのは怖くなったので、jsファイル以外の静的ファイルのコピーなどはrimrafやcpxを使い、npm scriptsでビルドすることにしました。
また開発中の自動コンパイルのために、chokidarとbrowser-syncを使いました。&lt;/p&gt;

&lt;h2 id=&#34;設計&#34;&gt;設計&lt;/h2&gt;

&lt;p&gt;一定時間ごとにゲームループをまわし、大元のゲームオブジェクトから各マネージャのupdateメソッドを呼び出して処理を行い、最後にレンダリングを行うという基本的な設計としています。&lt;/p&gt;

&lt;p&gt;今回は、エンティティを管理するエンティティマネージャ、スコアを管理するスコアマネージャ、エンティティとスコア以外のゲーム内表示を管理するエフェクトマネージャ、ユーザーからの入力を受け取るインプットマネージャを用意しました。
また、スコアマネージャはインスタンスを2つ生成してそれぞれ取得スコアとミス回数を管理するようにしています。&lt;/p&gt;

&lt;p&gt;ステートマシンを用いてゲーム状態の遷移を管理する方法もありますが、今回はタイトルとゲーム中とゲームオーバーの三状態しかなく、また各エンティティも決まった動きしかしないため不要と判断しました。&lt;/p&gt;

&lt;p&gt;エンティティごとにスプライトのテクスチャを用意しておく必要があり、これはstaticメンバとして各エンティティのクラスに紐付けることにしました。
このテクスチャの生成はアセットのローディングが終わった後に行う必要があるため、エンティティマネージャの初期化時に各staticメソッドを呼び出すことで初期化するようにしました。&lt;/p&gt;

&lt;h3 id=&#34;eventemitterによるメッセージング&#34;&gt;EventEmitterによるメッセージング&lt;/h3&gt;

&lt;p&gt;PIXI.jsで用意されているクラスは&lt;a href=&#34;https://github.com/primus/eventemitter3&#34;&gt;EventEmitter&lt;/a&gt;を継承しており、イベント駆動でのオブジェクト間のメッセージングが可能です。
たとえば&lt;code&gt;アライさん&lt;/code&gt;オブジェクトは&lt;code&gt;Hat&lt;/code&gt;コレクションに対する参照を持ちませんが、イベントの発火にフックしてエンティティマネージャがメソッド引数にコレクションの参照を流し込むことで、&lt;code&gt;アライさん&lt;/code&gt;オブジェクトは外部の参照を持つことなく&lt;code&gt;Hat&lt;/code&gt;コレクションにアクセスし、当たり判定の処理を行うことができます。
これにより、ゲーム内エンティティを表すオブジェクト同士を疎結合に保つことができます。
&lt;code&gt;Hat&lt;/code&gt;のように複数のインスタンスが生成される場合、そのたびにイベントの登録を行う必要があるので、このようなクラスはファクトリを通して実体化するようにします。&lt;/p&gt;

&lt;p&gt;その他にも、インプットマネージャがキーボード入力を受け取ったり、ゲーム画面上に配置されている透明のスプライトに対するクリック・タッチ入力を受け取った場合に、入力された動作に応じたイベントを発火することで、入力の種類を隠蔽したうえでそれにフックする処理を定義可能になります。&lt;/p&gt;

&lt;h2 id=&#34;はまりどころ&#34;&gt;はまりどころ&lt;/h2&gt;

&lt;p&gt;ちょっとしたミスなどですが、詰まった点について。&lt;/p&gt;

&lt;h3 id=&#34;エンティティの消去&#34;&gt;エンティティの消去&lt;/h3&gt;

&lt;p&gt;ループ中にループ対象の配列を変更するな、というのは基本ですが、ゲームの場合当たり判定がヒットしたエンティティを消去したいという場面は多いです。
&lt;code&gt;Hat&lt;/code&gt;コレクションに対してループを回して&lt;code&gt;update()&lt;/code&gt;を呼び出し、その処理の中で&lt;code&gt;Hat&lt;/code&gt;オブジェクトを消去してしまい、それ以降のオブジェクトの処理がおかしくなるというバグが発生しました。&lt;/p&gt;

&lt;p&gt;対処として、まずエンティティに&lt;code&gt;alive&lt;/code&gt;フラグを持たせておき、エンティティを消去したいときには以下のような処理を呼び出すだけにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;die() {
    this.alive = false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、全エンティティのupdate処理終了後に再度ループを回し、ここでaliveフラグがfalseとなっているエンティティをコレクションから取り除きます。
ただし、死んだはずのオブジェクトの当たり判定が残ったりすることを防ぐため、一度aliveフラグがfalseになったエンティティは処理から除外するようにしておく必要があります。
また、結局ループ中の配列を弄ることになるので、このループの中でおかしなことが起きるかもしれないので注意が必要です(とはいえ削除処理を別のループに分けていることで、最悪でもエンティティの削除が次回以降のフレームに引き延ばされてしまう程度の影響しか起きません)。&lt;/p&gt;

&lt;p&gt;ループ中に配列から安全に要素を取り除く方法としては、要素の削除時にイテレータをうまく調整したり、ループインデックスをずらして対処するなどといった方法がありますが、イテレータの仕様を正しく理解している必要があったり、削除処理のタイミングで自分の外側のループのことを考えないといけなかったりするため、処理がやや煩雑になりがちです。
そこで技巧的な方法として、ループのインデックスを配列の末尾から順に0に向けてデクリメントしていけば、途中で要素が取り除かれてもループに影響が出ない、といったものがあります。
ただし処理順は逆になってしまうので、それが気になるなら先述したエンティティ削除用のループでのみ行うなどする必要があります(エンティティの削除処理程度なら順序が変わっても影響が出ないため)。
最も単純なのはループ前にコレクションをコピーしてループを回すことですが、ゲームプログラムで毎フレームごとに配列のコピーを生成するのはパフォーマンス的に避けたいところでもあります。
なお今回は、&lt;code&gt;Hat&lt;/code&gt;オブジェクトは同時に10個も存在することはないため、毎回配列をコピーして削除用のループを回すことにしました。&lt;/p&gt;

&lt;h3 id=&#34;faviconの配信&#34;&gt;faviconの配信&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;favicon.ico&lt;/code&gt;を配信しようと思ったのですが、&lt;a href=&#34;https://tatamo.github.io/japari-watch/&#34;&gt;https://tatamo.github.io/japari-watch/&lt;/a&gt; というURLのルートパスは&lt;a href=&#34;https://tatamo.github.io/&#34;&gt;https://tatamo.github.io/&lt;/a&gt; であるため、&lt;a href=&#34;https://tatamo.github.io/japari-watch/&#34;&gt;https://tatamo.github.io/japari-watch/&lt;/a&gt; 直下にfaviconを配置しても正しく読み込ませることができません。
そのため、&lt;code&gt;&amp;lt;link rel=&amp;quot;shortcut icon href=&amp;quot;favicon.ico&amp;quot; type=&amp;quot;image/x-icon&amp;quot;&amp;quot;&amp;gt;&lt;/code&gt;などとして明示的にfavicon.icoの位置を示す必要がありました。&lt;/p&gt;

&lt;p&gt;また、&lt;code&gt;manifest.json&lt;/code&gt;を&lt;a href=&#34;https://tatamo.github.io/japari-watch/favicons/manifest.json&#34;&gt;https://tatamo.github.io/japari-watch/favicons/manifest.json&lt;/a&gt; に、同様にandroid用のアイコン画像を&lt;code&gt;favicons/&lt;/code&gt;ディレクトリに配置していました。
&lt;code&gt;manifest.json&lt;/code&gt;中の相対パスは基準となるディレクトリが&lt;code&gt;manifest.json&lt;/code&gt;自身となることを知らなかったので、srcパスを&lt;code&gt;&amp;quot;favicons\/android-icon-***.png&amp;quot;&lt;/code&gt;としたところ、&lt;code&gt;favicons/favicons/&lt;/code&gt;が読まれてしまって正しくアイコンを配信できなかったりしました。&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.pixijs.com/&#34;&gt;PIXI.js&lt;/a&gt;はチュートリアルだけは読んだことがあるという状態で、一度実際に使ってみたいと思っていたので使用することができて良かったです。
ドキュメントをろくに読み込まずに使いたい機能だけ調べて使うといった感じでしたが、かなり高速にゲーム開発ができたので非常に便利でした。
またwebpackやBabel、npm scriptsをメインに用いたビルドなどもはじめてだったのですがいい感じにできました。&lt;/p&gt;

&lt;p&gt;使用した画像については作者である&lt;a href=&#34;https://twitter.com/kirai_s&#34;&gt;@kirai_s&lt;/a&gt;さんに確認を得ないまま加工して作り始めてしまったのですが、使用を快く承諾していただけました。
この場を借りてお礼申し上げます。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>ブログのシンタックスハイライトを改善しました</title>
      <link>http://tatamo.81.la/blog/2017/11/08/syntax-highlight-improvement/</link>
      <pubDate>Wed, 08 Nov 2017 18:00:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/11/08/syntax-highlight-improvement/</guid>
      <description>
        &lt;p&gt;このブログのシンタックスハイライトには&lt;a href=&#34;https://highlightjs.org/&#34;&gt;highlight.js&lt;/a&gt;を使用していますが、使い勝手を上げるために調整を行いました。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;コードの強調は不要だがhighlight-jsのテーマは使いたい&#34;&gt;コードの強調は不要だがhighlight.jsのテーマは使いたい&lt;/h2&gt;

&lt;p&gt;プログラムの実行結果など、プログラムそのもの以外を&lt;code class=&#34;html&#34;&gt;&amp;lt;code&amp;gt;&lt;/code&gt;タグで囲いたくなる場合が何度かありました。
class要素に&lt;code&gt;nohighlight&lt;/code&gt;を指定すればハイライトは行われなくなりますが、highlight.jsのCSSテーマも適用されなくなります。&lt;/p&gt;

&lt;h2 id=&#34;インライン要素のハイライトをデフォルトで無効化したい&#34;&gt;インライン要素のハイライトをデフォルトで無効化したい&lt;/h2&gt;

&lt;p&gt;さらに、インライン要素のハイライトを行う場合、対象となるコードが短いために言語の自動検出がうまく働かないことが多いです。
ブロック要素ではMarkdownでcode部分を囲う際に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;```javascript
/* code */
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすることで言語注釈をつけることができますが、インラインの場合はこれができないため言語を明示的に指定する場合には直接codeタグを書く必要があります。&lt;/p&gt;

&lt;h2 id=&#34;解決策&#34;&gt;解決策&lt;/h2&gt;

&lt;p&gt;今のところ&lt;code class=&#34;html&#34;&gt;&amp;lt;code&amp;gt;&lt;/code&gt;で囲った部分はすべてhighlight.jsのテーマを適用してしまって問題はないので、&lt;code&gt;nohighlight&lt;/code&gt;を指定した場合でもCSSテーマが適用されるようにします。
また、インライン要素の場合はデフォルトで&lt;code&gt;nohighlight&lt;/code&gt;にしてしまって、必要がある場合のみHTMLタグを記述して明示的に言語を指定することとしました。
&lt;a href=&#34;http://tatamo.81.la/blog/2015/12/12/apply-highlightjs-to-inline/&#34;&gt;highlight.jsをインライン要素にも適用できるようにした&lt;/a&gt; で書いたコードを、さらに手直しします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// hljs.initHighlightingOnLoad();
window.addEventListener(&amp;quot;DOMContentLoaded&amp;quot;, () =&amp;gt; {
	const elements = document.getElementsByTagName(&amp;quot;code&amp;quot;);
	for (const el of elements) {
		if (el.parentNode.tagName != &amp;quot;PRE&amp;quot;) {
			// インライン要素
			el.style.display = &amp;quot;inline&amp;quot;;
			el.style.margin = &amp;quot;0 2px&amp;quot;;
			el.style.padding = &amp;quot;1px 3px&amp;quot;;
			if (el.classList.length == 0) {
				// classが指定されていない場合はnohighlightとする
				el.classList.add(&amp;quot;nohighlight&amp;quot;);
			}
		}
		hljs.highlightBlock(el);
		// nohighlightでもテーマは適用する
		if (el.classList.contains(&amp;quot;nohighlight&amp;quot;) ||
			el.classList.contains(&amp;quot;lang-nohighlight&amp;quot;) ||
			el.classList.contains(&amp;quot;language-nohighlight&amp;quot;)) {
			el.classList.add(&amp;quot;hljs&amp;quot;);
		}
	}
}, false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、&lt;code class=&#34;html&#34;&gt;&amp;lt;code&amp;gt;&lt;/code&gt;タグでclassの指定が明示的に行われていない場合は自動的に&lt;code&gt;nohighlight&lt;/code&gt;クラスを追加しています。
この処理はhighlight.jsでのハイライト化の処理を行う前に持ってきました。
スタイルの適用も同じように前に持ってきましたが、特に問題はないようです。
次に、&lt;code&gt;nohighlight&lt;/code&gt;が指定されていてハイライトが行われていない要素に対して、classにhighlight.jsで使用されているクラスである&lt;code&gt;hljs&lt;/code&gt;を指定することでテーマの適用を行っています。&lt;/p&gt;

&lt;p&gt;あとは既存の記事をこの変更に合わせて修正しました。
ところどころ不自然なハイライトが行われていた箇所がありましたが、これで改善されました。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>Indeed視察ツアー2017参加記</title>
      <link>http://tatamo.81.la/blog/2017/09/17/indeed-austin-tour/</link>
      <pubDate>Sun, 17 Sep 2017 01:54:04 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/09/17/indeed-austin-tour/</guid>
      <description>
        &lt;p&gt;9月10日から15日まで、Indeed Austin視察ツアーに参加してきました。
これは、自己負担なしでアメリカのオースティンに連れて行ってもらえるというものです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;参加まで&#34;&gt;参加まで&lt;/h2&gt;

&lt;p&gt;一ヶ月のインターン(東京/オースティン)、一週間の視察ツアーという3つのコースが募集されていたので全部申し込んだところ、インターンには落とされてツアーに連れて行ってもらえることになりました。&lt;/p&gt;

&lt;p&gt;ツアーには学生16人が参加していて、学部と修士の割合はほぼ半々でした。
インターンに落とされてツアーに参加することになったという人が結構多かった印象です。&lt;/p&gt;

&lt;p&gt;いろいろなお話を英語で聞けるのですが、同行のスタッフが逐一翻訳してくれるので英語力がなくても一応は大丈夫です。&lt;/p&gt;

&lt;h2 id=&#34;1日目&#34;&gt;1日目&lt;/h2&gt;

&lt;p&gt;朝から新幹線に乗って羽田空港へ移動。
他の参加者と一緒に席が取られていたので、自己紹介などをしながら品川へ。&lt;/p&gt;

&lt;p&gt;羽田空港で集合し、まずはロサンゼルスに飛びました。
集団行動しながら搭乗手続きをするのはなかなか疲れるものがありました。&lt;/p&gt;

&lt;p&gt;機内食は味付けが日本とは違っていてちょっと口に合わないものもありましたが、赤ワインが飲めたので満足です。
9時間のフライトでひたすら寝ていたら体のあちこちが痛くなりました。&lt;/p&gt;

&lt;p&gt;日本を14時頃に出発して、ロサンゼルスには時間が戻って12時頃の到着になります。
テキサス州にあるオースティンの時刻ではこの時点で14時です。
LAXにはちょうど3ヶ月前に来ていて、これで2度目なので海外とはいえ安心感があります。
そしてそのままオースティンへ、約3時間かけて移動しました。&lt;/p&gt;

&lt;p&gt;到着後はバスでレストランに向かって夕食。
サーモンなどが出ました。
ひと皿で一食分になりそうなほどの量の食事がどんどん出てきたので、出されたもの全部食べてたら相当苦しくなりました。
この日から夕食には普通にアルコールが頼めたので、ほぼ毎日飲んでいました。&lt;/p&gt;

&lt;h2 id=&#34;2日目&#34;&gt;2日目&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2017/09/17/1505577496161.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2017/09/17/1505577496161.jpg&#34; alt=&#34;indeed本社&#34; style=&#34;width:45%;&#34;&gt;&lt;/a&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2017/09/17/1505577506288.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2017/09/17/1505577506288.jpg&#34; alt=&#34;we help people get jobs.&#34; style=&#34;width:45%;&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;朝は10時集合で、この日はindeed本社オフィスへ。
お話を聞いているのは眠くなるので、コーヒーを飲んでおけばよかったという感じです。&lt;/p&gt;

&lt;!--
memo:
###  First
#### principle
 * simple
 * fast
 * comprehensive
 * relevant

#### small team
* ideally, less than 8 engineers in a team
 * 2-7 software engineers
 * product manager
 * QA Analyst
 * Program Manager
* separate team and keep small teams
* everyone can make decisions

#### data-driven
* everything data-driven
* not depend * location, but * product
 * log everything
 * use data to decide what to do
 * use data to masure success
 * use data to power the products

#### make it fast
##### rapid iteration
* not commiting code but **putting software in production** helps people
* faster feedback -&gt; better products
* less stressful / lower risk
 * fewer changes from week to week -&gt; small error

##### keep it simple, stupid
* don&#39;t over-engineer
* solve the most important pieces first

#### make it scalable
* make products work at needed scale
--&gt;

&lt;p&gt;昼食も社内食堂を利用しました。
sushiは人がとてもたくさん並んでいたので諦めました。
社員の人と英語で話しながら食事を取ったのですが、英語が全然聞き取れなくてつらくなりました。&lt;/p&gt;

&lt;p&gt;午後も引き続いて話を聞き、この日は終了でした。&lt;/p&gt;

&lt;p&gt;夕食はメキシカンで、到底食べ切れる量ではなく残しました。&lt;/p&gt;

&lt;p&gt;夜はかなり時間があったので、4人で集まってカードゲームに興じたりしました。&lt;/p&gt;

&lt;h2 id=&#34;3日目&#34;&gt;3日目&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2017/09/17/1505578674596.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2017/09/17/1505578674596.jpg&#34; alt=&#34;市庁舎&#34; style=&#34;width:45%;&#34;&gt;&lt;/a&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2017/09/17/1505578681788.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2017/09/17/1505578681788.jpg&#34; alt=&#34;景色&#34; style=&#34;width:45%;&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;なぜか前日より集合時間が早くなっていましたが、午前はIT企業見学、午後はセグウェイに乗っての観光でした。&lt;/p&gt;

&lt;p&gt;日本だとベンチャー起業は若い人がするものという印象が強いですが、訪問した企業であるCognitiveScale社では、むしろ長い間業界を見てきたことによる知見を活かしてB2Bのビジネスを提供しているという感じでした。
また人材面でも、人工知能や自然言語処理などの分野でPh.Dを取った人を探しているなど、会社に合った専門知識を持った人を活かそうとしているようでした。&lt;/p&gt;

&lt;p&gt;昼食はサラダとバーガーで、量が多すぎたりもせず美味しかったです。&lt;/p&gt;

&lt;p&gt;セグウェイは基本的な操作は意外とすぐに慣れることができました。
とはいえ速く走っているときの旋回動作、ブレーキ動作は怖くてあまりうまくできませんでした。
ダウンタウン全体を見て回りましたが、ずっと立った姿勢でいなければいけないのでかなり疲れました。&lt;/p&gt;

&lt;p&gt;夕食はtempuraとsushiで、ネタが大きかったりアボカドロールがおいしかったりしたのが印象的でした。&lt;/p&gt;

&lt;h2 id=&#34;4日目&#34;&gt;4日目&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2017/09/17/1505579496959.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2017/09/17/1505579496959.jpg&#34; alt=&#34;UT&#34; style=&#34;width:45%;&#34;&gt;&lt;/a&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2017/09/17/1505578843235.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2017/09/17/1505578843235.jpg&#34; alt=&#34;肉の塊&#34; style=&#34;width:45%;&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ツアー最終日で、この日はテキサス大学に行きました。
いろいろな施設を案内してもらいましたが、ずっと立って歩き回るのは大変でした。
テキサス大学カラーのオレンジが至る所に配置されているのが印象的で、売っているグッズがTシャツだけでも相当な数のバリエーションがあって驚きました。&lt;/p&gt;

&lt;p&gt;昼食はカフェテリアを利用しました。
ここにきてアメリカで初めてピザを食べられましたが、見た目が細かったのでいくつか取ったところ、非常に腹にたまって食べきるのが大変でした。
自分は食べていませんが、うどんはスープがみそ汁になっていて割と不評でした。&lt;/p&gt;

&lt;p&gt;午後にはまたindeed本社に移動し、全体のまとめとして個人ワークと発表をしました。&lt;/p&gt;

&lt;p&gt;夕食はバーベキュー料理で、無限に肉が供給され続ける感じでした。&lt;/p&gt;

&lt;p&gt;ホテルに戻ってから何人かで買い出しに行き、お酒を買ってきてしばらく飲み続けていました。&lt;/p&gt;

&lt;h2 id=&#34;5-6日目&#34;&gt;5,6日目&lt;/h2&gt;

&lt;p&gt;日に日に集合時刻が早くなっていったのですが、この日は朝5:30にホテルを出て帰国のため空港に向かいました。&lt;/p&gt;

&lt;p&gt;睡眠不足だったのでオースティンからロサンゼルスまでの飛行機でずっと寝ていて、起きたら鼻の調子が悪くて耳の気圧調節がうまくいかなくて耳が痛くなりました。&lt;/p&gt;

&lt;p&gt;東京までの飛行機では、買ってから食べられていなかったビーフジャーキーなどの肉製品をビールを飲みながら消費し、映画を一本見て寝て起きてまた映画を一本見たら到着しました。&lt;/p&gt;

&lt;p&gt;羽田で解散し、東京らしいことは何もなくそのまま新幹線で帰りました。&lt;/p&gt;

&lt;h2 id=&#34;運動&#34;&gt;運動&lt;/h2&gt;

&lt;p&gt;応募した際の面接で1時間×3本のホワイトボードコーディングを課せられて疲れ果てて、体力の必要性を痛感したというのがあります(インターンの応募の際の面接で、ツアーのみの応募の場合はここまでやらされないそうなので安心してください)。
それから家で少しずつ筋トレを続けてきましたが、アメリカ滞在中は何故か毎日運動しまくる機会がありました。&lt;/p&gt;

&lt;h3 id=&#34;1日目-1&#34;&gt;1日目&lt;/h3&gt;

&lt;p&gt;夕食後、ホテルに24時間利用可能なトレーニングルームがあったため、ランニングマシーンで30分走ったりダンベルを持ち上げたりして1時間ほどこもっていました。&lt;/p&gt;

&lt;h3 id=&#34;2日目-1&#34;&gt;2日目&lt;/h3&gt;

&lt;p&gt;夕食前に一時間ほどホテルで自由時間があったので、前日同様にトレーニングルームに行きました。&lt;/p&gt;

&lt;h3 id=&#34;3日目-1&#34;&gt;3日目&lt;/h3&gt;

&lt;p&gt;前日から朝にランニングをしている人たちがいたので加わりました。
案の定自分が一番走れなかったので、開始早々から息を切らしながらなんとかついていく感じでした。
何度も休憩を入れてもらいながら、池の周りを走ったりスーパーに向かったりして1時間ほど走りました。&lt;/p&gt;

&lt;p&gt;これで完全に疲れ果ててしまったので、日中のセグウェイでさらに体力を奪われたこともあって、夜ホテルに帰るとそのままベッドに倒れ込みました。&lt;/p&gt;

&lt;h3 id=&#34;4日目-1&#34;&gt;4日目&lt;/h3&gt;

&lt;p&gt;前日の影響で筋肉痛でしたが、朝から少し走り、前日に走っている途中に見つけていたバスケコートに行って8人でバスケットボールをしました。
ルールや動き方がよくわかっていなかったのでチームに貢献は出来ていないですが、それでも走り回っているととても体力を使いました。
歩くと足が痛いくらい筋肉痛になってしまった上、日中のUT見学はずっと立って歩き回ったので大変でした。&lt;/p&gt;

&lt;h3 id=&#34;5-6日目-1&#34;&gt;5,6日目&lt;/h3&gt;

&lt;p&gt;朝5:30集合のため特に運動している時間はありませんでした。
筋肉痛は残っていて、歩くと普通に痛かったです。&lt;/p&gt;

&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-cards=&#34;hidden&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;君の名は。見てました あれは良い映画ですね &lt;a href=&#34;https://t.co/lgMoEoBXTG&#34;&gt;pic.twitter.com/lgMoEoBXTG&lt;/a&gt;&lt;/p&gt;&amp;mdash; たたもさん@がんばらない (@&lt;strong&gt;tatamo&lt;/strong&gt;) &lt;a href=&#34;https://twitter.com/__tatamo__/status/908578060579958784&#34;&gt;2017年9月15日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
帰りの飛行機で「君の名は。」を初めて見ましたが、とても良い映画でした。&lt;/p&gt;

&lt;p&gt;以下多少ネタバレを含みます。&lt;/p&gt;

&lt;p&gt;特にラストシーン直前から最後の一カットへの、バッドエンド的な寂寥感・喪失感とハッピーエンド的な明るさとが同居する終わり方が最高ですね。
良い作品は終わった後に空虚な気持ちになれるのが苦手であると同時に大好きです。&lt;/p&gt;

&lt;p&gt;物語中盤で明らかになる事実を瀧くんが「忘れていた」こと、二人が入れ替わり中にその事実に起因する差異について違和感を抱かなかったことなど、入れ替わりはあくまで夢として語られ、曖昧さ・矛盾を持つものになっています。
一方で夢から覚めるとその内容を忘れてしまうように、逆にそれが物語中盤以降で二人が「忘れていく」ことへの説得力を与える要因にもなっている気がしました。&lt;/p&gt;

&lt;p&gt;「あの世から此岸に帰るためには自分の大切な半分を引き換えにしなければならない」という伏線は、最後の入れ替わりが終わるとともにお互いのこと、「あの世」のことを忘れていくことをも示唆しています。
また、名前を忘れることと引き換えにして好意を伝えることにも関連を見いだすことが出来ます。&lt;/p&gt;

&lt;p&gt;おばあちゃんの「自分も三葉の母親も昔同じような夢を見ていたが、いつか忘れていく」という発言や、父親が三葉の中の瀧に気付くシーンがあるように、一部の人々は入れ替わりを知っています。
作中で明言はされていませんが、このことがラストシーンに繋がっていると考えるのは自然でしょう(省略された説得フェイズがうまくいった理由など)。&lt;/p&gt;

&lt;p&gt;結構複雑というか思ったよりもオタク向けというか、これ一般受けするんだなあという感じがしないでもないです。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;本題。&lt;/p&gt;

&lt;p&gt;自己負担無しでアメリカに行けて、さらに毎食違った所に連れて行ってもらってたくさん食べられる(すごい量ですが)ので、とてもおすすめの企画です。
アメリカでいろいろと意識の高い企業や人々を見せてもらえて、また一緒に行った人たちからも刺激を得られたのでとても良かったです。&lt;/p&gt;

&lt;p&gt;英語力は必要ないとはいえ、一緒に来た人が英語で現地の社員の方などと会話している一方で、自分は会話を聞き取れなくてついていくのがやっとだという状況が発生したりして、能力の差やそれによって得られるものの違いも感じたりしました。&lt;/p&gt;

&lt;p&gt;これからの時代で日本だけに篭って生きていこうとしても先行きが見えない上いろいろと機会を逃してしまうので、いわゆるグローバルな視点というのは必要になってきます。
幸いなことに英語が話せれば英語圏のみならず多くの国々にアプローチできるようになってくるので、やはり英語は最重要です。
学生のうちに勉強しておくものとして英語は最も費用対効果が高いと感じました。&lt;/p&gt;

&lt;p&gt;一方で、英語を使って活動するようになると、そこはもう英語が話せて当然の世界です。
そこでは英語が話せるということはスタートラインに立つための最低条件でこそあれ、それ単体ではアドバンテージとはなりません。
そのため、エンジニア的な人間になろうとするなら、別の軸で何か一つ強みを持っておくことは重要だろうなと思いました。&lt;/p&gt;

&lt;p&gt;とはいえ、日本的な価値観で生きてきた以上、大学生のうちは自己投資なんざにかまけていないでモラトリアムを満喫したいという気持ちがあります。
アメリカの大学生なんかはみんな至る所で勉強していて、のんびりとしていたらどんどん差をつけられてしまう気もするので、悩ましい限りです。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>セキュリティキャンプ全国大会2017に参加してきました</title>
      <link>http://tatamo.81.la/blog/2017/08/27/seccamp-2017/</link>
      <pubDate>Sun, 27 Aug 2017 23:54:42 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/08/27/seccamp-2017/</guid>
      <description>
        &lt;p&gt;8/14から8/18まで開かれたセキュリティキャンプに参加してきました。
応募用紙に書いた内容は&lt;a href=&#34;http://tatamo.81.la/blog/2017/05/29/seccamp-2017-sheet/&#34;&gt;こちら&lt;/a&gt;の記事に書いてあります。&lt;/p&gt;

&lt;p&gt;今日中に感想文を上げないといけないらしいので、参加記を書きます。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;0日目&#34;&gt;0日目&lt;/h2&gt;

&lt;p&gt;開始日前日がC92最終日だったのでもしかしたらコミケ行けるのでは？などと思っていましたが、大学の試験期間中は事前課題に全く手をつけていなかったのでいろいろ山積していてだめでした。&lt;/p&gt;

&lt;p&gt;夕方のうちに名刺を刷っておこうと思っていたのですが、Windows 10 Creators Updateが入ってノートPCが数時間使えなくなった上にGRUBが上書きされてデュアルブート環境が壊れました。
修復用のディスクの用意やGRUBの再インストールなどでかなり時間を使ってしまい、睡眠時間を削って名刺を刷る羽目になりました。&lt;/p&gt;

&lt;h2 id=&#34;1日目&#34;&gt;1日目&lt;/h2&gt;

&lt;p&gt;すいみん不足。&lt;/p&gt;

&lt;p&gt;休憩時間に軽く寝てたら名刺交換出遅れたりしました。
名刺は60枚ほどは交換できたかな、という感じです。
JSON形式のプロフィール文をcatしたものを印刷しただけ、という名刺を持っていきましたが、意外とネタ被りしている人が少なく(一人はいた)、名刺を覚えてもらいやすかったので重複して交換することを防げました。
100枚ほどは用意したので、流石に名刺入れに収まりきらないだろうと思ってデッキケースに入れていったところ、同じことをしている決闘者を発見できました。&lt;/p&gt;

&lt;p&gt;初日なのでありがたいお話をひたすら聞くだけでした。
支給されたハンドスピナーを回したりしながら耐えていましたが、2つ目の全体講義は記憶から完全に飛んでいます。
まあそれ以外の講義もろくに覚えちゃいませんが。
何人かのチューターの方の圧倒的進捗の報告を聞いて圧倒されたのは覚えています。&lt;/p&gt;

&lt;p&gt;お夕飯を食べましたが、お夕飯にしては控えめな量だった気がします。
その後グループワークになり、ぼんやりしたお題だなあと一抹の不安を感じつつ、ひとまずノルマとして課せられた講師やチューターへの聞き込みを各自で進めることに決めました。
グループワークでの情報のやりとりにはTwitterのグループDMとGoogle Docsを使いました。&lt;/p&gt;

&lt;p&gt;22時に終了したので風呂に入ってそのまま寝ました。&lt;/p&gt;

&lt;h2 id=&#34;2日目&#34;&gt;2日目&lt;/h2&gt;

&lt;p&gt;最初の講義は8:30開始でしたが、目が覚めたのは8:20でした。
空腹だったので食堂に行き(8:24)、時間がなかったので、ひと皿だけ取って食べて講義の教室に入り(8:29)ました。&lt;/p&gt;

&lt;h3 id=&#34;c1-ブラウザの脆弱性とそのインパクト&#34;&gt;C1 ブラウザの脆弱性とそのインパクト&lt;/h3&gt;

&lt;p&gt;ブラウザの脆弱性を見つけて生計を立てていた人がどのように脆弱性を見つけていたのか、を教えてもらいました。
やっぱり場数かなあ、と思いました。
リリースノートを監視していくのは単純に面白そう。&lt;/p&gt;

&lt;h3 id=&#34;d2-3-カーネルエクスプロイトによるシステム権限奪取&#34;&gt;D2~3 カーネルエクスプロイトによるシステム権限奪取&lt;/h3&gt;

&lt;p&gt;講師の方が同じ大学の先輩なのですが、リアルでは会ったことがなくセキュキャン会場ではじめてお会いしました。
グループワークの聞き込みで名前と所属を聞かないといけなかったのですが、「ああ知ってます、イノベーションなんとか科のるくすくん(&lt;a href=&#34;https://twitter.com/RKX1209&#34;&gt;@RKX1209&lt;/a&gt;)さんですよね？」って言ったら覚えてろよって言われました。&lt;/p&gt;

&lt;p&gt;応募用紙でカーネルエクスプロイト問を選択したのでその延長という感覚で受講を決めた講義です。
事前課題でROPの組み方を予習して、講義ではそれを使ってエクスプロイトを書くという感じだったので、ひたすらROP職人っぽいことをしていたという感じの印象があります。&lt;/p&gt;

&lt;p&gt;前半はWebKitの脆弱性で遊びました。
32bitの範囲内の数値しか扱えないJavaScriptで64bitメモリ空間のROPをやるにはこうすればいいのかーなどど思いました。&lt;/p&gt;

&lt;p&gt;後半はBadIRETでユーザー空間とカーネル空間のGSレジスタがswapされてしまう脆弱性を突いたエクスプロイトを記述しようと試みました。
&lt;a href=&#34;https://speakerdeck.com/rkx1209/kaneruekusupuroitoniyorusisutemuquan-xian-duo-qu&#34;&gt;講義資料&lt;/a&gt;のP65の任意アドレス書き込みのためのパディングの大きさを調べようとしたところ、当該箇所の構造体の定義部分が200行ぐらいあって詰みました。
ちゃんとカーネルデバッグかけてサイズを吐かせる必要があるようです。
講義時間だけではとても足りなかったのでもう少し自分で続きをやりたいところです。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;この日は早めに寝ました。&lt;/p&gt;

&lt;h2 id=&#34;3日目&#34;&gt;3日目&lt;/h2&gt;

&lt;p&gt;朝6:30に起きてグループで集まって話し合いをしました。
聞き取り結果などをまとめて部屋に戻ったら、ちょうどけものフレンズが始まったところだったので見ました。
早起きしたのでちょっと睡眠が足りていないかな？という感じでした。&lt;/p&gt;

&lt;h3 id=&#34;e4-サイバー犯罪捜査の現場&#34;&gt;E4 サイバー犯罪捜査の現場&lt;/h3&gt;

&lt;p&gt;事前学習スレに講師からの投稿が100件以上あってヒーヒー言ってました。&lt;/p&gt;

&lt;p&gt;千葉県警の協力のもと、家宅捜索してDFして逮捕するという流れを一通りやりました。
チームのリーダーをやらせてもらったのですが、座って時々指示を出して情報をまとめるお仕事をしていたら捜査フェイズが終わったのでフォレンジックらしいことはチームのメンバーに丸投げする形になってしまいました。&lt;/p&gt;

&lt;p&gt;家宅捜索フェイズでは証拠品を探し回ったのですが、見つけさせる気無いだろうというぐらい手の込んだ隠し方でした。
役得というか、容疑者の自室前で捜査令状を突きつけたり、後半で容疑者に逮捕状を突きつけたりできたので、単純にひたすら楽しかったです。
令状を持って容疑者宅の前まで行ったら報道陣まで待機していて笑いました。&lt;/p&gt;

&lt;p&gt;その後の昼食で担当してもらった(というか逮捕した)警察の方に色々と話を聞かせてもらったのもとても楽しかったです。&lt;/p&gt;

&lt;h3 id=&#34;c5-暗号運用技術&#34;&gt;C5 暗号運用技術&lt;/h3&gt;

&lt;p&gt;なかなか重い講義が多いセキュキャンでしたが、これは入門講義という感じで割とふんわりしていました。
ちょっと座学が多かった(=眠くなった)気がします。
普段使ってる「証明書」って何なの？という感じだったので、運用面まで含めて教えてもらえたのは良かったです。
ある二つのRSA鍵が共通の秘密鍵を使っている場合、公開鍵同士の最大公約数は簡単に求まるためクラック可能だというのはなるほどと思いました。&lt;/p&gt;

&lt;h3 id=&#34;bof-企業プレゼン&#34;&gt;BoF、企業プレゼン&lt;/h3&gt;

&lt;p&gt;BoFが終わったら既に企業プレゼンが始まっている時間でした。&lt;/p&gt;

&lt;p&gt;セキュリティ、というかITに関係のない人の話を聞きましたが、なんか既視感があったので同じ人もしくは似たような人の話を以前聞いたことがあるのではないかという気がします。
結構強烈だったのでしばらく感覚がセキュキャンから引き離されました。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;その後はグループワークをして終了。
最初はなかなか方向性を絞りきれずに話が脱線しがちだったのですが、話し合っているうちになぜかテーマがまとまってきていて不思議でした。&lt;/p&gt;

&lt;p&gt;お酒が飲みたくても飲めないのでふてくされつつ、ゆっくりお茶をいれてお菓子を食べていたら寝る時間が削れました。&lt;/p&gt;

&lt;h2 id=&#34;4日目&#34;&gt;4日目&lt;/h2&gt;

&lt;p&gt;選択講義は4日目が最終日です。&lt;/p&gt;

&lt;h3 id=&#34;c6-スマートフォン向けゲームのセキュリティ&#34;&gt;C6 スマートフォン向けゲームのセキュリティ&lt;/h3&gt;

&lt;p&gt;超楽しかったです。&lt;/p&gt;

&lt;p&gt;まずはWeb上のゲームのハック。
事前課題で出ていたものの難易度を少し上げたものに挑戦しました。
難読化されたソースコードをデコードして(これは想定外だったらしい)、リクエストを飛ばす関数をそのまま呼び出して突破。&lt;/p&gt;

&lt;p&gt;次にAndroidエミュレータ上でいろいろな手段でゲームアプリのクラックを試みました。&lt;/p&gt;

&lt;p&gt;まずはメモリの書き換え。
うさみみハリケーンとかスペシャルねこまんま57号とか、使ったことありますよね。
あれでJava上で動いているソフトを攻略できたためしがないので、もしかして仮想マシンなどの上で動くソフトはメモリ書き換えに耐性があるのかな、などと思いました。
メモリ書き換えまでしっかり対策したプログラムを書くのは大変そうです。&lt;/p&gt;

&lt;p&gt;次にパケットの改竄。
当然通信は暗号化されているのですが、「バイナリコードを覗いてみたらXCHG命令があって、しかもその部分に謎の定数が置かれているのでこれがXORの鍵っぽい」とかいうやり方で突破していてまじかってなりました。&lt;/p&gt;

&lt;p&gt;これ一般に出回っているゲームアプリに普通にチート仕掛けられるのでは？と心配になるほどいろいろやったので、全体講義で口うるさく言われたセキュリティ倫理を早くも試されているのか、という気持ちになりました。&lt;/p&gt;

&lt;h3 id=&#34;a7-ファジング実習&#34;&gt;A7 ファジング実習&lt;/h3&gt;

&lt;p&gt;ファジング #とは という感じだったうえに事前課題でルータを渡されて「調査してみてください」と言われ、資料通りに何時間かファジングしてみたものの何も起こらず、？？？という気持ちだったので不安でしたが、講義では詳細に教えてもらえてむしろ事前課題とは何だったのか、という感じになりました。&lt;/p&gt;

&lt;p&gt;ルータをファジングしましょうと言われたのでファジングとはネットワーク系の検査に使うものなのかな、などと思っていたのですが、実際にはソフトウェアに対しても行うことができ、なかなか強力なようです。
自分が作ったソフトの脆弱性発見にも役立ちそうなので、使いこなせるようになってみたいと思います。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;その後はグループワークをしたあと、技術書のプレゼントが行われました。
年齢が若い人から順に早いもの勝ちで、私はほぼ最高齢だったので人権はありませんでした。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;うらやましくなんてないのです、我々は大人なので &lt;a href=&#34;https://twitter.com/hashtag/seccamp?src=hash&#34;&gt;#seccamp&lt;/a&gt;&lt;/p&gt;&amp;mdash; たたもさん@がんばらない (@&lt;strong&gt;tatamo&lt;/strong&gt;) &lt;a href=&#34;https://twitter.com/__tatamo__/status/898157958206377985&#34;&gt;2017年8月17日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;E4の講義で中のコインの内側にMicroSDが隠されていた豚の貯金箱がまだ残っていたので、一つもらっておきました。&lt;/p&gt;

&lt;p&gt;他の日より一時間程度早く終わりましたが、グループワークが間に合っているはずもなく、風呂に入ってからまたグループで集まりました。
とはいえ方向性はまとまりつつあったので、一時間程度話し合った時点で解散。
夜遅くまでグループでの話し合いを続けることは免れました。&lt;/p&gt;

&lt;p&gt;我々のグループはかなり早めに解散できたのですが、プレゼン担当の人はその後数時間作業してくれていたようで頭が上がりません。&lt;/p&gt;

&lt;p&gt;早めに寝ようと思っていたのですが、ちょっとtwitterを開いたばかりに40分ほど持って行かれました。&lt;/p&gt;

&lt;h2 id=&#34;5日目&#34;&gt;5日目&lt;/h2&gt;

&lt;p&gt;最終日です。
まずはグループワークの総仕上げと発表で、我々のチームは既にプレゼンも仕上げてもらっていたので、最後の作業時間はのんびりと過ごしていました。&lt;/p&gt;

&lt;p&gt;グループワークの発表は、我々のチームは割と全体を通してまとまりのある雰囲気の発表が出来た気がするので良かったと思います。
5000兆円フォントがネタとして被りまくっていたので、使わなかったのは正解でした。&lt;/p&gt;

&lt;p&gt;その後昼食を挟んで成果報告、その後閉会式でした。
終始時間に追われていたセキュキャンで何をどうやれば閉会式に90分も割り当てられるのか不思議でたまりません。&lt;/p&gt;

&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;まず、全体的にハードな時間配分だったように感じます。
8:30の講義開始に間に合わせるように起床して、次に自由が得られるのは22:00です。
それから部屋に戻って風呂に入って筋トレをして寝るので、8時間睡眠を得るには困難が伴います。&lt;/p&gt;

&lt;p&gt;昼食時間は基本的に参加者やチューター、講師との交流にあてられるため、休憩をしている余裕はあまりなかったように感じます。
これは余談ですが、3日目ぐらいに一度「食事会」があり、チューターや講師と相席になるようにして交流をするという企画でした。
スケジュール表には他の食事と全く同じように表示されており、また人が揃ってから一斉に食べるという方針でしたが、まあ伝達が行き届かなくて人が揃いきるのは無理だろうという感じで、せめて時間を他の日の食事時間よりも多めに取ったほうが良かったのではないかという気がします。&lt;/p&gt;

&lt;p&gt;それも含めてではありますが、全体的に過密スケジュールになっているので、どこにしわ寄せが来るかというと睡眠時間、休憩時間、そして参加者同士の交流の時間が削られていくのかなという感じでした。&lt;/p&gt;

&lt;p&gt;まあ単純に、もう少し寝られたら良かったなあという感じです。
演習がなければやっていることは大学の講義に似ているので、当然眠くなります。
初日の全体講義は席が決まっているし、企業プレゼンは名簿を取られていたのでサボるための抜け道に欠けます。&lt;/p&gt;

&lt;p&gt;とはいえグループワークで一緒になったメンバーとは思った以上に話をする機会が多く、いろいろな情報を共有できたのは良かったです。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;一番上の年齢層の私が言うのも、ですが、大学生や20歳以上の人が多いなあというのは感じました。
私は中高生のときに尻込みしてセキュキャン応募できなかったので最後のチャンスに応募したというのが理由ですが、聞く限りではリアルの知り合いからセキュキャンのことを知って応募したという人が多く、ネットなどで存在を知った私のような人はどうやら少ないらしいです。
なんででしょうね。&lt;/p&gt;

&lt;p&gt;応募用紙の課題をこなせる力量という面で言えば大学生や高専生の上の方の学年の人間は比較的有利だろうなあという気はしますが、そのあたりは運営の方でうまく加味してもらっているのではないかとも思いますし謎です。&lt;/p&gt;

&lt;p&gt;中高生が多いほうが良いんじゃないかなあ、とは思います。
大学生と中高生(と小学生)が同居できるイベントでは中高生が主役になるべきです。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;セキュキャン最終日とか終了後のアンケートとかで、「セキュキャンで挫折を味わいましたか？」という質問があり、大半の人が手を挙げているのが見えたのですが、私としては挫折は味わっていないかなあ、などと思いつつ手を挙げずにいました。
そもそも挫折を感じるというのは、何かに取り組んでみて自分の能力が足りなくて力及ばなかったために打ちひしがれる、というようなことを言うのではないかと思うのですが、セキュキャンで何か自分の能力を測られるようなことに取り組んだか？と言われると大して思い当たる節が無いように感じます。
そのように振り返ってみると、まだ挫折を感じるという段階にも達していないのかなあというように思います。&lt;/p&gt;

&lt;p&gt;挫折を感じたかどうかは置いておくとして、チューターや講師の方が圧倒的な進捗を出しているのを見て、今の自分ではとても敵わないなあ、果たして追いつけるのだろうか、という気持ちは大いに抱いています(これを挫折と言うんでしょうか？)。
参加者ともたくさん話す機会があり、ネットワークをやっている人やセキュリティをやっている人など、自分がこれまで会った人があまりやっていないようなことをメインにやっている人も多く、そういうことをやっている人って実在したんだなどと思ったりしていました。
いろいろな人がいろいろなことをやっているようなのですが、どうも圧倒的進捗を生んでいる人はある特定の分野で圧倒的進捗を生んでいるみたいです(当然)。ということは、みんな自分が得意という分野を持っているのかなあ、というように思いました。&lt;/p&gt;

&lt;p&gt;私はこれをやりたいなというものがあまりないですし、何か見つけられるかなと思ってセキュキャンに行ってみた、という側面もあるのですが、結局セキュリティに興味を持ったか？といわれるとウーンそこまでかなあという感じで、なにをやりたいかを見つけるのは大変なようです。
そういった面では、セキュキャンに行ったからといって何かが変わるということはなく、得られた知見をきっかけにして進捗を出していくほかはないようです。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>HIROic Freeciv Challengeの参加結果</title>
      <link>http://tatamo.81.la/blog/2017/07/11/freeciv-arago-challenge-02/</link>
      <pubDate>Tue, 11 Jul 2017 15:03:07 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/07/11/freeciv-arago-challenge-02/</guid>
      <description>
        &lt;p&gt;&lt;a href=&#34;https://www.arago.co/hiro-freeciv&#34;&gt;aragoのFreeciv Strategy Challenge&lt;/a&gt;の企画である&lt;a href=&#34;https://freeciv-leader-board.hiro.community/about&#34;&gt;HIRO-ic Challenge&lt;/a&gt;に参加していましたが、結果が出ました。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;結果&#34;&gt;結果&lt;/h2&gt;

&lt;p&gt;それぞれのゲームプレイをもとにして、各プレイヤーの行動を模したAIが作成されます。
そのAI同士で対戦を行うことで、順位が決定されます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://freeciv-leader-board.hiro.community/ladder&#34;&gt;順位表&lt;/a&gt;によると、私は全プレイヤー中2位の結果となりました。世界ランク2位(自称)です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://freeciv-leader-board.hiro.community/battle-grid&#34;&gt;BATTLE GRID&lt;/a&gt;を見ると、私のAIのみが唯一すべてのプレイヤーのAIに対して勝ち越しまたは引き分けており、1位のプレイヤー相手にも勝ち越していることがわかります。
1位のAIと比べると、私のAIは格下相手に稼ぎ負けたために2位になったといえます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://freeciv-leader-board.hiro.community/detailed/Tatamo&#34;&gt;個人スコア&lt;/a&gt;を見ると、各国家が小島からスタートするルールでのスコアが非常に低く、ほとんどの対戦で負け越しています。
これは交易路主体の戦略がこのルールでは弱く、またある程度国土を広げると拡大を止めるために他の国家と都市数の面で不利になったこと、これらが合わさって都市の成長速度が遅いために十分にスコアを稼ぐ前に終了ターンに達してしまったことなどが考えられます。&lt;/p&gt;

&lt;p&gt;さらに自分のゲームプレイから考えると、自分がプレイしたゲームでは近い位置に隣国がいるようなマップを引かなかったので、完全に内政寄りのAIになっていてゲーム序盤から戦争を仕掛けられた場合に不利になっていたのではないかと考えられます。
また、都市数を抑えて交易路で準備を整えてから祝祭ブーストによって国力を一気に引き上げるため、準備が整うまでにゲーム終了となると都市数を多く増やした国家に勝つことができません。&lt;/p&gt;

&lt;h2 id=&#34;報酬&#34;&gt;報酬&lt;/h2&gt;

&lt;p&gt;初期のアナウンスによると、上位数人の参加者には&lt;a href=&#34;http://south.paxsite.com/&#34;&gt;PAX South 2017&lt;/a&gt;へ招待されるとのことでしたが、結果発表時には既に開催日を過ぎていたので、後のアナウンスによって&lt;a href=&#34;https://www.e3expo.com/&#34;&gt;E3 2017&lt;/a&gt;のチケットがもらえるという報酬に変更されました。
また、上位20名にはCiv6が提供されるとのことです。&lt;/p&gt;

&lt;p&gt;私は2位ですので、その両方の報酬がもらえます。&lt;/p&gt;

&lt;h2 id=&#34;ゲームプレイ&#34;&gt;ゲームプレイ&lt;/h2&gt;

&lt;p&gt;前回の記事では紹介しなかったゲームについても振り返ってみたいと思います。&lt;/p&gt;

&lt;h3 id=&#34;2回目&#34;&gt;2回目&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/09/29/freeciv-arago-challenge-01/&#34;&gt;以前の記事&lt;/a&gt;で1度目のプレイを紹介しましたが、以降もう一度後半戦のゲームプレイを行いました。&lt;/p&gt;

&lt;p&gt;基本的にはルールは同じで、民族を再割当てしてのゲームでしたが、割り当てられた民族は北米大陸のアメリカ人で、なんと前回プレイしたスー族と数タイルしか変わらない初期位置からのスタートでした。
そのため最初の動きは前回のゲームとほぼ変わらず。
南米大陸にブラジル人がいたのですが遠いのでそこまで進出するつもりはなく、初心者用AIなので戦士を数ユニットほど送り込むだけで空都市をいくつか破壊・占領できました。
対ブラジルの最前線以外には北米大陸の外に都市は建てず、前回のプレイ同様の都市配置を行っていきました。&lt;/p&gt;

&lt;p&gt;どうせなので前回とは研究ルートを変更し、共和制に直行して祝祭ブーストを行ってから他国に交易路を引いていきました。
マップが広いことから交易路が強いのでこれはあまり強くなく、結果としてゲーム終了まで数十ターン余計にかかりました。&lt;/p&gt;

&lt;p&gt;また敵文明をすべて根絶やしにするのがひたすら面倒なことを前回のゲームで実感したので、今回は宇宙勝利を目指しました。
コンピュータまで直行してニュートン+SETIで研究をブーストし、一気にロケットを打ち上げます。
ロケット打ち上げ後に首都防衛のためこちらから他国家に打って出たところ、「あとはロケットの到着を待つだけなのになぜ戦争をするのか？」と担当者に不思議がられました。&lt;/p&gt;

&lt;h3 id=&#34;3回目&#34;&gt;3回目&lt;/h3&gt;

&lt;p&gt;本来ゲームプレイは2回で終了のはずだったのですが、2回めのゲーム終了からしばらくして先方からまた連絡が入りました。
曰く、もっとプレイを見せてほしいとのこと。&lt;/p&gt;

&lt;p&gt;結果として追加で2回のゲームプレイをすることになりました。&lt;/p&gt;

&lt;p&gt;3回目のマップは、それまでの地球型マップという点では同じでしたが、それまでとは違って全国家が5タイル前後の広さの小島からのスタートでした。
英国スタートだったので普通に地図に直行して欧州大陸に殖民したのですが、大陸が広すぎるので10都市前後で殖民を停止。
キャラバンを生産して他国家に交易路を引きに行ったのですが、AIはまだ大半が初期位置の小島から外に出ておらず、距離が遠い上に交易相手となる都市が少ないために交易に苦労しました。
実際、交易優先よりもこの時代のうちに他国を攻め滅ぼしたほうが早かったような気がします。&lt;/p&gt;

&lt;p&gt;戦闘機の時代になった時点で攻勢に出ることにして、圧倒的技術差から特に問題なく勝利。&lt;/p&gt;

&lt;h3 id=&#34;4回目&#34;&gt;4回目&lt;/h3&gt;

&lt;p&gt;4回目のマップは、それまでとは全く違ったマップでした。
国家は2つしか存在せず、それぞれが別の広大な大陸からのスタート。
さらに大陸と大陸の間には広い海とやたら多い島があったのですが、大陸内に10都市建ててもまだ大陸の半分程度しか埋まらない広さだったので、ある程度植民してから島嶼部は無視して他大陸と交易。
大砲を使って敵大陸に殴りこみ、物量差で押し込んで征服し勝利。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>セキュリティキャンプ2017の応募用紙</title>
      <link>http://tatamo.81.la/blog/2017/05/29/seccamp-2017-sheet/</link>
      <pubDate>Mon, 29 May 2017 12:00:01 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/05/29/seccamp-2017-sheet/</guid>
      <description>
        &lt;p&gt;&lt;a href=&#34;https://www.ipa.go.jp/jinzai/camp/2017/zenkoku2017.html&#34;&gt;セキュリティ・キャンプ2017&lt;/a&gt;の応募用紙を提出したので、どうせなので公開します。
私はこの記事がアップロードされたことを確認したら寝ます。
いい加減期限が迫ってから焦って取り組もうとするのはやめたほうが良いと思います。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;追記: 受かりました。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;推敲まで行っている余裕がとてもなかったため、悪文・乱文が多い可能性があります。
審査員の方々には申し訳ない限りです。&lt;/p&gt;

&lt;p&gt;その上分量が多く、また最低限の整形しか行っていないため見づらいことがあるかと思いますがご容赦ください。
フォームに直接書いた生の文字列と、Markdownに則った形式とでは見え方が違うためです。
いずれ直そうと思いますが、私ははやく寝たいのです。&lt;/p&gt;

&lt;p&gt;(追記：全体的に整形を加えました。
すべての行に改行を入れたり見出しやリストによる整形も行おうかと考えましたが、前者は画面右端の改行と被ってしまうため、後者はもともとの回答と見え方がずれてしまうためどちらも行っていません。)&lt;/p&gt;

&lt;p&gt;また、応募用紙そのものに対する感想、注釈、検閲等については&lt;code&gt;/* */&lt;/code&gt;で囲った部分、または&lt;code&gt;//&lt;/code&gt;に続く箇所に書いているものとします。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;共通問題&#34;&gt;共通問題&lt;/h2&gt;

&lt;h3 id=&#34;共-1-1&#34;&gt;共-1（1）.&lt;/h3&gt;

&lt;p&gt;あなたが今まで作ってきたものにはどのようなものがありますか？
いくつでもいいので、ありったけ自慢してください。
プログラミングを始めた頃に作ったものから順に紹介していきます。&lt;/p&gt;

&lt;p&gt;1.まさおコンストラクションと呼ばれる、ユーザーが自由にアクションゲームのステージを作成してWebページ上で公開することができるJavaアプレットゲーム上で作ったたくさんのステージ。また、それを公開するために作成したWebサイト。&lt;/p&gt;

&lt;p&gt;これは基本的にはHTMLのparamタグにマップデータを配置したり、専用のマップエディタを用いてステージを作成できる機能が提供されているJavaアプレットですが、それに加えてJavaScriptを用いてJavaアプレット内のゲームの状態を取得したり、画像描画の命令を呼び出すことのできるAPIが提供されていました。
私は単に与えられた機能の範囲内で遊んでいて楽しいゲームを作るだけでなく、このJavaScript拡張の機能によって新しい仕掛けや敵キャラクター、強化された演出などを追加したゲームを作成し、自分のWebサイトで公開しました。&lt;/p&gt;

&lt;p&gt;2.マルチプラットフォームで動作する、ソケット通信を使った小型のGUIチャットソフト。&lt;/p&gt;

&lt;p&gt;一人がホストモードでソフトを起動し、他の人がホストに対してソケット接続を行うと、ホストが接続されているすべてのクライアントに通信を転送し、全員がリアルタイムでチャットを行うことができます。
Pythonから起動するほか、Windows用にexe形式の実行ファイルも用意されています。&lt;/p&gt;

&lt;p&gt;3.Windows上で動作する、いわゆる「テトリス」のソフト。&lt;/p&gt;

&lt;p&gt;GUIアプリケーションとして作ったものであり、ろくに活動実績のなかった廃部寸前の高校コンピュータ部において文化祭出展用の目玉プログラムの座を3年間維持し続けたものです。
コンパクトなUIでありながらゲームとして完結しており、落ちてくる四角い物のバリエーションの偏りの排除、次に落ちてくる物の予告、必要な時に一つだけ保持しておいたものと入れ替えるホールド、一度にたくさん消滅させたときのスコアの上昇とその連鎖、スコアとゲーム時間に応じた難易度の上昇、およびハイスコア登録が可能と、何度でも繰り返し遊べるような機能を備えています。&lt;/p&gt;

&lt;p&gt;4.ブラウザ上で動作し、同時にそのページにアクセスしているプレイヤーとリアルタイムでの対戦ができる2Dアクションゲーム。&lt;/p&gt;

&lt;p&gt;ブラウザ上でプレイすることができるジャンプアクションゲームを作成し、これをネットワークを介した人間のプレイヤー同士での対戦ができるように、リアルタイム通信機能を付け加えたものです。
一秒間におよそ14フレーム、1フレームあたり70msごとに画面が更新されてプレイヤーキャラクターを移動させることができる純粋なアクションゲームとしての性格を備えながら、ネットワーク越しの相手も同様にリアルタイムで移動し、お互いに攻撃しあうことで対戦が可能な通信ゲームとなっています。
アクションゲームとしては14fpsと、一般的な30fpsや60fpsよりも画面の更新周期がやや遅い設定であるものの、それでも完全なリアルタイム通信を行いたい場合は70msの遅延しか許されません。
プレイヤーの入力データが相手に届くまでにこれ以上の時間がかかった場合は、たとえば本当は自分と相手は同時に移動をしたはずなのに、相手からのデータが届いていないために自分だけが動いているように見えるというような事態が起こります。
これでは相手のクライアントが見ているゲーム画面と自分が見ているゲーム画面の間に差異が生じてしまううえ、このような誤差が蓄積されていくと同じキャラクターでもクライアントによって位置がどんどんずれていってしまう恐れがあります。
このゲームでは、行動を入力してから1~3フレーム程度の間だけ待機時間を持たせ、その間に入力データを先に送ってしまうことでロスを防ぐしくみを組み込んでいます。
そしてそれだけではなく、実際に通信が遅れて届いた場合でも、過去数フレーム分のプレイヤーキャラクターの位置や状態を逆算可能にしておくことで、本来正しく通信が受信されていたはずの時点まで巻き戻して再計算を行い、結果として相手に見えているはずの、正しいキャラクターの位置や状態に修正することができるようになっています。
とはいえこの場合でも、やはり一瞬の時間だけプレイヤー間で見えているものが違うという状態が起こり得ます。
たとえば敵のキャラクターがこちらのキャラクターに向かって攻撃を行い、明らかに敵の攻撃に当たってしまったとき、やられた！と思った瞬間に、実は敵のキャラクターの移動の入力データが届いておらず、本当は相手は全く違う方向に攻撃をしていたのだ、ということが判明したなら、これはゲームとしては楽しくないといえます。
そのため、キャラクターの移動は入力(と通信)が行われてから1フレームだけ後に行動に移され、ジャンプは2フレーム、攻撃動作は3フレームというように、そのデータが届かなかったときの影響の大きさによって入力から実際の行動までの間隔を調整しています。
これは単に通信が届かない確率を減らす効果が得られるだけではなく、それに加えて、3フレームの間隔が開くような動作に対しては、次のフレームでは2フレーム以下の間隔を持つような入力は無視され、その次のフレームでは1フレーム以下の間隔を持つような入力は無視される、という仕組みを取り入れることで、より同期ずれによる不都合が軽減できるようになっています。
たとえば、キャラクターが右を向いている状態で攻撃の入力を行い、即座に左に振り向こうとしたとします。
攻撃の入力が行われたのが0フレーム目だとすると、0,1,2フレームの間は入力から行動までの間隔が1である移動入力は無視され、結果として左方向への移動の入力は3フレーム目に有効になります。
この3フレーム目で実際の攻撃動作が行われ、3フレーム目に入力された移動動作は4フレーム目に行われることから、「攻撃の入力から実際に攻撃の動作が行われるまでの間、キャラクターが急に方向転換することはない」といえるようになります。
結果として、方向転換の通信が正しく届かなかったとしても、右を向いて攻撃をしようとしているキャラクターが攻撃の瞬間には左を向いている、という可能性を除外することができます。
ゲームをプレイしているプレイヤーは、キャラクターが動き始めるのが1フレーム遅れた、ということはあまり気になりませんが、右方向に発射された攻撃が一瞬後には左方向の攻撃に変わっていた、という事態には大きく戸惑うことが予想されます。
このように、プレイヤーが気にならないような誤差はあえて許容しつつ、深刻なずれが生じる可能性を極力減らすような設計とすることで、見かけ上はリアルタイムに同期がとれているかのようなゲームプレイを実現しています。&lt;/p&gt;

&lt;p&gt;5.Freecivのユニット間の戦闘の勝率を計算するソフト。&lt;/p&gt;

&lt;p&gt;私が約5年の間、週末に3時間から10時間程度は必ずプレイしているFreecivというゲームがあります。
「シヴィライゼーション」シリーズをもとにして20年前につくられたこのGPLソフトウェアでは、プレイヤーの帝国の手足となる軍事ユニットが絶えず他国のユニットと戦闘を行います。
この戦闘は、互いのユニットの戦闘力に加え、ユニットの熟練度の差、様々な地形の補正効果、要塞や城壁による防御効果、ユニット間の相性による能力値の変化、港湾都市に停泊中の艦船ユニットが敵からの攻撃に対して脆弱になる特殊補正など、様々な要素によって勝敗が決まります。
都市の中に籠っている複数体の相手ユニットに対し、こちらが何ユニットの攻城兵器を用意すれば撃破が可能なのか？という問いに答えることは、敵都市の防御ユニットをすべて倒すことができればその都市を占領して大きな優位性が得られ、一方で1ユニットでも相手が生き残ってしまえばただ自国軍が全滅しただけの大損害になってしまうというハイリスク・ハイリターンさから、攻撃の計画を立てる上で非常に重要となってきます。
そのため、戦闘の発生する状況を入力すれば、その戦闘での勝率、与えられるダメージの期待値などをweb上で算出できるアプリケーションを作成しました。
予めFreecivのルールセットに対応したユニット能力値や補正効果などのデータセットを作成しておくことで、複雑になりがちな補正効果の計算をすべて自動的に行うことができます。
またFreecivは自由度の高いゲームでもあり、ユーザーが自由にルールセットを改造して独自のユニットや効果を持った新しいルールセットを作ることができるようになっていますが、この計算ソフトではユーザーが計算に用いるためのデータセットを改変して新しいルールセットに対応したものとできるという柔軟性を持っています。
このソフトによって、経験によって「勘」で攻撃に必要なユニット数を把握できるような熟練プレイヤーのみでなく、このゲームの初心者であっても実際の数値をもとに戦略を立てることができるようになるため、プレイヤー全体のスキル向上に寄与できると考えています。&lt;/p&gt;

&lt;p&gt;6.HTML5 Canvas上で動くアクションゲームと、そのフレームワーク。&lt;/p&gt;

&lt;p&gt;先述した4.のブラウザ上で動くゲームはC#+Silverlightで開発していたのですが、気付けばSilverlightがほとんどのブラウザで動かなくなってきていたため、TypeScript+Canvasでの書き直しと、その洗練を試みたものです。ただし、通信に関する機能は含んでいません。
(なおSilverlightが動かなくなったためにJavaScript関連の技術に移植したのは、先述した5.の計算ソフトも同じ流れをたどっています)&lt;/p&gt;

&lt;p&gt;7.いくつかのWebサイト。&lt;/p&gt;

&lt;p&gt;スマートフォンでアクセスしたり、ウィンドウサイズが小さくなったりすると自動的にメニューが画面端に格納され、隅のボタンをクリックすることでメニューがアニメーションしながら開閉する、いわゆるハンバーガーメニューをJavaScriptを用いずにCSSのみで実装したWebサイトを作成しました。
また、ブログを作ってGitHubにMarkdownで書いた記事をpushすればビルドしてアップロードしてくれるようにもしました。
他に、wikiの設置・管理も行っています。&lt;/p&gt;

&lt;p&gt;8.LALR(1)パーサジェネレータ。&lt;/p&gt;

&lt;p&gt;漠然と「構文解析がしたい」と思ったので作りました。
構文ファイルを与えることでそれを構文木に変換できるようなパーサを生成し、解析を行うことができます。
また、パーサ生成時に構築される構文解析表と、それを読み取って解析を行う部分のみを取り出してソースコードとして出力することで、パーサの生成処理だけを予め行っておくこともできます。
このパーサジェネレータでは、構文規則を記述するための構文ファイル自体の規則もこのパーサジェネレータによって生成されています。
構文ファイルに使うための構文規則が自分自身の構文を定義しているため、構文を表現する方法を拡張したり、別の表現を用いることができるようにすることが容易です。
また、作っているうちにこれはYaccやBisonとよばれるパーサジェネレータの二番煎じにしかならないことに早々に気付いたため、単にパーサジェネレータの開発を進めるだけでなく、並行して開発の流れや理論的概略を紹介する記事をブログに書くことにしました。&lt;/p&gt;

&lt;h3 id=&#34;共-1-2&#34;&gt;共-1（2）.&lt;/h3&gt;

&lt;p&gt;それをどのように作りましたか？
ソフトウェアの場合には、どんな言語で作ったのか、どんなライブラリを使ったのかなども教えてください。追加したい機能や改善の案があれば、それも教えてください。&lt;/p&gt;

&lt;p&gt;1.&lt;br&gt;
当時は個人サイトが活発な時代だったため、同じようなステージを作って公開している人と掲示板などで交流をしながらステージ作りやWebサイト作りをしました。
このゲームのJavaScript拡張がプログラミングに触れたはじめてのきっかけでした。
初めはJavaScript拡張機能のサンプルを見て、そこに登場する敵キャラクターの動きの新鮮さに驚き(用意されている敵キャラクターはたいてい同じ動きや攻撃を繰り返すだけのものだったが、そのキャラクターは残りのHPに応じて動きを変えるボスキャラクターだった)、どのようにして攻撃を切り替えているのか、プログラムのどの部分が攻撃を出す部分なのか、などが気になり、ソースコードを書き替えては実行してを繰り返しました。
何度もエラーを出したりしながら攻撃を出す部分(関数呼び出し)を見つけ、その引数の数値を変えると攻撃の種類が変わることに気付くと、いろいろな攻撃を試したくなって朝方近くまでずっとそのサンプルコードで遊んでいました。
以前のそのゲームでは考えられなかったような目新しい動きをする強力なボスキャラクターに惹かれ、見よう見まねで自分なりのボスを作って公開したり、新しい仕掛けが作れないかどうか考えを巡らせたりしていました。
いくつかそういった機能を追加していくうちに、配列を使うことを覚えたり、ボスをオブジェクトにして、しかもそれを配列に入れてしまえば、わざわざ変数を分けて書かなくてもたくさんのボスキャラクターを出現させられることに気付いたりして、次第にプログラミングというものに興味が沸いていきました。&lt;/p&gt;

&lt;p&gt;近年ではJavaアプレットはほぼ駆逐されつつあるため、このゲームもそのままでは遊ぶことができなくなってきています。
一方、このゲームをJavaからJavaScript+Canvasコードに変換した移植プロジェクトが存在しており、高い互換性から既存のステージのCanvas版への移行が進んでいます。
しかしもともとJavaScriptによる拡張を施していたステージについてはそのままでは移行できないこともあり、私が作ったそのようなステージは現在遊ぶことができない状態になっています。
そのため、いずれこのようなステージを遊ぶことができるように移行作業を行いたいと考えています。&lt;/p&gt;

&lt;p&gt;2.&lt;br&gt;
JavaScript以外のプログラミング言語にも触れてみたいと思っていた時にハッカーになろう(&lt;a href=&#34;http://cruel.org/freeware/hacker.html&#34;&gt;http://cruel.org/freeware/hacker.html&lt;/a&gt; )を読む機会があり、まんまと影響されたためにPythonを使って何か作ろうと思い、作りました。
Pythonと、Pythonで使用できるGUIツールであるTkinterを用いて作成しました。
exe形式の実行ファイルへの変換は、py2exeを使用しています。&lt;/p&gt;

&lt;p&gt;3.&lt;br&gt;
高校1年の文化祭の展示物として、GUIアプリケーションを作成できるQtを用いて、C++で作成しました。
元ネタが非常に洗練されたゲームであるため、ゲームとして必要な機能はおおよそまとまっているように思えるので、何か機能を追加するとしたら(ソースコードを紛失していることも忘れるとしたら)、演出を強化してより見栄えの良いものにしたいと思います。&lt;/p&gt;

&lt;p&gt;4.&lt;br&gt;
1.でとりあげたJavaアプレットゲームでは、私はあくまでJavaScriptを使って外側からゲームに手を加えている立場でしたが、自分でもアクションゲーム自体を作ってみたいと思うようになり、またどうせならJavaアプレットよりも新しい技術を使い、新しい機能を付け加えてみたい、と考えました。
そこで、当時新しく登場していたHTML5、Socket.io、Silverlightといった技術に目を付け、複数人で通信してゲームができればきっと楽しいだろうと思い、ブラウザ上でオンラインプレイ可能なアクションゲームを作ろうと思って作り始めました。
この当時はまだCanvasの仕様や実装が固まっていなかったため、C#+Silverlightを使って開発することに決めました。
またこの頃socket.ioのリアルタイム通信が騒がれていたため、これを使ってリアルタイムで通信をさせようと思いましたが、結局のところ生のWebSocketのほうがsocket.ioを使うよりも高速に通信できることから、サーバー側もC#で書き、WebSocketでの通信を行うことにしました。
(しかしながら、ただでさえ主要ブラウザの一部に実装されたばかりのような状態であるWebSocketが至る所で繋がらなかったり、それに加えてSilverlightのセキュリティポリシーのためclientaccesspolicy.xmlを別ポートで配信しておかないとクロスドメイン通信はできず、かつこのSilverlight上でWebSocket通信を確立しようと試みたため、実際のゲーム面のみならずインターネットを介して通信を確立させるというただ一点についてもかなり苦労することとなりました)&lt;/p&gt;

&lt;p&gt;現在はSilverlightを動かすことさえ困難になりつつある一方で、Canvasを使えないブラウザはほとんどなくなり、またUDP上で構築されているためにWebSocketよりも速度が期待できるWebRTCが広まってきたことなどから、今後改善するとすればまずはHTML5への移植であると考えられます。&lt;/p&gt;

&lt;p&gt;また、ブラウザ上での(見かけ上)同期のとれたリアルタイム通信は、いずれ再挑戦したい点だと考えています。
(1)で述べたようにこのプログラムには通信遅延による影響を抑えるために様々な工夫が凝らしてあるのですが、それ以前の問題があります。
たとえば互いに0.2秒ずれていても通信が成り立つとしても、そのずれが小さくなっていく方向に修正していく機能がなければ、恒常的に0.2秒ずれた状態で通信がつながっていて、たまたまそのずれが0.21秒に広がったときに破綻してラグが生じる、ということが起こりますから、こういった点は改善の余地があると思います。&lt;/p&gt;

&lt;p&gt;5.&lt;br&gt;
このソフトは現在Web上で公開していますが、バージョン番号に2がついています。
バージョン1はC#+Silverlightで、バージョン2はTypeScript+jQuery(+jQueryUI)となっています。
またバージョン2では、タスクランナーであるgulp.jsを用いることで、ソースコードの更新を検知して即座にコンパイルしてブラウザ上に反映しながら開発しました。
ユニットの戦闘は、戦闘力比をもとにした確率でどちらかがダメージを受け、それを片方が倒れるまで繰り返すという処理によって行われるため、二項係数を用いて計算することができます。
とはいえ数式上では120C60などの値が登場し、これを実際に計算しようと思えばlong型の最大値も越えてしまいます。
バージョン1では(ごく限られた機能の)多倍長整数演算ができるようなクラスを自作して頑張って計算していましたが、バージョン2では競技プログラミングに少し触れていたこともあって、二項係数はメモ化しておけば高速化できる上に、複数回計算を行った場合に前の計算の結果を使えばすぐ結果が返せる、また結果の勝率はせいぜい小数点3位程度までが正確であればよいので、double型の精度で生じるような誤差は無視して構わないと考えたことなどから、バージョン1よりも簡潔かつ高速に処理ができるようにしました。&lt;/p&gt;

&lt;p&gt;バージョン2の開発時、ユニットをリストから選ぶことでも、名前を直接入力することでも、また名前の一部を入力することで表示されるサジェストを選択することでもユニットが選択できるようなコンボボックスを利用したかったため、この要件を満たせるようなUIが提供されるJavaScriptライブラリを探していたところjQueryUIが見つかりました。
そのためにバージョン2にはjQueryを使っていますが、この前同じようなコンボボックスがReact系のライブラリでも実現できることを知ったため、今後はこれをReactで書き直してみたいと思っています。&lt;/p&gt;

&lt;p&gt;また、データセットにはJSONを読み込んでおり、その一部の文字列を正規表現で読み取って独自記法のようにしている部分があります。
今の私には8.で作った自作のパーサジェネレータがあるため、それを使って生成したパーサを用いてより簡潔かつ拡張性に富んだ形でデータセットが記述できるようにしたいと考えています。
UI部分のReactでの書き直しと合わせて、早いうちにバージョン3の開発に取り掛かりたいと思います。&lt;/p&gt;

&lt;p&gt;6.&lt;br&gt;
アクションゲームを作成するのと並行して、そのゲームを作成できるフレームワークを作り、アクションゲームだけでなくほかの種類のゲームの開発も容易に行えるようにしたい、と考えたため、単にゲームを実装しているのではなく、フレームワーク部分とゲーム部分の2つにプロジェクトを分け、フレームワーク部分の持つべき役割を考えながら作成していました。
外部のデータを読み込むローダーをそれ単体で利用しやすい形に設計したり、あるクラスを多様な用途に使えるようにするために、どこまでの役割をそのクラスに持たせて、残りを別のクラスの役割とするべきなのかを考えながら作っていましたが、これぞといった設計を捻りだすのは難しく、ウンウン唸ってばかりでなかなか開発が進まなかったりしていました。&lt;/p&gt;

&lt;p&gt;7.&lt;br&gt;
Freecivプレイヤーの知人が新しく常設ゲームサーバーを作ろうとしていたので、その公式サイトの作成を担当しました。
HTML5やCSS3の新機能はある程度追いかけていたのですが、実際にWebページを作った経験はHTML4.1の時代で止まっていたので、HTML5の仕様に準拠したモダンな作りのWebサイトにできるよう心がけました。
またデザインも自分が考えることになったので、派手にならず、かつ味気ないものにならないような見た目のページにするにはどのようにすればいいかを考えながら作りました。&lt;/p&gt;

&lt;p&gt;ブログは、Twitter等ではあまり長い文章を書くことができないため、何らかの形で長めの文章や技術的な話題について発進&lt;code&gt;/* 誤字 -&amp;gt; 発信 */&lt;/code&gt;できるような場所が欲しいと思ったことから作りました。
このブログには静的サイトジェネレータであるHugoを使用しています。
コメント機能やトラックバック機能などは必要ないと考えたため、サーバーサイドでブログ用のプログラムは走らせず、手元で記事を書くたびにサイトをビルドしてそれをアップロードするようにしました。
Hugoのテンプレートエンジン機能を利用して、さまざまなブログ向けのテンプレートが公開されていたのですが、あまりしっくりくるものがなかったため、テンプレートを自分で記述してブログのデザインを行いました。
また、ビルドからアップロードまでの手順を自動化しようと思い、CIサービスであるWerckerを利用してそちらでビルドが行えるようにしました。
手元で記事を書き、Markdownファイルを追加したコミットを作成してGitHubにpushすることで、Wercker側でビルドが行われ、用意しておいた別のGitHubリポジトリにビルド結果のコミットが行われて、その内容がサーバーにアップロードされることで記事が反映されます。
ブログのデザインや、カテゴリ・タグ表示の機能にはもっと見やすくするための改善の余地があると思っています。&lt;/p&gt;

&lt;p&gt;8.&lt;br&gt;
どうすれば構文解析ができるのかよくわからなくて調べたところ、Yaccなどのツールを使えばいいということがわかりましたが、どうもプログラミングっぽさに欠けるなあと思い、もう少し調べると、そのようなツールが用いているLR法などの手法を用いることで構文解析が実現できるとわかりました。
構文解析に関する大学の講義を受けていた上級生の知人がいたため、その方に理論を教えてもらったり、web上に上がっていた言語解析に関する大学の講義スライドを読んだりしてLR法について勉強し、これをコードに落とし込みました。
実装はTypeScriptによるフルスクラッチです。
LR法による構文解析は行う手順が多く、それらの手順が明確に分離されているため、「とりあえずこの機能さえ動けば次に進める」ような箇所が多くありました。
そのため、とにかく動作するように開発を進めていくことでテンポよく開発を進めていきましたが、その分だけ複雑な処理をしている部分のコードが非効率的なままになってしまう傾向がありました。
それでもまずは完成させることを優先して開発を進め、構文解析の成功に至った段階ですべてのソースコードの見直しを行ってリファクタリングと最適化を進めました。
結果として、自分自身の構文ファイルを解析してパーサーを生成する処理に2秒程度かかっていたのが、最終的に100msから50msにまで処理時間を減らすことができました。&lt;/p&gt;

&lt;p&gt;追加していきたい機能は複数あります。
まず、このパーサジェネレータではLA(1)文法&lt;code&gt;/* 誤字 -&amp;gt; LR(1)文法 */&lt;/code&gt;に厳密に従ったあいまいさのない構文しか処理することができません。
具体的には、 S -&amp;gt; S+S | x というような構文があったとき、x+x+xという入力の(x+x)+xとx+(x+x)の2通りを区別できないためにこの構文はコンフリクトを起こし、パーサの生成に失敗します。
演算子に右結合・左結合の設定を行ったり、演算子の優先順位の設定を行える機能を搭載し、例のような構文も処理できるようにしたほうが実用的になると考えています。&lt;/p&gt;

&lt;p&gt;また、実際にパーサに入力を与えたときに構文解析に失敗した場合、失敗したという事実は通知されますが、どこでどのような失敗が起こったのかというエラーメッセージを表示する機能がないので、パーサがただ構文解析表を読み取っていくだけでなくどのような失敗が発生したのかも検知できるようにしたいと思っています。&lt;/p&gt;

&lt;p&gt;そして、ただ構文木を作るだけでなく、規則ごとに割り当てられたコードをその場で実行できるように、構文ファイルに処理を書き込めるような機能も追加したいです。
現状ではコールバックを渡すことで同様の処理が可能ですが、渡した関数の中で今どの規則の解析を行ったのかを判断しないといけないため、煩雑になりがちです。
そのため、規則とコードを直接結びつけて構文ファイルに記述できるようにするのがよいと考えています。&lt;/p&gt;

&lt;h3 id=&#34;共-1-3&#34;&gt;共-1（3）.&lt;/h3&gt;

&lt;p&gt;開発記のブログ、スライドなどの資料があれば、それも教えてください。コンテストなどに出品したことがあれば、それも教えてください。&lt;/p&gt;

&lt;p&gt;4.は、立命館大学主催のソフトウェアコンテストであるICT Challenge+R2013高校版(&lt;a href=&#34;http://www.2013.ict-challenger.jp/&#34;&gt;http://www.2013.ict-challenger.jp/&lt;/a&gt; )に出品してファイナリストに選ばれ、2つの企業賞を受賞しています。
またこれに参加した際のスライド発表の様子は、youtube上に公開されています(&lt;code&gt;/*検閲により削除。探せば見れます。*/&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;7.のブログの構築については、ブログ上の記事でその流れを公開しています(&lt;a href=&#34;http://tatamo.81.la/blog/tags/blog/&#34;&gt;http://tatamo.81.la/blog/tags/blog/&lt;/a&gt; )。&lt;/p&gt;

&lt;p&gt;また、8.のパーサジェネレータについても、構文解析入門、およびパーサジェネレータの自作方法の解説という体裁で紹介記事を同じブログで公開しています(&lt;a href=&#34;http://tatamo.81.la/blog/tags/parser-generator/&#34;&gt;http://tatamo.81.la/blog/tags/parser-generator/&lt;/a&gt; )。&lt;/p&gt;

&lt;h3 id=&#34;共-1-4&#34;&gt;共-1（4）.&lt;/h3&gt;

&lt;p&gt;Twitterアカウント、Github、ブログをお持ちでしたら、アカウント名、URL等を記載してください。&lt;/p&gt;

&lt;p&gt;Twitter: @__tatamo__ &lt;a href=&#34;https://twitter.com/__tatamo__&#34;&gt;https://twitter.com/__tatamo__&lt;/a&gt;&lt;br /&gt;
GitHub: &lt;a href=&#34;https://github.com/tatamo&#34;&gt;https://github.com/tatamo&lt;/a&gt;&lt;br /&gt;
ブログ: &lt;a href=&#34;http://tatamo.81.la/blog/&#34;&gt;http://tatamo.81.la/blog/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;共-2-1&#34;&gt;共-2（1）.&lt;/h3&gt;

&lt;p&gt;あなたが経験した中で印象に残っている技術的な壁はなんでしょうか？
（例えば、C言語プログラムを複数ファイルに分割する方法など）&lt;/p&gt;

&lt;p&gt;GoFの23のデザインパターンについてインターネットで調べ、どのような設計のしかたが一般に行われているのかを勉強しました。
また、ゲームのプログラムをどのように構成すればよいのかを知るために、「ゲームプログラマになる前に覚えておきたい技術」「ゲームエンジン・アーキテクチャ」を読みました。
そして、実際にいろいろな言語で提供されているゲーム制作用のライブラリのリファレンスやソースコードを読んで、どのような機能が提供されていて、他の機能とどこで分けられているのか、それがどのような使い方をされるように作られているのかを調べました。
そして実際に、ゲームを作るというよりゲームのフレームワークを作るようにすれば、それを使って簡潔にゲームが作れるようになるのではないかと思い、自分でプログラムを作っていきました。&lt;/p&gt;

&lt;h3 id=&#34;共-2-2&#34;&gt;共-2（2）.&lt;/h3&gt;

&lt;p&gt;また、その壁を乗り越えるためにとった解決法を具体的に教えてください。
（例えば、知人に勧められた「○○」という書籍を読んだなど）&lt;/p&gt;

&lt;p&gt;GoFの23のデザインパターンについて調べ、そしてその前提として必要ならば、オブジェクト指向についての理解を深めるようにアドバイスをします。
そしてその上で、この壁についてあまり深く考えることはやめたほうがいい、と言いたいと思います。&lt;/p&gt;

&lt;p&gt;ゲームのフレームワークを作らなくてもゲームを作ることはできますし、一般に個人的にゲームプログラムを作るぐらいなら、コード全体に影響を及ぼすような破壊的な変更を含む大幅な仕様変更はそう何度も行われるものではない(または、行われるべきではない)と思います。
そのような場合は、「そこそこ」の設計であってもゲームは正しく動作すると思われるので、設計に頭を悩ませるよりも、その時間でゲーム自体にどのような機能を追加できるか、それによってゲームを面白いものにできるかを考えるべきだと思います。
つまり、ゲームを作りたいのか、それともゲームのフレームワークを作りたいのか、自分がそのどちらを望んでいるのかを見失うべきではないです。&lt;/p&gt;

&lt;p&gt;また、ただ考え続けるよりは実際に動くプログラムを書いたほうが、設計があいまいであっても全体がどのように動くのかを把握できるため、次に似たものを作るときによりよい設計が浮かびやすくなると思います。
プログラミングが好きだからゲームを作りたい、と思っていると、「既存のライブラリやフレームワークを使ってゲームを作るよりも、自分のプログラムでゲームを動かしたい」という気持ちになりがちだと思います。
しかしながら、既存の良く考えて設計されたフレームワークを使えば、その設計に触れ親しむことにもなり、また肝心のゲームを面白くすることにより注意を払うことができるようになります。
そのため、まずはあまり深く考えるのをやめて、とにかく動くゲームを作ってみたり、既存のライブラリやフレームワークを使ってみたりするほうがいい、とアドバイスしたいです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
お察しの通り、入力フォームに1箇所ずれて回答を貼り付けてしまっており、共-2 (1)の回答が消滅しています。
ここに書いたところで何の意味もありませんが、以下に本来の2(1)の回答を掲載しておきます。

作りたいプログラムを書くときに、機能をどのように分け、クラスをどのように設計すればよいか。
特に、ゲームを作る際のキャラクターやエンティティを表すクラスについて、それぞれがゲーム全体の情報にどこまでアクセスできるようにするべきか、
またほかのゲーム内エンティティを表しているオブジェクトに対してどのようにメッセージのやりとりを行うべきか、
そして、どのようにゲームプログラム内のクラスの継承関係や依存関係を構築していけば、
全体の見通しを良くすることができたり、可能な限りコードクローンの量を小さくでき、
可能な限り多くの処理コードをスーパークラスや他のクラスから引き継げるのか。
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;共-2-3&#34;&gt;共-2（3）.&lt;/h3&gt;

&lt;p&gt;その壁を今経験しているであろう初心者にアドバイスをするとしたら、あなたはどんなアドバイスをしますか？&lt;/p&gt;

&lt;p&gt;GoFの23のデザインパターンについて調べ、そしてその前提として必要ならば、オブジェクト指向についての理解を深めるようにアドバイスをします。
そしてその上で、この壁についてあまり深く考えることはやめたほうがいい、と言いたいと思います。&lt;/p&gt;

&lt;p&gt;ゲームのフレームワークを作らなくてもゲームを作ることはできますし、一般に個人的にゲームプログラムを作るぐらいなら、コード全体に影響を及ぼすような破壊的な変更を含む大幅な仕様変更はそう何度も行われるものではない(または、行われるべきではない)と思います。
そのような場合は、「そこそこ」の設計であってもゲームは正しく動作すると思われるので、設計に頭を悩ませるよりも、その時間でゲーム自体にどのような機能を追加できるか、それによってゲームを面白いものにできるかを考えるべきだと思います。
つまり、ゲームを作りたいのか、それともゲームのフレームワークを作りたいのか、自分がそのどちらを望んでいるのかを見失うべきではないです。&lt;/p&gt;

&lt;p&gt;また、ただ考え続けるよりは実際に動くプログラムを書いたほうが、設計があいまいであっても全体がどのように動くのかを把握できるため、次に似たものを作るときによりよい設計が浮かびやすくなると思います。
プログラミングが好きだからゲームを作りたい、と思っていると、「既存のライブラリやフレームワークを使ってゲームを作るよりも、自分のプログラムでゲームを動かしたい」という気持ちになりがちだと思います。
しかしながら、既存の良く考えて設計されたフレームワークを使えば、その設計に触れ親しむことにもなり、また肝心のゲームを面白くすることにより注意を払うことができるようになります。
そのため、まずはあまり深く考えるのをやめて、とにかく動くゲームを作ってみたり、既存のライブラリやフレームワークを使ってみたりするほうがいい、とアドバイスしたいです。&lt;/p&gt;

&lt;h3 id=&#34;共-3-1&#34;&gt;共-3（1）.&lt;/h3&gt;

&lt;p&gt;あなたが今年のセキュリティ・キャンプで受講したいと思っている講義は何ですか？（複数可）
そこで、どのようなことを学びたいですか？なぜそれを学びたいのですか？&lt;/p&gt;

&lt;p&gt;■C1　ブラウザの脆弱性とそのインパクト&lt;br /&gt;
私はJavaScript(やSilverlight)によってWeb上で動作するアプリケーションを開発しているので、実際に自分が作ったものが動いている基盤であるブラウザに関連した攻撃は他人事とは思えません。
また、ブラウザはサーバーサイドとクライアントサイドの間に立っているもので、かつ十分すぎるほどの複雑さを持ったものです。
サーバー側のセキュリティ、それに接続するクライアント側のセキュリティについて考えることは当然ですが、そこに介在しているブラウザの、その脆弱性が悪用されることについて見落とすべきではないといえるはずです。
しかしブラウザはいつも使っているものでありながら、その内側については何も知らないというような気がします。
そのため、ブラウザの脆弱性について具体的に考えられるようになるための知識、そして考え方を学びたいと思っています。&lt;/p&gt;

&lt;p&gt;■D2~3　カーネルエクスプロイトによるシステム権限奪取&lt;br /&gt;
問題の出題順とは前後しますが、私はこの回答を選択問題A-5に取り組んでから書いています。
そして率直に言って、あの選択問題はさっぱりわかりませんでした。
カーネル部分のコードの脆弱性の発見、それを利用したコード実行、さらに実際に権限昇格を行うためのコードの作成、そしてそれを防ぐためのセキュリティの回避、これらについて私は全くといっていいほど知見を持っていません。
カーネルのソースコードを読むだけでなく、カーネルモードやユーザ―モードといったCPU・OSの動作の仕組み、仮想メモリの展開や領域確保のされかたなど、膨大かつ細部に渡るような知識を持っていなければ、このような脆弱性を見つけ出し、そして悪用することはとてもできないのではないかと感じました。
しかしながら、実際にセキュリティに携わる人々、そして攻撃を行う人々は大勢います。
つまり、すごい人たちがたくさんいるんだなあと実感しました。そのような世界についてとても学びたいです。&lt;/p&gt;

&lt;p&gt;■E4　サイバー犯罪捜査の現場&lt;br /&gt;
サイバー攻撃は犯罪ですから、当然攻撃した人は逮捕されないといけません。
とはいえセキュリティの世界は、(何も知らない私から見た考えですが、)たとえばセキュリティソフトを開発している民間の企業や、脆弱性に対してパッチをあてる開発者、攻撃を受けたことを調べるネットワーク管理者など、警察とは関係のない人々が大半のように思えます。
このようなセキュリティの世界において犯罪捜査をどのように行っていくのか、ということは興味深く、そしてこれを学べる機会は貴重なものだと思います。
攻撃と防御だけでなく、捜査という観点からセキュリティについての理解を深めたいと思っています。&lt;/p&gt;

&lt;p&gt;■A6　ハードウェアセキュリティ最前線&lt;br /&gt;
「暗号回路で実行される処理中に発生する副次的（サイドチャネル）な情報を取得し、それらの信号にどのような情報が埋め込まれていたかをデジタルオシロスコープを用いて観測し、実際に暗号解読を試みる」。
ワクワクする響きだと思いました。暗号をオシロスコープを使って解読する。
処理中に発生する情報、そしてそれを取得し利用するという発想は、ソフトウェアをプログラミングする観点からではそう出てくるものではないと思います。
結果として得られる暗号がソフトウェア的に利用されるものだとしても、それを生成するハードウェアから情報を盗み出せるという観点に興味を抱いたため、ぜひ受講したいと思っています。&lt;/p&gt;

&lt;p&gt;■D7　ゲームセキュリティ入門&lt;br /&gt;
ブラウザの脆弱性同様、自分がこれまで触れてきたことに関係する分野であり、それでいてセキュリティと結びつけて考えたことはありませんでした。
ゲームとセキュリティをどのように結び付けて考えればいいのか？どのように解析されうるのか？といったことを実際に行って学び取ることができればと思います。&lt;/p&gt;

&lt;h3 id=&#34;共-3-2&#34;&gt;共-3（2）.&lt;/h3&gt;

&lt;p&gt;あなたがセキュリティ・キャンプでやりたいことは何ですか？　身につけたいものは何ですか？（複数可）
自由に答えてください。&lt;/p&gt;

&lt;p&gt;私がセキュリティキャンプでやりたいことは、わかりません。
身に着けたいことも、よくわかりません。
このような積極性に欠ける姿勢はよくないだろうと思われるかもしれませんが、実際に私はセキュリティキャンプに対して受け身な姿勢で臨むだろうと思います。
そもそも私はこれまでセキュリティというものにほとんど触れたことがありません。
リバースエンジニアリングを行って実行ファイルを解析したこともありませんし、バイナリハックなども(フリーゲームのセーブデータをバイナリエディタで弄ってチートをしようと思ったことはありますが)全然やったことがありませんし、暗号技術がどのように運用されているかも知りません。
Linuxカーネルのソースコードを読んだこともなければ、流れているパケットをキャプチャしたこともありません。&lt;/p&gt;

&lt;p&gt;私はこの回答を、選択問題をほとんど回答した後に記述しています。
適切な表現かはわかりませんが&lt;code&gt;/* 何を今更 */&lt;/code&gt;、選択問題について、これはよくできた問題だなあ、ということを幾度となく感じました。
OSとCPUがどのように協調して動作しているのか、仮想メモリはどのように展開されているのか、TCP/IPはどのように構築されているのかということから始めて、それに関連してどのような脆弱性が存在するのか、それをどのように悪用して攻撃につなげるのか、など一つの問題の中で段階を踏んで何度もわからない箇所が現れ続けるので、壁の高さを感じました。
一方で、それを少しずつ紐解こうとしているうちに、基礎から実践、応用と幅広い範囲についてわずかではあるものの見通せるようになったような気がしました。&lt;/p&gt;

&lt;p&gt;一般になにかの技術について勉強しようと思ったら、本を読んだり、実際に試してみたりして理解を深めていくものだと思います(勉強会に行ったりする人もいると思いますが、私は行ったことがありません)。
しかしながら、たとえば私がカーネルエクスプロイトなどについて勉強しようと思ったとして、まず何から手を付けていいかわからないでしょうし、知見が足りないためにこなすべき問題の設定も適切にできるとはいえないでしょう。
また、その分野について詳しい人が身の回りにいるとも限りません。
セキュリティキャンプの応募用紙の問題に取り組んでいて、この問題設定はよくできている、と思った点はそこにあります。
全くの知見がない私であっても、適切な問題が与えられることで基礎から応用まで俯瞰しながら取り組むことができたからです。&lt;/p&gt;

&lt;p&gt;私はこのような受け身の姿勢でもってセキュリティキャンプに対して期待を持っています。
つまり、私の知らないことに対して、驚くほど適切に学ぶべき道を示してくれるだろうという期待です。&lt;/p&gt;

&lt;p&gt;限りなく抽象的に述べるならば、私がセキュリティキャンプでやりたいこととは、何を学べばいいのかを見つけることであり、身に着けたいものはそのようにして与えられたものです。
当然、それらの与えられたものについては全力で学び取っていこうと思います。&lt;/p&gt;

&lt;p&gt;もちろん、同じように学んでいける人々とつながりを持つということも求めていきたいです。
一緒に学んでいける人がいるということには、数えきれないほどのメリットがあるからです。
そしてそのような人々が詳しいこと、私が詳しいことは人によって皆違うはずなので、詳しい人からたくさん学ぶことができるようになり、セキュリティキャンプが終わった後も良い影響を及ぼしあうようになることができればと考えています。&lt;/p&gt;

&lt;h2 id=&#34;選択問題&#34;&gt;選択問題&lt;/h2&gt;

&lt;h3 id=&#34;選-a-1&#34;&gt;選-A-1.&lt;/h3&gt;

&lt;p&gt;添付したファイルに記録された通信を検知しました。この通信が意図するものは何か、攻撃であると判断する場合は何の脆弱性を狙っているか。また、通信フローに欠けている箇所があるがどのような内容が想定されるか、考えられるだけ全て回答してください。なお、通信内容を検証した結果があれば評価に加えます。&lt;/p&gt;

&lt;p&gt;.pcapについて調べると、パケットキャプチャを記録しておくためのファイルだということが分かったため、Wiresharkを使用して開きました。
192.168.74.1および192.168.74.130の二者の間での14件のパケットが記録されており、そのうちの13件がTCPプロトコル、1件がHTTPプロトコルによるものだということがまず分かりました。
また、Wireshark上で警告表示のあるパケット4件も含まれていました。
理由は後述しますが、私は結論としてこの通信が攻撃であると判断しているため、簡単のために192.168.74.1を攻撃側、192.168.74.130をサーバー側と呼称することにします。
これらのパケットは、攻撃側55522番ポートとサーバー側8080番ポートの間の9件の通信、および攻撃側53653番ポートとサーバー側22番ポートの間の5件の通信に分けられます。
8080番ポートは80番ポートの代替としてHTTP用に用いられており、実際にこのポートに対してHTTPリクエストが行われていることからHTTPサーバーが起動しているものと考えられます。
また22番ポートはSSHに割り当てられたwell-knownポートであり、サーバー側に対して攻撃側がSSHに関連した接続を行っているものと思われます(ただしキャプチャされたパケットにはssh通信は記録されていません)。
192.168.74.130がこれらの既知のポートで通信を行っていることから、こちらが攻撃を受ける側であると考えられます。&lt;/p&gt;

&lt;p&gt;まずは、8080番ポートに関連した通信に絞って調べました。
最初の3つのパケットは交互にSYN,SYN・ACK,ACKの通信が行われており、これはTCPの3ウェイハンドシェイクによる接続の確立だと判断できます。&lt;/p&gt;

&lt;p&gt;次に、/struts2-rest-showcase/orders.xhtml に対してGETメソッドによるHTTPリクエストが行われています。
このリクエストは、HTTPヘッダのContent-Typeの項目に明らかにMIMEタイプやcharsetの定義ではない、何らかのコードであると思われる文字列を含んでいます。
リクエスト先にstruts2という文字列が含まれている点、およびContent-Type部分にコードが書き込まれていることから、これはStrtus2の脆弱性であるCVE-2017-5638(S2-045/S2-046)を狙ったものであると考えられます。
この脆弱性によってContent-Typeに含まれるOGNL式が評価されるため、OGNLによって表現された任意のコードが実行可能となります。
今回検知された通信に含まれているコードは、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;cat /etc/passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というコマンドの実行を行うものです。
これにより、脆弱性に対する対策が取られていなかった場合、サーバー側は攻撃側に対して/etc/passwdの中身を送信します。
このGETリクエストに対するACKのパケットの次に検知されたパケットは、攻撃側からサーバー側に対してのACKであり、Wiresharkはこのパケットに対して警告を出しています。
このパケットでは攻撃側からサーバー側に対して、何らかの通信へのACKが行われ、Acknowledgment numberは最前の攻撃側からのパケットでの数値が1だったにもかかわらず1464となっています。
またこれより後に続くサーバー側の通信(11番目のパケットである、FIN・ACKの応答)に目を遣ると、Sequence numberが1464となっていることもわかります。
よって、このパケットの直前に攻撃側はサーバー側から長さ1463のデータを受け取っており、そのパケットは記録から欠けていると判断できます。
この失われたパケットは、攻撃側からのHTTPリクエストに対するサーバーからの返答であると考えられます。
ただし、TCP接続確立に用いられた最初の2つのパケットを確認すると、双方ともに最大セグメントサイズを1460バイトと規定していることがわかります。
このため、長さ1463のデータで通信する場合、パケットは2つに分割されていたのではないかと考えられます。
よって、ここで欠けているパケットは1つとは限らず、2分割された2つのパケット、またはそれらに加えて分割されたうち1つ目のパケットに対するACK応答などが含まれていた可能性があります。&lt;/p&gt;

&lt;p&gt;このACKのパケットに続いて、FIN・ACKフラグがセットされた通信が攻撃側から行われています。
このパケットのAcknowledgment numberも1464であるため、HTTPレスポンスの通信を検知していないWiresharkはTCP ACKed unseen segmentの警告を出しています。
TCPヘッダにFINフラグがセットされているため、これは通信終了を示しています。
その次の通信はサーバー側からの通信であり、FIN・ACKフラグがセットされています。
このパケットに対しWiresharkはTCP Previous segment not captured警告を発しており、またTCPの通信終了の際はサーバー側からのFIN・ACKフラグのセットされた通信の前に、攻撃側からのFINに対するACKのパケットが送られるべきであることから、この直前の通信が欠けており、その内容は長さ0のACKであると判断できます。
その後攻撃側からACK応答が届き、このポートでの通信は終了しています。&lt;/p&gt;

&lt;p&gt;次に、22番ポートにおける通信に着目します。
このポートでの通信は5回検知されていますが、そのすべてが攻撃側からサーバー側への、長さ0のACK応答となっています。
最初に検知されたパケットのTCPヘッダを確認すると、Sequence numberおよびAcknowledgment numberがともに1となっています。
ハンドシェイクによる接続確立のパケットは確認できないため、既に接続を確立した後のものであると考えられますが、何らかのデータの受信に対してACKの応答を行った場合、Acknowledgment numberは1より大きくなっているのではないかと推測されます。
よって、このACK応答は3ウェイハンドシェイクのうちの最後の1つであり、この前に攻撃側からのSYN→サーバー側からのSYN・ACKの通信が行われており、記録ではその2つのパケットが欠けていると考えることができます。
その後の4回の通信は、900から2500バイトのデータをサーバー側から連続して受け取ったことに対するACK応答であるように見えます。
しかしサーバー側から攻撃側に送信されたデータは記録されておらず、確認できません。
また、この間常に攻撃側のパケットのSequence numberは1のため、攻撃側が能動的にリクエストを発した形跡はないと考えられます。
また、実際にdockerでSSHを待ち受け、その接続の様子をキャプチャしてみましたが、SSHの接続処理によって攻撃側とサーバー側双方のSequence numberおよびAcknowledgment numberは1より大きくなったため、この攻撃者はSSHでの接続は行っていないと思いました。
一方でtelnetでSSHに接続を行ったところ、サーバー側からのSSHプロトコル通信によってやはりSequence numberおよびAcknowledgment numberの両方が1にはなりませんでした。
そのため、この一連の接続において攻撃側が何を行ったのかはわかりませんでした。&lt;/p&gt;

&lt;p&gt;以上の通信記録より、これはCVE-2017-5638を悪用した攻撃であると判断します。
攻撃者がcat /etc/passwdというコマンドの実行を試みたこと、SSHに使用されるポートに対する接続を行っていることから、この通信の意図は3つ考えられます。&lt;/p&gt;

&lt;p&gt;まず1つ目に、攻撃者が/etc/passwdに格納されている情報の利用を試みた可能性についてです。
この脆弱性が存在する最も古いバージョンであるStruts2.3.5のリリースは2012年であることから、パスワードハッシュが/etc/shadowではなく/etc/passwdに格納されているような大昔のUNIXシステム上で脆弱性のあるStruts2が動作していると考えるのは困難です。
またシステム管理者がシャドウパスワードを無効化するような設定を行っていたり、パスワードなしでログイン可能なユーザーが存在すれば攻撃対象とすることができますが、やはり非現実的であるように考えられます。&lt;/p&gt;

&lt;p&gt;もう1つは、この通信は攻撃対象のシステムがCVE-2017-5638脆弱性を含んでいるかどうか調査するための通信であるという可能性です。
サーバー側からのレスポンスによって任意コード実行が成功したかどうかを判別できるので、この通信によってCVE-2017-5638を利用した攻撃が可能かどうかを知ることができます。
しかしながら、今回の通信時に攻撃用のコードを直接実行しなかったこと、SSHに使用されるポートに対しても接続を行っていることについては疑問が残るように思われます。
前者については、このシステムだけでなく複数のシステムに対しての調査を行い、攻撃可能な対象の情報が十分に集まってから攻撃に移ることを意図しているのではないか、後者については、別の脆弱性を利用して特権昇格を行うことで、rootの乗っ取りを図ろうとしているのではないか、またはそもそもSSHポートが開いているのかどうかを調査しようと考えたのではないかと考えることができます。&lt;/p&gt;

&lt;p&gt;そして最後に、これらの一連の通信はサーバー管理者によるペネトレーションテストなのではないかという可能性です。
実行されたコードが攻撃性の少ないものであることに加え、通信している両者は同じローカルネットワーク上に存在しており、Ethernetヘッダに含まれているMACアドレスはどちらもVmware上の仮想システムを示しています。
そのため、この通信は管理者が本番環境に使われているのと同じ構築の仮想環境を用意し、自らが管理しているシステムに脆弱性が含まれているかどうかを実際に攻撃を行うことで調べようとして行ったものである可能性が考えられます(もっとも、その場合はこの通信が「攻撃」なのかどうか、という判断が揺らぎかねないような気もしますが)。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://io.cyberdefense.jp/entry/2016/06/22/Docker%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%80%81Apache_Struts2%E3%81%AE%E8%84%86%E5%BC%B1%E6%80%A7S2-037%E3%81%AE%E3%82%84%E3%82%89%E3%82%8C%E7%92%B0%E5%A2%83%E3%82%92%E6%89%8B%E8%BB%BD%E3%81%AB%E4%BD%9C&#34;&gt;http://io.cyberdefense.jp/entry/2016/06/22/Docker%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%80%81Apache_Struts2%E3%81%AE%E8%84%86%E5%BC%B1%E6%80%A7S2-037%E3%81%AE%E3%82%84%E3%82%89%E3%82%8C%E7%92%B0%E5%A2%83%E3%82%92%E6%89%8B%E8%BB%BD%E3%81%AB%E4%BD%9C&lt;/a&gt;
に記載されている方法によって、Docker上で脆弱性を含んだバージョンであるStruts2.5.10のサンプルアプリケーション(struts-2.5.10-apps.zip)を構築し、インターネットに接続していないコンピュータ上でこれを実行しました。
その上でtelnetを用い、localhostに向けて記録されたHTTPリクエストと同じ内容のリクエストを送信したところ、/etc/passwdの内容が返っており、この通信をキャプチャすると記録されたログとほぼ同じものであることが確認できました。
また、脆弱性が修正されたバージョンで同様にリクエストを送信したところ、このコードは無視され、本来返されるべきHTMLが正常に返されていることが確認できました。
また、リクエストが/struts2-rest-showcase/orders.xhtml であることから、記録された通信においても私が検証に用いたのと全く同じサンプルアプリケーションが使われていたのではないかと推測できます。
仮にそうであるならば、このアクセスに対する正常なレスポンスではデータ長が1000バイト前後に収まるはずであるため、Acknowledgment numberが1463も増えている今回の通信においては、このサーバー側システムには脆弱性が存在し、攻撃者は任意コード実行に成功したものと考えられます。&lt;/p&gt;

&lt;h3 id=&#34;選-a-3&#34;&gt;選-A-3.&lt;/h3&gt;

&lt;p&gt;自分がソフトウェア・ハードウェアを実装した部分について、自分とは意見が異なる実装を提案してきた人が現れた場合、あなたはどうしますか。&lt;br /&gt;
- 自分の実装のほうが優れていると思った場合どうしますか？&lt;br /&gt;
- 自分の実装のほうが優れていないと思った場合どうしますか？&lt;br /&gt;
- 相手の母国語が自分と違うために正確に議論が進まない場合はどうしますか？&lt;br /&gt;
- 相手がものすごく強硬で石頭でこちらのいうことを何も聞かず実装を勝手に修正してしまった場合どうしますか？&lt;/p&gt;

&lt;p&gt;意見が異なる実装が提案された場合、まず互いに議論を進めることが最優先だと考えます。
自分の実装と相手の実装それぞれについて、それを採用する利点は何か、そして欠点は何かをお互いに理解し、その上でどちらを採用するかを決めるのが理想的です。
異なる実装を提案してくるということは、既存の(自分の)実装に対して差別化できる何らかの理由があるものと考えられます。
そのうえで自分の実装の方が優れていると思った場合、以下の状況が想定できます。&lt;/p&gt;

&lt;p&gt;1.
自分の実装には、自分が見逃している欠点がある。&lt;br /&gt;
2.
自分の実装に存在する欠点を、自分は理解していない。&lt;br /&gt;
3.
自分の実装について、自分が思っている利点が相手にとっては小さく、欠点が相手にとっては大きく感じられている(または、人によってどちらが良いか意見が割れるような問題である)。&lt;br /&gt;
またこれは相手にとっても同様のことがいえます。&lt;/p&gt;

&lt;p&gt;ここで議論を交わすことによってそれぞれの実装の利点と欠点を互いに理解することができれば、1,2のパターンだった場合は誤った認識を正すことで合意に至れるのではないかと思います。または、3のようなパターンに移行する可能性もあります。
議論を進めた結果として3のようなことが争点になった場合、そのソフトウェア・ハードウェアの利用方法について自分と相手の想定が食い違っているのではないか、という可能性についてまず考慮したいと思います。
たとえば自分が想定している利用方法では特定の関数を数回しか呼び出さないものであり、一方で相手にとってはその関数が数万回呼び出されるべきものであった場合、自分にとっては少しのオーバーヘッドなら無視できるが、相手にとってはそれが大きな問題となるため、少しでも高速な実装を採用するべきだということになります。
このような利用方法の想定の違いについての齟齬を正すことは、お互いの認識をすりあわせるという点ももちろんですが、実装をしているときに考慮していなかったことについて気付かせてくれる機会でもあるため、相手がどのような利用を考えているのかは知るようにするべきだと思います。&lt;/p&gt;

&lt;p&gt;また、その分野について自分や相手よりも詳しいと思われる第三者に意見を求めるのも重要だと考えます。
自分と相手の二者では、いくら意見を交換してもその問題についての知識が足りないために適切な決定に至れないおそれがあり、また自分と相手の両方が認識していなかった別の要素が存在している可能性もあるからです。&lt;/p&gt;

&lt;p&gt;そして、自分と相手の実装がどのぐらい異なっているのかによっても、対処の仕方が変わってくると思います。
小規模な修正で、変更する範囲が小さいとか、パフォーマンスが大きくは変わらない、全体にとっては些細な修正であるというような場合には、実際には「どちらでもいい」可能性もあります。
また小規模な修正であっても、先述した利用シーンの想定での例のように、状況や使う人にとっては明確な違いが出る場合もあります。
相手が異なる実装の提案をしているという時点で、「どちらでもいい」の基準の閾値を越えている可能性の方が高いだろうと想定できるのですが(両者の誤解や見逃しが解消されたうえでのことで、ですが)、そうであるならば、両方の案を採用して設定で切り替えをできるようにするとか、ケースによって使い分けるようにするのが最も適切である、という可能性があることについては忘れないようにしたいです(もっとも、ハードウェアではこれは難しいことも多いかと思います)。
また大規模な修正であるならば、相手が単なる提案だけをしているのか、それとも実際に代替となる実装を用意しているのかも重要になってきます。
まだその代案での実装が存在しないのであれば、その実装にかかるコストや、その実装を行った場合に他の箇所に予期しない影響が出ないかどうか、既に自分が作った実装を使っている人やものに影響が出ないかどうかについても考える必要があります(これは小規模な修正であっても起こりうることですが、大規模な修正であればそのリスクは増えていくと思います)。
変更の範囲が大規模であればあるほど、変更を加えることによって全体の設計思想の一貫性が崩れてしまう可能性を含んでいることについても考えるべきで、もしかしたら、その部分の変更だけではなく全体の見直しも含めた修正が必要になることがあるかもしれないと思います。
このような場合、全体の設計思想と照らし合わせて本当にメリットになるのかどうか、ということについても相手の考えを問うべきだと思います。
逆に、自分が、またはチーム全体が、どのような設計思想のもとでそれを作ろうとしているのか、それをしっかりと意識したうえでの実装であったのかを自分に問うことも同様に必要です。&lt;/p&gt;

&lt;p&gt;相手の母国語が自分と違っていて議論が正確に進まないというのは、かなり難しい状況だと思います。
(もっとも技術の世界では、とにかく英語が使えるなら相手の言っていることが全くわからない、ということにはなりづらいのではないかと思います。
実際にそのような状況が起こった場合には仕方のないことではあるのですが、まずこのような状況が発生しにくくなるように、個々人が、つまり私が、より高い英語のスキルを身に着けられるように努力することを忘れないようにしたいです。)
やはり基本的には、これまで述べてきたような観点から相手の&lt;code&gt;/* 誤字 -&amp;gt; 相手と */&lt;/code&gt;議論が進められるように根気よく議論していくのが一番であると思っています。
その上で、言語の違いが原因でなかなか議論が進まないのであれば、議論を行っている方法についても見直しをします。
たとえば口頭で議論をしている場合、発言の内容はログとして残ることがなく、聞き間違え、単語の意味がわからない、相手の言っている意味を理解しようとするのに必死になってその中身を吟味する余裕がない、などの副次的な問題が発生します。
また、メールや掲示板の形式で議論をしている場合、技術的な問題だけでなく言語間の差異による認識の違いを正すための発言がどうしても多くなってしまうため、やりとりの件数が増えてしまって本筋の議論が見失われがちになり、また一つのやりとりで多くの内容のメッセージを送るためやりとりの間隔が長くなるので、時間も多く必要になります。
ただし、メールおよびツリー型のBBSならば、言語の差のために正しく伝わらなかった情報を修正するために議論が脱線したとしても、もともとの発言に戻って本筋の議論を続けることができるという利点があります。
IRCのようなテキストチャットは、発言のログが残り、かつリアルタイムにやりとりをすることができるので、このような場合には比較的適していると思います。
しかしながら、チャットのログが増えるとやはり問題の本筋に関する発言が(文字通り)見失われてしまう可能性があります。
以上のメリットとデメリットから、このような場合の議論はできるだけテキストベースで行うようにして、またリアルタイム性が確保できるようにチャットの形をとりながら、要所ごとにそれまでの議論をまとめた文章をどこか別の場所に置くようにすれば、言語の違いを克服して議論を進めやすくなるのではないかと思います。&lt;/p&gt;

&lt;p&gt;もしも、相手がものすごく強硬で石頭でこちらのいうことを何も聞かず実装を勝手に修正してしまった場合、これは難しいというより厄介な状況だと思います。
まず、相手が別の箇所の実装やプロジェクトでも同じようなふるまいをしているのかどうかを調べます。
そして、やはり別の箇所でも強硬で石頭なふるまいをしているようであれば、その相手自体が厄介な相手なのではないかという懸念が生まれるので、できるだけ自分と相手だけではなく第三者にも議論に参加してもらえるように助けをもとめたほうがよいと思います。
そのような様子があまり見当たらないのであれば、その相手にとってその実装はかなりの重要性を持っているのではないかと推測できます。
そのため、なぜ相手がその実装に拘ろうとしているのかについて聞くことで理由を知ることができるかもしれません。
とはいえ、相手が勝手に実装を修正してしまったのなら、ゆっくり話し合いをしている場合ではないことも多いのではないかと思います。
それをもともと実装した人である自分の同意を得ないうちに修正をしてしまうという状況は、チームや開発コミュニティ内でのルールや作法に違反している可能性が高いので、そのような場合は自分と相手だけで片付けようとせずに、ほかのメンバーにも相談して適切な対処方法を決めるようにします(チームの外にいる人間が既存の実装への修正の権限を持ちながら突然やってきて変更を加えていく、というのはむしろその状況自体が理解に苦しむので考えないことにします)。&lt;/p&gt;

&lt;p&gt;全体を通して、できるだけお互いに間違った認識がないように注意を払いながら議論を続けていくことで合意を目指す、というのが基本的な方針です。
そして、状況が難しくなりそうならできるだけ早く第三者にも意見を求めていくべきだと思っています。&lt;/p&gt;

&lt;h3 id=&#34;選-a-5&#34;&gt;選-A-5.&lt;/h3&gt;

&lt;p&gt;以下のプログラムはLinuxカーネル3.8〜4.4に存在する脆弱性を悪用しています。このプログラムの実行により発生する不具合を説明してください。また、この脆弱性をさらに悪用することでroot権限昇格を行うエクスプロイトを記述し、自分が試した動作環境や工夫点等を説明してください。加えて、このような攻撃を緩和する対策手法をなるべく多く挙げ、それらを説明してください。
完全には分からなくても構いませんので、理解できたところまでの情報や試行の過程、感じた事等について自分の言葉で記述してください。また参考にしたサイトや文献があれば、それらの情報源を明記してください。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;lt;stddef.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;keyutils.h&amp;gt;
 
int main(int argc, const char *argv[])
{
    int i = 0;
    key_serial_t serial;
 
    serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, &amp;quot;leaked-keyring&amp;quot;);
    if (serial &amp;lt; 0) {
        perror(&amp;quot;keyctl&amp;quot;);
        return -1;
    }
 
    if (keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL) &amp;lt; 0) {
        perror(&amp;quot;keyctl&amp;quot;);
        return -1;
    }
 
    for (i = 0; i &amp;lt; 100; i++) {
        serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, &amp;quot;leaked-keyring&amp;quot;);
        if (serial &amp;lt; 0) {
            perror(&amp;quot;keyctl&amp;quot;);
            return -1;
        }
    }
 
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このプログラムは、CVE-2016-0728を悪用しています。
プロセスが使用しているセッションキーリングを、システムコール呼び出しによって別のキーリング(leaked-keyring)に切り替えたのち、それと同じ名前のキーリングへの切り替えを複数回試みています。
結果として、同じ名前のキーリングへの切り替えを行おうとした際に、keyctlシステムコール内に存在する脆弱性のために、内部的に生成された新しいキーリング(つまりleaked-keyring)の解放が行われず、このキーリングに対する参照が残り続けてしまいます。
keyctlシステムコールは鍵保存サービスの一部分であり、鍵保存サービスはそれぞれの鍵が使用されている数を表す参照カウントを持っていますが、上記の解放漏れのために、同じkeyring名でのkeyctl(KEYCTL_JOIN_SESSION_KEYRING,name)呼び出しが行われると、そのたびに参照カウントがインクリメントされ、この参照はプログラムが終了しても残り続けます。
よってこのキーリングは鍵保存サービスに残り続けてしまいます。&lt;/p&gt;

&lt;p&gt;そこでまず、キーリングの参照リークが発生することを確かめようと、実際にDebian8.6のインストールされたマシン上でこのプログラムの実行を試みました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;$ uname -srvmo
Linux 3.16.0-4-amd64 #1 SMP Debian 3.16.36-1+deb8u2 (2016-10-19) x86_64 GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Linuxカーネルのバージョンが3.16であることから、脆弱性が存在しているバージョンであると思われます。
しかしながら/proc/keysの内容はこのプログラムの実行前と実行後で変化がなく、参照のリークを確かめることはできませんでした。
これは、DebianがこのLinuxカーネルの脆弱性に対してセキュリティアップデートを行っているため、パッチによって既に修正されているのだと考えました。
そこで、環境をVirtualBox上のDebian8.8に移し、
&lt;a href=&#34;https://www.debian.org/releases/jessie/mips/ch08s06.html.ja&#34;&gt;https://www.debian.org/releases/jessie/mips/ch08s06.html.ja&lt;/a&gt; &lt;a href=&#34;https://www.hiroom2.com/2016/05/18/ubuntu-16-04%E3%81%A7%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E3%82%92%E5%86%8D%E3%83%93%E3%83%AB%E3%83%89%E3%81%99%E3%82%8B/&#34;&gt;https://www.hiroom2.com/2016/05/18/ubuntu-16-04%E3%81%A7%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E3%82%92%E5%86%8D%E3%83%93%E3%83%AB%E3%83%89%E3%81%99%E3%82%8B/&lt;/a&gt; &lt;a href=&#34;http://d.hatena.ne.jp/adsaria/20081104/1225766991&#34;&gt;http://d.hatena.ne.jp/adsaria/20081104/1225766991&lt;/a&gt;
というようなWebページを参考にして、Linuxカーネル3.18.25のビルドおよびインストールを行い、このカーネルを脆弱性のあるカーネルで上書きすることを試みました。&lt;/p&gt;

&lt;p&gt;カーネルのビルド前に、/security/keys/process_keys.cのjoin_session_keyring関数を調べ、このカーネルが脆弱性を含んでいることを確認しました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;$cat security/keys/process_keys.c | grep &amp;quot;keyring == new-&amp;gt;session_keyring&amp;quot; -4 -n
792-		}
793-	} else if (IS_ERR(keyring)) {
794-		ret = PTR_ERR(keyring);
795-		goto error2;
796:	} else if (keyring == new-&amp;gt;session_keyring) {
797-		ret = 0;
798-		goto error2;
799-	}
800-
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;keyringがnew-&amp;gt;session_keyringと等しかった際の処理にkey_put(keyring);の行が存在しないことから、このソースコードは脆弱性を含んでいることがわかります。&lt;/p&gt;

&lt;p&gt;さらに、KEYCTL_SETPERMを第一引数としてkeyctlを呼び出したときに実行されるであろう部分にprintkを仕込んで、カーネルの上書きが成功していることを確かめようと考えました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;$ cat security/keys/keyctl.c | grep &amp;quot;Hello&amp;quot; -A 3 -B 6 -n
910-long keyctl_setperm_key(key_serial_t id, key_perm_t perm)
911-{
912-	struct key *key;
913-	key_ref_t key_ref;
914-	long ret;
915-
916:	printk(&amp;quot;Hello, World!&amp;quot;);
917-
918-	ret = -EINVAL;
919-	if (perm &amp;amp; ~(KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この状態でカーネルのビルドを行い、インストールしてカーネルの再構築を行いました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;$ uname -r
3.18.25-leak-test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再起動後にlinuxバージョンの確認を行ったところ、バージョン3.18.25に変化していることからカーネルの再構築が完了したと考え、再度プログラムの実行を行いました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;$ cat /proc/keys
3840ddc9 I--Q---   100 perm 3f3f0000  1000  1000 keyring   leaked-keyring: empty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお、dmesgでカーネルの出力を調べたところ、 Hello, World! の文字列が出力されているのが確認できました。&lt;/p&gt;

&lt;p&gt;また、VirtualBox上でCD版KNOPPIXバージョン7.2.0を実行し、この環境で参照リークの再現が可能かどうかを調べました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;$ uname -nr
Microknoppix 3.9.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Linuxバージョン3.9.6であり、このバージョンのリリースはCVE-2016-0728発見前の2013年であるためやはり脆弱性を含んでいることが予想され、結果としてkeyringの参照漏れが確認できました。&lt;/p&gt;

&lt;p&gt;次に、この脆弱性を用いたroot権限昇格を行うエクスプロイトを&amp;rdquo;記述&amp;rdquo;します。&lt;/p&gt;

&lt;p&gt;(おおよそ自明なものであるため回答可能文字数確保を目的として省略) &lt;code&gt;// 原文ママ&lt;/code&gt;&lt;br /&gt;
(&lt;a href=&#34;https://gist.github.com/PerceptionPointTeam/18b1e86d1c0f8531ff8f#gistcomment-1682326&#34;&gt;https://gist.github.com/PerceptionPointTeam/18b1e86d1c0f8531ff8f#gistcomment-1682326&lt;/a&gt;)&lt;br /&gt;
(gistで公開されているコードではなく、コメントで投稿されていたループ回数を2回減らしたほうのコードであることに注意)&lt;/p&gt;

&lt;p&gt;これは、&lt;a href=&#34;http://perception-point.io/2016/01/14/analysis-and-exploitation-of-a-linux-kernel-vulnerability-cve-2016-0728/&#34;&gt;http://perception-point.io/2016/01/14/analysis-and-exploitation-of-a-linux-kernel-vulnerability-cve-2016-0728/&lt;/a&gt; で紹介されていたものです。&lt;/p&gt;

&lt;p&gt;「基礎からわかるTCP/IP ネットワークコンピューティング入門」によると、CPUはユーザーモード、カーネルモード(スーパーバイザモード)といった状態を持っており、ユーザーモードで動くアプリケーションがシステムコールを呼び出すと、動作モードがカーネルモードに変化します。
ユーザーモードでは特定のアドレス空間にしかアクセスできない一方、カーネルモードでは任意のメモリアドレスを参照することができ、任意の命令の実行が可能になります。
そのため、CPUがカーネルモードにあるときに任意のコードが実行された場合、容易に特権昇格を行うことができるようになります。
たとえば、commit_creds(prepare_kernel_cred(0));を実行すると、prepare_kernel_credはNULLが与えられた場合にデフォルト値としてuid=0,gid=0となるようなroot権限のcredentialsを返し(&lt;a href=&#34;http://elixir.free-electrons.com/linux/v3.18.25/source/kernel/cred.c#L35&#34;&gt;http://elixir.free-electrons.com/linux/v3.18.25/source/kernel/cred.c#L35&lt;/a&gt; , &lt;a href=&#34;http://elixir.free-electrons.com/linux/v3.18.25/source/kernel/cred.c#L600&#34;&gt;http://elixir.free-electrons.com/linux/v3.18.25/source/kernel/cred.c#L600&lt;/a&gt; )、commit_credsによってそのcredentialsを現在のタスクに適用する(&lt;a href=&#34;http://elixir.free-electrons.com/linux/v3.18.25/source/kernel/cred.c#L401&#34;&gt;http://elixir.free-electrons.com/linux/v3.18.25/source/kernel/cred.c#L401&lt;/a&gt; )ため、以後そのアプリケーションはroot権限で実行されるようになります。&lt;/p&gt;

&lt;p&gt;CVE-2016-0728を用いたroot権限昇格のエクスプロイトでも、このカーネルモードでの任意コード実行を目指します。&lt;/p&gt;

&lt;p&gt;この脆弱性によって発生することは、キーリングの参照が残り続けること、そしてそれによって参照カウントのインクリメントが可能であることです。
key構造体(&lt;a href=&#34;http://elixir.free-electrons.com/linux/v3.18.25/source/include/linux/key.h#L132&#34;&gt;http://elixir.free-electrons.com/linux/v3.18.25/source/include/linux/key.h#L132&lt;/a&gt; )は32bit整数値で参照カウントを持っているため、参照カウントのインクリメントを0x100000000回行うことでオーバーフローが発生し、参照カウントが0となるためにそのキーリングがもはや使われていないと判断され、ガベージコレクション機能によってキーが解放されます。
ただし、keyctl(KEYCTL_JOIN_SESSION_KEYRING,name)呼び出しによってjoin_session_keyring関数(&lt;a href=&#34;http://elixir.free-electrons.com/linux/v3.18.25/source/security/keys/process_keys.c#L753&#34;&gt;http://elixir.free-electrons.com/linux/v3.18.25/source/security/keys/process_keys.c#L753&lt;/a&gt; )が呼ばれて参照リークが発生する場合、内部的に新しいキーリングを作ろうと試みるため、prepare_creds();が呼ばれてキーリングの参照カウントが1加算され、そしてjoin_session_keyring関数から抜ける際にabort_creds関数によって再び参照カウントが1減少します。
しかしながら、abort_creds関数は内部的にcall_rcuを呼び出し(&lt;a href=&#34;http://elixir.free-electrons.com/linux/v3.18.25/source/kernel/cred.c#L141&#34;&gt;http://elixir.free-electrons.com/linux/v3.18.25/source/kernel/cred.c#L141&lt;/a&gt; )、そのコールバック内でput_keyを遅延実行しようとします。
そのため、参照カウントのインクリメントに対してデクリメントが遅れ、カウントが現在のループ回数よりも多くなってしまうので、予期しないタイミングで参照カウントがオーバーフローを起こして0となってしまうおそれがあります。
そのため、残りのループ回数が半分になるたびにsleep(1)を呼び出して待機することで、意図しないオーバーフローを防ぐ必要があります(参照カウントのデクリメントが遅れても、呼び出した回数の2倍より大きくはならないためオーバーフローが起きることがない)。
このようにしてキーリングのメモリ空間を解放すれば、そのメモリ空間を上書きし、さらにキーリング構造体が持っている関数ポインタの位置に実行したい関数のアドレスを書き込み、システムコール内でその関数を呼び出させることで、CPUがカーネルモードの状態で任意のコードを実行可能になります。&lt;/p&gt;

&lt;p&gt;そのため、先ほど参照カウンタが0になったことによって解放されたメモリアドレスを確保する必要があります。
エクスプロイトコードでは、fork()によってプロセスを分け、メッセージキューを「たくさん」用意して、そこにちょうどkey構造体と同じだけのサイズを持つ構造体を用いてメッセージ送信を「たくさん」行っています。
メッセージはlong型のヘッダと自由な長さのメッセージ内容からなる構造体である(&lt;a href=&#34;http://www.geocities.co.jp/Athlete-Samos/7760/study/msgkyu1.html&#34;&gt;http://www.geocities.co.jp/Athlete-Samos/7760/study/msgkyu1.html&lt;/a&gt; )ため、メッセージ内容の長さをsizeof(key)-sizeof(long)にすれば、ちょうど全体がkey型の構造体と同じサイズになるようにすることが可能です。
その上で、本来revoke関数へのポインタが配置されている位置にcommit_creds(prepare_kernel_cred(0));を実行する関数のアドレスを格納しておきます。
それにより、解放された領域にこのメッセージが割り当てられた場合、システムコール内でrevoke関数が呼ばれた際に特権昇格の命令が実行されます。&lt;/p&gt;

&lt;p&gt;ただし、本来ユーザーモードではcommit_credsおよびprepare_kernel_credはメモリ保護されていて使用できないため、いくら実行時にカーネルモードで処理が行われるとしても、その命令を記述することができません。
そのため、予めこれらの命令が仮想メモリ空間上のどの位置に配置されるのかを調べておき、そのアドレスを直接参照することでcommit_credsとprepare_kernel_credを示すことができます。
仮想メモリ空間において、カーネル領域は同じLinuxカーネルならば同じ仮想アドレス上に展開される上、そのアドレスは/proc/kallsymsで確認可能なため、その中身を見ることで調べたり、攻撃の前に別のマシンで調べておくこともできます。&lt;/p&gt;

&lt;p&gt;実際にこのエクスプロイトを用いて特権昇格を試みた結果を書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;$ gcc exploit.c -o exploit -lkeyutils -Wall
$ ./exploit attack
uid = 1000, euid = 1000
[+] increfs...
[+] finish increfs
[+] fork...
exploit...
強制終了
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スタックトレースは、以下のようになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;[  +0.000003] Stack:
[  +0.000001]  ffffffff81091da6 0000000000400ae8 8948818f00000000 ffff880157
[  +0.000002]  0000000000000000 ffff880157c65280 ffff880157c652a1 ffffffff81
[  +0.000002]  00007fff92148680 ffff880157c65280 00000000fffffffd ffffffff81
[  +0.000001] Call Trace:
[  +0.000004]  [&amp;lt;ffffffff81091da6&amp;gt;] ? wait_task_inactive+0xa6/0x160
[  +0.000004]  [&amp;lt;ffffffff81244657&amp;gt;] ? key_revoke+0x37/0x80
[  +0.000002]  [&amp;lt;ffffffff81247380&amp;gt;] ? keyctl_revoke_key+0x30/0x70
[  +0.000003]  [&amp;lt;ffffffff81548e0d&amp;gt;] ? system_call_fastpath+0x16/0x1b
[  +0.000001] Code: c0 48 83 c4 30 5b 5d 41 5c 41 5d 41 5e c3 66 83 43 08 01
[  +0.000016] RIP  [&amp;lt;ffffffff81548345&amp;gt;] _raw_spin_unlock_irqrestore+0x5/0x20
[  +0.000002]  RSP &amp;lt;ffff8800db31bf08&amp;gt;
[  +0.000001] CR2: 00000000004009d0
[  +0.000002] ---[ end trace c403a12e9768e731 ]---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;wait_task_inactiveで終了しているようでしたが、カーネルのkey_revokeのソースコードからwait_task_inactiveへの呼び出しは見つけられず、何らかのセキュリティによって強制的にプロセスを遮断されたのではないかと思いましたが、よくわかりませんでした。
また、/proc/kallsymsでkey_revokeやkeyctl_revoke_keyのアドレスを表示しましたが、このスタックトレースに表示されているアドレスとは異なっており、またその差もばらばらであったため一定のオフセット値によってずれているわけでもなさそうなので、ここで手詰まりとなりました。&lt;/p&gt;

&lt;p&gt;同じプログラムを何回か試したところ、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;$ ./exploit attack
uid = 1000, euid = 1000
[+] increfs...
[+] finish increfs
[+] fork...
exploit...
[+] keyctl_revoke: Input/output error
uid = 1000, euid = 1000
$ whoami
tatamo
$ exit
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;tatamo@debian:~$ ./exploit exp
uid = 1000, euid = 1000
[+] increfs...
[+] finish increfs
[+] fork...
exploit...
[+] keyctl_revoke: Required key not available
uid = 1000, euid = 1000
$ whoami
tatamo
$ exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように、異なるエラーメッセージが出てroot権限を得られないままプログラムが終了することがありました。
これは、オーバーフローを発生させた瞬間もやはりabort_credsの非同期性のために予期せぬオーバーフローが発生しうること、直後にfork()を行ったことによってさらに参照カウンタが動いていること、また解放されたメモリアドレスへの再割り当てを試みたが結果として何も割り当てられなかったこと、が原因なのではないかと推測します。&lt;/p&gt;

&lt;p&gt;このような攻撃を防ぐための技術として、Supervisor Mode Execution Prevention(SMEP)とSupervisor Mode Access Prevention(SMAP)が挙げられます。
これはともに、カーネルモードのCPUがユーザー空間からの攻撃を防ぐために設計されたものです。
SMEPは、ユーザー空間上にあるコードをカーネルモードで動作しているCPUから実行することを禁止させます。
SMAPはIntel製のCPUでサポートされている機能であり、SMEPの実装でもあります。
これはカーネルモードで動作しているCPUのユーザー空間上のメモリに対しての読み書きを禁止します(&lt;a href=&#34;https://en.wikipedia.org/wiki/Supervisor_Mode_Access_Prevention&#34;&gt;https://en.wikipedia.org/wiki/Supervisor_Mode_Access_Prevention&lt;/a&gt; )。
これによって、カーネルが意図しない形でユーザー空間にアクセスした場合にはページフォールトを発生させ、今回の脆弱性を悪用したコードによるカーネルモードでの任意コード実行を防止することができます。
またubuntuでは、Kernel Address Display Restrictionと呼ばれる機能により、一般ユーザーが/proc/kallsymsを表示しようとした場合、すべてのアドレスが0で埋められて表示されるようになっています(&lt;a href=&#34;http://inaz2.hatenablog.com/entry/2015/03/21/175433&#34;&gt;http://inaz2.hatenablog.com/entry/2015/03/21/175433&lt;/a&gt; )。
攻撃者が多くのLinuxディストリビューション上で動作するようなエクスプロイトコードを書きたいと思った場合、/proc/kakllsymsから動的にcommit_credsなどのメモリアドレスを取得しようとすることが考えられるため、そのような攻撃に対しての効果が期待されます。&lt;/p&gt;

&lt;p&gt;以降、この問題を解こうとして感じたことを述べます。
まず、私はこの回答欄にエクスプロイトコードを&amp;rdquo;記述&amp;rdquo;しましたが、それは調べたら見つかっただけのものであって&amp;rdquo;作成&amp;rdquo;してはいません。
それどころか、このコードの一部は理解することすらできませんでした(なぜfork()をしているのか、メモリ確保のルールをどのように利用して解放されたアドレスに再び別のオブジェクトを割り当てるのか？)。
今の私にはこのようなエクスプロイトを作成することは逆立ちしても不可能であると感じたので、せめてできるだけ理解しようと試みました。
しかしそもそも、実際に脆弱性の再現を行ううえで、Linuxカーネルのソースコードを読むこと、そして再ビルドしてインストールすることはこれまで一度も行ったことがなかったため、なかなかスムーズに進まず、スタートラインにすら立てていない感覚に焦りを覚えていました。&lt;/p&gt;

&lt;p&gt;実はカーネルを再構築して問題のコードを実行した後、/proc/keysをroot権限で表示するとユーザー側で実行していた参照リークを起こしているキーリングを見ることができないことを知らず、sudo catで表示していたために失敗したと思い込んでいました。
同様にdmesg -Hを実行するとlessされて表示されましたが、マウススクロールで表示が下に下がらなかったために一画面目の一番下の行が最新のカーネルログだと思い込んでしまい、実際にはカーネルに仕込んだ”Hello, World!”のメッセージが表示されていたにもかかわらず見落とし、しばらくカーネルの再構築に失敗したのではないかと考えていました。
これで悩んでかなりの時間を費やしたのですが、本当は想定通りに参照リークが発生していたこと、メッセージが表示されていたことに気付いたときは、なんだ成功していたのか、という気持ちと同時に、静かな興奮が沸き上がってくるのを感じました。
問題には直接関係なく、正しくカーネルの再構築ができているか確かめるのに役立つだろうと思って、ビルドの前にカーネルのソースコードを改変し、keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL)システムコールが呼ばれたときにprintk(“Hello, World!”);が実行されるようにしていたことです。
実際にやってみれば(ビルドにかなりの時間がかかるものの)Linuxカーネルのインストールは思った以上に簡潔な手順で完了し、しかも自分が書き換えたコードがこうも容易にOSの中核部分で動いているのだ、これだけ自分がセキュリティを破るのに苦労しているカーネルというものはプログラミング可能なものなのだ、と実感したときのワクワク感はしばらく忘れられないと思います。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;お目汚し失礼致しました。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第6回:パーサの実装と構文解析の実行</title>
      <link>http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-06/</link>
      <pubDate>Tue, 04 Apr 2017 23:41:09 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-06/</guid>
      <description>
        &lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-05/&#34;&gt;前回&lt;/a&gt;ではLR(1)法による構文解析表の実装を済ませました。
今回はいよいよ、構文解析表をもとに実際に構文解析を行うことのできる構文解析器を実装し、実際に構文解析を行ってみます。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;概略は&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;第4回&lt;/a&gt;で示した通りであり、ステートマシンの仕様に沿って構文解析表を解析できるようにします。
第4回でアルゴリズム面まで踏み込んで解説してしまったため、あまり書くことがなくてやや後悔しています。&lt;/p&gt;

&lt;h2 id=&#34;astの定義&#34;&gt;ASTの定義&lt;/h2&gt;

&lt;p&gt;パーサを実装する前に、パーサの出力結果となる抽象構文木の定義を行います。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/ast.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/ast.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// ast.ts
export interface ASTNode{
	type: Token;
	value: string|null;
	children: Array&amp;lt;ASTNode&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;構文木は再帰的な木構造によって表されます。
それぞれのノードにはそれが何の記号かを示すトークン、およびそのトークンに紐つけられている実際の入力文字列(そのトークンが非終端記号である場合はnull)、自身の子となるノードの配列を持ちます。&lt;/p&gt;

&lt;p&gt;たとえば、&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;第3回&lt;/a&gt;で定義した構文規則によって&lt;code&gt;1+1&lt;/code&gt;を解析した場合、結果として得られる抽象構文木は以下のようになるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
    {&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
        {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
            {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
                {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;, &amp;quot;value&amp;quot;:&amp;quot;1&amp;quot;, &amp;quot;children&amp;quot;:[]}
            ]}
        ]}
    ]}, 
    {&amp;quot;type&amp;quot;:&amp;quot;PLUS&amp;quot;, &amp;quot;value&amp;quot;:&amp;quot;+&amp;quot;, &amp;quot;children&amp;quot;:[]}, 
    {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
        {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
            {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;, &amp;quot;value&amp;quot;:&amp;quot;1&amp;quot;, &amp;quot;children&amp;quot;:[]}
        ]}
    ]}
]}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;簡単ですね。&lt;/p&gt;

&lt;h2 id=&#34;パーサの実装&#34;&gt;パーサの実装&lt;/h2&gt;

&lt;p&gt;ではParserクラスを作っていきます。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/parser.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/parser.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// parser.ts
export interface TerminalCallbackArg {
        token: string;
        value: string;
        terminal: true;
}
export interface NonterminalCallbackArg {
        token: string;
        children: Array&amp;lt;any&amp;gt;;
        pattern: Array&amp;lt;string&amp;gt;;
        terminal: false;
}
export declare type ParserCallbackArg = TerminalCallbackArg | NonterminalCallbackArg;
export declare type ParserCallback = (arg: ParserCallbackArg) =&amp;gt; any;
export declare class Parser {
        private lexer;
        private syntax;
        private parsingtable;
        private default_callback;
        constructor(lexer: ILexer, syntax: SyntaxDefinitions, parsingtable: ParsingTable, default_callback?: ParserCallback | null);
        setDefaultCallback(default_callback?: ParserCallback | null): void;
        parse(input: string, cb?: ParserCallback): any;
        private _parse(inputs, cb?);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;できました。&lt;/p&gt;

&lt;p&gt;構文解析処理を行う処理は、110行程度に及ぶ&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/parser.ts#L40&#34;&gt;Parser#_parse()メソッド&lt;/a&gt;の内部で完結しています。
これは、&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;第4回&lt;/a&gt;に示したオートマトンの動作を仕様通りに実装しています。
入力を前から順に読み込み、現在スタックに積まれている状態番号を取得し、構文解析表の該当する位置に書かれている命令を実行していくだけです。&lt;/p&gt;

&lt;p&gt;ここでは、構文解析の実行中に衝突した命令が存在した場合、その時点で解析失敗としてエラーを返すようにしています。
コンフリクトが発生した際の対処についても&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;第4回&lt;/a&gt;で触れていますが、一般に使用されているパーサジェネレータでは、構文規則を定義するファイルの中に演算子の優先度や右結合/左結合の指定を行うことができたり、指定のない場合はshift/reduceのいずれかを優先するようになっていたりします。&lt;/p&gt;

&lt;p&gt;このあたりのコンフリクト回避処理や、エラーが発生した際の詳細なエラー情報の検知・回避などの機能面には大きく改善の余地があります。&lt;/p&gt;

&lt;p&gt;あとは、このParserをParserGeneratorから利用できるようにするため、適当にファクトリクラスを作ります。
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/factory.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/factory.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// factory.ts
export class ParserFactory{
	public static create(grammar: GrammarDefinition, parsing_table: ParsingTable, default_fallback?: ParserCallback):Parser{
		let lexer = new Lexer(grammar.lex);
		return new Parser(lexer, grammar.syntax, parsing_table, default_fallback);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/parsergenerator.ts#L32&#34;&gt;ParserGenerator#getParser()メソッド&lt;/a&gt;には、以下のような記述を行います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// parsergenerator.ts
public getParser(default_callback?: ParserCallback):Parser{
	return ParserFactory.create(this.grammar, this.parsing_table, default_callback);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで完成です。&lt;/p&gt;

&lt;h2 id=&#34;構文解析を実行する&#34;&gt;構文解析を実行する&lt;/h2&gt;

&lt;h3 id=&#34;構文木を生成する&#34;&gt;構文木を生成する&lt;/h3&gt;

&lt;p&gt;では、実際に構文解析を実行してみましょう。
与える構文は、以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const syntax:SyntaxDefinitions = [
	{
		ltoken: &amp;quot;EXP&amp;quot;,
		pattern: [&amp;quot;EXP&amp;quot;, &amp;quot;PLUS&amp;quot;, &amp;quot;TERM&amp;quot;]
	},
	{
		ltoken: &amp;quot;EXP&amp;quot;,
		pattern: [&amp;quot;TERM&amp;quot;]
	},
	{
		ltoken: &amp;quot;TERM&amp;quot;,
		pattern: [&amp;quot;TERM&amp;quot;, &amp;quot;ASTERISK&amp;quot;, &amp;quot;ATOM&amp;quot;]
	},
	{
		ltoken: &amp;quot;TERM&amp;quot;,
		pattern: [&amp;quot;ATOM&amp;quot;]
	},
	{
		ltoken: &amp;quot;ATOM&amp;quot;,
		pattern:[&amp;quot;DIGITS&amp;quot;]
	},
	{
		ltoken: &amp;quot;ATOM&amp;quot;,
		pattern:[&amp;quot;LPAREN&amp;quot;, &amp;quot;EXP&amp;quot;, &amp;quot;RPAREN&amp;quot;]
	}
];
const lex:LexDefinitions = [
	{token:&amp;quot;DIGITS&amp;quot;, pattern:/[1-9][0-9]*/},
	{token:&amp;quot;PLUS&amp;quot;, pattern:&amp;quot;+&amp;quot;},
	{token:&amp;quot;ASTERISK&amp;quot;, pattern:&amp;quot;*&amp;quot;},
	{token:&amp;quot;LPAREN&amp;quot;, pattern:&amp;quot;(&amp;quot;},
	{token:&amp;quot;RPAREN&amp;quot;, pattern:&amp;quot;)&amp;quot;},
	{token:null, pattern:/(\r\n|\r|\n)+/},
	{token:null, pattern:/[ \f\t\v\u00a0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]+/},
	{token:&amp;quot;INVALID&amp;quot;, pattern:/./},
];

const grammar:GrammarDefinition = {
	lex: lex,
	syntax: syntax,
	start_symbol: &amp;quot;EXP&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt;という式を解析するためには、以下のように実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;new ParserGenerator(grammar).getParser().parse(&amp;quot;9 + 11 * (2 + 1)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すると、結果として以下のようなオブジェクトが得られます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
    {&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
    {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
        {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;9&amp;quot;,&amp;quot;children&amp;quot;:[]}
            ]}
        ]}
    ]},
    {&amp;quot;type&amp;quot;:&amp;quot;PLUS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;+&amp;quot;,&amp;quot;children&amp;quot;:[]},
    {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
        {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
            {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;11&amp;quot;,&amp;quot;children&amp;quot;:[]}
            ]}
        ]},
        {&amp;quot;type&amp;quot;:&amp;quot;ASTERISK&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;*&amp;quot;,&amp;quot;children&amp;quot;:[]},
        {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
            {&amp;quot;type&amp;quot;:&amp;quot;LPAREN&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;(&amp;quot;,&amp;quot;children&amp;quot;:[]},
            {&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                {&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                    {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                        {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                            {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;2&amp;quot;,&amp;quot;children&amp;quot;:[]}
                        ]}
                    ]}
                ]},
                {&amp;quot;type&amp;quot;:&amp;quot;PLUS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;+&amp;quot;,&amp;quot;children&amp;quot;:[]},
                {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                    {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                        {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;children&amp;quot;:[]}
                    ]}
                ]}
            ]},
            {&amp;quot;type&amp;quot;:&amp;quot;RPAREN&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;)&amp;quot;,&amp;quot;children&amp;quot;:[]}
        ]}
    ]}
]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どこからどう見ても成功ですね。
おめでとうございます。&lt;/p&gt;

&lt;h3 id=&#34;コールバックを利用して構文木のさらなる解析を行う&#34;&gt;コールバックを利用して構文木のさらなる解析を行う&lt;/h3&gt;

&lt;p&gt;ついに、本記事の目標である構文木の取得を達成しました。
あとはこれに適当な再帰的処理を挟めば、良い感じに数式処理ができるでしょう。&lt;/p&gt;

&lt;p&gt;確かに一度構文木を生成してからそれを解析してもよいのですが、パーサに適当なコールバックを渡し、構文木を生成する代わりに数式処理を行ってしまうという手もあります。&lt;/p&gt;

&lt;p&gt;先ほどのparsergenerator.tsに、以下のような定義が含まれていました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export interface TerminalCallbackArg {
        token: string;
        value: string;
        terminal: true;
}
export interface NonterminalCallbackArg {
        token: string;
        children: Array&amp;lt;any&amp;gt;;
        pattern: Array&amp;lt;string&amp;gt;;
        terminal: false;
}
export declare type ParserCallbackArg = TerminalCallbackArg | NonterminalCallbackArg;
export declare type ParserCallback = (arg: ParserCallbackArg) =&amp;gt; any;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Parserのコンストラクタ引数、ParserGeneratorのgetParserメソッドの引数、またはParserのparseメソッドの引数としてコールバックを与えると、reduce処理が行われた際にそれを呼び出すことができます。
処理するべきトークンが終端器号であった場合はそのトークンの種類と実際の入力が、非終端記号であった場合は対応する規則の情報、およびその子ノードの情報が引数として与えられます。&lt;/p&gt;

&lt;p&gt;実際に、数式の処理を行うための関数を書いてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;let solve_terminal = (arg:TerminalCallbackArg)=&amp;gt;{
	switch(arg.token){
		case &amp;quot;DIGITS&amp;quot;:
			return +arg.value;
		default:
			return null;
	}
}
let solve_nonterminal = (arg:NonterminalCallbackArg)=&amp;gt;{
	switch(arg.token){
		case &amp;quot;EXP&amp;quot;:
			if(arg.children.length == 1) return arg.children[0];
			else return arg.children[0] + arg.children[2];
		case &amp;quot;TERM&amp;quot;:
			if(arg.children.length == 1) return arg.children[0];
			else return arg.children[0] * arg.children[2];
		case &amp;quot;ATOM&amp;quot;:
			if(arg.children.length == 1) return arg.children[0];
			else return arg.children[1];
	}
}
let solve = (arg:ParserCallbackArg)=&amp;gt;{
	if(arg.terminal) return solve_terminal(arg);
	else return solve_nonterminal(arg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをもとに、以下のように実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;new ParserGenerator(grammar).getParser(solve).parse(&amp;quot;9 + 11 * (2 + 1)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果は、以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これにて、パーサジェネレータの実装および構文解析が完了しました。
ここまでお付き合いいただき、ありがとうございました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回:かんたん構文解析入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-05/&#34;&gt;前回:LR(1)パーサジェネレータの実装&lt;/a&gt;&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第5回:LR(1)パーサジェネレータの実装</title>
      <link>http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-05/</link>
      <pubDate>Tue, 04 Apr 2017 21:54:01 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-05/</guid>
      <description>
        &lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;前回&lt;/a&gt;の記事ではLR(1)法の解説を行いました。
今回は前回解説した部分の実装を行います。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;今回はひたすらパーサジェネレータの実装をしていきます。
概略やアルゴリズムは既に紹介しているため、基本的に省略します。
適宜&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;前回&lt;/a&gt;の記事を参照してください。&lt;/p&gt;

&lt;p&gt;今回取り上げる部分は特にパフォーマンスに与える影響が大きいため、処理速度を重視した設計を行っています。
そのため、天下り的な解説となる箇所が増えるかもしれませんがご了承ください。&lt;/p&gt;

&lt;h2 id=&#34;syntaxdbクラスの作成&#34;&gt;SyntaxDBクラスの作成&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;第3回&lt;/a&gt;で終端記号と非終端記号の区別を行ったり、First集合を求めたりしたように、与えられた構文から様々な情報を得る必要があります。&lt;/p&gt;

&lt;p&gt;そこで、それらの情報取得を担うクラスとしてSyntaxDBクラスを作成します。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/syntaxdb.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/syntaxdb.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// syntaxdb.d.ts
export declare class SyntaxDB {
    private syntax;
    private _start_symbol;
    private _first;
    private _symbols;
    private tokenmap;
    private tokenid_counter;
    private defmap;
    constructor(grammar: GrammarDefinition);
    private initDefMap();
    readonly start_symbol: Token;
    readonly first: FirstSet;
    readonly symbols: SymbolDiscriminator;
    findDef(x: Token): Array&amp;lt;{
        id: number;
        def: SyntaxDefinitionSection;
    }&amp;gt;;
    getTokenId(token: Token): number;
    get(id: number): SyntaxDefinitionSection;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SyntaxDBクラスの読み取り専用メンバとして第3回で作成したFirstSetとSymbolDiscriminatorを持たせており、このクラスから終端記号の区別、First集合の取得が可能です。
また、開始記号の取得も行えるようにします。
さらに、構文id(上から何番目かを表す番号)を与えるとそれに対応する規則を返す&lt;code&gt;get&lt;/code&gt;メソッド、記号を与えるとそれが左辺に現れる規則すべてを、構文idとともに返す&lt;code&gt;findDef&lt;/code&gt;メソッド、そして記号を与えるとそれに対応した一意なトークンidを返す&lt;code&gt;getTokenId&lt;/code&gt;メソッドを持ちます。&lt;/p&gt;

&lt;p&gt;findDefメソッドは愚直に実装した場合、複数回呼ばれるとそのたびに&lt;code&gt;O(n)&lt;/code&gt;程度の計算量がかかります。
そのため、SyntaxDBインスタンスの初期化時に非終端記号と規則群を対応付けたMapを生成する(計算量は&lt;code&gt;O(n)&lt;/code&gt;程度)ことで、findDefの呼び出し時にはMapの中身をそのまま返すだけで済むようにします。&lt;/p&gt;

&lt;p&gt;getTokenIdメソッドは後述するアイテム集合部分で使用する必要がありますが、特に厳密なシリアライズや復元可能性を求めているわけではなく、単にハッシュ代わりに使用されます。
そのため、同一のSyntaxDBインスタンスのgetTokenIdメソッドにトークンを与えると、同一のトークンならば必ず同じ番号が返ってくるようになっていればそれで構いません。
よって、以下のような単純な実装で事足ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// Tokenを与えると一意なidを返す
public getTokenId(token: Token): number{
	if(!this.tokenmap.has(token)) this.tokenmap.set(token, this.tokenid_counter++);
	return this.tokenmap.get(token)!; /// ※ !はTypeScriptのnon-nullable注釈
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このSyntaxDBクラスは、パーサジェネレータ全体を通して一つのインスタンスのみを使いまわすようにします。&lt;/p&gt;

&lt;h2 id=&#34;アイテム集合とクロージャー展開&#34;&gt;アイテム集合とクロージャー展開&lt;/h2&gt;

&lt;p&gt;まずは、LRアイテムおよびその集合を表現するクラスを作っていきます。
アイテム集合クラスには、自身をクロージャー展開する機能を持たせることとします。&lt;/p&gt;

&lt;p&gt;また、DFAの構築において、「既存のアイテム集合の中に、新しく生成されたアイテム集合と一致するものが存在するかどうか判定する」処理が必要とされます。
愚直に実装すると、この処理を1回行うだけで&lt;code&gt;O(n^3)&lt;/code&gt;程度の計算量が必要となり、パーサジェネレータの処理全体の中で最大のボトルネックとなりえます。
そのため、2つのアイテム集合の高速な一致判定を行えるようにする必要があります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/closure.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/closure.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// closure.d.ts
export declare class ClosureItem {
    private syntax;
    private _syntax_id;
    private _dot_index;
    private _lookaheads;
    private _lr0_hash;
    private _lr1_hash;
    constructor(syntax: SyntaxDB, _syntax_id: number, _dot_index: number, _lookaheads: Array&amp;lt;Token&amp;gt;);
    readonly syntax_id: number;
    readonly dot_index: number;
    readonly lookaheads: Array&amp;lt;Token&amp;gt;;
    private sortLA();
    private updateHash();
    getLR0Hash(): string;
    getLR1Hash(): string;
    isSameLR0(c: ClosureItem): boolean;
    isSameLR1(c: ClosureItem): boolean;
    merge(c: ClosureItem): ClosureItem | null;
}
export declare class ClosureSet {
    private syntax;
    private closureset;
    private _lr0_hash;
    private _lr1_hash;
    constructor(syntax: SyntaxDB, closureset: Array&amp;lt;ClosureItem&amp;gt;);
    private sort();
    readonly size: number;
    getArray(): ClosureItem[];
    includes(item: ClosureItem): boolean;
    isSameLR0(c: ClosureSet): boolean;
    isSameLR1(c: ClosureSet): boolean;
    private updateHash();
    getLR0Hash(): string;
    getLR1Hash(): string;
    mergeLA(cs: ClosureSet): ClosureSet | null;
    private expandClosure();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ClosureItemクラスはLRアイテム1つに対応し、構文id、&lt;code&gt;.&lt;/code&gt;の位置、および先読み記号の情報を持ちます。
ClosureSetクラスは複数のClosureItemをまとめた集合を表し、自身をクロージャー展開することが出来ます。
さらに、後述するハッシュに関連した機能、および先読み部分のマージ機能などを持ちます。&lt;/p&gt;

&lt;h3 id=&#34;クロージャー展開&#34;&gt;クロージャー展開&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// クロージャー展開を行う
// TODO: リファクタリング
private expandClosure(){
	// 展開処理中はClosureItemのlookaheadsの要素数を常に1に保つこととする
	// 初期化
	let set:Array&amp;lt;ClosureItem&amp;gt; = [];
	// ClosureItemをlookaheadsごとに分解する
	for(let ci of this.closureset){
		for(let la of ci.lookaheads){
			set.push(new ClosureItem(this.syntax, ci.syntax_id, ci.dot_index, [la]));
		}
	}
	this.closureset = set;
	this.sort();

	// 変更がなくなるまで繰り返す
	let i=0;
	while(i&amp;lt;this.closureset.length){
		let ci = this.closureset[i++];
		let {ltoken, pattern} = this.syntax.get(ci.syntax_id);

		if(ci.dot_index == pattern.length) continue; // .が末尾にある場合はスキップ
		let follow = pattern[ci.dot_index];
		if(!this.syntax.symbols.isNonterminalSymbol(follow)) continue; // .の次の記号が非終端記号でないならばスキップ

		// クロージャー展開を行う

		// 先読み記号を導出
		// ci.lookaheadsは要素数1のため、0番目のインデックスのみを参照すればよい
		let lookaheads = [...this.syntax.first.get(pattern.slice(ci.dot_index+1).concat(ci.lookaheads[0])).values()];
		lookaheads.sort((t1:Token, t2:Token)=&amp;gt;{
			return this.syntax.getTokenId(t1) - this.syntax.getTokenId(t2);
		});

		// symbolを左辺にもつ全ての規則を、先読み記号を付与して追加
		let definitions = this.syntax.findDef(follow);
		for(let {id, def} of definitions){
			for(let la of lookaheads){
				let new_ci = new ClosureItem(this.syntax, id, 0, [la]);
				// 重複がなければ新しいアイテムを追加する
				let flg_duplicated = false;
				for(let existing_item of this.closureset){
					if(new_ci.isSameLR1(existing_item)){
						flg_duplicated = true;
						break;
					}
				}
				if(!flg_duplicated){
					this.closureset.push(new_ci);
				}
			}
		}
	}
	this.sort();

	// ClosureItemの先読み部分をマージする
	let tmp = this.closureset;
	this.closureset = [];
	let lookaheads = [];
	for(let i=0; i&amp;lt;tmp.length; i++){
		lookaheads.push(tmp[i].lookaheads[0]);
		if(i == tmp.length-1 || !tmp[i].isSameLR0(tmp[i+1])){
			this.closureset.push(new ClosureItem(this.syntax, tmp[i].syntax_id, tmp[i].dot_index, lookaheads));
			lookaheads = [];
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まだリファクタリングしていません。
すみません。&lt;/p&gt;

&lt;p&gt;ClosureItemは本来複数の先読み記号を保持することができるのですが、クロージャー展開の初期化段階では、まずそれを分解し、一つのClosureItemが必ず一つの先読み記号のみを持つようにします。&lt;/p&gt;

&lt;p&gt;この制約がなければ、たとえば&lt;code&gt;[x,y]&lt;/code&gt;という先読み記号を持ったAというClosureItemの展開処理が済んだあと、BというClosureItemを展開したところ、&lt;code&gt;[y,z]&lt;/code&gt;という先読み記号を持ち、先読み部分以外はAと全く同じClosureItemが生成される、といった自体が発生する可能性があります。
この場合、先読み記号&lt;code&gt;y&lt;/code&gt;については2度展開されてしまったり、それを防ぐために処理済みのClosureItemの走査を行うことで余計な計算が必要になってしまうなど、様々な弊害が発生します。
クロージャー展開の処理中だけはClosureItemの先読み記号は常に一つであるという制約を設けていることで、展開処理が非常に簡潔になります。&lt;/p&gt;

&lt;p&gt;処理が終わった段階で、ClosureItemの先読み部分をマージすることによってクロージャー展開後のClosureSetが完成します。&lt;/p&gt;

&lt;h3 id=&#34;ハッシュ&#34;&gt;ハッシュ&lt;/h3&gt;

&lt;p&gt;先述したように、2つのClosureSetの高速な比較を可能とする必要があります。
そこで、ClosureItemおよびClosureSetにハッシュ文字列の生成機能を追加し、構文番号、&lt;code&gt;.&lt;/code&gt;の位置、先読み記号という要素が一致していれば同じ文字列を生成するようにすれば、同一性の比較を文字列比較に落としこむことができ、非常に高速になります。
ハッシュといっても、SHA-1やMD5のようなビット列を出力する必要はなく、要素が同じなら同じ結果が得られ、かつ衝突が発生しなければそれでよいので、単純に要素を文字列化してしまえば事足ります。&lt;/p&gt;

&lt;p&gt;たとえば、構文番号1、&lt;code&gt;.&lt;/code&gt;の位置が左から2番目、先読み記号が&lt;code&gt;[$,x]&lt;/code&gt;のClosureItemなら、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;quot;1,2,[$,x]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような文字列を出力すれば目的は果たせます。
ClosureItemの集合であるClosureSetの場合は、まず自身の持っているClosureItemを、このハッシュ文字列を使ってソートした上で、以下のような文字列を生成します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;quot;1,2,[$,x]|2,3,[$]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ClosureItemが常にソートされていると仮定したならば、こちらも同一性の判定に用いることができます。&lt;/p&gt;

&lt;p&gt;ただしこの場合、ひとつだけ問題が生じます。
もし上記の&lt;code&gt;x&lt;/code&gt;のかわりに、&lt;code&gt;x]|2,2,[y&lt;/code&gt;という名前の終端記号があったとすると、さきほどのClosureSetのハッシュ文字列は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;quot;1,2,[$,x]|2,2,[y]|2,3,[$]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となってしまい、&lt;code&gt;2,2,[y]&lt;/code&gt;というClosureItemが存在した時に衝突が発生してしまう可能性があります。
これを防ぐため、先ほどのSyntaxDBを用いて、それぞれの終端記号を個別の数値に直してしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;quot;1,2,[0,1]&amp;quot;
&amp;quot;1,2,[0,1]|2,3,[1]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにすることで、危険性は回避できます。&lt;/p&gt;

&lt;p&gt;また、LALR(1)法のDFAマージの際に、先読み記号を除いた部分が一致しているかどうか調べる必要もあるため、ハッシュ文字列は先読み部分を除いたLR(0)ハッシュと、先読み部分も含めたLR(1)ハッシュの2種類を用意しておきます。&lt;/p&gt;

&lt;h4 id=&#34;closureitemおよびclosuresetのconst性&#34;&gt;ClosureItemおよびClosureSetのconst性&lt;/h4&gt;

&lt;p&gt;ハッシュの再生成や、それに伴うClosureSetのソート処理を回避するため、ClosureItemおよびClosureSetは、初期化終了後は自身の状態を変化させることがないようにします。&lt;/p&gt;

&lt;p&gt;たとえば、クロージャー展開を行うとClosureSetの中身は変化しますが、この処理はコンストラクタ呼び出し時に行うようにすることで、オブジェクトの初期化が終了した時点でクロージャー展開は終わっており、それ以降ClosureSetの状態が変化することはありません。
また、ClosureSetおよびClosureItemは、LR(0)部分(先読み部分を除いた部分)が同じなら先読み記号をマージするmergeメソッドを持っていますが、このメソッドもそのオブジェクト自身の状態を変更するのではなく、新しいオブジェクトを生成してそれを返すようにしています。&lt;/p&gt;

&lt;h2 id=&#34;dfaの構築&#34;&gt;DFAの構築&lt;/h2&gt;

&lt;p&gt;アイテム集合を扱えるようになったため、次はDFAの構築です。
DFAGeneratorクラスを作っていきます。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/dfagenerator.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/dfagenerator.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// dfagenerator.d.ts
export declare type DFAEdge = Map&amp;lt;Token, number&amp;gt;;
export declare type DFANode = {
    closure: ClosureSet;
    edge: DFAEdge;
};
export declare type DFA = Array&amp;lt;DFANode&amp;gt;;
export declare class DFAGenerator {
    private syntax;
    private lr_dfa;
    private lalr_dfa;
    constructor(syntax: SyntaxDB);
    getLR1DFA(): DFA;
    getLALR1DFA(): DFA;
    private generateNewClosureSets(closureset);
    private indexOfDuplicatedNode(dfa, new_node);
    private generateDFA();
    private mergeLA(dfa);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とはいえ、やるべきことはDFAの構築処理、およびLALR(1)法のDFAを生成するためのマージ処理のみです。&lt;/p&gt;

&lt;p&gt;DFAは、DFANodeの配列として表現します。
DFANodeは、一つのClosureSetとDFAEdgeを持ちます。
DFAEdgeはトークンをキーとしてDFANodeのインデックスを持つMapであり、これはトークンをラベルとして他のDFANodeに向けて張られた辺の情報を意味します。&lt;/p&gt;

&lt;p&gt;前回紹介したアルゴリズムをそのままコードにするだけなので、DFAの構築処理は特に解説する点はありません。&lt;/p&gt;

&lt;h2 id=&#34;構文解析表の構築&#34;&gt;構文解析表の構築&lt;/h2&gt;

&lt;p&gt;構文解析表と、それに必要な四種類の命令群を定義しておきます。
また、コンフリクトが発生したことを表す命令も定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// parsingtable.ts
export type ShiftOperation = {type: &amp;quot;shift&amp;quot;, to: number};
export type ReduceOperation = {type: &amp;quot;reduce&amp;quot;, syntax: number};
export type ConflictedOperation = {type: &amp;quot;conflict&amp;quot;, shift_to:Array&amp;lt;number&amp;gt;, reduce_syntax:Array&amp;lt;number&amp;gt;};
export type AcceptOperation = {type: &amp;quot;accept&amp;quot;};
export type GotoOperation = {type : &amp;quot;goto&amp;quot;, to: number};
export type ParsingOperation = ShiftOperation|ReduceOperation|ConflictedOperation|AcceptOperation|GotoOperation;
export type ParsingTable = Array&amp;lt;Map&amp;lt;Token, ParsingOperation&amp;gt;&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;構文解析表の構築処理は、ParserGeneratorクラスのメソッドとして実装します。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/parsergenerator.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/parsergenerator.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// parsergenerator.d.ts
export declare class ParserGenerator {
    private grammar;
    private parsing_table;
    private syntax;
    private dfa_generator;
    constructor(grammar: GrammarDefinition);
    init(): void;
    getParser(default_callback?: ParserCallback): Parser;
    getParsingTable(): ParsingTable;
    private generateParsingTable(dfa);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これも前回紹介したアルゴリズムの通り、DFAを読み取って適切な命令を配置していくだけです。
ParserGeneratorクラスは、初期化時にSyntaxDBおよびDFAGeneratorのインスタンスを生成し、DFAGeneratorから得られたDFAをもとに構文解析表の生成を行います。&lt;/p&gt;

&lt;p&gt;ここまでで構文解析表の構築まで終了したので、パーサジェネレータはほぼ完成となります。
あとは、この構文解析表を読み取ることのできるパーサの実装が必要です。
次回はパーサの実装を行いますが、そのパーサの動作等についても前回の記事である程度解説しているため、やはり実装中心となります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回:かんたん構文解析入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;前回:かんたんLR(1)法入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-06/&#34;&gt;次回:パーサの実装と構文解析の実行&lt;/a&gt;&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第4回:かんたんLR(1)法入門</title>
      <link>http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/</link>
      <pubDate>Wed, 22 Mar 2017 15:58:04 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/</guid>
      <description>
        &lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;前回&lt;/a&gt;で構文解析器を生成する際に必要となる準備を済ませたため、LR(1)法ベースのパーサジェネレータを作る用意が整いました。
ですが相変わらず本題のパーサジェネレータ作成には入らず、まずはLR(1)法のおおまかな理論的概略の紹介を行います。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回&lt;/a&gt;では構文解析全体の流れを解説しましたが、実際にどのような過程でパーサを、またパーサジェネレータを作成するかについては触れませんでした。
今回は、LR法による構文解析の流れを解説するとともに、これからどのような流れでパーサジェネレータを作成していくのかを紹介します。
今回は解説のみのためソースコードが載りません。&lt;/p&gt;

&lt;h2 id=&#34;lr-1-構文解析の流れ&#34;&gt;LR(1)構文解析の流れ&lt;/h2&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;字句規則を用意して字句解析器にかけてトークン列を取得したあと構文規則をもとにFIRST関数とFOLLOW関数を求め、それをもとにgotoグラフを導出することによってLR表を作成して、構築したLRパーサでトークン列を解析して得た抽象構文木を処理すれば構文解析ができると知ったわたし &lt;a href=&#34;https://t.co/aIbxqSf5qj&#34;&gt;pic.twitter.com/aIbxqSf5qj&lt;/a&gt;&lt;/p&gt;&amp;mdash; たたも (@&lt;strong&gt;tatamo&lt;/strong&gt;) &lt;a href=&#34;https://twitter.com/__tatamo__/status/798837425313189888&#34;&gt;2016年11月16日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;FOLLOW関数はSLR法などで使用する概念のため、LR(1)法を用いる今回の記事では用いません。忘れてください。&lt;/p&gt;

&lt;p&gt;LR構文解析の流れは、以下の通りとなります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;First関数を求める&lt;/li&gt;
&lt;li&gt;アイテム集合およびDFA(gotoグラフ)を作成する&lt;/li&gt;
&lt;li&gt;(LALR法のみ)DFAの先読み部分をマージし、より状態数が少なく軽量なDFAにする&lt;/li&gt;
&lt;li&gt;DFAをもとに構文解析表(LR表)を構築する&lt;/li&gt;
&lt;li&gt;構文解析表を実行できるパーサを作成する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1.のFirst関数については、&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;前回&lt;/a&gt;の記事で紹介を済ませているため割愛します。&lt;br /&gt;
LALR法のLR(1)法との相違点は3.のみで、他はLR(1)法と全く同じ処理を行います。&lt;/p&gt;

&lt;p&gt;パーサジェネレータを作成して解析する構文を自由に決定できるようにする場合、4.の構文解析表までを与えられた構文に合わせて自動的に生成できるようにします。&lt;/p&gt;

&lt;h2 id=&#34;アイテム集合とdfa&#34;&gt;アイテム集合とDFA&lt;/h2&gt;

&lt;p&gt;LR法による構文解析のためには、DFA(決定性有限オートマトン)の作成を行う必要があります。&lt;/p&gt;

&lt;p&gt;LR法によって作られるDFAは、それぞれの状態(ノード)に、アイテム集合と呼ばれる情報と、他の状態への遷移ルールを示すトークンをラベルとした辺情報とを持ちます。
このLRアイテム集合は、構文解析表やDFA自身の構築のために必要な情報として使用されます。&lt;/p&gt;

&lt;p&gt;アイテム集合は、文字通りアイテム(便宜的にLRアイテムと呼称します)からなる集合です。&lt;/p&gt;

&lt;h3 id=&#34;lrアイテム&#34;&gt;LRアイテム&lt;/h3&gt;

&lt;p&gt;個別のLRアイテムは、以下のようなものです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;X -&amp;gt; A . B C [x,y,$]
Xは非終端記号
A,B,Cは終端記号または非終端記号
x,yは終端記号
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一見すると&lt;code&gt;X -&amp;gt; A B C&lt;/code&gt;のような構文規則のルールのように見えますが、相違点があります。&lt;/p&gt;

&lt;p&gt;まず、規則の右辺に&lt;code&gt;.&lt;/code&gt;という記号が存在します。
これは終端記号でも非終端記号でもなく、「現在この部分まで解析した」ということを示すマーカーです。
上記の場合、&lt;code&gt;X&lt;/code&gt;という記号の解析の途中で既に&lt;code&gt;A&lt;/code&gt;を読み終え、次は&lt;code&gt;B C&lt;/code&gt;が与えられることが期待されているということを意味します。&lt;/p&gt;

&lt;p&gt;次に、規則の右辺のさらに右に、&lt;code&gt;[x,y,$]&lt;/code&gt;という表記が存在します。
これはLR(1)法の(1)先読みのために用いる先読み記号の集合を表しています。
解析が進んで&lt;code&gt;X&lt;/code&gt;の解析が終わった場合、つまり&lt;code&gt;.&lt;/code&gt;の位置が右端まで移動した場合、その次には&lt;code&gt;x&lt;/code&gt;,&lt;code&gt;y&lt;/code&gt;,&lt;code&gt;$&lt;/code&gt;のいずれかの記号が来ることを意味します。
先読み記号は常に終端記号であることに注意してください。
また、&lt;code&gt;$&lt;/code&gt;は「入力の終わり」を表す記号で、これは便宜的に終端記号として扱います(&lt;a href=&#34;http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/&#34;&gt;第2回&lt;/a&gt;で内部的に追加したSymbol(EOF)トークンのことです)。&lt;/p&gt;

&lt;h3 id=&#34;dfaの構築&#34;&gt;DFAの構築&lt;/h3&gt;

&lt;p&gt;まず、DFAを最初の状態で初期化します。
このとき、DFAのノード数は一つのみであり、そのノードは、以下のようなLRアイテム一つのみを要素とするアイテム集合を持ちます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S&#39; -&amp;gt; . S [$]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただし、&lt;code&gt;S&lt;/code&gt;は開始記号であり、&lt;code&gt;S&#39;&lt;/code&gt;は便宜的に追加した新しい非終端記号です。
便宜的には、&lt;code&gt;S&#39;&lt;/code&gt;について以下の規則が成り立つこととみなします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S&#39; -&amp;gt; S $
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを自己展開させることによって、構文解析のためのDFAを構築していきます。&lt;/p&gt;

&lt;h4 id=&#34;クロージャー展開&#34;&gt;クロージャー展開&lt;/h4&gt;

&lt;p&gt;まず、初期化時点で存在するこのDFAノードは、まだ完全な状態にはなっていません。
一定のルールに従い、アイテム集合を「クロージャー展開」する必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;X -&amp;gt; α . Y β [x]
X,Yは非終端記号(X=Yであってもよい)
xは終端記号
α,βは任意の長さの終端記号または非終端記号の列
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というLRアイテムが存在する場合、&lt;code&gt;Y&lt;/code&gt;を左辺として&lt;code&gt;.&lt;/code&gt;が右辺の左端にあるような新しいLRアイテムを、アイテムセットに追加します。
ただし、先読み記号はFirst(βx)で得られる記号全てとします。
つまり、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;Y -&amp;gt; γ
γは任意の長さの終端記号または非終端記号の列
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような規則があった場合、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;Y -&amp;gt; . γ [First(βx)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というLRアイテムを新しく追加します。&lt;/p&gt;

&lt;p&gt;これを、新しいアイテムが追加されなくなるまで繰り返します。&lt;/p&gt;

&lt;p&gt;具体的に見て行きましょう。
以下の規則を仮定します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S -&amp;gt; 0
S -&amp;gt; X 1
X -&amp;gt; 0
Sは開始記号
S,Xは非終端記号
0,1は終端記号
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、開始記号は&lt;code&gt;S&lt;/code&gt;なので、最初のLRアイテムは以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S&#39; -&amp;gt; . S [$]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.&lt;/code&gt;の次にある&lt;code&gt;S&lt;/code&gt;を展開します。
先読み記号は&lt;code&gt;First($)=[$]&lt;/code&gt;です。
以下のアイテムを追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S -&amp;gt; . 0 [$]
S -&amp;gt; . X 1 [$]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに、新しく追加されたアイテムにも同様の処理を行うと、&lt;code&gt;.&lt;/code&gt;の次に&lt;code&gt;X&lt;/code&gt;があるため、これを展開します。
&lt;code&gt;0&lt;/code&gt;は終端記号のため、展開は行いません。
先読み記号は、&lt;code&gt;First(1$)=[1]&lt;/code&gt;です(First関数は終端記号の列の左端の記号を得るので、ここでは&lt;code&gt;1&lt;/code&gt;のみとなります)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;X -&amp;gt; . 0 [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上の規則では&lt;code&gt;0&lt;/code&gt;は終端記号のため、ここで展開は終了します。&lt;/p&gt;

&lt;p&gt;結果として、最初のDFAノードの持つアイテム集合は以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S&#39; -&amp;gt; . S [$]
S -&amp;gt; . 0 [$]
S -&amp;gt; . X 1 [$]
X -&amp;gt; . 0 [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上がクロージャー展開の処理です。
こうして展開したアイテム集合をもとに、新しいDFAノードを生成していきます。&lt;/p&gt;

&lt;h4 id=&#34;新しいdfaノードの生成&#34;&gt;新しいDFAノードの生成&lt;/h4&gt;

&lt;p&gt;クロージャー展開が完了したアイテム集合から、一定のルールのもとで新しいDFAノードを生成します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;X -&amp;gt; α . A β [x]
Xは非終端記号
Aは終端記号または非終端記号(X=Aであってもよい)
xは終端記号
α,βは任意の長さの終端記号または非終端記号の列
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というLRアイテムが存在する場合、以下の新しいLRアイテムを生成します(そのDFAノードのアイテムセットには追加しません)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;X -&amp;gt; α A . β [x]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そのDFAノードの持つ全てのLRアイテムについてこの処理が終わったら、&lt;code&gt;.&lt;/code&gt;の左隣の記号、つまり&lt;code&gt;A&lt;/code&gt;の位置の記号ごとに新しいアイテム集合を作り、それを情報としてもつ新しいDFAノードを生成します。
そして既存のDFAノードから、&lt;code&gt;A&lt;/code&gt;をラベルとして新しいノードに対して辺を張ります。&lt;/p&gt;

&lt;p&gt;具体的には、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S&#39; -&amp;gt; . S [$]
S -&amp;gt; . 0 [$]
S -&amp;gt; . X 1 [$]
X -&amp;gt; . 0 [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というアイテム集合を持つDFAからは、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S&#39; -&amp;gt; S . [$]
S -&amp;gt; 0 . [$]
S -&amp;gt; X . 1 [$]
X -&amp;gt; 0 . [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という4つのLRアイテムが生成され、これは以下の3つに分けられます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;1. ラベル: S
S&#39; -&amp;gt; S . [$]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;2. ラベル: 0
S -&amp;gt; 0 . [$]
X -&amp;gt; 0 . [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;3. ラベル: X
S -&amp;gt; X . 1 [$]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このようにして新しく3つのDFAノードを生成し、もとのノードからそれぞれの記号をラベルとした辺を張ります。
あとは、新しいノード全てについて、同様にクロージャー展開を行い、さらに新しいDFAノードを生成していきます。
ただし、その過程で既存のノードと全く同じアイテム集合を持つDFAノードが作られた場合は、新しいノードとしてそこに辺を張るのではなく、かわりに重複する既存のノードに対して辺を張るものとします。&lt;/p&gt;

&lt;p&gt;この処理を繰り返し、DFAノードが新しく生成されなくなればDFAの構築は終了です。&lt;/p&gt;

&lt;h4 id=&#34;lalr法のみ-先読み部分のマージ&#34;&gt;(LALR法のみ)先読み部分のマージ&lt;/h4&gt;

&lt;p&gt;LALR法では、この時点でDFAのサイズ縮小を行います。
そのアルゴリズムは、以下の通りです。&lt;/p&gt;

&lt;p&gt;まず、DFAの持つアイテム集合から、それぞれのLRアイテムの先読み部分のみを除いた場合に、全く同じアイテム集合を持つようなDFAノードの組を見つけます。
そして、そのようなDFAノードの組において、LRアイテムの先読み部分をそれぞれの和集合とするような新しいDFAノードを作り、それらのノードに対して辺を張っていたノードがあれば、その辺を新しいノードに対して張り直します。&lt;/p&gt;

&lt;p&gt;具体的に、以下のようなアイテム集合を持つ2つのDFAノードを考えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;DFAノードA:
X -&amp;gt; .Y Z [x]
Y -&amp;gt; .V W [x,y]

DFAノードB:
X -&amp;gt; .Y Z [z]
Y -&amp;gt; .V W [y,z]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この2つのDFAノードは、先読み部分を除けば一致しているため、マージして次のDFAノードCを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;DFAノードC:
X -&amp;gt; .Y Z [x,z]
Y -&amp;gt; .V W [x,y,z]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、DFAノードAまたはBに対して辺を張っているDFAノードが存在するならば、それらの辺をDFAノードCに向けたものに書き換えます。&lt;/p&gt;

&lt;h2 id=&#34;構文解析表と構文解析器&#34;&gt;構文解析表と構文解析器&lt;/h2&gt;

&lt;p&gt;DFAが完成したら、それをもとにして構文解析表を生成していきます。
構文解析表はそれ自体がステートマシンの動作仕様を表すものであり、構文解析表が完成してしまえば、それに沿ってステートマシンを動作させることで構文解析が可能となります。&lt;/p&gt;

&lt;h3 id=&#34;構文解析を行うステートマシン&#34;&gt;構文解析を行うステートマシン&lt;/h3&gt;

&lt;p&gt;構文解析表には、ステートマシンの現在の状態、および次の入力に応じて、4種類の命令のいずれかが記述されます。
構文解析を行うステートマシンは、現在の状態を示すスタックと、構文解析の結果を保持するスタックの2つのスタックを持ちます。
また、入力を一文字だけ確認するか、入力を消費して一文字先に進めることができます。
(この仕様自体は変更の余地があります。)&lt;/p&gt;

&lt;p&gt;ステートマシンは、構文解析表から(状態スタックの一番上にある状態, 現在見ている入力)の命令を実行します。
最初は(初期状態, 一文字目の入力)となります。&lt;/p&gt;

&lt;p&gt;以下に、4つのそれぞれの命令の説明を記します。
とはいえ、ステートマシンの仕様なんざ読んでいて動きが分かるわけもなく楽しくも何ともないため、参考資料の&lt;a href=&#34;http://www.slideshare.net/ichikaz3/lr-parsing&#34;&gt;LR parsing&lt;/a&gt;のスライドを確認していただくことをおすすめします。
ステートマシンの動きを視覚的に追いかけることができて非常にわかりやすいです。&lt;/p&gt;

&lt;h4 id=&#34;shift命令&#34;&gt;shift命令&lt;/h4&gt;

&lt;p&gt;shift命令を受けると、ステートマシンは入力を一つ消費します。
shift命令には状態番号が付与されているので、ステートマシンは状態スタックにその数値を追加します。&lt;/p&gt;

&lt;h4 id=&#34;reduce命令&#34;&gt;reduce命令&lt;/h4&gt;

&lt;p&gt;reduce命令は文法idが付与されています。
ステートマシンがreduce命令を受けると、示された文法規則を確認し、その右辺の記号の数だけ状態スタックからポップして取り除きます。
さらに、結果スタックからも右辺の記号の数だけ取り除き、取り除いた結果すべてを現在見ている規則の左辺の記号を親とする木構造の子にして、そうしてできた木を結果スタックに追加します(または、取り除いた結果および文法idを引数として何らかのプログラムを実行し、その結果をスタックに追加する場合もあります)。&lt;/p&gt;

&lt;p&gt;そしてその処理の終了後、構文解析表の(状態スタックの一番上にある状態、規則の左辺の記号)の位置にあるgoto命令を実行させます。&lt;/p&gt;

&lt;h4 id=&#34;goto命令&#34;&gt;goto命令&lt;/h4&gt;

&lt;p&gt;goto命令は、reduce命令の直後に実行されることが期待されます。
goto命令には状態番号が付与されているので、ステートマシンは状態スタックにその数値を追加します。
shift命令と異なり、入力の消費は行いません。&lt;/p&gt;

&lt;h4 id=&#34;accept命令&#34;&gt;accept命令&lt;/h4&gt;

&lt;p&gt;ステートマシンがaccept命令を受けると、それは構文解析が終了したことを意味します。
理想的な入力が与えられた場合、入力は全て消費され、結果スタックには最終的な構文解析結果のみが入っていることが期待されます。&lt;/p&gt;

&lt;h3 id=&#34;構文解析器&#34;&gt;構文解析器&lt;/h3&gt;

&lt;p&gt;構文解析器は、上記の仕様をなぞって構文解析表を読み取ることのできるステートマシンそのものです。
よって、構文解析表さえ個々の構文にあわせて生成することができれば、それを構文解析器に与えることによってさまざまな構文の解析が可能になります。&lt;/p&gt;

&lt;h3 id=&#34;構文解析表の構築&#34;&gt;構文解析表の構築&lt;/h3&gt;

&lt;p&gt;完成したDFAをもとにして、構文解析表を生成することができます。&lt;/p&gt;

&lt;h4 id=&#34;shiftおよびgotoオペレーションの登録&#34;&gt;shiftおよびgotoオペレーションの登録&lt;/h4&gt;

&lt;p&gt;それぞれのDFAノードは、ステートマシンの状態と対応しています。
簡単のため、個々のDFAノードには一意なid(ステートマシンの状態番号)が割り振られているものとします。
すべてのDFAノードについて、そのノードから張られている辺を参照します。&lt;/p&gt;

&lt;p&gt;その辺のラベルの記号が終端記号であるならば、構文解析表の(そのDFAノードのid, ラベルの記号)の部分にshift命令を書き込み、その辺の向かう対象となるDFAノードのidを付与します。&lt;/p&gt;

&lt;p&gt;その辺のラベルの記号が非終端記号であるならば、同様にしてgoto命令を書き込みます。&lt;/p&gt;

&lt;h4 id=&#34;acceptおよびreduceオペレーションの登録&#34;&gt;acceptおよびreduceオペレーションの登録&lt;/h4&gt;

&lt;p&gt;すべてのDFAノードについて、そのアイテム集合の持つLRアイテム一つ一つを確認していきます。
もしも&lt;code&gt;.&lt;/code&gt;の位置が右辺の末尾にある場合、そのLRアイテムの持つ先読み記号それぞれについて、以下の処理を行います。&lt;/p&gt;

&lt;p&gt;構文解析表の(そのDFAノードのid, 先読み記号)の部分にreduce命令を書き込み、そのLRアイテムのもととなっている規則のidを付与。&lt;/p&gt;

&lt;p&gt;ただし、その規則が&lt;code&gt;S&#39;&lt;/code&gt;に対応するものであった場合、かわりにaccept命令を書き込みます。&lt;/p&gt;

&lt;h4 id=&#34;shift-reduceコンフリクト&#34;&gt;shift/reduceコンフリクト&lt;/h4&gt;

&lt;p&gt;shiftオペレーションおよびreduceオペレーションは、表の同じ位置に競合して書き込まれてしまうことがあります。
このような状況を、shift/reduceコンフリクトと呼びます。
なお、shift/reduceコンフリクトだけでなく、reduce/reduceコンフリクト、複数回競合しあった3つ以上の命令のコンフリクト等も発生する可能性があります(shift/shiftコンフリクトも発生する可能性があると聞きましたが、上記のアルゴリズムでshiftを登録している場合はDFAが壊れていない限り発生し得ない気がします)。&lt;/p&gt;

&lt;p&gt;コンフリクトが発生してしまった場合の対処法は、大きく分けて二種類存在します。&lt;/p&gt;

&lt;p&gt;まずひとつは、諦めることです。
コンフリクトが発生した時点でそれはLR(1)文法を逸脱しているため、もともと解析可能な構文ではありません。
構文規則を等価になるようにいろいろ書き換えるとうまくコンフリクトが消せる(かもしれない)ので、与える構文の見直しをします。&lt;/p&gt;

&lt;p&gt;もうひとつは、規則ごとにオペレーションの優先度を設定し、コンフリクトが発生した場合は強制的にどちらかの命令を実行すると決めてしまうことです。
これは一般的に行われている方法であり、かなり乱暴ですが大抵の場合はまあなんとかなります。&lt;/p&gt;

&lt;h2 id=&#34;参考資料&#34;&gt;参考資料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回&lt;/a&gt;で紹介したものを今回もそのまま参考資料としているため、基本的にはそちらをご覧ください。
今回紹介した内容の理解を深めるのに特に役立つと思われるおすすめの資料を抜粋しておきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.cornell.edu/courses/cs412/2003sp/lectures/lec09.pdf&#34;&gt;Cornell CIS Introduction to Compilers Lecture 9: LR(1) Parsing&lt;/a&gt;&lt;br /&gt;
LR(1) DFA、クロージャー展開、構文解析表等について詳細な定義や図解等が記載されています。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/ichikaz3/lr-parsing&#34;&gt;LR parsing&lt;/a&gt;&lt;br /&gt;
クロージャー展開やDFAの構築、実際のステートマシンの動きに至るまで実際の動作過程を見ることができます。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;今回でおおまかなLR(1)構文解析器作りの解説を済ませたので、次回からは実装をしていくだけです。
誰も他人のソースコードの解説なんて読む気は起きないでしょうし、これ以上続ける意味があるのか大いに疑問ではあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回:かんたん構文解析入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;前回:儀式の下準備&lt;/a&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-05/&#34;&gt;次回:LR(1)パーサジェネレータの実装&lt;/a&gt;&lt;/p&gt;
      </description>
    </item>
    
  </channel>
</rss>