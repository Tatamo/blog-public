<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>わたしろぐ</title>
    <link>http://tatamo.81.la/blog/</link>
    <description>Recent content on わたしろぐ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sat, 11 Feb 2017 18:13:48 +0900</lastBuildDate>
    <atom:link href="http://tatamo.81.la/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第2回:字句解析器の実装</title>
      <link>http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/</link>
      <pubDate>Sat, 11 Feb 2017 18:13:48 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/</guid>
      <description>
        

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;前回&lt;/a&gt;は構文解析の概略を紹介したので、今回から実装に移っていきたいと思います。
まずは字句解析器を用意する必要があるため、今回は字句解析器の作成について紹介します。&lt;/p&gt;

&lt;p&gt;なお今回から実際のプログラムを記述していきますが、使用言語はTypeScriptとします。&lt;/p&gt;

&lt;p&gt;パーサジェネレータを作るのに比べれば字句解析器を作るのは非常に単純です。
早速はじめていきましょう。&lt;/p&gt;

&lt;h2 id=&#34;字句解析器の仕様を確認する:33ced0e1bdc35ac00ed380cf2d7265fa&#34;&gt;字句解析器の仕様を確認する&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;前回&lt;/a&gt;の記事でも紹介しましたが、字句解析器の行う処理は以下のような流れになります。&lt;/p&gt;

&lt;p&gt;まず、解析するべき入力を文字列として受け取ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;9 + 11 * (2 + 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに加えて、字句規則を用意します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;数字: /[1-9][0-9]*/
プラス: &amp;quot;+&amp;quot;
アステリスク: &amp;quot;*&amp;quot;
左括弧: &amp;quot;(&amp;quot;
右括弧: &amp;quot;)&amp;quot;
(読み捨て): /\s/
(不正): /./
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字句解析器は受け取った入力を先頭から順に字句規則にあてはめ、マッチするものがあればそのトークンを割り当てます。
結果として得られる出力は、以下のようなリストになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;数字: 9
プラス: +
数字: 11
アステリスク: *
左括弧: (
数字: 2
プラス: +
数字: 1
右括弧: )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得られたトークンのリストを構文解析器の入力として渡すことで、構文解析器は文法の解析のみに注力することができます。&lt;/p&gt;

&lt;h2 id=&#34;字句規則を定義する:33ced0e1bdc35ac00ed380cf2d7265fa&#34;&gt;字句規則を定義する&lt;/h2&gt;

&lt;p&gt;実際に解析を行うタイミングでは文字列のみを入力として受け取りますが、字句解析器の生成時には字句規則が必要です。
そのため、予め字句規則を別の設定ファイルなどに書いておくなどして用意しておかなければなりません。
ただし、&lt;strong&gt;字句規則の解析には構文解析器が必要&lt;/strong&gt;となるため、現時点ではプログラム内にハードコーディングしておくなどする必要があります。
今回は、字句規則を内部的に以下のようなデータ構造で扱うこととして、しばらくは字句規則をその内部データの形式で直接書くことにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;// 定義
export type Token = string|symbol;
export interface LexDefinitionSection{
	token: Token|null;
	pattern: string|RegExp;
}
export type LexDefinitions = Array&amp;lt;LexDefinitionSection&amp;gt;;

// 実際の字句規則
const lex: LexDefinitions = [
	{token:&amp;quot;NUMBER&amp;quot;, pattern:/[1-9][0-9]*/},
	{token:&amp;quot;PLUS&amp;quot;, pattern:&amp;quot;+&amp;quot;},
	{token:&amp;quot;ASTERISK&amp;quot;, pattern:&amp;quot;*&amp;quot;},
	{token:&amp;quot;LPAREN&amp;quot;, pattern:&amp;quot;(&amp;quot;},
	{token:&amp;quot;RPAREN&amp;quot;, pattern:&amp;quot;)&amp;quot;},
	{token:null, pattern:/\s/},
	{token:&amp;quot;INVALID&amp;quot;, pattern:/./},
];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この字句規則の定義について、実用上の理由で追加したいくつかの仕様に注意する必要があります。&lt;/p&gt;

&lt;p&gt;Tokenの型定義にsymbolを含めている点についてはここで説明せずに後述することとします。&lt;/p&gt;

&lt;h3 id=&#34;入力の読み捨て:33ced0e1bdc35ac00ed380cf2d7265fa&#34;&gt;入力の読み捨て&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;{token:null, pattern:/\s/}
// (読み捨て): /\s/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この部分は、何らかの空白文字が入力に存在していればマッチングされます。
&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; を解析する際、ここに含まれている空白は文法上何の意味も持たず、&lt;code&gt;9+11*(2+1)&lt;/code&gt; のように入力が与えられたとしても解析結果は変化しません。
このような場合、構文解析器に空白の情報を与えることすらせずに、字句解析器上で空白を検知した段階でその情報を捨ててしまったほうが、構文解析器に余計な処理をさせずに済みます。&lt;/p&gt;

&lt;p&gt;今回は、トークンのラベル部分にnullを指定することで、読み取った結果をトークンとして保持することなく読み捨てることを表すようにしています。&lt;/p&gt;

&lt;h3 id=&#34;正規表現パターンと文字列パターンの使い分け:33ced0e1bdc35ac00ed380cf2d7265fa&#34;&gt;正規表現パターンと文字列パターンの使い分け&lt;/h3&gt;

&lt;p&gt;(ごちゃごちゃ書いている割に小手先のテクニックという感じが強いため、よくわからなければ読み飛ばしてください)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{token:&amp;quot;PLUS&amp;quot;, pattern:&amp;quot;+&amp;quot;}&lt;/code&gt; のように、パターン部分に正規表現ではなく文字列を用いて記述している箇所があります。
すべて正規表現を使って記述するのではなく文字列も許容している理由として、まず&lt;code&gt;/\+/&lt;/code&gt;のように特殊記号をエスケープせずに済む点が挙げられます。
そして、「文字列でパターンを記述した場合は、アルファベットの途中でトークンを区切らないようにする」というルールを用いることで、一部のパターンを簡潔に書くことが可能になります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vwxyz&lt;/code&gt; という入力を考えてみましょう。
ここでもし、&lt;code&gt;&amp;quot;vwx&amp;quot;&lt;/code&gt; にマッチする規則と、&lt;code&gt;&amp;quot;vwxyz&amp;quot;&lt;/code&gt; にマッチする規則の2つが存在した場合、&lt;code&gt;&amp;quot;vwxyz&amp;quot;&lt;/code&gt; の規則を先に書かない限り、入力&lt;code&gt;vwxyz&lt;/code&gt; は&lt;code&gt;&amp;quot;vwx&amp;quot; + yz&lt;/code&gt; とみなされ、&lt;code&gt;&amp;quot;yz&amp;quot;&lt;/code&gt; に対応する規則が存在しなければエラーとなります。
これを回避するためには、よりマッチするパターンが長い規則を常に短い規則よりも先に書くようにする必要がありますが、面倒です。
そこで、正規表現ではなく文字列で&lt;code&gt;&amp;quot;vwx&amp;quot;&lt;/code&gt; などのパターンが定義され、かつその末尾の文字が&lt;code&gt;\w&lt;/code&gt; にマッチする場合、マッチした部分の一文字先の文字が&lt;code&gt;\w&lt;/code&gt; 以外でなければマッチしないようにします。
これは、正規表現で&lt;code&gt;/vwx(?!\w)/&lt;/code&gt; 、&lt;code&gt;/vwxyz(?!\w)/&lt;/code&gt; というような否定的前方先読みをパターンの最後に追加することに相当します。
このルールを追加することで、正規表現を用いる場合よりも簡潔に記述可能となります。&lt;/p&gt;

&lt;h2 id=&#34;字句解析器を実装する:33ced0e1bdc35ac00ed380cf2d7265fa&#34;&gt;字句解析器を実装する&lt;/h2&gt;

&lt;p&gt;ではLexerクラスを作っていきましょう。
とはいえ字句規則さえ定義してしまえば、やることはほとんどありません。
コンストラクタ引数として字句規則データを受け取って保持しておくようにして、解析実行時に上から順に字句規則のマッチングを試みるだけです。&lt;/p&gt;

&lt;p&gt;今回はコード量が少ないので、 &lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/lexer.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/lexer.ts&lt;/a&gt; 全体をそのまま貼り付けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/// token.ts
export type Token = string|symbol;
export const SYMBOL_EOF:Token = Symbol(&amp;quot;EOF&amp;quot;);
export const SYMBOL_SYNTAX:Token = Symbol(&amp;quot;S&#39;&amp;quot;);
export const SYMBOL_DOT:Token = Symbol(&amp;quot;.&amp;quot;);

export type TokenList = Array&amp;lt;{token:Token, value:string}&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/// lexer.ts
/// LexDefinitionsの定義は先述のものと同一
import {Token, SYMBOL_EOF, TokenList} from &amp;quot;./token&amp;quot;;
import {LexDefinitions} from &amp;quot;./grammar&amp;quot;;

export interface ILexer{
	exec(str: string):TokenList;
}

export class Lexer implements ILexer{
	constructor(public def: LexDefinitions){
		// 正しいトークン定義が与えられているかチェック
		for(var i=0; i&amp;lt;this.def.length; i++){
			var token_pattern = this.def[i].pattern;
			if(typeof token_pattern == &amp;quot;string&amp;quot;){
				continue;
			}
			else if(token_pattern instanceof RegExp){
				// フラグを整形する
				let flags:string = &amp;quot;&amp;quot;;
				// gフラグは邪魔なので取り除く
				// i,m,uフラグがあれば維持する
				if(token_pattern.ignoreCase){
					flags += &amp;quot;i&amp;quot;;
				}
				if(token_pattern.multiline){
					flags += &amp;quot;m&amp;quot;;
				}
				if(token_pattern.unicode){
					flags += &amp;quot;u&amp;quot;;
				}
				// yフラグは必ずつける
				flags += &amp;quot;y&amp;quot;;
				// フラグをつけなおして新しい正規表現オブジェクトにする
				this.def[i].pattern = new RegExp(token_pattern, flags);
				continue;
			}
			throw new Error(&amp;quot;invalid token definition: neither string nor RegExp object&amp;quot;);
		}
	}
	exec(str: string):TokenList{
		var result:TokenList = [];
		let lastindex = 0;
		while(lastindex &amp;lt; str.length){
			for(var i=0; i&amp;lt;this.def.length; i++){
				var token:Token|null = this.def[i].token;
				var token_pattern = this.def[i].pattern;
				var match:string;
				if(typeof token_pattern == &amp;quot;string&amp;quot;){
					let last_tmp = lastindex+token_pattern.length;
					if(str.substring(lastindex,last_tmp) != token_pattern) continue;
					if(last_tmp &amp;lt; str.length &amp;amp;&amp;amp; /\w/.test(token_pattern.slice(-1)) &amp;amp;&amp;amp; /\w/.test(str[last_tmp])) continue; // ヒットした文字の末尾が\wで、そのすぐ後ろが\wの場合はスキップ
					match = token_pattern;
					lastindex += token_pattern.length;
				}
				else{
					// token_pattern: RegExp
					token_pattern.lastIndex = lastindex;
					let m = token_pattern.exec(str);
					if(m === null) continue; // マッチ失敗
					match = m[0];
					lastindex = token_pattern.lastIndex; // lastindexを進める
				}
				// tokenがnullなら処理を飛ばします
				if(token != null){
					result.push({token:token, value:match});
				}
				break;
			}
		}
		// 最後にEOFトークンを付与
		result.push({token:SYMBOL_EOF, value:&amp;quot;&amp;quot;});
		return result;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まずコンストラクタでは、与えられた字句規則に簡単な型チェックと正規表現の整形を行っています。
グローバルマッチは今回は邪魔なだけなので、与えられた正規表現にgフラグがついていれば取り除きます。
ES2015でRegExpに追加されたstickyフラグ(&lt;strong&gt;ほぼ&lt;/strong&gt;全ての主要モダンブラウザ上で実装済み)を使うと楽なので、ここでyフラグの追加も行います。&lt;/p&gt;

&lt;p&gt;execメソッドでは入力を読み終えるまでマッチングを繰り返し、&lt;code&gt;{token:Token, value:string}&lt;/code&gt; というオブジェクトを結果の配列に追加していきます。
先述のようにパターンが文字列であれば&lt;code&gt;\w&lt;/code&gt;が連続した場所では区切らないようにして、マッチングが成功するたびにインデックス位置を先に進めていきます。&lt;/p&gt;

&lt;p&gt;また、すべての入力を読み終えた後、最後にSymbol(EOF)を名前としたトークンを結果に追加します。
これは入力の末尾を意味するトークンで、構文解析の際に内部的に使用されます。&lt;/p&gt;

&lt;p&gt;(Symbolは、それ自身と比較しない限り&lt;code&gt;==&lt;/code&gt;や&lt;code&gt;===&lt;/code&gt;の評価結果が常にfalseになるプリミティブ型で、ES2015で追加されたものです。
字句規則で定義されたトークンとの衝突が発生しないようにここでSymbolを使用していますが、Symbolそのものはオブジェクトのプロパティとして使用することで後方互換性を維持することを目的としてJavaScriptに追加された型であるため、この用途で用いるのに適しているのかどうかは議論の余地があります。
とはいえプログラミング言語個別の問題はこの記事の主題とは関係がないため、詳しくは言及しません。)&lt;/p&gt;

&lt;p&gt;この字句解析器に先ほどの字句規則を与え、&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; を入力すると、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;[
	{token:&amp;quot;NUMBER&amp;quot;, value:&amp;quot;9&amp;quot;},
	{token:&amp;quot;PLUS&amp;quot;, value:&amp;quot;+&amp;quot;},
	{token:&amp;quot;NUMBER&amp;quot;, value:&amp;quot;11&amp;quot;},
	{token:&amp;quot;ASTERISK&amp;quot;, value:&amp;quot;*&amp;quot;},
	{token:&amp;quot;LPAREN&amp;quot;, value:&amp;quot;(&amp;quot;},
	{token:&amp;quot;NUMBER&amp;quot;, value:&amp;quot;2&amp;quot;},
	{token:&amp;quot;PLUS&amp;quot;, value:&amp;quot;+&amp;quot;},
	{token:&amp;quot;NUMBER&amp;quot;, value:&amp;quot;1&amp;quot;},
	{token:&amp;quot;RPAREN&amp;quot;, value:&amp;quot;)&amp;quot;},
	{token:Symbol(EOF), value:&amp;quot;&amp;quot;}
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という結果が得られます。
これでトークンの並びを得ることに成功したので、次回以降はいよいよパーサジェネレータの作成に移っていくことになります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;前回:かんたん構文解析入門&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第1回:かんたん構文解析入門</title>
      <link>http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/</link>
      <pubDate>Thu, 22 Dec 2016 03:03:09 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/</guid>
      <description>
        

&lt;p&gt;この記事は&lt;a href=&#34;http://www.adventar.org/calendars/1881&#34;&gt;Kobe University Advent Calendar 2016&lt;/a&gt;の21日の記事です。また遅刻か。
なお私は当該大学の学部2年(2016年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;構文解析ができるプログラマはちょっとかっこいいですよね。
「構文解析？ああ、できますよ」とか言って自分のスキルを自慢できそうな印象があります。&lt;/p&gt;

&lt;p&gt;(ほぼ)フルスクラッチでTypeScriptによるLR(1)パーサジェネレータを実装した(ついでにLALR(1)パーサも作れる)ので、これを完成させるまでの流れを紹介していこうと思います。&lt;/p&gt;

&lt;p&gt;今回は構文解析自体の入門編となります。&lt;/p&gt;

&lt;p&gt;自作したパーサジェネレータは &lt;a href=&#34;https://github.com/Tatamo/parsergenerator&#34;&gt;https://github.com/Tatamo/parsergenerator&lt;/a&gt; にあります。&lt;br /&gt;
今のところパーサジェネレータ部分は完成、基本的な構文解析なら問題なくこなせるので構文規則や字句規則を外部から読み取って構文解析してパーサジェネレータに渡すような処理や、全体の見通しを良くするための設計の見直しやリファクタリング等を行っている段階です。
ドキュメント作ってなくてすみません。&lt;/p&gt;

&lt;h2 id=&#34;構文解析をしたい:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;構文解析をしたい&lt;/h2&gt;

&lt;p&gt;構文解析、時々見かけるフレーズです。
プログラマなら覚えておいて損はない技術……かどうかはわかりませんが、そういう類のスキルに(傍からは)見えます。&lt;br /&gt;
ぜひやりましょう。&lt;/p&gt;

&lt;p&gt;ひとまず、何をやりたいのかを明確にする必要があります。&lt;br /&gt;
この記事では、「入力として与えられるLR(1)文法に属する文法に従ったトークン列をパース(構文解析)することで、その構造を構文木として出力する」ことを目標とします。
何を言っているのかさっぱりわかりませんね、わからなくていいです。&lt;/p&gt;

&lt;p&gt;順を追って説明する必要がありますが、詳細は適宜省略します。
そのため、まずは今回主に参照した資料を列挙しておきます。&lt;/p&gt;

&lt;h2 id=&#34;参考資料一覧:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;参考資料一覧&lt;/h2&gt;

&lt;p&gt;より詳しく知りたい方は、下記に挙げる資料やそこで紹介されている参考文献などを参照されるのが良いと思われます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.cornell.edu/courses/cs412/2003sp/lectures/lec09.pdf&#34;&gt;Cornell CIS Introduction to Compilers Lecture 9: LR(1) Parsing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jaist.ac.jp/~kshirai/lec/i223/04a.pdf&#34;&gt;JAIST 自然言語処理論Ｉ 4.文法2(構文解析) その1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jaist.ac.jp/~kshirai/lec/i223/04b.pdf&#34;&gt;JAIST 自然言語処理論Ｉ 4.文法2(構文解析) その2&lt;/a&gt;
(注：「LR法による構文解析」として紹介されているアルゴリズムはSLR法)&lt;br /&gt;
上記3つはネット上にアップロードされている特定の大学の講義資料ですが、公開の規定等を確認していないためリンクを張ることに不都合があるようなら知らせていただけると助かります。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Canonical_LR_parser&#34;&gt;Canonical LR parser - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/ichikaz3/lr-parsing&#34;&gt;LR parsing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kimiyuki.net/blog/2016/08/03/context-free-grammar/&#34;&gt;文脈自由文法とその構文解析法 &amp;middot; うさぎ小屋&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/uhyo_&#34;&gt;うひょ(@uhyo_)さん&lt;/a&gt; 生き字引。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;構文解析とは-ざっくり:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;構文解析とは？(ざっくり)&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; という数式を考えてみます。
構文解析をすることによる最終的な目的は、この数式を(たとえば)文字列として与えると、結果としてこの数式の答えが&lt;code&gt;42&lt;/code&gt;であることを導く、といったことです。&lt;/p&gt;

&lt;p&gt;そのためには、以下のものが必要になります：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数式を表現する構文規則&lt;/li&gt;
&lt;li&gt;上記構文規則を解析するように作られた構文解析器(Parser)&lt;/li&gt;
&lt;li&gt;解析された構文を処理するプログラム&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さらに、これらの構文解析に入る前の下準備のために以下が必要です；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;文字列をトークンとして分割して表現するための字句規則&lt;/li&gt;
&lt;li&gt;上記字句規則をもとに、文字列を読み取ってトークンを返す字句解析器(Lexical Analyzer、略してLexer)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ちなみに、今回の記事の目標は、それらに加えて以下のものを実装することです：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;構文規則および字句規則を入力として与えることで、構文解析器そのものを自動生成するパーサジェネレータ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;実際の構文解析を行う手順とはずれてしまいますが、紹介した順番に沿って構文解析器→字句解析器の順に解説していきます。&lt;/p&gt;

&lt;h3 id=&#34;構文解析器-パーサ:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;構文解析器(パーサ)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; という数式を解析するためには、まずこの数式がどのようなルールで記述されているのかを(再)定義する必要があります。
そのルールをを表すのが構文規則です。
構文規則を書き表すルールは、たとえば&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%90%E3%83%83%E3%82%AB%E3%82%B9%E3%83%BB%E3%83%8A%E3%82%A6%E3%82%A2%E8%A8%98%E6%B3%95&#34;&gt;BNF&lt;/a&gt;など様々な種類がありますが、基本的な発想としては&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;S -&amp;gt; X Y Z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように左辺の記号を右辺の記号の並びによって定義することで行います。&lt;/p&gt;

&lt;p&gt;具体的に見てみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;式 -&amp;gt; 式 &amp;quot;+&amp;quot; 項
式 -&amp;gt; 項
項 -&amp;gt; 項 &amp;quot;*&amp;quot; 因子
項 -&amp;gt; 因子
因子 -&amp;gt; 数
因子 -&amp;gt; &amp;quot;(&amp;quot; 式 &amp;quot;)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;妥当ですね。
&lt;code&gt;式 -&amp;gt; 式 + 項&lt;/code&gt; と &lt;code&gt;式 -&amp;gt; 項&lt;/code&gt;の２つの規則が、再帰的な繰り返しを表現していることに注意してください。
たとえば、&lt;code&gt;項&lt;/code&gt;は当然&lt;code&gt;式&lt;/code&gt;ですし、&lt;code&gt;項 + 項&lt;/code&gt;も&lt;code&gt;式(-&amp;gt;項) + 項&lt;/code&gt; より&lt;code&gt;式&lt;/code&gt;となります。
さらに、&lt;code&gt;項 + 項 + 項&lt;/code&gt;は最初の&lt;code&gt;項 + 項&lt;/code&gt;が&lt;code&gt;式&lt;/code&gt;なので、&lt;code&gt;式(-&amp;gt;項 + 項) + 項&lt;/code&gt; より&lt;code&gt;式&lt;/code&gt;です。
よって、&lt;code&gt;式&lt;/code&gt;は&lt;code&gt;項&lt;/code&gt;を&lt;code&gt;&amp;quot;+&amp;quot;&lt;/code&gt;によって任意の回数だけ繋げたものであり、同様に&lt;code&gt;項&lt;/code&gt;は&lt;code&gt;因子&lt;/code&gt;を&lt;code&gt;&amp;quot;*&amp;quot;&lt;/code&gt;で繋げたものとなります。
最後に、&lt;code&gt;因子&lt;/code&gt;は単なる&lt;code&gt;数&lt;/code&gt;かもしれませんし、または&lt;code&gt;&amp;quot;(&amp;quot;&lt;/code&gt;と&lt;code&gt;&amp;quot;)&amp;quot;&lt;/code&gt;で囲まれた&lt;code&gt;式&lt;/code&gt;かもしれません。
これは括弧で囲まれた部分の式が他の部分よりも高い優先順位となることを表現しています。&lt;/p&gt;

&lt;p&gt;たとえば&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt;は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;式{ [9] [+] [11 * (2 + 1)] }
式{ 項{ [9] } &amp;quot;+&amp;quot; 項{ [11] [*] [(2 + 1)] } }
式{ 項{ 因子{9} } &amp;quot;+&amp;quot; 項{ 因子{11} &amp;quot;*&amp;quot; 因子{ [(] [2 + 1] [)] } } }
式{ 項{ 因子{9} } &amp;quot;+&amp;quot; 項{ 因子{11} &amp;quot;*&amp;quot; 因子{ &amp;quot;(&amp;quot; 式{ [2] [+] [1] } &amp;quot;)&amp;quot; } } }
式{ 項{ 因子{9} } &amp;quot;+&amp;quot; 項{ 因子{11} &amp;quot;*&amp;quot; 因子{ &amp;quot;(&amp;quot; 式{ 項{ [2] } &amp;quot;+&amp;quot; 項{ [1] } } &amp;quot;) &amp;quot;} } }
式{ 項{ 因子{9} } &amp;quot;+&amp;quot; 項{ 因子{11} &amp;quot;*&amp;quot; 因子{ &amp;quot;(&amp;quot; 式{ 項{ 因子{2} } &amp;quot;+&amp;quot; 項{ 因子{1} } } &amp;quot;)&amp;quot; } } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように展開されます(こうして得られた構造をどう解析するかについては省略します)。この、解析対象→構文木の変換を自動で行うのがパーサです。&lt;/p&gt;

&lt;p&gt;ちなみにですが、この構文規則は解析したい対象ごとにあなたが一から書き上げる必要があります。&lt;/p&gt;

&lt;h3 id=&#34;字句解析器-レキシカルアナライザ:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;字句解析器(レキシカルアナライザ)&lt;/h3&gt;

&lt;p&gt;上記構文規則では、&lt;code&gt;+&lt;/code&gt;や&lt;code&gt;*&lt;/code&gt;のような演算子、&lt;code&gt;数&lt;/code&gt;についての規定はありません。
これらの「左辺に現れない記号」を、「終端記号」と呼びます。左辺に現れる記号は非終端記号と呼ばれます。&lt;/p&gt;

&lt;p&gt;通常、&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; のような入力は文字列で与えられますが、記号と記号の間には複数もしくは0個の空白が挿入されている可能性もあります。
しかし以下のような構文規則を定義するのは本質的ではありません：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;空白 -&amp;gt; &amp;quot; &amp;quot;
空白 -&amp;gt; &amp;quot; &amp;quot; 空白
数字 -&amp;gt; &amp;quot;0&amp;quot; | &amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | ... | &amp;quot;9&amp;quot;
数字 -&amp;gt; (&amp;quot;0&amp;quot; | &amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | ... | &amp;quot;9&amp;quot;) 数字
数 -&amp;gt; (&amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | &amp;quot;3&amp;quot; ... | &amp;quot;9&amp;quot;) 数字
ただし、|は「または」を表す
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そこで、通常は「入力として与えられた文字列」を「終端記号として分類されたトークンの列」に変換する処理をはさみ、これによって得られたトークンを構文解析器に与えます。
トークンとは終端記号と、必要ならばそれに紐付いた元々の情報を保持しておいたものです。たとえば、&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt;は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;数字: 9
プラス: +
数字: 11
アステリスク: *
左括弧: (
数字: 2
プラス: +
数字: 1
右括弧: )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような9つのトークンの列に分けることができます。
構文解析器はそのトークンがどのような終端記号に対応しているかは見ますが、たとえば個々の数字が何であるかを判断することはしません。
これによって、構文解析器は本質的な文法の解析のみに注力することができます。&lt;/p&gt;

&lt;p&gt;この処理をするのが字句解析器で、どのような文字や文字列が与えられた場合に何という終端記号かを判別するための規則が字句規則です。&lt;/p&gt;

&lt;p&gt;字句規則は、例えば以下のような書き方になるでしょう：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;数字: /[1-9][0-9]*/
プラス: &amp;quot;+&amp;quot;
アステリスク: &amp;quot;*&amp;quot;
左括弧: &amp;quot;(&amp;quot;
右括弧: &amp;quot;)&amp;quot;
(読み捨て): /\s/
(不正): /./
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでは字句規則の表現のために、文字列および正規表現を使用しています。
通常(?)字句規則は上から順に文字列の先頭部分を当てはめていき、マッチするものがあればその終端記号に対応付けます。
そのため、&lt;code&gt;(不正)&lt;/code&gt;の部分は入力された文字全てにマッチする正規表現&lt;code&gt;/./&lt;/code&gt;が使用されていますが、これは上の規則のいずれにも当てはまらなかった場合にのみマッチします。&lt;/p&gt;

&lt;p&gt;与えられた文字列を前から順番に見ていくだけなので、字句解析器の実装はパーサやパーサジェネレータの実装と比べると単純です。&lt;/p&gt;

&lt;h3 id=&#34;パーサジェネレータ:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;パーサジェネレータ&lt;/h3&gt;

&lt;p&gt;ここまで構文解析器(パーサ)と字句解析器(レキシカルアナライザ)について見てきました。
基本的にはこの2つによって構文解析を行うことができ、基本的な流れとしては&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;入力となるような解析したい言語を用意する&lt;/li&gt;
&lt;li&gt;字句規則を用意して、それをもとにしたレキシカルアナライザを用意する&lt;/li&gt;
&lt;li&gt;レキシカルアナライザに入力を与え、トークンの列を取得する&lt;/li&gt;
&lt;li&gt;構文規則を用意して、それをもとにしたパーサを用意する&lt;/li&gt;
&lt;li&gt;パーサにトークンの列を与え、解析結果を得る&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となります。
パーサジェネレータとは何かというと、この 4. の部分を自動化するものです。
(LR法の)構文解析器は、内部的には入力を受け取ってスタックに積みながら状態遷移を繰り返すオートマトンにすぎません。
そのため、どの入力が与えられればどのような状態に遷移するかを示す「構文解析表」を得ることができれば、その構文を解析するパーサを作成することができます。
パーサジェネレータは、構文規則を読み取ることでこの構文解析表をつくり上げるという処理を主に行います。&lt;/p&gt;

&lt;p&gt;字句解析器程度ならわざわざジェネレータを作らなくても、字句規則そのものを字句解析器に渡せば良い感じに字句解析してくれるようにできますが、パーサジェネレータも「構文解析表の構築後、それをもとにして構文解析を行う」ような機能がついていればそれはパーサであるとも言えます。
わざわざパーサとパーサジェネレータが分けられているのは、一つには計算資源の乏しかった昔はパーサジェネレータがオンメモリで展開した構文解析表をもとにそのままパーサとして振る舞うというようなことが少なく、構文解析表を与えることで「パーサのソースコード」を出力するようなものが一般的だったからではないかと思われます(適当な思いつきを言っています)。
もっとも、現在でもパーサジェネレータがパーサを生成する際の処理には時間がかかるため、予めパーサをコンパイルしておけるようにするのは妥当といえるでしょう。
字句解析器のための「字句解析器ジェネレータ」も実際に存在していますが、ここでは簡単のために字句解析器はコンストラクタに字句規則を与えれば勝手に良い感じの字句解析を行ってくれるようになるものと思ってもらえればよいです。&lt;/p&gt;

&lt;h3 id=&#34;文脈自由言語について:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;文脈自由言語について&lt;/h3&gt;

&lt;p&gt;構文解析器が解析対象とする「言語」がどのようなものであるかについてはいろいろな定義がなされています。&lt;/p&gt;

&lt;p&gt;これについては、参考資料でも紹介した&lt;a href=&#34;https://twitter.com/ki6o4&#34;&gt;うさぎさん(@ki6o4)&lt;/a&gt;の&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kimiyuki.net/blog/2016/08/03/context-free-grammar/&#34;&gt;文脈自由文法とその構文解析法 &amp;middot; うさぎ小屋&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が詳しいため、こちらを参照していただくことをおすすめします。
ここでは、厳密な話はあまりせずにごくごく簡単に触れていこうと思います。&lt;/p&gt;

&lt;p&gt;構文解析の対象とするのは、基本的に文脈自由言語となります。
構文解析の手法にも様々なものがありますが、それらの手法の中には文脈自由言語すべてを解析できるわけではないものも多く、たとえばLR(1)法ならLR(1)文法やLR(1)言語というように、ある手法で解析できる文法や、解析できる言語全体をその手法の名前で表される言語として表現することがあります。&lt;/p&gt;

&lt;h3 id=&#34;解析手法と言語のクラス:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;解析手法と言語のクラス&lt;/h3&gt;

&lt;p&gt;いくつかの手法を主観を交えて乱暴に紹介していきます。&lt;/p&gt;

&lt;h4 id=&#34;先読み:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;先読み&lt;/h4&gt;

&lt;p&gt;**この項は下のLR法などの項を「先読み」してから戻ってきて読むことをおすすめします**&lt;/p&gt;

&lt;p&gt;たとえばLR(1)法のように、数字を括弧でくくって(k)と表現している手法がいくつかあります。このkは何文字先読みするかを示していて、たとえば(1)ならば1文字先読みするという意味です。
先読み数については、たとえばLR法については以下のようなことが言われています。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;LR(k)で表せる文法のクラス ⊆ LR(k+1)先読みで表せるクラス である&lt;/li&gt;
&lt;li&gt;LR(k)文法によって受理可能な言語のクラスは、LR(1)のそれと等しい&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.より、基本的には(1)について考えることが多いようです。&lt;/p&gt;

&lt;h4 id=&#34;ll-1-法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;LL(1)法&lt;/h4&gt;

&lt;p&gt;「再帰を使って構文解析する」という発想としては単純なもの。
LL(1)文法のクラスはLR(1)よりも大幅に小さいものの、それでもLALR(1)文法を外れた文法を解析できたりします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;S -&amp;gt; S + E
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような、右辺の一番左の場所に左辺の記号が登場するような「左再帰則」を読むことができません。ナンセンス。&lt;/p&gt;

&lt;h4 id=&#34;lr-0-法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;LR(0)法&lt;/h4&gt;

&lt;p&gt;先読み数が0なのでよわい。&lt;/p&gt;

&lt;h4 id=&#34;slr法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;SLR法&lt;/h4&gt;

&lt;p&gt;SLRのSはSimpleの意味です。LR(0)から単純な先読みを加えることでLR(0)よりも解析可能な文法が増えますが、それでもLALR(1)には及びません。&lt;/p&gt;

&lt;h4 id=&#34;lr-1-法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;LR(1)法&lt;/h4&gt;

&lt;p&gt;LR(0)に対し、1文字だけ先読みして次にどのような入力が期待されるかを判断。
LR(1)文法がそれなりに広いという点で優秀な一方、LR(0)に比べて構文解析表の大きさが爆発しやすいという欠点がある、と言われています。
しかし今の時代はそんなものは大した欠点になり得ない気がします。&lt;/p&gt;

&lt;h4 id=&#34;lalr-1-法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;LALR(1)法&lt;/h4&gt;

&lt;p&gt;プログラミング言語を解析するコンパイラなどによく使われている手法です。
LALR(1)のLAはLook-Aheadの略で、まずLR(1)法で構文解析表を作ってから、文法部分が同じで先読み記号だけが違うような状態をマージするという点がLR(1)法と異なります。
表を併合してしまうためにLR(1)法よりも解析可能な文法のクラスが小さくなるものの、実用上はほとんど問題にならず、LR(1)法の構文解析表が大きくなりすぎるという欠点を補える手法です。&lt;/p&gt;

&lt;p&gt;ただし、一度LR(1)法の表を作ること変わりはないのでメモリ消費量はそう変わらないし、大きなデータも問題なく扱える今の時代にわざわざ構文解析表を数十パーセント程度削減したところで何の意味があるのかという疑問があります。&lt;/p&gt;

&lt;p&gt;また、LALR法のLAはLook-Aheadの略だと言いましたが、注意しなければならないのは&lt;strong&gt;Look-Ahead(先読み)を行うのはLALR法固有の手法ではない&lt;/strong&gt;ということです。  先読み自体はLR(1)法でもやりますし、LALR(1)はあくまでLR(1)の先読み部分をマージしたものにすぎません。
私はLALR法の名前の付け方はあまり良くないと思っていて、MLR法(Merged Look-Ahead LR法)とかなんとか、そういう感じの名前に変えたほうが良いと思います。&lt;/p&gt;

&lt;h4 id=&#34;glr法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;GLR法&lt;/h4&gt;

&lt;p&gt;「あいまいな」解釈が可能な文法があった場合、考えられうるすべての可能性を探索してしまうことによって解決する手法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;「お魚くわえた猫を追いかけるサザエさん」&lt;/code&gt;で魚をくわえているのが猫とサザエさんの両方に解釈できるように、一つの入力に対して複数の結果が得られることがあります。
どちらかというと自然言語処理向きかもしれません。&lt;/p&gt;

&lt;h4 id=&#34;cyk法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;CYK法&lt;/h4&gt;

&lt;p&gt;強力なアルゴリズムにより、文脈自由言語すべてを比較的高速に解析可能。
ただし、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;S -&amp;gt; NP VP
VP -&amp;gt; v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように、チョムスキー標準形といわれるような、「右辺が非終端記号ちょうど2つか終端記号1つでなければならない」、つまり結果として得られる構造が二分木になっていなければならないというナンセンスにも程がある制約を課されます(アルゴリズムの改良や規則の変換、得られた木構造の後処理などによって回避は可能ですが)。&lt;/p&gt;

&lt;p&gt;このCYK法の計算量オーダーは&lt;code&gt;O(n^3)&lt;/code&gt;程度で、文脈自由言語全てを解析可能なアルゴリズムの中では高速ですが、この記事で紹介されている他のアルゴリズムよりは低速となります。
たとえばLR(1)法は文脈自由言語全体を解析出来ないかわりに&lt;code&gt;O(n)&lt;/code&gt;で解析が可能です。&lt;/p&gt;

&lt;p&gt;プログラミング言語の解析では、言語の開発者が文法自体をある程度自由に定義することができるため、文脈自由言語の一部だけでなく全体を解析したいという需要はあまり発生しません。&lt;/p&gt;

&lt;h2 id=&#34;lr-1-パーサジェネレータをつくろう:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;LR(1)パーサジェネレータをつくろう&lt;/h2&gt;

&lt;p&gt;構文解析の大まかな流れはわかりました。
とりあえず字句規則と構文規則を用意して、あとはどうにかしてこの構文を読んでくれるようなパーサを用意すれば構文解析ができそうです(字句解析器なんてのは適当にやってもすぐ用意できます)。&lt;/p&gt;

&lt;p&gt;先ほど紹介したような手法によって構文ごとに一からパーサをプログラミングするようなことはやりたくないので、パーサジェネレータを用いてパーサを自動的に生成してもらえば事は済みそうですね。&lt;/p&gt;

&lt;p&gt;ここに&lt;a href=&#34;https://www.gnu.org/software/bison/&#34;&gt;Bison&lt;/a&gt;という有名なパーサジェネレータがあります。
今の時代にわざわざCやC++で構文解析なんてしたくないのでしたら、Pythonで&lt;a href=&#34;http://www.dabeaz.com/ply/&#34;&gt;PLY&lt;/a&gt;とか、JavaScriptの&lt;a href=&#34;https://github.com/zaach/jison&#34;&gt;jison&lt;/a&gt;というものなど、いくらでも選択肢があります。
これらのうち一つを選んで、チュートリアルを読んでパーサを作っていくのがいいでしょう。&lt;/p&gt;

&lt;p&gt;というわけで、前段を書いていると結構分量が膨らんでしまったため、今回はここで区切ります。&lt;/p&gt;

&lt;p&gt;では次回からは、構文解析を行えるようになるため、LR(1)法を用いたパーサジェネレータを実際に作っていく流れを紹介していきたいと思います。&lt;/p&gt;

&lt;p&gt;えっちょっとまって、今パーサジェネレータは既存のものを使えばいいって言ったよね、ねえ&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/&#34;&gt;次回:字句解析器の実装&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Javaのリフレクションを悪用してクラス設計してみる</title>
      <link>http://tatamo.81.la/blog/2016/12/15/java-generics-and-reflection/</link>
      <pubDate>Thu, 15 Dec 2016 01:11:23 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/12/15/java-generics-and-reflection/</guid>
      <description>
        

&lt;p&gt;この記事は&lt;a href=&#34;http://www.adventar.org/calendars/1881&#34;&gt;Kobe University Advent Calendar 2016&lt;/a&gt;の14日の記事です。遅刻です。
なお私は当該大学の学部2年(2016年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最近、大学の授業などで少しだけJavaに触れる機会があったので、ちょっとした黒魔術っぽいことでもやってみようと思います。&lt;/p&gt;

&lt;p&gt;と思ったのですが、記事を書こうとして調べていたら普通に書きたかったことをわかりやすく書いている記事がありました。&lt;br /&gt;
* &lt;a href=&#34;http://d.hatena.ne.jp/Nagise/20131121/1385046248&#34;&gt;new T()したいケースへの対処法 - プログラマーの脳みそ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;もう帰っていいですかね。&lt;/p&gt;

&lt;h2 id=&#34;総称型tに対してt-classやnew-t-したい:c600ddb79433125511402a932eb728b1&#34;&gt;総称型Tに対してT.classやnew T()したい&lt;/h2&gt;

&lt;h3 id=&#34;ジェネリクスとは:c600ddb79433125511402a932eb728b1&#34;&gt;ジェネリクスとは&lt;/h3&gt;

&lt;p&gt;わざわざ書くまでもないとは思いますが、ジェネリクスについておさらいをしておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;ArrayList&amp;lt;String&amp;gt; strlist = new ArrayList&amp;lt;String&amp;gt;();
ArrayList&amp;lt;Integer&amp;gt; intlist = new ArrayList&amp;lt;Integer&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ArrayList&lt;T&gt;に対し、ジェネリクスとしてStringやIntegerなど、リストの要素として入れたい型をTの部分に具体的に書くことで、一つのクラスであるArrayListに利用者側が好きな要素を入れることができるようになります。&lt;/p&gt;

&lt;p&gt;ジェネリクスを用いて自分でメソッドを定義する場合は、以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public &amp;lt;T&amp;gt; void doSomething(T arg){
	// doSomething
}

// TをSomeClassのサブクラスに限定する
public &amp;lt;T extends SomeClass&amp;gt; void notDoAnything(T arg){
	return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらのメソッドを呼び出すときは、&lt;code&gt;hoge.&amp;lt;SomeClass&amp;gt;doSomething();&lt;/code&gt;のようになります。&lt;br /&gt;
どうして&lt;code&gt;hoge.doSomething&amp;lt;SomeClass&amp;gt;();&lt;/code&gt;じゃないんだろう。&lt;/p&gt;

&lt;h3 id=&#34;ジェネリクスはt-classやnew-t-をさせてくれない:c600ddb79433125511402a932eb728b1&#34;&gt;ジェネリクスはT.classやnew T()をさせてくれない&lt;/h3&gt;

&lt;p&gt;Javaのジェネリクスでは、以下のコードはコンパイルエラーとなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public &amp;lt;T extends SomeClass&amp;gt; List&amp;lt;T&amp;gt; getSubClassList(List&amp;lt;SomeClass&amp;gt; list){
	return list
		.stream()
		.filter(value -&amp;gt; value instanceof T) // ここでlistの要素valueがTのインスタンスかどうか判別したい -&amp;gt; error
		.collect(Collectors.toList());
}

public &amp;lt;T extends SomeClass&amp;gt; List&amp;lt;T&amp;gt; getSubClassList2(List&amp;lt;SomeClass&amp;gt; list){
	return list
		.stream()
		.filter(value -&amp;gt; value.getClass() == T.class) // instanceofがだめならclassを取得して判別したい -&amp;gt; error
		.collect(Collectors.toList());
}

public &amp;lt;T&amp;gt; void doSomething(String arg){
	T foo = new T(arg); // T型の新しいインスタンスfooを作りたい -&amp;gt; error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ジェネリクス型に対して、hoge instanceof T、T.class、new T()といった操作を行うことはできません。
残念でしたね。&lt;/p&gt;

&lt;h2 id=&#34;なぜしたいのか:c600ddb79433125511402a932eb728b1&#34;&gt;なぜしたいのか&lt;/h2&gt;

&lt;h3 id=&#34;もしかして-設計が間違っている:c600ddb79433125511402a932eb728b1&#34;&gt;もしかして： 設計が間違っている&lt;/h3&gt;

&lt;p&gt;先ほどのgetSubClassListメソッドを見てみましょう。
正しく動くかどうかはさておき、やりたいことは以下の通りです：&lt;br /&gt;
* SomeClassとそのサブクラスを含んだリストlistの要素のうち、SomeClassのサブクラスTのインスタンスだけを要素とする新しいリストを取得したい。&lt;/p&gt;

&lt;p&gt;そもそも、抽象化された集合から具体的なクラスのインスタンスを取り出そうとすること自体がオブジェクト指向やポリモーフィズムの考え方に対する反逆である可能性があります。&lt;/p&gt;

&lt;p&gt;SomeClassのリストであるlistをイテレートして、それぞれの要素のdoSomething()メソッドを呼べば、あとはそれがSomeClassのインスタンスであろうと、もしくはSomeClassを継承した別のクラスのインスタンスであろうと、外部からはただdoSomething()メソッドを呼ぶだけで操作が完結していなければなりません。
それがサブクラス固有のふるまいをするとしても、その実装はそのクラス自身に隠蔽されるべきなのです。&lt;/p&gt;

&lt;p&gt;よって、サブクラスだけを取り出そうとする試み自体がナンセンスなものである可能性が非常に高く、まずそのような試みが必要になる設計そのものを見直す必要があります。&lt;/p&gt;

&lt;p&gt;終わり。&lt;/p&gt;

&lt;h3 id=&#34;そうも言っていられない:c600ddb79433125511402a932eb728b1&#34;&gt;そうも言っていられない&lt;/h3&gt;

&lt;p&gt;実際その通りなのですが、それではこの記事が続きません。&lt;/p&gt;

&lt;p&gt;ここからは、少し具体的なプログラムの設計を例にとって考えてみたいと思います。&lt;br /&gt;
あなたはちょっとしたゲームを作るためのフレームワークを作っています。
その一部分が以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;// 抽象的なゲーム内エンティティクラス
public abstract class Entity {
	private int x;
	private int y;
	public Entity(int x, int y){
		this.setX(x);
		this.setY(y);
	}
	public int getX() { return x; }
	public void setX(int x) { this.x = x; }
	public int getY() { return y; }
	public void setY(int y) { this.y = y; }

	public abstract void update(EntityManager manager);
}

// なんでもかんでも××Managerという名前を付けるのはやめましょう
public class EntityManager {
	private ArrayList&amp;lt;Entity&amp;gt; all_entities;
	public EntityManager(){
		this.all_entities = new ArrayList&amp;lt;Entity&amp;gt;();
	}
	public void add(Entity e){
		this.all_entities.add(e);
	}
	public ArrayList&amp;lt;Entity&amp;gt; getAll() {
		return new ArrayList&amp;lt;Entity&amp;gt;(this.all_entities);
	}
	public void updateAll(){
		this.all_entities.forEach(e-&amp;gt;e.update(this));
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なんのことはありませんね。
ゲーム内に登場するエンティティを表す抽象クラスEntityを作り、それをEntityManagerで管理します(なんでもかんでも××Managerという名前を付けるのはManagerクラスの肥大化を招きかねないため避けるべきであるなどという話もありますが、今回は置いておきます)。
たとえば毎フレームごとにメインループ内で&lt;code&gt;EntityManager#updateAll()&lt;/code&gt;を呼び出すことで、全てのエンティティの更新を行ったりすることが想定されます。
オーソドックスなループ駆動型のゲームプログラム設計です。&lt;br /&gt;
Entityインスタンスを作成するためのFactory Methodパターンを使うべきとか、そういう話もあっちでやってください。&lt;/p&gt;

&lt;p&gt;あとは、このフレームワークの利用者にはEntityクラスを継承したクラスを作らせ、それをもとにゲームを作ってもらえればいいだけです。
以下のクラスを追加してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;// あなたです
public class Player extends Entity{
	private int hp; // プレイヤーはヒットポイントを持ちます
	public Player(int x, int y, int hp){
		super(x, y);
		this.setHp(hp);
	}
	public int getHp() { return hp; }
	public void setHp(int hp) { this.hp = hp; }
	@Override
	public void update(EntityManager manager){
		// プレイヤーが動きます
	}
}

// 敵です
public class Enemy extends Entity {
	private int damage; // 敵がプレイヤーに与えることのできるダメージ値です
	public Enemy(int x, int y, int damage){
		super(x, y);
		this.setDamage(damage);
	}
	public int getDamage() { return damage; }
	public void setDamage(int damage) { this.damage = damage; }
	@Override
	public void update() {
		// 敵が動きます
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プレイヤーと敵を登場させました。
常命の者であるプレイヤーにはヒットポイントが定められており、敵はこれを脅かすダメージ値を持っています。&lt;/p&gt;

&lt;p&gt;注意しておく必要があるのは、これらのクラスはあくまでフレームワークの利用者が作るものだということです。
よって、EntityクラスやEntityManagerクラスからはこのようなEntityサブクラスの存在を知ることはできません。&lt;br /&gt;
知る必要もないというのがオブジェクト指向の考え方だったはずです。
そうですよね？&lt;/p&gt;

&lt;p&gt;ここで、「敵のダメージ値を参照して、プレイヤーのヒットポイントを減らす」処理をしたいという需要が当然生まれます。
実装の方法はいろいろあると思いますが、ひとまずこの処理を、Enemyのメソッドとして書いてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;// 敵です
public class Enemy extends Entity {
	private int damage; // 敵がプレイヤーに与えることのできるダメージ値です
	public Enemy(int x, int y, int damage){
		super(x, y);
		this.setDamage(damage);
	}
	public int getDamage() { return damage; }
	public void setDamage(int damage) { this.damage = damage; }
	@Override
	public void update(EntityManager manager) {
		// 敵が動きます
		// プレイヤーがいたらダメージを与えます
		manager.getAll().forEach((entity)-&amp;gt;{ // 全てのエンティティを調べる
			if(entity instanceof Player){ //  エンティティがプレイヤーなら
				if(this.getX() == entity.getX() &amp;amp;&amp;amp; this.getY() == entity.getY()){ // プレイヤーと敵の座標が同じなら
					this.doDamage((Player) entity); // ダメージを与える
				}
			}
		});
	}
	public void doDamage(Player p){
		p.setHp(p.getHp() - this.getDamage()); // プレイヤーのヒットポイントをダメージ値分だけ減らします
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここであなたは気を利かせます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;manager.getAll().forEach((entity)-&amp;gt;{
	if(entity instanceof Player){
		if(...){
			...
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この部分です、どう見ても冗長ですし、いちいち全エンティティのリストをforEachで回しているので高速化も望めませんし、同様のコードクローンが至る所に発生するのは目に見えています。&lt;/p&gt;

&lt;p&gt;できるならたとえばこう書きたい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;manager.&amp;lt;Player&amp;gt;getAllOfSubClass().forEach((player)-&amp;gt;{
	if(...){
		...
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでPlayerクラスだけが得られるなら、呼び出し側のコード量は減りますし、もしあなたがO(n^2)の処理をO(nlogn)に落とすような作業に慣れているなら、Managerクラスの内側でより高速になるような最適化を行い、その実装も内部に隠蔽することができます。&lt;/p&gt;

&lt;p&gt;また、ゲームのセーブとロードをするときのことも考えてみます。
たとえばデータのセーブを行うときはとりあえずオブジェクトを文字列化するとして、&lt;br /&gt;
&lt;code&gt;public String Entity#serialize()&lt;/code&gt;などといったメソッドを作ってセーブし、ロード時には文字列配列を引数として受け取るようオーバーロードされたコンストラクタを使用してオブジェクトを再生成するといったことが考えられます。
そういうことはFactory Methodあたりに委譲するべきな気もしますし、うまくやらないとフレームワークの利用者側の負担が増える気もしますが、今は置いておきます。&lt;/p&gt;

&lt;p&gt;結局、セーブデータのロード時にこのようなコードを書くことになるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;	public &amp;lt;E extends Entity&amp;gt; E createEntity(List&amp;lt;String&amp;gt; args){ // 可変長引数としてもよい
		return new E(args); // ジェネリクス型はnewできない -&amp;gt; error
	}
	public loadSaveData(SaveData savedata){
		// セーブデータから1行ずつ読み込んでオブジェクトを再生成する
		... {
			entityManager.add(this.createEntity(agrs));
		}
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかしジェネリクス型はnewできないため、コンパイルエラーとなります。&lt;/p&gt;

&lt;h2 id=&#34;解決策:c600ddb79433125511402a932eb728b1&#34;&gt;解決策&lt;/h2&gt;

&lt;p&gt;さて、だいぶん勿体つけたが、解決編に入ろう。&lt;/p&gt;

&lt;p&gt;……というか、例として取り上げた題材が無理やりすぎた気がしてやる気が尽きかけてきました。&lt;/p&gt;

&lt;h3 id=&#34;リフレクションを使用する:c600ddb79433125511402a932eb728b1&#34;&gt;リフレクションを使用する&lt;/h3&gt;

&lt;p&gt;Javaにはリフレクションという機能があり、プログラムの実行中にクラス名やメソッド名を動的に取り扱うことができます。
これのClass&lt;T&gt;型を、ジェネリクスと併用しましょう。
&lt;code&gt;EntityManager#getAllOfSubClass&lt;/code&gt;メソッドを考えてみます。
実装は以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;	@SuppressWarnings(&amp;quot;unchecked&amp;quot;)
	public &amp;lt;E extends Entity&amp;gt; List&amp;lt;E&amp;gt; getAllOfSubClass(Class&amp;lt;E&amp;gt; cls){
		return (List&amp;lt;E&amp;gt;) all_entities.stream()
			.filter(entity -&amp;gt; entity.getClass() == cls)
			.collect(Collectors.toList());
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを呼び出す際は、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;entityManager.getAllOfSubClass(Player.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにして、Class型の&lt;code&gt;クラス名.class&lt;/code&gt;を引数として与えます。
ここで型推論が働くので、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;entityManager.&amp;lt;Player&amp;gt;getAllOfSubClass(Player.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにPlayerクラス名を2度も書く必要はありません。&lt;/p&gt;

&lt;p&gt;また、Playerクラスだけでなく、Playerクラスを継承したクラスも含めて判別したいときは、以下のようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;	@SuppressWarnings(&amp;quot;unchecked&amp;quot;)
	public &amp;lt;E extends Entity&amp;gt; List&amp;lt;E&amp;gt; getAllOfSubClass(Class&amp;lt;E&amp;gt; cls){
		return (List&amp;lt;E&amp;gt;) all_entities.stream()
			.filter(entity -&amp;gt; cls.isAssignableFrom(entity.getClass()))
			.collect(Collectors.toList());
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;createEntity&lt;/code&gt;メソッドも、以下のようにすれば書くことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;	public &amp;lt;E extends Entity&amp;gt; E createEntity(Class&amp;lt;E&amp;gt; cls, List&amp;lt;String&amp;gt; args){
		// cls型のString[]を引数にとるコンストラクタを呼び出す
		return cls.getConstructor(new Class&amp;lt;?&amp;gt;[] { String[].class }).newInstance(args);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やや黒魔術じみてきました。
実際にはE型がString[]を引数にとるコンストラクタを持つということが担保されていないためこれだけでは動かず、例外回避のためにいろいろやる必要があります。&lt;/p&gt;

&lt;p&gt;最初の例に戻ってみましょう。&lt;code&gt;getSubClassList&lt;/code&gt;は、以下のように書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public &amp;lt;T extends SomeClass&amp;gt; List&amp;lt;T&amp;gt; getSubClassList(List&amp;lt;SomeClass&amp;gt; list, Class&amp;lt;T&amp;gt; cls){
	return list
		.stream()
		.filter(value -&amp;gt; value.getClass() == cls)
		.collect(Collectors.toList());
}

// 呼び出し側
getSubClassList(list, SubClassOfSomeClass.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;めでたしめでたし。&lt;/p&gt;

&lt;h3 id=&#34;おまけ:c600ddb79433125511402a932eb728b1&#34;&gt;おまけ&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public &amp;lt;T&amp;gt; int getStaticValue(Class&amp;lt;T&amp;gt; cls) throws Exception{ // なにがthrows Exceptionだやる気あんのか
	return (int) cls.getMethod(&amp;quot;getStaticValue&amp;quot;).invoke(null);
}

// 呼び出し
getStaticValue(SomeClass.class); // SomeClass.getStaticValue() を呼んでいるのと同じになる
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;staticメソッドも呼び出し可能なうえ、「そのクラスに与えられた名前のstaticメソッドが存在しない場合、その親クラスの同名のstaticメソッドを呼び出す」というようなふるまいを疑似的に再現することも可能です。&lt;/p&gt;

&lt;h2 id=&#34;おわり:c600ddb79433125511402a932eb728b1&#34;&gt;おわり&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Class&amp;lt;T&amp;gt; cls&lt;/code&gt;を引数にとり、&lt;code&gt;value.getClass() == cls&lt;/code&gt;で比較を行うのは、実質的にはinstanceofの迂回といえます。&lt;br /&gt;
この程度なら型安全性は一応担保されますが、コンストラクタやメソッドの取得と呼び出しまで始めた場合、throw宣言やcatch節が山のように膨らんだり、メソッドの存在確認や型の確認などに多大なコストを支払う必要がありそうです。
実際に使用するには相当の覚悟を必要とするでしょう。&lt;strong&gt;やめましょう。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;自分でプログラムを組んでいる際にこのような需要が発生することが時々あったので、Javaではリフレクションを使うことで強引に解決できると知って記事を書いてみましたが、自分の中ではむしろ「設計が悪い」の一言に実感が沸くという結果となった気がします。&lt;br /&gt;
今回例に挙げたゲームプログラムの設計はまさしく昔私が作ったものそのものなのですが、記事を書く上で「リフレクションを使いたい理由付け」を明確にしようとすればするほど、その理由が無理やりなものにしかならないのではないかという気持ちに陥りました。
途中まで書いた記事がグダグダになりそうな予感がしてくると結構精神的につらい。&lt;br /&gt;
……うーん。Abstract Factoryパターンとか、もととなるクラスが増えるとそれに合わせてFactoryクラスも増やさないといけないのがあまり好きじゃないので、そのあたりも動的になんとかできないかなどと思っていたのですが、なかなか難しいようです。&lt;/p&gt;

&lt;p&gt;私感としては、instanceof Tの代用としてClass型を使用する程度は許容できますが、普通のプログラムを書くならそれ以上は安易に手を出すべきではないという印象です。&lt;/p&gt;

&lt;p&gt;プログラミングをするときはまともな設計をするようにしましょう。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>自作PCの紹介</title>
      <link>http://tatamo.81.la/blog/2016/12/07/intro-my-homebuilt-pc/</link>
      <pubDate>Wed, 07 Dec 2016 13:53:12 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/12/07/intro-my-homebuilt-pc/</guid>
      <description>
        

&lt;p&gt;この記事は&lt;a href=&#34;http://www.adventar.org/calendars/1881&#34;&gt;Kobe University Advent Calendar 2016&lt;/a&gt;の7日の記事です。
なお私は当該大学の学部2年(2016年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;私は自作PCerなので、この機会に普段使用しているPCのパーツ構成を紹介していきたいと思います。
趣味の中でも結構金がかかっている分野です。&lt;/p&gt;

&lt;h2 id=&#34;外観:14cdc902344e522bd60455484bb9d961&#34;&gt;外観&lt;/h2&gt;

&lt;p&gt;クリックすると別タブで拡大表示します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/12/07/img01.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/12/07/img01.jpg&#34; alt=&#34;自作PC外観(筐体)&#34; height=&#34;600&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/12/07/img02.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/12/07/img02.jpg&#34; alt=&#34;自作PC外観(卓上)&#34; width=&#34;600&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;使用用途-スペック:14cdc902344e522bd60455484bb9d961&#34;&gt;使用用途・スペック&lt;/h2&gt;

&lt;p&gt;ごく普通のプログラミングやネットサーフィンに加え、ゲームを多くプレイするため、少なくとも比較的新しいゲームを高画質設定でプレイ出来るだけのスペックを目指して構築しています。&lt;/p&gt;

&lt;h2 id=&#34;パーツ構成-本体:14cdc902344e522bd60455484bb9d961&#34;&gt;パーツ構成(本体)&lt;/h2&gt;

&lt;p&gt;おおよそ5年前の2011年年末から2012年の年始に組み上げ、そこからパーツを少しずつ更新して現在に至ります。
当時のパーツで残っているのはCPUとM/B、およびメモリとHDD程度。&lt;/p&gt;

&lt;h3 id=&#34;cpu-マザーボード:14cdc902344e522bd60455484bb9d961&#34;&gt;CPU・マザーボード&lt;/h3&gt;

&lt;p&gt;CPU: Phenom II X6 1065T&lt;br /&gt;
M/B: GIGABYTE GA-990FXA-UD5&lt;/p&gt;

&lt;p&gt;AMD機体です。
マザーボードは当時Socket AM3+が登場した頃だったため、採用しているCPUはSocket AM3のPhenom II X2ですが将来的な性能向上を見越してSocket AM3/AM3+の両方に対応しているGA-990FXA-UD5を採用。M/Bはパーツ交換の頻度が最も低くなると思ったので、ここは金を掛けるべきと判断してUD3ではなく一つ上のUD5にしています。&lt;/p&gt;

&lt;p&gt;一方でCPUはコストパフォーマンスを重視し、6コア帯の中でも消費電力の低いモデルであるPhenom II X6 1065Tを採用。2011年当時でもやや古めのモデルではあるものの、ミドルクラス構成としては悪くないものだと思っています。
6コアまたは4コア8スレッド以上の性能を持つCPUを求める場合、Intel製品では2万円台から3万円台以上は見る必要があった中で、1万7000円前後で6コアを得られるPhenom II X6シリーズは魅力的でした。
この性能に対する価格のパフォーマンスの高さが、AMDを選択する理由の一つになっています。&lt;/p&gt;

&lt;p&gt;現在でもSocket AM3+対応で2012年から2014年にかけて展開されたAMD FX8xxx/9xxxシリーズはミドルクラスからハイクラスにかけて良好な性能を誇る上に、同等の性能帯のIntel製CPUに比べて1万円から2万円程度安く入手できます。
一方でそれよりも上の性能を目指す場合はIntelの一強状態となっており、ハイエンドでもAMDが多少は追随できていた2011年当時とは状況が異なっています。
そのため、今からPCを組む場合は何も考えずにAMD製品を選ぶというわけにはいかないように思います。&lt;/p&gt;

&lt;h3 id=&#34;メモリ:14cdc902344e522bd60455484bb9d961&#34;&gt;メモリ&lt;/h3&gt;

&lt;p&gt;PC3-12800の4GBを4枚 計16GB&lt;br /&gt;
→最近1枚壊れたため3枚12GB&lt;/p&gt;

&lt;p&gt;Minecraftあたりのメモリを食いまくるゲームをやっていたり、Chromeでやたらとタブを開いたりしていると、8GBではやや足りない状況があるので16GB。
普通に使っていると8GBで足りるか足りないか程度だと思うので、8GBから多少上であればいいと思います。
今のところ16GBから12GBに減ってもほとんど影響を感じることはありません。&lt;/p&gt;

&lt;h3 id=&#34;グラフィックボード:14cdc902344e522bd60455484bb9d961&#34;&gt;グラフィックボード&lt;/h3&gt;

&lt;p&gt;SAPPHIRE R9 270 2G GDDR5&lt;/p&gt;

&lt;p&gt;やはりAMDの、Radeon R9 270です。特筆することは少ないですが一応は現在でもミドルクラス上位レベルの性能らしいですし、2万円台前半と、悪くない価格帯でもあります。
新しいゲームでも普通に1080pで悪くない画質設定で遊べますし、コストパフォーマンスも良いです。
Batman:Arkham Knightは画質設定を低にしないと遊べませんでしたが… VRAMが2GBというのがそろそろ時代遅れになってきているのかもしれません。
PCを組んだ当初は二束三文で売られていたRadeon HD4xxxか5xxxあたりのグラボを使っていましたが、そのVRAMが512MBぐらいしかなかったことを考えると隔世の感があります。&lt;/p&gt;

&lt;p&gt;当然ながらVRをプレイしようと考えるのは無理があります。&lt;/p&gt;

&lt;h3 id=&#34;電源:14cdc902344e522bd60455484bb9d961&#34;&gt;電源&lt;/h3&gt;

&lt;p&gt;どのモデルだったか忘れました。
500Wのものですが、一度壊れたので換装しています。&lt;/p&gt;

&lt;h3 id=&#34;ストレージ:14cdc902344e522bd60455484bb9d961&#34;&gt;ストレージ&lt;/h3&gt;

&lt;p&gt;SSD: CFD CSSD-S6T512NHG6Q (512GB)&lt;br /&gt;
HDD1: HGST HDS721050CLA362 (500GB)&lt;br /&gt;
HDD2: TOSHIBA DT01ACA300 (3TB)&lt;/p&gt;

&lt;p&gt;最初は500GBのHDD1個のみで、2015年春に512GBのSSDを、そして今年に入って3TBのHDDを増設しました。
現在はSSD上にWindows10をインストールして使用しています。
SSDは登場当初に比べて随分安くなった印象です。
5年ほどひたすら値下がりを待ってようやく私が512GBのSSDを購入した時点で3万円程度でしたが、今は512GBを2万円台前半で買えるようです。&lt;/p&gt;

&lt;p&gt;SSD化までは500GBのHDD1本だけで運用していましたが、通電時間2万時間越えのこのHDDは今でも不良セクタが1つもなくとても健康な状態のようです。&lt;/p&gt;

&lt;h3 id=&#34;光学ドライブ:14cdc902344e522bd60455484bb9d961&#34;&gt;光学ドライブ&lt;/h3&gt;

&lt;p&gt;Pioneer BDR-207JBK&lt;/p&gt;

&lt;p&gt;BD対応ドライブです。光学ドライブもやはり交換頻度は少ないだろうと踏み、やや性能の高いものを採用しています。
1万円台中盤程度で、十数万円をどうにか絞り出してPCを組んだ当初これを買っている余裕はなかったため、OSのインストール等は手元にあったUSB外付けDVDドライブでなんとかしのぎ、資金力の回復を待った上で後付けで購入しました。
耐久性も良好ですし性能も高く良い感じですが、PCケースと干渉してディスクトレイがうまく開かないことがあるのが玉に瑕。&lt;/p&gt;

&lt;h3 id=&#34;pcケース:14cdc902344e522bd60455484bb9d961&#34;&gt;PCケース&lt;/h3&gt;

&lt;p&gt;Antec SOLO II&lt;/p&gt;

&lt;p&gt;音が静かで、見た目が好みで、作りが良いです。
最初は似た価格帯のケースが半額で売っていたので買って使っていましたが、サイドパネルがペラペラだったり購入後すぐ前面の開閉部分が壊れたりあまり作りが良くなかったり裏側配線ができなかったりして投げ捨てたので、今使っているこのケースは非常に満足しています。
唯一前面パネルのUSBポートの作りがやや甘かったのか、購入から1年しないぐらいでUSB2.0のポートが1つ潰れました。&lt;/p&gt;

&lt;h2 id=&#34;周辺機器構成:14cdc902344e522bd60455484bb9d961&#34;&gt;周辺機器構成&lt;/h2&gt;

&lt;p&gt;画像再掲&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/12/07/img02.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/12/07/img02.jpg&#34; alt=&#34;自作PC外観(卓上)&#34; width=&#34;600&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;モニタ:14cdc902344e522bd60455484bb9d961&#34;&gt;モニタ&lt;/h3&gt;

&lt;p&gt;EIZO FORIS FS2333 2枚&lt;/p&gt;

&lt;p&gt;23.5インチ2枚のデュアルディスプレイ編成です。
最近FS2333の同ディスプレイ2枚体制の構築を達成しました。
このディスプレイは使い勝手もよく文句なしです。&lt;/p&gt;

&lt;h3 id=&#34;スピーカー:14cdc902344e522bd60455484bb9d961&#34;&gt;スピーカー&lt;/h3&gt;

&lt;p&gt;Logicool Speakers Z130&lt;/p&gt;

&lt;p&gt;とくにこだわりもなくずっと使ってますが、モニタ内臓のスピーカーよりはよっぽど良いですし値段も安かったため満足しています。
音楽は作業中にアニソンを流す程度であまり聴きません。&lt;/p&gt;

&lt;h3 id=&#34;トラックボール:14cdc902344e522bd60455484bb9d961&#34;&gt;トラックボール&lt;/h3&gt;

&lt;p&gt;サンワサプライ MA-TB38&lt;br /&gt;
エレコム M-DT1URBK&lt;/p&gt;

&lt;p&gt;トラックボーラーです。&lt;br /&gt;
サンワサプライのMA-TB38は私の愛機で、5年ぐらい使い続けた結果ホイールが壊れたため現在は2機目です。
標準の金属支持球をセラミック球に交換した上でゴムシートによる安定化を図る改造も施しており、何度も試行錯誤した結果改造ノウハウもたまっています。&lt;br /&gt;
大玉トラックボールとしては珍しいマウスホイール搭載機であり、多くのトラックボールが抱える「ホイールクリックボタンがない」という重大な欠点を解消しつつも非常に良好な操作性を誇り、また個体差や欠陥構造を有しているものの簡単な改造でそれを補えるため、現状これ以外の選択肢はほとんど考えられません。
現時点で既に製造終了モデルとなっているのが残念なところです。&lt;/p&gt;

&lt;p&gt;エレコムのトラックボールは1代目のMA-TB38が故障した頃にちょうど新しく出たモデルだったので、ちょっと気になってつなぎ兼予備として購入。有線モデル特有の欠点として、耳を近づけるとわずかにコイル鳴きが聞こえるのが難点。
使い勝手は悪くないですが、結局2代目のMA-TB38を確保してからはほとんど使っていません。&lt;/p&gt;

&lt;h3 id=&#34;キーボード:14cdc902344e522bd60455484bb9d961&#34;&gt;キーボード&lt;/h3&gt;

&lt;p&gt;Skydigital NKEY-P&lt;/p&gt;

&lt;p&gt;買い換えよう買い換えようと思いつつ、なかなか良いキーボードが見つからないため結局5年ぐらい使い続けています。
安価かつゲーミング向きという観点からこのキーボードを選びましたが、5000円程度で全キー同時押し対応、反応速度が向上するゲームモード搭載、着脱式のパームレスト付きと、値段に対してやたらと尖った性能をしておりコストパフォーマンスは非常に高かったのでは無いかと思っています。&lt;/p&gt;

&lt;p&gt;流石にスペースキーの調子が悪かったり一部キーが押しづらくなったりしてきているので、いい加減に買い換えを検討中です。&lt;/p&gt;

&lt;p&gt;現在の買い換え候補は、2017年に発売が予定されている&lt;a href=&#34;http://www.realforce.co.jp/&#34;&gt;REALFORCE RGB&lt;/a&gt;の日本語配列版です。
REALFORCEシリーズのゲーミング向けモデルがついに発売されるということで、非常に注目しています。&lt;/p&gt;

&lt;h3 id=&#34;ゲームパッド:14cdc902344e522bd60455484bb9d961&#34;&gt;ゲームパッド&lt;/h3&gt;

&lt;p&gt;Microsoft Xbox 360 Controller for Windows&lt;/p&gt;

&lt;p&gt;もはやデファクトスタンダードといってもよさそうな定番コントローラーで、値段の安さも驚くべきことです。
ただドライバ周りに少し癖があり、公式ドライバと非公式ドライバの両方を使い分けたほうがいい場合があったりする点には注意が必要です。&lt;/p&gt;

&lt;h2 id=&#34;今後:14cdc902344e522bd60455484bb9d961&#34;&gt;今後&lt;/h2&gt;

&lt;p&gt;一度自作PCを組むと、いくらでも機能を向上させたくなるために際限なく金が吸われます。&lt;/p&gt;

&lt;p&gt;今最も買い換えたいのはキーボードで、Razerの&lt;a href=&#34;http://www.razerzone.com/jp-jp/gaming-keyboards-keypads/razer-blackwidow-chroma&#34;&gt;BlackWidow Chroma&lt;/a&gt;を購入候補として検討していましたが、Razerの緑軸はやや打鍵音が強すぎますし、一方でオレンジ軸は自分の好みとは遠い感じでした。
そこで前述したように&lt;a href=&#34;http://www.realforce.co.jp/&#34;&gt;REALFORCE RGB&lt;/a&gt;が近々発売されるということを知ったため、今のところはこれの発売と評価を待っている状況です。
あまりに期待値を下回った場合は&lt;a href=&#34;http://www.razerzone.com/jp-jp/gaming-keyboards-keypads/razer-blackwidow-chroma&#34;&gt;BlackWidow Chroma&lt;/a&gt;を買うことになるかも。
そんなにキーボードを光らせたいのか。&lt;/p&gt;

&lt;p&gt;あとはグラフィックボードのVRAMまわりに若干の力不足を感じていますが、そんなに最新のゲームをやりまくるわけでもないですし(Steamでなかなか割引されないので)、最新かつ高いグラフィックを要求するゲームのプレイ頻度がそう高くないので今のところ現状で問題はあまりない気もしています。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>aragoのHIROic ChallengeでのFreecivプレイレポ 前編</title>
      <link>http://tatamo.81.la/blog/2016/09/29/freeciv-arago-challenge-01/</link>
      <pubDate>Thu, 29 Sep 2016 23:00:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/09/29/freeciv-arago-challenge-01/</guid>
      <description>
        

&lt;p&gt;&lt;a href=&#34;https://www.arago.co/hiro-freeciv&#34;&gt;aragoのFreeciv Strategy Challenge&lt;/a&gt;の企画である&lt;a href=&#34;http://hiroic.arago.co/&#34;&gt;HIRO-ic CHALLENGE&lt;/a&gt;に参加しています。
これは「人間の思考をコンピュータ向けに翻訳する」といわれるHIROというAIのトレーニングを行うための企画です。
私はゲームをプレイする参加者として、aragoのメンバーから担当者を一人割り当てられ、その人に観戦してもらいながら通常のAIとの対戦を行います。&lt;/p&gt;

&lt;p&gt;決められた2回のゲームのうち1回を既に終えたので、プレイレポ的なものを書きます。
とはいえ、ゲーム自体は単なるAI戦なのであまり面白みはないかもしれません。&lt;/p&gt;

&lt;p&gt;ゲーム外に付随する要素として、ゲーム中は担当者とSkypeで常に通話(webカメラなどは持ってないのでAndroidのアプリを使用)、さらにWebexのミーティング機能を使用してスクリーンを担当者と共有しながらプレイします。
また、プレイヤーの行動に対して担当者がいろいろと聞いてくるので、行動の理由や目的などについて説明しながらプレイを続けます。
始まってからしばらくすると、特に求められるでもなく自分から現在行っている行動とその意図を解説し、さらに質問をされた場合に適宜答える、といった形式でゲームが進んでいくように。3時間喋りっぱなし。まるで実況者とかそういう人みたい。
なお、担当者とのやりとりはメール、Skypeでの通話ともにすべて英語で行っています。&lt;/p&gt;

&lt;p&gt;「人にもよるが、一回のプレイには8時間から12時間かかる」という旨を伝えられましたが、私は一度目のゲームは3時間のセッション2回の計6時間で終わりました。&lt;/p&gt;

&lt;p&gt;以下プレイレポ。&lt;/p&gt;

&lt;h2 id=&#34;ゲーム概要:991cc667eabf7ea7d3c5eb1f19c43440&#34;&gt;ゲーム概要&lt;/h2&gt;

&lt;p&gt;人間1、AI3の計4プレイヤーでの対戦。AIの難易度はnormal。
シナリオマップの「地球(古典的/小型)」を使用。
それ以外は基本的にすべてデフォルト設定。&lt;/p&gt;

&lt;h3 id=&#34;スクリーンショット:991cc667eabf7ea7d3c5eb1f19c43440&#34;&gt;スクリーンショット&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/09/29/bd3929d405c6b3f99b07fcbf734d8468.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/09/29/bd3929d405c6b3f99b07fcbf734d8468.png&#34; alt=&#34;スコア&#34; width=&#34;700&#34;&gt;&lt;/a&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/09/29/b959cf03d4fe11810910486956610ac7.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/09/29/b959cf03d4fe11810910486956610ac7.jpg&#34; alt=&#34;本土&#34; width=&#34;700&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;序盤:991cc667eabf7ea7d3c5eb1f19c43440&#34;&gt;序盤&lt;/h2&gt;

&lt;p&gt;自分に割り当てられた民族はスー族。ほかのプレイヤーはケルト、シュメール、それからエチオピアあたりの民族だったので、自分だけ北米大陸、ほかは全員ユーラシアという恵まれた立地。
五大湖の西岸付近でスタートしたので、湖岸に首都を建設し、さらに東に進んでカナダ東岸付近に第二都市を建設。
研究は陶器→アルファベット→筆記→葬儀→地図→法律→君主とし、神秘主義・航海・兵法を適当なタイミングでとりつつ交易を取得する方針。&lt;/p&gt;

&lt;p&gt;最序盤は基本的に全都市で開拓者を生産し続け、労働者はひたすら道路建設。また陶器の完了後は開拓者だけでなく労働者も作成し、北米大陸全土を繋ぐ道路網の建設を進める。
小屋がないので最序盤に科学が急にジャンプしたりすることもないため、ゆったりとした立ち上がりとなり、道路を引き切るだけの時間は十分に得られた。
道路を引き終えた後は、大量の労働者を使って大陸各地で地形改善を行わせる。
ちょうど10都市作れたら開拓者の生産をストップさせ、このころには地図を取得していたのでトライリームを生産して探検を進める。&lt;/p&gt;

&lt;p&gt;北極海に沿って東に進み、他大陸の文明であるケルトと接触。またしばらく後になってケルトよりも大陸の東に位置するシュメールと接触する。
ケルトの南のそう遠くない位置にエチオピアも存在したが、中盤以降になるまで接触は持たず。
この新しい大陸のことを&amp;rdquo;New World&amp;rdquo;、つまり新大陸と呼ぶことにした。
新しく接触した文明とは基本的に停戦を維持。のちにケルト・シュメールから和平を求められたので合意。&lt;/p&gt;

&lt;h2 id=&#34;中盤:991cc667eabf7ea7d3c5eb1f19c43440&#34;&gt;中盤&lt;/h2&gt;

&lt;p&gt;とりあえず税多めに振って全都市でキャラバン生産。それとトライリーム。
北極海ルートでキャラバンを全力輸送し、ケルトやシュメールと交易路を引く。
何を考えたかこの時期にケルトと和平を結んでしまったので、ケルト都市に接岸しづらくなり交易が少しばかり面倒に。
交易路を引き切ったあたりで工学→火薬→民主主義の研究が完了したので、得られた経済力と交易ボーナスを投入して港→市場を全都市に揃えつつ、民主化。&lt;/p&gt;

&lt;p&gt;民主化が完了した段階でプレイ開始から3時間が経過したため、ここで一日目は終了。およそターン90からターン100。&lt;/p&gt;

&lt;p&gt;二日目、民主化が終わった直後なのでそのまま祝典に突入。
研究を止めて上水道や必要な建造物なども買い揃え、全都市サイズ12に(実際は1都市だけサイズ11で止まった)。
のんびりと民主化して祝典まで済ませたにもかかわらず哲学はまだ発見されておらず、哲学ブーストで大学を取得。
ついでに経済も予め取っておき、また研究を止めて証券取引所と大学を買い揃える。&lt;/p&gt;

&lt;p&gt;そして研究を再開、爆薬および鉄道を取得、鉄道網を設置する。
その後磁気学を取得、鉄道網が完成しきらないうちに3本目の交易路を引き始め、それを引き切らないうちに工業化→株式会社の研究が完了して4本目の交易路もほぼ同時に引くことに。
また金も余り気味だったため適当にトラックを集めてニュートンの学士院を建てたり、トラックを作るのも面倒になってリチャードの十字軍遠征をそのまま購入したりした。
さらに株式会社取得後に下水道を研究、上陸戦→小型化→無線通信の研究を進めながら同時に2回目の祝典も行う。
そういえばダーウィン取るの忘れてた。&lt;/p&gt;

&lt;h2 id=&#34;終盤:991cc667eabf7ea7d3c5eb1f19c43440&#34;&gt;終盤&lt;/h2&gt;

&lt;p&gt;気が付けばロケット工学の研究まで終わっていたので、首都にマゼランの探検航海と自由の女神を建造。
空母2隻+AWACS1機+輸送艦3隻+イージス巡洋艦1隻+潜水艦数隻を用意する。
そしてケルトとの和平条約を破棄、手始めにケルトによってアメリカ大陸付近に建設されていた都市を占領。そしてついに、アメリカの先住民族であるスー族は戦闘機主体の空軍力によって「新大陸」への侵略を開始する。
とにかく大陸が大きいので占領作業に時間がかかるものの、同時期に実用化したヘリコプターや機甲部隊も使用して攻撃。
都市数が増えすぎたのでJSバッハの大聖堂なども建ててみたものの、それでも暴動が起きないようにするには60%程度の贅沢が必要だったのでこれは諦め、自由の女神パワーで体制転覆から即座に民主主義復活を繰り返す。&lt;/p&gt;

&lt;p&gt;大陸東部まで侵攻し、内戦によって新たに誕生したヴァイキング、バビロニアとともにケルトおよびシュメール滅亡。
そしてエチオピアにも攻撃を開始。
戦闘機の損耗が激しく30機程度しか残っていなかったうえ、エチオピア都市にマスケット兵が山ほど配置されていたためにやや苦戦する。しかし前線都市で巡航ミサイルを買って毎ターン撃ちまくっているうちに大陸全土の制圧を完了。
マダガスカルとかスリランカあたりに存在したエチオピア都市を空挺降下で占領し、エチオピア滅亡。&lt;/p&gt;

&lt;h2 id=&#34;ゲーム終了:991cc667eabf7ea7d3c5eb1f19c43440&#34;&gt;ゲーム終了&lt;/h2&gt;

&lt;p&gt;170T程度でスー族を除く全文明が滅亡したため、スー族の勝利でゲーム終了。
3時間のセッションのうちちょうど2時間50分を過ぎたあたりで、区切りよく2回のセッションで1ゲームが終わる形となった。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>FreecivCalc2を公開しました</title>
      <link>http://tatamo.81.la/blog/2016/05/26/freecivcalc2-released/</link>
      <pubDate>Thu, 26 May 2016 15:47:37 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/05/26/freecivcalc2-released/</guid>
      <description>
        

&lt;p&gt;Freecivのユニット同士の戦闘勝率を手軽に行えるソフトであるFreecivCalcの新バージョン、FreecivCalc2を公開しました。&lt;/p&gt;

&lt;p&gt;FreecivCalc2: &lt;a href=&#34;http://tatamo.81.la/freecivcalc2/&#34;&gt;http://tatamo.81.la/freecivcalc2/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以前から公開していた&lt;a href=&#34;http://m06t625.81.la/files/FreecivCalc.html&#34;&gt;FreecivCalc&lt;/a&gt;はSilverlight上で動作するソフトのため、現状では動作するブラウザがほとんどなくなってきています。&lt;/p&gt;

&lt;p&gt;そこでHTML5+JavaScript/TypeScriptに移植し、機能やインターフェースを大幅に見直したFreecivCalc2を開発しました。&lt;/p&gt;

&lt;p&gt;Chrome, Opera, Firefox, Edgeでの動作を確認しています。&lt;/p&gt;

&lt;h2 id=&#34;freecivcalc2の新機能:0fe09111c483b88d0d4fda3fcdc49d63&#34;&gt;FreecivCalc2の新機能&lt;/h2&gt;

&lt;p&gt;FreecivCalc2の画面からユニットを選択し、各種補正情報を入力することで戦闘勝率を表示できます。また詳細結果タブを開くことで、戦闘後のユニットHPの期待値を表示できるほか、タブを保持しておくことで復数の戦闘の予測結果を見比べることなどができます。&lt;/p&gt;

&lt;p&gt;従来バージョンでは、地形による防御ボーナスの適用の可否や特定のユニット同士の戦闘にかかる特殊補正などの補正の情報を手動で入力する必要がありました。
FreecivCalc2ではこれらの特殊補正は自動で適用されるため、Freecivの複雑な戦闘補正を十分に把握していない場合でも正確に戦闘勝率の予測が可能です。
ユニットにかけられている補正の一覧は、詳細結果タブ内で確認することができます。&lt;/p&gt;

&lt;h2 id=&#34;複数の言語-多様なルールセットに対応可能な拡張性:0fe09111c483b88d0d4fda3fcdc49d63&#34;&gt;複数の言語、多様なルールセットに対応可能な拡張性&lt;/h2&gt;

&lt;p&gt;戦闘補正の自動適用を実現するために、ユニットの情報や補正の条件など、ルールセットに関連するすべての情報を外部データ化しました。
これによってclassicルールセットだけでなく、多様なルールセットに対応することが可能です。
同時に、FreecivCalc2のインターフェース部分もテンプレートを用いて外部ファイルからコンテンツ内容を流し込んでいるため、容易に多言語化が可能になっています。&lt;/p&gt;

&lt;p&gt;現状では、classicルールセットを日本語および英語の2か国語で対応しています。&lt;/p&gt;

&lt;h2 id=&#34;開発について:0fe09111c483b88d0d4fda3fcdc49d63&#34;&gt;開発について&lt;/h2&gt;

&lt;p&gt;FreecivCalc2は三条項BSDライセンス下で公開されています。&lt;/p&gt;

&lt;p&gt;ローカル環境でのビルド、他のルールセットや言語に対応させるためのデータセットの文法などについては&lt;a href=&#34;https://github.com/Tatamo/freecivcalc2&#34;&gt;GitHubリポジトリ&lt;/a&gt;上で記述しているため、そちらを参照してください。&lt;/p&gt;

&lt;p&gt;FreecivCalc2は大半をTypeScriptで、jQuery UIのウィジェット定義など一部を生のJavaScriptで書いています。&lt;/p&gt;

&lt;p&gt;また使用したライブラリはjQuery, jQuery UI, amChartsです。
当初jQueryを使う予定はなかったのですが、ユニット選択用のUIとしてコンボボックスを実現するためのライブラリを探していたところjQuery UIが最も用途に適っていたため採用し、その流れでjQueryも使用することになりました。
amChartsは簡単にグラフを表示できるライブラリとして使いやすそうだったため使用しました。&lt;/p&gt;

&lt;p&gt;その他、外部JSONファイルからテンプレートを通してHTMLファイルを生成するためのテンプレートエンジンとしてEJSを使用しました。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Freecivオンラインプレイ解説 最初の都市を建設するまで</title>
      <link>http://tatamo.81.la/blog/2016/02/20/freeciv-build-first-cities/</link>
      <pubDate>Sat, 20 Feb 2016 02:39:08 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/02/20/freeciv-build-first-cities/</guid>
      <description>
        

&lt;p&gt;日本のオンライン環境で主流となっている一人一島の島嶼戦マップにおける、ゲーム開始直後のユニットの動かし方およびマップの探索についての解説です。
ゲームが開始してから、最初の2都市を建設するまでの流れを説明します。&lt;/p&gt;

&lt;h2 id=&#34;事前情報:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;事前情報&lt;/h2&gt;

&lt;p&gt;今回の本土となる島のスクリーンショットです。本来はゲーム開始時に知ることのできない情報ですが、題材とする島の広さを把握していただくために掲載します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img01.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img01.png&#34; alt=&#34;初期配置(観察状態)&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ゲーム設定は、マップの生成方法：島ベース、開始地点の決定方法：大陸のサイズに合わせる、サイズ1、プレイヤー数7、丘/山の量0、小屋(先住民の集落)なし、(科学タブ)科学技術係数200%。
最小限の設定変更で、かつ日本のオンライン対戦で主流の設定と近いマップが生成されるようにしています。&lt;/p&gt;

&lt;h2 id=&#34;0ターン目:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;0ターン目&lt;/h2&gt;

&lt;h3 id=&#34;生まれ落ちる:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;生まれ落ちる&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img02.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img02.png&#34; alt=&#34;初期配置&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;さて、あなたの文明がこの地に生まれ落ちたばかりの状態です。
一つ上の章でこの島の全景の画像が掲載されているようですが、忘れてください。
ゲーム開始直後、あなたはせいぜい周囲2タイル程度の情報しか知りません。&lt;/p&gt;

&lt;p&gt;今回の解説は、この状態から数ターンの間にどのようにユニットを動かし、マップを探索し、都市を建設するかを主眼に置いています。&lt;/p&gt;

&lt;h3 id=&#34;ユニットを動かす前に:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;ユニットを動かす前に&lt;/h3&gt;

&lt;p&gt;さて、あなたはすぐにでも手持ちの探検家ユニットを動かして、この暗い世界を少しでも明るく照らしたいと思ったかもしれません。
しかし、ちょっと待ってください。
どの方向にユニットを動かすのが最善なのでしょうか？&lt;/p&gt;

&lt;p&gt;探検家は1ターンに3タイル移動することができるので、最初のマップ探索の主力は探検家になります。
この貴重な探索ユニットを明後日の方角に向かわせてしまい、また元の場所に戻ってくるのに2ターンかかったとしたらどうでしょう？
より効率的に探索を行っていたならば、6タイルも向こう側の地形の情報を得られたかもしれません。
まずは、探検家をどの方角に向かわせるのが最善かを考えましょう。&lt;/p&gt;

&lt;p&gt;今得られている狭い視界だけで、今回の島がどのような形なのかを予想してみるのは良い方法です。
(もっとも、予想を立てるにしても、自分の島がおおよそどのくらいの広さなのかはおおよそ把握できておいたほうがいいと思われます。
しかしそれは、ゲームやゲームの設定に少し慣れていないと難しいことだと思います。
なので最初はだいたいでいいのです。)&lt;/p&gt;

&lt;p&gt;この島はどんな島なのでしょうか？わくわくしますね。&lt;/p&gt;

&lt;p&gt;おそらく、南東の方角に陸地がずっと続いている、というわけではないでしょう。
どう考えても南東には海が広がっています。こんな方向に探検家を向かわせる必要はありません。&lt;/p&gt;

&lt;p&gt;では北西は？
こちらはかなり向こうまで陸地が続いている可能性があります。
南東の海岸線がすでに見えているのですから、北西側の海岸までは距離が開いていると考えるのは妥当でしょう。
(もっとも、かなり細長い島が生成されることもそう珍しくはありません。だいたいの予想でいいのです。)&lt;/p&gt;

&lt;p&gt;北東、および南西方面はちょっと悩みどころです。
どちらの方向にも海岸線は見えていませんから、どれだけ陸地が続いているかはわかりません。
もちろん、陸地はいま見えている部分だけで、それより先は海、ということもあり得ます。&lt;/p&gt;

&lt;p&gt;どうやら、南東以外の方向に探検家を進ませるのがよさそうです。
といっても、北東、北西、南西と考えるだけでも、3つも選択肢が残っています。
ほかの情報も考慮して、どちらの方向へ探索を行えばいいのか考えていきましょう。
いったい、いつになればあなたのユニットは栄光ある一歩を踏み出すことができるのでしょう？&lt;/p&gt;

&lt;p&gt;まず、喫緊の課題として、あなたは帝国の最初の都市、つまり首都を建設する場所を決めなければいけません。
また初期ユニットの開拓者は2つありますから、2つ目の都市を建設する場所も考えてあげるべきでしょう。
文明に都市が1つもない状態を長く続けるべきではありません。
そのため、既に今見えているタイルのうちのいずれかに首都を建設するべきである可能性は高いと言えます。&lt;/p&gt;

&lt;p&gt;もう一度、あなたの狭い視界が何を捉えているかを確認しましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img02.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img02.png&#34; alt=&#34;初期配置&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;西側にキジがありますね？
キジは専制政治下でも2/2/0と、要求を満たせるだけの食料、そして森の高い生産を両立できるとても優秀なタイルです。
もっとも、キジの上に直接都市を立てるのはあまり得策ではなかったり、また丘都市や森都市と併用すると産出される交易が0になってしまったりもしますが。
しかしそれはこのキジ(変換ミスではありません)の趣旨からは外れるため、詳しい解説は行いません。&lt;/p&gt;

&lt;p&gt;ともかく、キジは首都の都市圏内に含めるタイルとしては非常に良い特産物です。
このキジを首都で利用できるようにすることを考えましょう。
では、探検家をこのキジの近くに移動させればいいでしょうか？
とはいっても、南西方向に向かえばいいでしょうか、それとも北西方向に向かえばいいでしょうか。
そろそろ考えるのが面倒になってきたでしょうし、とりあえず探検家をキジの真上に移動させてみるのなんてどうでしょう？&lt;/p&gt;

&lt;p&gt;ここで、特に島嶼戦マップにおいては、都市をより海岸に寄せて建設するべきであるというセオリーを思い出しましょう。
これまた本記事の趣旨ではないので詳しい解説は見送りますが、より海に寄せて都市を建設することで、将来的に多くの海洋タイルを利用できる、国家の総面積が広がる、遠くまで見渡せるなどのメリットがあります。
なので、意気揚々と探検家を向かわせた先が内陸部であったなら、島嶼戦マップではあなたはちょっとがっかりするべきです。&lt;/p&gt;

&lt;p&gt;となると、海岸線に沿って探検家を移動させれば、移動した先も海岸に違いありません。
これはだいたい正しいのですが、完全に海岸線沿いにユニットを移動させた場合、ユニットの視界には退屈で変わり映えしない海がずっと映りつづけることに注意してください。
海岸線を把握することと同等に、陸地に何があるかを知ることも重要です。
あまりにべったりと海に沿って探検家を移動させることは、やはり得策とは言えません。
また、海岸線沿いに探検家を移動させていった場合、ユニットが半島の袋小路に入ってしまうこともあります。
そうなると同じタイルを往復するぶんの移動が無駄になってしまうので、その点にも気を付けたほうが良いでしょう。&lt;/p&gt;

&lt;p&gt;また、先ほど島の形を大まかに予想した際、北西方向にはしばらく陸地が続いている可能性が高い、と考えました。
仮に3タイル進んでも対岸が見えなかったとして、そんな内陸部に首都を建設するのはややセオリー外です。&lt;/p&gt;

&lt;p&gt;というわけで、あなたのユニットの記念すべき一歩は、探検家を西に移動させることで決定です。&lt;/p&gt;

&lt;h3 id=&#34;記念すべき一歩:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;記念すべき一歩&lt;/h3&gt;

&lt;p&gt;では早速……&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img03.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img03.png&#34; alt=&#34;最初の移動?&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ちょっと待ってください！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;どれだけ引き延ばせば気が済むのか、と考えているかもしれませんが、ちょっと待ちましょう。
特に最初のターンは、一気に探検家を複数タイル移動させるべきではありません。
1タイル移動するだけでも視界は広がるので、それを考慮すれば次に移動する最善のタイルが変わってくるかもしれません。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img04.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img04.png&#34; alt=&#34;(今度こそ)最初の移動&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;まあ、大して驚愕の事実などはありませんでしたが。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img05.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img05.png&#34; alt=&#34;2歩目は何処へ?&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;マーカーをつけた2つのタイルのうち、次にどちらへ向かうかは難しい問題です。
つまり深く考える必要はないということです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img06.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img06.png&#34; alt=&#34;2歩目&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;南へ移動したところ、そこが半島になっていることがわかりました。
&lt;strong&gt;当然、&lt;/strong&gt;3歩目の移動は北西の草原にでも向かわせましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img07.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img07.png&#34; alt=&#34;3歩目&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;これで南西方向の視界は晴れました。
そしてあなたの探検家は疲れ果てています。
残りのユニットをどう動かすかを考える時間です。&lt;/p&gt;

&lt;h3 id=&#34;首都-予定地-に開拓者を向かわせる:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;首都(予定地)に開拓者を向かわせる&lt;/h3&gt;

&lt;p&gt;首都は南西部に建設すると大まかに決まっています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img08.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img08.png&#34; alt=&#34;首都建設候補地&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;クジラを都市圏内に入れることは良いことですし、普通は都市は草原か平野に建てるのが妥当です。
この2か所のうちどちらかに首都を建てることになるでしょう。
まあどちらにせよ開拓者を動かす場所は変わりません。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img09.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img09.png&#34; alt=&#34;首都のための開拓者移動&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ここで、2つの候補地のうちどちらに首都を建てるかを決めてしまう必要は&lt;strong&gt;ありません&lt;/strong&gt;。
次のターンになれば探検家を再度動かすことができ、それによってより多くの情報が得られるからです。
それらの情報も踏まえたうえで、どこに首都を建てるのかを判断します。&lt;/p&gt;

&lt;h3 id=&#34;2つ目の都市をどこに建てるかを考える:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;2つ目の都市をどこに建てるかを考える&lt;/h3&gt;

&lt;p&gt;さて、首都を建てる位置も(だいたいは)決まりました。
しかし、2つ目の都市をどこに建てるかはまだ考えていません。
考えましょう。&lt;/p&gt;

&lt;p&gt;都市と都市の間隔は、大いにプレイヤーの好みによるものの、桂馬飛びの場所に2つの都市が位置していても特に問題はないと一般に言われています。
問題ないというのは、2つの都市が遠すぎないという意味ではなく、近すぎないという意味です。
ここでは、記事を書いた人の好みのため、桂馬飛びよりも1タイルほど遠い位置に都市を配置していくことを考えたいと思います。&lt;/p&gt;

&lt;p&gt;もちろん、首都に向かった最初の開拓者と全く同じルートを2つ目の開拓者にも向かわせるのは得策とは言えません。
既に首都を建てる位置は(おおまかに)決まっているので、別の土地を探さなければいけませんし、そこはまだ闇の中です。
初期位置から東側に2つ目の都市を建てることを考えましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img10.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img10.png&#34; alt=&#34;第二都市建設候補地&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;考えるのもそろそろ面倒になってきています。
ちょうど初期地点の南東にいい感じの海岸があるので、ここに都市を建てるのがいいのではないでしょうか。&lt;/p&gt;

&lt;p&gt;おっと。この2つの候補地のうち、南側の草原に都市を建ててしまう場合、もし首都を南の平地に配置したならば桂馬飛びの位置になってしまいます。
実際、それは何の問題もないのですが、ここでは記事を書いた人がそれを嫌っているので、やめておくことにしましょう。
なんとも我が儘な理由ではありますが、都市の配置方法はプレイヤーによって非常に個性が出ると言われているもので、その個性というのも、だいたいこういった理由から生じているのです。&lt;/p&gt;

&lt;p&gt;では、平野のほうに2つ目の開拓者を向かわせることで良さそうです。
早速開拓者を1タイル東に向かわせて……&lt;/p&gt;

&lt;p&gt;本当にそれでいいのでしょうか？&lt;/p&gt;

&lt;p&gt;よく考えてみてください。
今検討しているのは、&lt;strong&gt;2番目の&lt;/strong&gt;都市の建設地点です。
このゲームでは最初に建設された都市が首都になりますから、2番目の都市は2番目に建設される必要があります。
(実際、これは非常に大きな問題です。
専制政治下では首都にのみ75%もの生産ボーナスが与えられる他、まあいろいろな違いが生じます。)&lt;/p&gt;

&lt;p&gt;ところで首都を建設するための開拓者は現在、まだその途上にいます。
次のターンに予定地に到達し、さらにその次のターンになってやっと首都が実際に建設されるでしょう。
ここで第二都市用の開拓者をすぐに予定地に向かわせても、1ターン余計に待っている時間が生じてしまうのです。&lt;/p&gt;

&lt;p&gt;たとえば、まだ見えていない北東部に、第二都市を建設するのにもっと適した場所があるかもしれません。
もちろん、そんなことを言っていて都市の建設が遅れては本末転倒です。
しかし現時点で1ターンの時間の余裕があるのですから、これは活用するべきです。&lt;/p&gt;

&lt;p&gt;非常に幸いなことに、初期地点から北東に向かって川が伸びています。
探検家以外の初期ユニットは通常、どれも1ターンに1タイルしか移動することができません。
しかし川に沿った移動は、移動力を1/3しか消費しません。
つまり川の上を移動する場合は、通常のユニットでも探検家のような移動力を得るというわけです。
この川を利用して、北東方向の視界を広げてみましょう。&lt;/p&gt;

&lt;p&gt;とはいえ、開拓者をいきなり探索に向かわせるのは、往々にして避けるべきです。
こんなところに移動するんじゃなかった、と思っても引き返すのに合計2ターンかかり、その遅れがそのまま都市建設の遅れに直結するためです。
なので、代わりに労働者を向かわせて先の様子を見させるのが良いでしょう。&lt;/p&gt;

&lt;p&gt;労働者の本分は労働なので、よくわからない未開の地に向かわせるよりも地形改善のための労働をするべきだ、と思われるかもしれません。
実際それは正しく、あまり長い間労働者に探検家の真似ごとをさせるべきではありません。
どこで労働者を探索に使うのをやめるか、というのはやや難しい問題です。
とはいえ、2都市目の建設予定地を探すために2体いるうちの片方の労働者を数ターン探索に割り当てるくらいは、全く問題ではないと言っていいでしょう。&lt;/p&gt;

&lt;p&gt;では早速……&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img11.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img11.png&#34; alt=&#34;労働者の探索?&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ちょっと待ってください！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;この期に及んで、1タイルずつ移動しろ、と言おうとしているのではありません。
そもそも、1タイル移動したところで見えるタイルが新しく増えるわけではなく、すべて既視圏内です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img12.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img12.png&#34; alt=&#34;ちょっとお得&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;川に沿っての移動は移動力を1/3しか消費せず、またユニットはたとえ移動力が1/3しか残っていなくても0でないならば移動ができます。
なのでこのように一度川に沿って移動した後に目的タイルに移動すれば、どちらも同じ1ターンの移動ですがより多く移動でき、見えるタイルが増えます。
小手先のテクニックですね。
とはいえ、ゲーム開始時の都市展開において、情報は非常に重要です。
1タイルでも広く見えるような、効率的な移動を心がけると良いでしょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img13.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img13.png&#34; alt=&#34;労働者の探索&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;北東方面では、あまり東のほうまで海岸線が続いているわけではなさそうです。
ところで、マーカーをつけた部分は視界外となっています。
まあこの海岸線の形を見れば、ここがきっと海だろうということは容易に想像できます。
なのでこのような場所を調べるために、特に最初の都市が建つ前は、わざわざ往復の手間をかけてユニットを向かわせるべきではないと言えます。&lt;/p&gt;

&lt;p&gt;もっとも、こういう海だろうと思った場所が海でなかった、ということは&lt;strong&gt;稀によくあります&lt;/strong&gt;。
仮にそのようなことが起こっても柔軟に対処できるよう、選択肢は広く持つようにしましょう。&lt;/p&gt;

&lt;p&gt;ここで良くないことに気付くのですが(実際のところ、とっくに気付いていておかしくなかったのですが)、先ほど想定していた平野に第二都市を建設した場合、どうやらクジラを得られないようです。
都市を建設したときに、食料2と生産1を産出するタイルを利用可能であることは非常に重要です。
当然本記事では詳しい解説は行いませんが。&lt;/p&gt;

&lt;p&gt;実際、都市を建ててみたら対岸にも土地があり、そこに付随していたクジラを利用できた、というラッキーは存在します。
しかしそれは都市を建ててはじめてわかることであり、頼るべきことではありません。
この場合、労働者を使って平野を灌漑する必要がありますが、平野の灌漑は意外と時間がかかり、その間都市は十分なタイル産出を得られないので、スタートダッシュに多少なりとも影響を及ぼします。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img14.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img14.png&#34; alt=&#34;第二都市の新たな建設候補地&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;このタイルに第二都市を建設してみるのはどうでしょうか？
もちろん、まだ周囲の視界が十分に得られていません。
次のターンに労働者を移動させることで、ようやく周囲のタイルがどのようであるかをある程度把握できるでしょう。
しかしここがなかなか良い立地である可能性もあります。
(その理由を問われればいろいろな要素を提示できますが、それはおおよそ、これまでのゲームの経験に基づいて類似する状況との関連性、および付随するマップ設定などの情報から有機的に導出したものであり、一般にそれは勘と呼ばれることがあります。)&lt;/p&gt;

&lt;p&gt;今労働者を動かした場所に開拓者を動かしたならば、どうでしょうか？
次のターンに労働者を北に1タイル動かして、そこが都市建設に適した場所かどうか知ることができます。
仮にそれが幻滅するような結果であった場合には、開拓者を南に動かせば元々の建設予定地に移動できますし、それでも首都が建つのと同じターンに第二都市を建設できます。
北のほうが都市建設に良さそうなタイルであれば、開拓者を北に動かすこともできます。&lt;/p&gt;

&lt;p&gt;優柔不断ではないか、と思われるかもしれませんが、1ターンのうちに得られる情報には限りがあります。
より多くの情報を得た状態で判断ができるなら、その選択肢を多めに用意しておくことは良いことではないでしょうか。&lt;/p&gt;

&lt;h3 id=&#34;最後の労働者を移動させる:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;最後の労働者を移動させる&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img15.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img15.png&#34; alt=&#34;移動していない最後のユニット&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;というわけで、2体目の開拓者もまた期待と不安の入り交じった旅路へと出発しました。
ところで、初期地点にまだ労働者が1ユニット残っています。
こいつを動かしましょう。&lt;/p&gt;

&lt;p&gt;ここで労働者をどう移動させるか、というのはやや難しい判断が必要なように思われます。
まず、第二都市がクジラを得られない可能性が高まっています。
その場合、近くの平野を速やかに灌漑しなければなりませんが、労働者2ユニットを同時に灌漑に充てれば作業時間は短く済みます。&lt;/p&gt;

&lt;p&gt;一方で、現時点で首都と第二都市の間は川で隔たりができています。
最初に2つの都市の間を道路で結ぶというのは悪くない選択であることが多いですが、今回は川に遮られるため道路を引くには迂回せざるを得ず、さらに次のターンの探索次第では都市と都市の距離が開く可能性もあります。
このような状況では、首都と第二都市との間でユニットを移動させるのに時間がかかります。
首都周辺でも地形改善の必要はありますが、労働者2ユニットともを東に向かわせてしまった場合、首都周辺のタイルを労働者で改善できるようになるまでにかなり時間がかかるでしょう。&lt;/p&gt;

&lt;p&gt;これらの状況や、今後どのタイルにどのような改善が必要か、ということも考慮して労働者をどう動かすか決める必要があります。
つまり、勘に頼るのがいいでしょう。&lt;/p&gt;

&lt;h3 id=&#34;0ターン目の移動の完了:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;0ターン目の移動の完了&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img16.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img16.png&#34; alt=&#34;最初のターン、移動終了&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首都周辺の地形改善ができない、例えば道路が引けないのは問題が多いと考えたため、2体目の労働者は西へ向かわせることにしました。&lt;/p&gt;

&lt;p&gt;これですべてのユニットが移動を終えました。
おめでとうございます。
あなたはようやく最初のターンを終えられます。&lt;/p&gt;

&lt;p&gt;まだ最初のターンであるにもかかわらず、これだけ多くのことを考えないといけないのか、とあなたはげんなりしているかもしれません。
ですが安心してください。
まず第一に、最初のターンだからこそ考えなければならないことが多くある、ということです。
次に、この記事の解説は無駄に冗長であるということです。
このようなろくでもない記事を長々と読む羽目になってしまったあなたの心中は察するに余りありますが、しかし記事が無駄に長ったらしいのであって、実際にたくさんのことをやらなければならないのだ、と悲観する必要はないと言えるでしょう。
では、最初のターンを終了しましょう。&lt;/p&gt;

&lt;h2 id=&#34;1ターン目:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;1ターン目&lt;/h2&gt;

&lt;h3 id=&#34;探索を進める:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;探索を進める&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img17.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img17.png&#34; alt=&#34;ターン1&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;さて、あなたのユニットは移動力を取り戻しました。
やはりまずは探検家を移動させましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img18.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img18.png&#34; alt=&#34;探検家を移動させる&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;やはり、1タイルずつ移動させていくのが良いと思われます。
しかしこれは、今探索している地域が最初に建てる都市から比較的近い距離にあるためです。
(つまり、探索の結果予期しない情報が手に入った場合には、都市を建設する位置を変更しなければならなくなる可能性も存在しているためです。)
一人一島ルールでは、序盤はほかのプレイヤーに干渉されることなく都市の展開が可能であり、先を越されるような心配はありません。
また初期ユニットの開拓者で都市を建ててから次の開拓者を生産できるようになるまでは、通常でも10ターン程度の時間がかかります。
それまでの間に探索を済ませ、次に都市を建てる場所を決められればいいのですから、次のターン以降は深く考えずに探検家を移動させて構いません。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img19.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img19.png&#34; alt=&#34;労働者による探索&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;さて、西岸の形がよりはっきりと明らかになってきました。
次は、島の東側の情報を得るために、労働者を移動させます。&lt;/p&gt;

&lt;h3 id=&#34;都市の建設地点を仮定してみる:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;都市の建設地点を仮定してみる&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img20.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img20.png&#34; alt=&#34;第二都市建設地点確定&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;労働者を北に移動させたところ、なんとクジラが発見されました。
また場所としても島の端にあたる位置のため、都市を建設するには最適といえます。
首都からの距離は開いてしまいますが、第二都市は北に建設することにしましょう。&lt;/p&gt;

&lt;p&gt;ところで、開拓者を北に移動させるのではなく、今開拓者が建っている場所に第二都市を建てる、という選択肢はないのでしょうか？
確かに首都の建設を待つためにこの開拓者は1ターンの間暇になりますが、それは大した問題とはいえません。
実際、ここに都市を建てたとしてもクジラは利用できます。ちょっとその場合を仮定してみましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img21.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img21.png&#34; alt=&#34;IF&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首都の位置を適当に決め、第二都市まで建設した状態です。
マーカーの地点に、「死角」が発生していることがわかるのではないでしょうか。
あなたの島の陸地に隣接した海タイルに死角をつくることは、非常に良くないことです。
これもまた詳しくは説明しませんが、ここに敵意を持った船が接岸してもあなたは気付くことができず、奇襲攻撃を受けて都市を占領されてしまう可能性があります。&lt;/p&gt;

&lt;p&gt;もっとも、少なくともあなたが島全体に都市を建設し終わるくらいまでは、船を出すことができるプレイヤーはいないでしょう。
そのため、3都市目以降でこの死角を埋めるような都市配置を行うことになります。
ですが今回の場合、この死角を埋めるのに妥当な都市の建設地点は一か所しかありません。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img22.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img22.png&#34; alt=&#34;編集モードで勝手に都市増やした&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;死角を埋めるためには、このように都市を配置することになります。
これらの都市はすべて桂馬飛びの位置になっていますから、距離が近すぎるということはありません。
なので、このような都市配置にすること自体はは何の問題もありません。
今回は記事を書いた人がもう少し都市の間隔が開いているほうが好きなので、この都市配置は採用しないというだけです。&lt;/p&gt;

&lt;p&gt;しかし、本当に注意していただきたいことは、&lt;strong&gt;最初の2都市を建てた時点で、次の都市の配置場所がただ一通りに決まってしまうことがある&lt;/strong&gt;ということです。
もちろん、その都市配置が良い都市配置であったなら、何も迷う必要はありません。
ただ、最初の2都市を建てた結果、次の都市を不本意な位置に建てなければならなくなるかもしれない、という可能性を頭に入れておいてください。&lt;/p&gt;

&lt;h3 id=&#34;首都を建設する場所を決める:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;首都を建設する場所を決める&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img23.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img23.png&#34; alt=&#34;結局、首都をどこに建てるのか&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;では、時間を巻き戻してみましょう。結局、あなたは首都をこの二か所のうち、どちらに建てるべきでしょうか？
実際のところ、それは私の知ったことではありません。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img24.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img24.png&#34; alt=&#34;首都IF&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;仮に、首都を草原に建てる場合を考えてみます。
ここに首都を配置した場合に死角となる海タイルをマーキングしています。
このタイルを視界内に収めるために考えられる次の都市の建設予定地は、草原マーカー二か所のいずれかとなります。
しかし、南西側の草原に都市を建てる場合は首都との距離が桂馬飛びの位置になってしまい、悪くはないのですが記事を書いた人の好みとは外れます。
また、北東側の草原はやや陸地がくぼんでいて湾のようになっています。
このような場所に都市を建てると、都市がやや内陸よりになってしまい、利用できる海タイルの数が減ってしまうということは直感的に感じられるのではないでしょうか。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img25.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img25.png&#34; alt=&#34;首都建設予定地&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;平野に首都を建設することを考えます。
この場合、マーカーをした地点の海タイルが死角となります。
都市の間隔が近くなりすぎることを嫌う場合、次に建設する都市はマーカーがしてある草原で確定します。
この草原は都市を建てるには良い場所のように思えるため、ここに首都を建ててしまうのは問題ないでしょう。&lt;/p&gt;

&lt;p&gt;以上の理由から、首都は平野に建設することに決定します。
もちろん決定のための判断材料には個人の好みが大いに含まれているため、実際にどのように都市を配置するかはあなたの考え次第です。
ですが重要なことは、最初に都市を建てる際、次の都市をどこに建てるのかも考慮に入れておくべきだ、ということです。
都市を建設した際の死角について考えることは、国防にとって重要であるだけでなく、次の都市の場所を大まかに想定するためにも役に立つため、意識しておくとよいと思われます。&lt;/p&gt;

&lt;p&gt;ところで、首都の北西部の草原に次の都市を建てることは決まりました。
しかし、この都市ではどうやらクジラを利用できなさそうです。
クジラがいない土地に都市を建てても良いのでしょうか？&lt;/p&gt;

&lt;p&gt;前述のとおり、最初の2都市を建てる際、クジラを都市圏内に収めることは重要です。
これは、食料2および生産1のタイルを都市建設直後から利用できるようにするためです。
しかし第三都市以降の建設までは、いちど都市で開拓者が完成するのを待つ必要があります。
つまり、それまでの間に労働者による地形改善で同等の産出を得られるタイルを用意することができます。
平野を灌漑すれば食料2、生産1が得られるので、都市圏内に平野が1つでも存在していれば3都市目以降の都市建設予定地としては次第点となるのです。
(なお仮に平野が存在しない場合、森を灌漑すれば平野に変化します。もちろん余計に時間ばかりかかるので、あまり嬉しい状況とは言えないでしょう。
森すら存在しないならば、湿地や草原を一度森に変え、そして平野に変える必要があります。もちろんこのような作業は完了までに非常に長い時間がかかります。
都市の圏内に草原と魚しかない、というような状況が予想される場合は、その都市の建設を後回しにし、先に他の場所に都市を建設するべきです。)&lt;/p&gt;

&lt;h3 id=&#34;1ターン目の移動の完了:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;1ターン目の移動の完了&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img26.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img26.png&#34; alt=&#34;ターン1移動終了&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;労働者の移動が残っていますが、首都からのユニットの移動が簡単になるように道路を建設するのがいいでしょう。
森や湿地といった険しい地形は道路を建設するのに時間がかかるため、可能であれば平地または草原に道路を引いていくのが良いかと思われます。
また、平地と草原は道路を引くことで交易にボーナスがつき、本来0ポイントの産出であるのが交易を1ポイント産出するようになります。
労働者の作業は1タイル移動→作業→1タイル移動を繰り返すのがよく、あまり移動に時間をかけてしまうと作業量が減ってしまいます。
なので道路を引きつつ、灌漑するべき平地にさしかかったときに道路建設と一緒に灌漑を行うのが良いでしょう。&lt;/p&gt;

&lt;p&gt;こうして、ターン1の行動も終了しました。&lt;/p&gt;

&lt;h2 id=&#34;2ターン目:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;2ターン目&lt;/h2&gt;

&lt;h3 id=&#34;はじめての都市建設:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;はじめての都市建設&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img27.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img27.png&#34; alt=&#34;都市建設完了&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;とうとう、都市の建設に成功しました！
このとき、首都から先に都市建設を行うことは絶対に忘れてはいけません。
(先に都市建設を行った都市が首都になるのですから、自己言及的な言い回しですね？)
キジがあることによって、首都は75%の生産ボーナスを得て、本来の生産3ではなく5もの生産力を得ているからです。
このように、生産ボーナスはもともとの生産が多ければ多いほど効果が高くなるので、キジや水牛といった高い生産が得られる特産物や、小麦などの多くの食料が得られる特産物(都市のサイズがより早く大きくなり、結果的に利用できるタイルが増えて生産力が上がります)が近くにあるほうを首都に選びましょう。&lt;/p&gt;

&lt;p&gt;なお、記事の趣旨からは外れますが、建設した直後の都市の生産物は二都市共に開拓者に変更しておきましょう。
また、研究する科学の決定を忘れてはいけません。
地図を研究目標にして、アルファベットの研究を開始しましょう！&lt;/p&gt;

&lt;p&gt;今回は開拓者がそれぞれ2回移動し、ターン2で都市を建てることができました。
最初の都市の建設はできるだけ早いほうがよく、今回は悪くないスタートだと言えるでしょう。
もっとも、開拓者の移動にもっと時間がかかることも、都市の建設に適した場所がなかなか見つからないこともあるでしょう。
ですが、T4くらいまでには第二都市の建設まで完了しておきたいものです。&lt;/p&gt;

&lt;h2 id=&#34;おわりに:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;今回の記事ではゲーム開始時に十分な視界が得られていない状態から、どのように最初の都市を建設していくかを解説しました。
記事の中でも幾度か触れたように、結果として得られた都市配置はプレイヤー自身の好みにも大きく左右されます。
なので、この記事からはゲーム開始時の思考の流れを汲み取って頂ければ幸いです。&lt;/p&gt;

&lt;p&gt;さて、これでこの記事の役割も終わりです。
これからあなたは島の探索を進め、地形の改善を進め、さらに都市を増やしていかなければなりません。
ですがやはり、それは私の知ったことではありません。
どうか頑張ってください。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>うくらいなにっき(Freecivマルチレポ) 2016/01/30</title>
      <link>http://tatamo.81.la/blog/2016/02/17/freeciv-2016-01-30/</link>
      <pubDate>Wed, 17 Feb 2016 22:35:10 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/02/17/freeciv-2016-01-30/</guid>
      <description>
        

&lt;p&gt;以前&lt;a href=&#34;http://sns.prtls.jp/freecivsnsneo/&#34;&gt;FreecivSNS&lt;/a&gt;でプレイレポートを投稿していましたが、今回より&lt;a href=&#34;http://tatamo.81.la/blog/&#34;&gt;本ブログ&lt;/a&gt;上で再開することにします。&lt;/p&gt;

&lt;p&gt;SNSには外部ブログの読み込み機能を利用して本記事の内容を後日投稿する予定です。そちらではコメントをつけていただくこともできます。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;序盤から同盟国を援護しつつ1国滅ぼし、そのまま続けて世界大戦に突入して勝利。&lt;/p&gt;

&lt;h2 id=&#34;ゲーム概要:28daa66540c07a81521e24fffe429e66&#34;&gt;ゲーム概要&lt;/h2&gt;

&lt;p&gt;2ch定期鯖(土曜夜)。不平等大陸マップ、プレイヤー数6。&lt;/p&gt;

&lt;p&gt;スコアログ：&lt;a href=&#34;http://ux.getuploader.com/freeciv2145/download/540/2016-01-30.log&#34;&gt;http://ux.getuploader.com/freeciv2145/download/540/2016-01-30.log&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;スクリーンショット:28daa66540c07a81521e24fffe429e66&#34;&gt;スクリーンショット&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/17/96731aa4ad3bb2936445da24bda4be54.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/17/96731aa4ad3bb2936445da24bda4be54.png&#34; alt=&#34;スコア&#34; width=&#34;700&#34;&gt;&lt;/a&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/17/0ece8e0f23652cef29112fdee3f8b66a.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/17/0ece8e0f23652cef29112fdee3f8b66a.png&#34; alt=&#34;民族一覧&#34; width=&#34;700&#34;&gt;&lt;/a&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/17/b112e302b4aae27a9dab717ab8d1457d.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/17/b112e302b4aae27a9dab717ab8d1457d.jpg&#34; alt=&#34;本土&#34; width=&#34;700&#34;&gt;&lt;/a&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/17/e5fb33d2d0525688fc7b37fef5289b4d.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/17/e5fb33d2d0525688fc7b37fef5289b4d.jpg&#34; alt=&#34;本土,北極&#34; width=&#34;700&#34;&gt;&lt;/a&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/17/b76e1c6b699420316618810450b9951f.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/17/b76e1c6b699420316618810450b9951f.jpg&#34; alt=&#34;他国&#34; width=&#34;700&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;序盤:28daa66540c07a81521e24fffe429e66&#34;&gt;序盤&lt;/h2&gt;

&lt;h3 id=&#34;ゲーム開始:28daa66540c07a81521e24fffe429e66&#34;&gt;ゲーム開始&lt;/h3&gt;

&lt;p&gt;ウクライナの初期配置は大陸の東側付近。西にフィンランド、東にハッカーと接触する。
フィンランド首都とは距離が開いていたため、大陸を東西に分けるように流れていた川を境界として領土を分けることを提案。
フィンランドはこれに合意し、互いに衝突は発生せず停戦。&lt;/p&gt;

&lt;p&gt;フィンランドとの国境線が画定したため、自国領を広く獲得するためにハッカーと国土を接する大陸東部への入植を優先させることに。
しかしここで、防衛がおそろかになっていたハッカーの第二都市が、ハッカー領北西部に領土を持つアッシリアの攻撃によって破壊される。
ハッカーは1都市のみに追い込まれ、アッシリアがハッカー方面に都市を建設、領土を拡大させる姿勢を見せる。&lt;/p&gt;

&lt;h3 id=&#34;ハッカーとの同盟:28daa66540c07a81521e24fffe429e66&#34;&gt;ハッカーとの同盟&lt;/h3&gt;

&lt;p&gt;都市数1のハッカーはアッシリアに対して圧倒的に不利であることは明らかであった。
仮にアッシリアがハッカーを滅亡させた場合、アッシリアとウクライナの国境線が接し、さらにハッカー攻撃に用いた兵力をもってウクライナへの攻撃が行われる可能性があった。
そこでハッカーの都市がアッシリアに破壊された直後、即座にウクライナはハッカーに対し同盟を打診。アッシリア-ハッカー間の戦争への介入を決定する。&lt;/p&gt;

&lt;p&gt;まだ大陸内の入植が完了していたわけではなかったため、弓兵数ユニットをハッカー首都に派遣しつつ、都市展開を優先させる。
ハッカーの注意が対アッシリアに向いていたため、ハッカーとウクライナの間にあった大陸東端の地帯はほぼすべてウクライナ領となった。&lt;/p&gt;

&lt;p&gt;兵法→石工術を研究したあとは通常通り筆記→君主制を目指す。
フィンランドとは不戦を保ちつつ、ハッカーに数学の研究を指示。
一時的に都市をハッカーに貸与して研究を加速させる。
数学の研究完了に伴って、アッシリア侵攻のため全都市でカタパルトの生産に入る。&lt;/p&gt;

&lt;h3 id=&#34;対アッシリア侵攻:28daa66540c07a81521e24fffe429e66&#34;&gt;対アッシリア侵攻&lt;/h3&gt;

&lt;p&gt;こちらが数学を取得するのと同時にアッシリアは車輪の研究を完了させる。
チャリオットによる視界外からの奇襲が想定されるため、ハッカーに警戒するよう指示。
ハッカーが前線に都市を建設しようと試みるが、ハッカーとアッシリアのプレイヤーの技量差のため何度も迎撃され失敗に終わる。
その間に本国でカタパルト8が完成、弓兵4とともにハッカー領に派遣する。
外交官を用いて敵の前線都市を調査したところ想定よりも防御ユニットが少なかったため、カタパルトを突入させ2都市破壊。
これによって元ハッカー領よりアッシリアを追い出すことに成功する。&lt;/p&gt;

&lt;p&gt;さらに進軍するためには川を越える必要があり、そのまま進軍して攻撃を加えるのがやや難しいこと、また仮に攻撃が成功しても増援を送るのに1ターン以上かかることから、破壊したアッシリア都市と同地点に都市を建設するよう指示。
この川都市から川を伝ってアッシリア領に進軍する方針を固める。&lt;/p&gt;

&lt;p&gt;ところで、ウクライナが対アッシリア戦争に邁進している間に他国は地図の研究を完了させ、外洋への進出を開始していた。
そして、船を使ってやってきた大陸の反対側の端に位置しているアイスランドがウクライナと接触する。
アイスランドは元々の国土の狭さから隣国のアステカに圧迫されており、接触よりしばらくして本土の全都市が陥落。
大陸西部はアステカとフィンランドの2国のみが支配することとなった。
ウクライナはアッシリアとの戦争状態にあるためアイスランドに対する具体的支援は行えなかったが、北極へのアイスランドの入植を全面的に支持することとする。
北極へは大陸東部より航路が開いていたが、アッシリア・ハッカー・ウクライナが戦争状態にあるため競合国は少ないものと思われた。
実際にアイスランドはアステカの妨害を受けつつも、北極の入植可能地帯をすべて取得することに成功する。
また、南極は全く戦争を行わず内政に注力する余裕のあったフィンランドが獲得する。&lt;/p&gt;

&lt;h2 id=&#34;中盤:28daa66540c07a81521e24fffe429e66&#34;&gt;中盤&lt;/h2&gt;

&lt;h3 id=&#34;アッシリア制圧:28daa66540c07a81521e24fffe429e66&#34;&gt;アッシリア制圧&lt;/h3&gt;

&lt;p&gt;アイスランドが北極入植を行う際にアッシリア近海を航行し、防御ユニットのいない空都市が存在していることを伝えてきたため、弓兵2ユニット程度を派遣してこの都市を破壊。
アッシリアの後方を荒らして国力を削ぎつつ、主力をアッシリア国境の川へと集結させる。&lt;/p&gt;

&lt;p&gt;一切の戦争を経ず内政を続けていたフィンランド、そしてアイスランドを完全に追い出して大陸西部を統一したアステカがともに勢力を伸ばしており、この両国が比較的友好な関係にあるとの情報ももたらされていた。
実際、この両大国が今後のウクライナ、そして全世界にとって最大の脅威となることも容易に予想される。
アイスランドがアッシリアは講和に応じる構えを見せており、この仲介に入る用意があると打診してきた。
しかしすでにウクライナ軍の主力はアッシリアを射程に捉えていること、アッシリアは軍事に大半のリソースを割り振っていたために技術・内政が大幅に遅れており、講和して共闘関係をもつには国力が低すぎること、またここで停戦してもハッカーが本来の領土を回復するだけで得られるものが少ないことなどの理由より、この提案を退けて戦争の継続を決定。&lt;/p&gt;

&lt;p&gt;川伝いに進軍し、森川に弓兵を展開させてアッシリア前線の都市を半包囲。これによって敵の迎撃を防ぎつつ、後方にカタパルトの主力を展開させる。
敵都市をカタパルトの射程内に収めることに成功し、そのまま突入させ敵都市を破壊。続けて川沿いの都市を2つ破壊することに成功する。
ハッカーに前線都市建設を指示し、これの完成とユニットのHP回復を待ってから攻撃を再開。
敵首都は防御の堅い丘川だったため一度迂回して残りの都市をすべて破壊する。
アッシリア首都に全軍を突入させて占領、ターン116にアッシリアは滅亡した。
ちょうどアッシリア首都が破壊されずにウクライナの占領下におかれたため、元アッシリア領西部をウクライナの領土とし、これによってウクライナは10都市を領することとなった。&lt;/p&gt;

&lt;h3 id=&#34;終戦-そして次の戦争へ:28daa66540c07a81521e24fffe429e66&#34;&gt;終戦、そして次の戦争へ&lt;/h3&gt;

&lt;p&gt;とはいえ、この間にフィンランドは政体を共和制に移行、祝典状態に突入して国力を大幅に引き上げはじめていた。
また当然技術力でも長期にわたる戦争によってウクライナは遅れをとっていた。
しかし幸いなことに、フィンランドがアイスランドに技術支援として供与した技術がウクライナにもたらされ、一時的にではあるがフィンランドと同等の科学技術を得られた。
またアイスランドはアステカに対する敵意とフィンランド-アステカ陣営が脅威であるとの認識からウクライナと友好関係を深め、ウクライナ-ハッカー同盟とアイスランドとの視野の共有も成立した。&lt;/p&gt;

&lt;p&gt;フィンランドとアステカは頻繁に技術協力を行っており、完全に脅威となる存在だったが、この両国は航海術ルートへ研究を進めており、火薬ルートではむしろウクライナ-ハッカー同盟側のほうが先行していた。
ウクライナは戦後復興を進め内政を整えたい時期ではあったが、このまま互いに内政に注力した場合、南極を支配するとともに、既に交易を進め共和祝典に入っているフィンランド側が時間の経過とともに有利になっていくことは明白であった。
そこで、フィンランドが火薬を取得する前の、さらに生産力の弱まる共和制の時代のうちに先制攻撃を仕掛け、フィンランドの国力に打撃を与える以外に勝算はないと判断。急遽対フィンランド戦争の構えに入る。&lt;/p&gt;

&lt;p&gt;幸いなことに南極のアイスランド都市からキャラバンが送られており、最低限の交易路が開通していた。
11都市を擁し共和制下にあるフィンランドはアッシリア滅亡時点で経済力約60と、他国すべてを圧倒していたが、フィンランドの次には経済力30のウクライナが2位に立っていた。
ウクライナは橋梁建設の研究を行い、フィンランドの間にある川の上に道路を建設。
アッシリア滅亡と同時期に締結されたウクライナ-フィンランド間の停戦条約が期限切れとなると同時に渡河攻撃を開始、1都市の占領に成功してフィンランドとの戦争へと突入する。&lt;/p&gt;

&lt;p&gt;この時点で大陸西部と南極を手に入れたフィンランドとアステカが協力関係にあり、アッシリアを滅亡させ大陸東部を平定したウクライナはハッカーと同盟。
またアステカに大陸を追い出され、北極へ移住したアイスランドもウクライナ側との協力関係にあった。
残存する国家が2つの陣営に分かれており、ウクライナによるフィンランド攻撃は事実上世界大戦の始まりであったといえる。&lt;/p&gt;

&lt;h3 id=&#34;対フィンランド全面戦争:28daa66540c07a81521e24fffe429e66&#34;&gt;対フィンランド全面戦争&lt;/h3&gt;

&lt;p&gt;先制攻撃によって都市を奪取することに成功するが、川をまたいだ敵前線への攻撃であったため、この都市へ至る道路は建設されていなかった。
この都市とウクライナ本土との間に道路を建設しなければならず、それまでの数ターンは増援の投入も時間がかかるため、即座に次の都市への攻撃へ移ることはできなかった。
その間にフィンランドは対ウクライナ戦争の態勢へ移り、全都市に城壁を建設してウクライナの攻撃に備える構えに入る。&lt;/p&gt;

&lt;p&gt;そのため丘都市であるフィンランド首都は目前であったものの、城壁の存在からカタパルトをもってしても陥落させることは困難と思われた。
ウクライナが都市横に要塞を建設して広範囲の視野を得たためフィンランド側が都市奪還を狙うことは難しく、またウクライナ側の兵力も都市を落とすに足りなかった。
小規模のユニットの衝突や、本国から占領都市への補給線を絶とうとするフィンランド軍のウクライナ本土側への侵入などが繰り返されながらも戦線は膠着する。&lt;/p&gt;

&lt;p&gt;20ターン近くの間睨み合いが続くが、ここでウクライナが火薬の研究を完了。前線の弓兵をマスケット兵にアップグレードして攻勢に移る。
首都を迂回してフィンランド本土西側に食い込み、2都市を続けて占領。
この攻撃中にフィンランドが火薬を取得したため、これ以上の攻勢は困難となる。
フィンランド西部にまで食い込んだためアステカとも国境を接することになり、城壁が建っておらず平地であったアステカ都市が射程に入ったため、余剰のマスケット兵を投入して2都市を破壊することに成功する。
こちらにもマスケット兵がいるためにしばらくフィンランド側は都市の奪還ができないと判断し、ここで攻撃を中断して占領した都市の防御を固めることに。&lt;/p&gt;

&lt;p&gt;フィンランドの都市3つを奪取し、ウクライナ13都市とやや都市数が増えすぎたため、アッシリア領の3都市をハッカーに移譲する。
またフィンランドの注意が本土に向いていると考えたため、南極にマスケットおよびカタパルトを派遣、狙い通り1都市を占領することに成功する。
しかしこの攻撃によって逆に、こちらの注意が本土から離れてしまっており、次のターンにフィンランド軍およびアステカ軍の総攻撃を受けてフィンランド領の最も西側にある都市を奪還されてしまう。&lt;/p&gt;

&lt;h2 id=&#34;終盤:28daa66540c07a81521e24fffe429e66&#34;&gt;終盤&lt;/h2&gt;

&lt;h3 id=&#34;小康-内政への注力:28daa66540c07a81521e24fffe429e66&#34;&gt;小康、内政への注力&lt;/h3&gt;

&lt;p&gt;以降は、フィンランド領都市に対する外交官による城壁破壊工作に曝されつつも戦闘は小康状態となる。
民主主義を獲得したウクライナはこの機に政体を移行、即座に祝典に移る。&lt;/p&gt;

&lt;p&gt;互いに決定打を与えられるよう内政に注力し、ウクライナはその都市数を活かして世界最大の経済力を持つ国家へ成長する。
しかしその間、祝典の維持と都市建造物を揃えるために研究は停止し、共和制下で既に祝典を行っていたフィンランドが再び研究面で優位に立つ。&lt;/p&gt;

&lt;p&gt;祝典を終え経済基盤を整えたウクライナはフィンランドの倍近い研究速度を叩き出し、また相変わらずのアイスランドの工作によりフィンランドの技術がアイスランド、ハッカーを経由してウクライナに流入した。
これによってウクライナはフィンランドと同等の技術水準まで追いつくが、しかしフィンランドは一足先に冶金学および鉄道の研究を済ませ、ユニットの大量生産態勢に移行しつつあった。&lt;/p&gt;

&lt;p&gt;ウクライナが国力の大半を内政に注いでいたころ、アステカがハッカーの東端の都市を奇襲、占領。
ハッカーはこの都市を奪還できず、数十ターン後に何らかの交渉をまとめたらしくハッカーとアステカの間に休戦が成立する。
曰くアステカがアイスランドを滅亡させた暁にハッカーへ都市が返還されるとのことであり、またハッカーはこのアステカ側の提案を呑みつつも奪還の機会を伺っているとのことであった。
そんな果たされるはずもない交渉を表面的にでも受け入れてしまうあたり、ハッカーのプレイヤースキルがまだまだ成長の余地があるなと思いつつ、周囲の都市に防御ユニットが揃っており奇襲を受けたとしてもそう簡単には落ちないということを確認して放置。
実際、先の2度にわたる戦争においてハッカーの軍事力がろくに役立ったことはなく、実質的にほぼウクライナ単独の戦争であったため、大して同盟国であるハッカーを重要視していなかったのである。&lt;/p&gt;

&lt;p&gt;なお後に判明することであるが、この際ハッカーはウクライナ陣営の視界をアステカ側に横流ししており、完全にウクライナに対する裏切り者であった。&lt;/p&gt;

&lt;h3 id=&#34;2度目の開戦:28daa66540c07a81521e24fffe429e66&#34;&gt;2度目の開戦&lt;/h3&gt;

&lt;p&gt;先に祝典を済ませていたことによる内政の優位から、フィンランドはウクライナより先に戦争準備を完了させる。
全国土に張り巡らせた鉄道によって瞬時に大陸内すべてのカノン砲を集結させ、元フィンランド都市へ一斉攻撃をかけ占領。
さらにもう1都市を占領するが、ウクライナは態勢を整えてこれを即座に奪還。
ここに再び2大陣営間の戦争が勃発する。&lt;/p&gt;

&lt;p&gt;ウクライナ側およびフィンランド-アステカ同盟はともにカノン砲を大量生産し、鉄道の輸送力をもって兵力を集中させ敵都市へ攻撃を加えた。
戦局は先制したフィンランドの優位に進み、ウクライナ本国の都市3つが破壊される。
ハッカーは敵に十分な打撃を与えられる兵力を持っていたが、ウクライナおよびそれを海上より支援していたアイスランド軍と歩調を合わせることができず、ウクライナ・フィンランド互いにカノン砲を使い果たした状態でフィンランド都市の防御に隙ができるというチャンスに恵まれたも関わらず、ハッカー軍が動くことはなかった。
ハッカー軍はアステカ軍の2倍相当の損害を出しながらも、撃破したユニットはアステカ軍の撃破数の半分程度、この数はウクライナ陣営が2度目の開戦以後撃破したユニットのうち20%にも満たず、戦局にほとんど影響を与えなかった。
ウクライナは一時的に5都市にまで追い込まれるが、ウクライナの前線の都市が占領ではなく破壊されたことから敵の支配下には落ちておらず、反攻を行い3都市を再度獲得。
フィンランドとウクライナの国境線付近で都市の占領と奪還を繰り返す一進一退の戦況となる。
激しい戦闘が続く中ゲーム終了ターン直前となり、最後の攻勢をかけ互いに都市を占領しあいゲーム終了となった。&lt;/p&gt;

&lt;h2 id=&#34;ゲーム終了:28daa66540c07a81521e24fffe429e66&#34;&gt;ゲーム終了&lt;/h2&gt;

&lt;p&gt;2度目の戦争はフィンランド本土全都市の奪還およびウクライナ本国都市の破壊と、緒戦はフィンランドの優勢で始まったが、その後ウクライナ側が押し返し混戦状態となった。
ゲーム終了時にはウクライナ本国の都市2つが破壊された状態となり、一方でフィンランドも本土および南極の1都市ずつがウクライナの占領下にあるという状態であった。
結果としてウクライナの都市数はプラスマイナス0、フィンランドが2都市を失っていることとなる。
これはウクライナ-フィンランド両陣営間の2度にわたる戦争のうち2度目はフィンランド優位に推移したが、1度目の戦争においてウクライナはフィンランドの都市3つを占領するという大きな勝利を収めており、結果として2度目の戦争における損失が抑えられたことによるものと考えられる。&lt;/p&gt;

&lt;p&gt;最終的に、ウクライナのユニット撃破数が336と他国を大きく引き離しており、これがスコアに大きく影響し、ウクライナの勝利に繋がった。&lt;/p&gt;

&lt;p&gt;実際、ウクライナ陣営がアッシリアとの戦争で疲弊していた一方で、内政で上位にあったフィンランドとアステカの2国が手を組んだことはゲームの流れを決定づけるに値する出来事であったといえる。
その後戦争が発生せず世界的に内政を進める流れとなった場合、フィンランド陣営が圧倒的有利となっていただろう。
比較的早期にフィンランド-アステカに対して開戦し、一方的に都市を奪取するという戦果を挙げたことがこのゲームの流れを変え、後に全世界を巻き込む大戦へと発展しウクライナに勝利をもたらしたといえるだろう。&lt;/p&gt;

&lt;p&gt;なおハッカーはゲーム開始時からの同盟国であったが、その機会に恵まれた一方で内政は進まず、また3度も大戦争を繰り広げているウクライナの同盟国であるにもにもかかわらずユニット撃破数は100に達しておらず、さらには視界を敵陣営に横流しする重大な裏切りを働くなど、こいつ居ないほうが良かったんじゃないかという感は大いに否めないものがある。&lt;/p&gt;

&lt;p&gt;あと久々にプレイ日記書いたら例のごとくたくさん書きすぎました。ここまで読んでくださった方に感謝します。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Hugoを導入してブログを作った デプロイ編</title>
      <link>http://tatamo.81.la/blog/2016/01/05/hugo-deployment/</link>
      <pubDate>Tue, 05 Jan 2016 20:50:32 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/01/05/hugo-deployment/</guid>
      <description>
        

&lt;p&gt;&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;によって構築したサイトを、GitHub,Wercker,DeployBotを経由してWebサーバー上にデプロイした流れです。今回はHugo自体はほとんど触れていません。&lt;/p&gt;

&lt;h2 id=&#34;werckerを使って自動ビルドする:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;Werckerを使って自動ビルドする&lt;/h2&gt;

&lt;p&gt;まずはビルドを手元ではなくオンライン上で自動的に行うようにします。
記事を書いて反映させる際は記事編集→ビルド→アップロードという3つの手順を踏みますが、これによってビルド作業を手元で行わなくてもよくなります。
また、Hugoの環境がなくても、gitさえ使うことができれば記事の更新を行うことができるようになります。&lt;/p&gt;

&lt;p&gt;今回使用した&lt;a href=&#34;http://wercker.com/&#34;&gt;Wercker&lt;/a&gt;は、このような自動ビルド作業およびデプロイ作業を自動化してくれるCIサービスです。
Werckerを利用した自動デプロイは、&lt;a href=&#34;https://gohugo.io/tutorials/automated-deployments/&#34;&gt;Hugoの公式ドキュメント&lt;/a&gt;に記事があるため、これを参考に行います。
この記事はGitHub Pagesへのデプロイまで解説してありますが、今回の環境ではFTPによるサーバーへのアップロードが必要だったため、もうひと手間かける必要がありました。&lt;/p&gt;

&lt;h3 id=&#34;wercker-ymlの記述:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;wercker.ymlの記述&lt;/h3&gt;

&lt;p&gt;公式ドキュメントによる解説にも書いてありますが、Werckerによる自動ビルド/デプロイを利用するには、対象のGitHubリポジトリ内にwercker.ymlというファイルを作成し、そこに設定やビルド時の処理を記述する必要があります。
既にHugoビルド用の設定を作ってくれている人がいるので、それを利用すれば簡単にビルドができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;box: debian 
build:
  steps:
    - arjen/hugo-build:
        version: &amp;quot;0.14&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけでHugoのビルドが可能です。
ビルドが完了しただけではまだ目的のサーバーにHugoサイトがアップロードされていませんので、続いてデプロイの設定を行います。&lt;/p&gt;

&lt;h2 id=&#34;werckerとdeploybotを使って自動デプロイする:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;WerckerとDeployBotを使って自動デプロイする&lt;/h2&gt;

&lt;p&gt;前述のように、今回使用している環境ではWebサーバーにFTPでアップロードすることが目的のため、デプロイはwerckerからlftpを使用して行おうとしましたが、うまくいきませんでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;box: debian 
build:
  steps:
    - arjen/hugo-build:
        version: &amp;quot;0.14&amp;quot;
deploy:
  steps:
    - install-packages:
        packages: lftp
    - script:
        name: mirror over lftp
        code: |
            lftp -u $DEPLOY_FTP_USER,$DEPLOY_FTP_PASS -e &amp;quot;set ftp:passive-mode off;set ftp:ssl-allow off;set net:timeout 5;set net:max-retries 3;set net:reconnect-interval-max 60;mirror -enR public /blog;quit&amp;quot; $DEPLOY_FTP_SERVER
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lftpでの接続に失敗し、アップロードを行うことができませんでした。
PASVモードのon/off、sslを使用しないようにするなどのオプションを試みましたが、コネクションがうまく確立できず失敗しました。&lt;/p&gt;

&lt;p&gt;後日また調べてみたいと思っていますが、ひとまずFTPでのアップロードを行うため、別のサービスを利用することにしました。
&lt;a href=&#34;http://deploybot.com/&#34;&gt;DeployBot&lt;/a&gt;は1プロジェクトまで無料で利用できるサービスで、FTPによるアップロードにも対応しているため、これを利用しました。
DeployBotによるデプロイは、&lt;a href=&#34;http://creative-tweet.net/blog/2015/10/usage-hugo-2.html&#34;&gt;Hugoをセットアップしてデプロイするまで［後編］CIサービスでビルドからデプロイを自動化するまで | creative tweet.&lt;/a&gt;で解説されているので、ここを参考にして行いました。&lt;/p&gt;

&lt;p&gt;全体としては、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;記事を書いてGitHub上にpushする&lt;/li&gt;
&lt;li&gt;Werckerが更新を検知して自動的にビルドを行い、別のGitHubリポジトリを更新する&lt;/li&gt;
&lt;li&gt;そのリポジトリの更新を検知してDeployBotによって自動的にサーバーへアップロードする&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;というような流れでのデプロイを行いました。&lt;/p&gt;

&lt;p&gt;Werckerから別のGitHubリポジトリへのpushを行うようにするため、公式ドキュメントに書かれている通りにwercker.ymlを書き換えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;box: debian 
build:
  steps:
    - arjen/hugo-build:
        version: &amp;quot;0.14&amp;quot;
deploy:
  steps:
    - install-packages:
        packages: git ssh-client
    - leipert/git-push:
        gh-oauth: $GIT_TOKEN
        basedir: public
        repo: $GITHUB_REPO
        clean_removed_files: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$GIT_TOKEN&lt;/code&gt;および&lt;code&gt;$GITHUB_REPO&lt;/code&gt;は、werckerの設定画面でdeploy targetごとに変数を定義できるため、そこに記述します。$GIT_TOKENはprotectedにチェックを入れ、外部から取得できないようにしておきます。&lt;/p&gt;

&lt;p&gt;あとはwerckerのデプロイ先に指定したGitHubリポジトリをDeployBotに登録するだけです。
DeployBotはリポジトリが更新されるとその内容をそのままサーバー上へアップロードしてくれ、設定も簡単でした。
これで目的のサーバーへの自動デプロイが完了しました。&lt;/p&gt;

&lt;h2 id=&#34;補足など:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;補足など&lt;/h2&gt;

&lt;h3 id=&#34;githubリポジトリの分割:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;GitHubリポジトリの分割&lt;/h3&gt;

&lt;p&gt;Hugoのビルドをローカルでは行わないようにしたため、リポジトリ内に/publicを含める必要がありません。.gitignoreに次の行を記述します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public/
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;リポジトリA:publicディレクトリを除くHugoディレクトリ&lt;/li&gt;
&lt;li&gt;リポジトリB:生成されたpublicディレクトリの内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;というようなGitHubリポジトリ構成とし、リポジトリBはWerckerとDeployBotをリンクさせるために使用するため手動では触れません。&lt;/p&gt;

&lt;h3 id=&#34;werckerの設定:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;Werckerの設定&lt;/h3&gt;

&lt;h4 id=&#34;dockerの使用:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;Dockerの使用&lt;/h4&gt;

&lt;p&gt;Werckerにプロジェクトを登録する際、wercker.yml設定の項目で「Dockerを使用する」かどうかのチェックボックスが存在します。
Werckerで使用するboxはDockerを使用しているものと使用していないものがあり、Hugo公式ドキュメントで使用しているbox:debianなどはDockerを使用しているため、Docker使用の設定をオンにしておかないと、&lt;a href=&#34;http://thleap.net/blog/recovering-wercker/&#34;&gt;boxが見つからないというエラー&lt;/a&gt;が発生します。
逆にwercker/defaultなどのDockerを使用しないboxを使用する場合、設定をオンにしておく必要はないでしょう。
(なお私はWerckerのBoxについてはよくわかっていません。Hugoをデプロイする場合は公式ドキュメント通りにdebianを使用すればいいのではないでしょうか。wercker/defaultでは環境のセットアップに15秒ほどかかりますが、debianでは1秒で済みます。)&lt;/p&gt;

&lt;h4 id=&#34;デプロイターゲット登録時のauto-deploy設定:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;デプロイターゲット登録時のAuto deploy設定&lt;/h4&gt;

&lt;p&gt;ちょっとしたこと(というかちゃんと読めばわかること)ですが、werckerででプロイターゲットを登録する時、&amp;rdquo;auto deploy successful builds to branch(es):&amp;ldquo;という設定項目でブランチ名を指定する箇所がありますが、これはどのブランチが更新されたときに自動的にビルドが走るかを指定するものであり、デプロイ先のブランチ名を指定するものではありません。
GitHubからGitHubへのデプロイを行うときは少し混乱するかもしれません。&lt;/p&gt;

&lt;p&gt;なお、デプロイ先のGitHubブランチ名は前述したwercker.yml内に指定する箇所があります。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上で、Hugoで生成したサイトを自動的にデプロイすることができました。
とはいえWerckerから直接デプロイすることに失敗したためにやや回りくどい方法をとっており、いずれ改善したいと思っています。&lt;/p&gt;

&lt;p&gt;Werckerはビルドごとに環境を最初から設定するため、ライブラリのインストールなども毎回行われ、ビルド環境が整うまでに1分ほどかかります。
手元でビルドができる環境ならばローカルでビルドしてアップロードしたほうが明らかに速いので、すぐに更新したいときなどはデプロイまでにかなり時間がかかる印象を受けます。
Werckerを経由せず、手動でアップロードできる方法も用意しておいたほうがいいのかもしれません。&lt;/p&gt;

&lt;p&gt;また、稀にですがWerckerのビルドが最初のsetup environmentの段階で動かなくなり、Abortも効かない状態でビルドに失敗したことがありました。
デプロイを自動で行っているとはいえ、結局デプロイがうまくいったかどうか確認しないといけないのは問題かもしれません。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Hugoを導入してブログを作った サイト構築編</title>
      <link>http://tatamo.81.la/blog/2015/12/17/hugo-implementation/</link>
      <pubDate>Thu, 17 Dec 2015 03:51:04 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2015/12/17/hugo-implementation/</guid>
      <description>
        

&lt;p&gt;この記事は&lt;a href=&#34;http://www.adventar.org/calendars/891&#34;&gt;KobeUniv Advent Calendar 2015&lt;/a&gt;の17日の記事です。なんとか期日に間に合いそうです。
なお私は当該大学の学部1年(2015年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;このブログを作るにあたって、&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;を使用しました。
Hugoを用いたサイト構築の基本的な考え方や流れの紹介、その際に詰まったことなど。&lt;/p&gt;

&lt;h2 id=&#34;そもそもhugoって何:618f10612e6a9a223dbbbddb739583ff&#34;&gt;そもそもHugoって何&lt;/h2&gt;

&lt;p&gt;静的なWebサイトを生成するためのエンジンです。
つまり:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;まずレイアウトを用意します&lt;/li&gt;
&lt;li&gt;次に記事を書きます&lt;/li&gt;
&lt;li&gt;hugoを実行します&lt;/li&gt;
&lt;li&gt;記事がHTMLに変換され、Webサイトが生成されます&lt;/li&gt;
&lt;li&gt;生成されたサイトをまるごとサーバーにアップロードします&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;これでWebサイトの完成というわけです。
あくまで静的なサイトなので、サーバーサイドでプログラムを走らせる必要もありません。&lt;/p&gt;

&lt;h2 id=&#34;hugoを使ってみる:618f10612e6a9a223dbbbddb739583ff&#34;&gt;Hugoを使ってみる&lt;/h2&gt;

&lt;p&gt;Hugoのインストール等については、既に多くの情報がネット上にあるため割愛します。&lt;/p&gt;

&lt;h3 id=&#34;hugoの基本的なディレクトリ構成:618f10612e6a9a223dbbbddb739583ff&#34;&gt;Hugoの基本的なディレクトリ構成&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo new site name_of_my_site
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行することで、サイト用のディレクトリが生成されます。
中には、config.tomlといくつかのディレクトリが生成されているはずです。
config.tomlはサイト全体の設定を記述するファイルです。なお、代わりにconfig.yamlとしてYAMLで記述することなども可能です。お好みで変更しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd name_of_my_site/
$ ls -p
archetypes/  config.toml  content/  data/  layouts/  static/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;contentディレクトリは、記事ファイルを配置する場所です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo new hoge.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとするとcontent内にmdファイル(記事は主にMarkdownで記述します)が生成されますので、これを編集して記事を作ることになります。&lt;/p&gt;

&lt;p&gt;また、layoutディレクトリにはWebサイトの基礎となるテンプレートを配置します。
基本的には独自のテンプレート記法が用いられたhtmlファイルを使います。
既存のテーマを利用する場合は、themesディレクトリを作り、そこに同様のテンプレートが同梱されたテーマを配置することになります。&lt;/p&gt;

&lt;p&gt;staticディレクトリには、CSSや画像などの静的なファイルを配置します。
このディレクトリ内にあるファイルは、生成時にサイトのルートディレクトリにそのままコピーされます。&lt;/p&gt;

&lt;p&gt;基本的には、この3つ(または4つ)のディレクトリの働きを把握しておけば、Hugoでサイトを作りはじめるのに不足はないかと思われます。&lt;/p&gt;

&lt;p&gt;また、hugoコマンドなどによって生成された完成品のサイトは、publicというディレクトリが作られてそこに配置されます。
サイトを公開するときは、publicディレクトリ下に生成されたファイルをすべてアップロードします。
なお、publicディレクトリ内に不要になったファイルがあったとしても、サイト生成時に削除されません。本番サイトの生成時にはpublicディレクトリを一度削除してからビルドを行うのが良いと思われます。&lt;/p&gt;

&lt;h3 id=&#34;レイアウトしてみる:618f10612e6a9a223dbbbddb739583ff&#34;&gt;レイアウトしてみる&lt;/h3&gt;

&lt;h4 id=&#34;テーマを使う:618f10612e6a9a223dbbbddb739583ff&#34;&gt;テーマを使う&lt;/h4&gt;

&lt;p&gt;いくつものHugoのレイアウトが&lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;公開されて&lt;/a&gt;います。基本的には、この中から気に入ったものを使うのが良さそうです。themesディレクトリ直下にテーマごとのディレクトリを作り、その中にテーマファイルを配置します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone --recursive https://github.com/spf13/hyde themes/hyde
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テーマを適用するときは、configファイル内でテーマを指定するか、hugoコマンドの実行時に&lt;code&gt;hugo -t hyde&lt;/code&gt;または&lt;code&gt;hugo server -t hyde&lt;/code&gt;のように-tオプションでテーマを指定します。ここで指定するテーマ名は、themes直下に配置したディレクトリの名前となります。
テーマを適用すると、hugoディレクトリ直下のファイルが読み込まれるよりも先に、そのテーマディレクトリ下に存在するファイルが読み込まれるようになります。&lt;/p&gt;

&lt;p&gt;既存のテーマを使用する場合、テーマによってconfigに記述する必要のある内容が大きく異なる可能性があります。READMEにどのような項目を記述すればいいかが書かれていると思いますので、必ず確認するのがいいでしょう。&lt;/p&gt;

&lt;h4 id=&#34;自分でレイアウトする:618f10612e6a9a223dbbbddb739583ff&#34;&gt;自分でレイアウトする&lt;/h4&gt;

&lt;p&gt;HugoはGo言語のテンプレートエンジンを使用しており、各種パラメータを呼び出したり、部分ごとにHTMLファイルを分けて再利用することでサイトのレイアウトを記述していくことができます。&lt;/p&gt;

&lt;p&gt;自分でHugoサイトをレイアウトする場合、確実に一定の学習コストが必要となるので、ここでは詳細には触れません。Hugoは公式ドキュメントが充実しているので、&lt;a href=&#34;https://gohugo.io/tutorials/creating-a-new-theme/&#34;&gt;公式チュートリアル&lt;/a&gt;などから始めるのがいいでしょう。また基本的なことであれば調べれば日本語の情報も得られると思います。&lt;/p&gt;

&lt;h2 id=&#34;詰まったことなど:618f10612e6a9a223dbbbddb739583ff&#34;&gt;詰まったことなど&lt;/h2&gt;

&lt;p&gt;今回はHTMLやCSSを自分で書いてサイトを一つ作りたいと思っていた&lt;del&gt;のと、自分以外のテーマ作者名の表記がページに現れるのが気に食わなかった&lt;/del&gt;ので、このサイトでは既存のテーマを使用せず、自前でレイアウトを記述して構築しました。
その途中で、いくつか不具合に遭遇して詰まったりしました。&lt;/p&gt;

&lt;h3 id=&#34;バージョン0-14-配列の並び替えにバグがある:618f10612e6a9a223dbbbddb739583ff&#34;&gt;(バージョン0.14)配列の並び替えにバグがある&lt;/h3&gt;

&lt;p&gt;サイドバーに最近の投稿やタグ・カテゴリの一覧を表示させる際、たとえば&lt;code&gt;.Reverse&lt;/code&gt;や&lt;code&gt;.ByDate&lt;/code&gt;で並び替えを行うと、ページによって正常に並び替えが行われなかったり、ビルドするたびに並び順が変わる、低確率で配列の中身が重複して表示されたりします。
これは並び替えを行う関数が配列そのものに変更を加えているのが原因です。さらにビルド時に並列処理が行われることで処理順がビルドのたびに変化し得るため、同じ記述をしていてもページによって表示される内容が変わるといった不具合が発生したり、そのバグの再現性が低くなったりします。&lt;/p&gt;

&lt;p&gt;このバグは開発版のバージョン0.15では&lt;a href=&#34;https://discuss.gohugo.io/t/error-when-trying-to-sort/1390/4&#34;&gt;修正済み&lt;/a&gt;であり、現行のバージョン0.14まででのみ発生します。&lt;/p&gt;

&lt;h3 id=&#34;rssuriオプションは使ってはいけない:618f10612e6a9a223dbbbddb739583ff&#34;&gt;RSSUriオプションは使ってはいけない&lt;/h3&gt;

&lt;p&gt;Hugoではビルド時に自動的にRSSフィードも生成されますが、そのファイル名は常にindex.xmlとなります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rssuri = &amp;quot;rss.xml&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにconfigファイル中に記述することで、RSSファイル名を変更する機能がありますが、この機能には&lt;a href=&#34;https://github.com/spf13/hugo/issues/1147&#34;&gt;いくつもの欠陥がある&lt;/a&gt;ため使ってはいけません。(2015年12月、バージョン0.14時点)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ルートディレクトリ直下のRSSファイルのファイル名はこの設定によって変更できるが、それ以外のRSSファイルはすべてindex.xmlのままになってしまう&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.RSSlink&lt;/code&gt;などの変数を呼び出すと、間違ったリンクが返される&lt;/li&gt;
&lt;li&gt;RSSファイル内のURLが間違ったものになる&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;hugoを使ってみた感想:618f10612e6a9a223dbbbddb739583ff&#34;&gt;Hugoを使ってみた感想&lt;/h2&gt;

&lt;p&gt;Hugoはシンプルで生成が非常に速いという評判があったため導入してみましたが、実際にサイトを構築してみると確かにそのような設計であることがよく感じられました。必要最小限の機能を持つように出来ており、簡潔なディレクトリ構造はとてもわかりやすいです。
生成速度についてはまだ記事数が少ないため何とも言えませんが、今のところは一瞬でビルドが完了するので良い感じだと思います。&lt;/p&gt;

&lt;p&gt;とはいえ、レイアウトから自前で書き始めるといくつかの不満点が出てきます。
レイアウトに使用するテンプレートはHugoの全体の印象に反して煩雑です。そのため、Hugo特有のレイアウトの記述方法にある程度習熟しておくことは不可欠となります。
しかし、Hugoは公式ドキュメントが非常に豊富ではあるのですが、決して使いやすいというわけではないと思います。
全体を通して解説風のドキュメントとなっているために最初はわかりやすいのですが、それ故にリファレンスとしての機能を十分に果たしておらず、また別途APIリファレンスなどがあるわけでもないので、テンプレートなどの機能を調べるのがやや困難です。
(とはいえ、基本はGo言語のテンプレートエンジンを用いているらしいので、既にGoに慣れている方にとっては問題ないのかもしれません)&lt;/p&gt;

&lt;p&gt;Hugoで使用するパラメータは、TaxonomyやPaginatorの概念が存在していることによってやや複雑な構造をしているため、ドキュメントの見通しが悪いのは問題になりがちだと思います。(rangeで.Data等で提供される配列の中身を回す時とTaxonomyを回すときの扱い方が微妙に異なるなど)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上、Hugoを使ったサイト構築の紹介でした。
Hugoでサイトを作ってからWeb上にデプロイするまでも一苦労あったので、後日その流れについても書いてみたいと思っています。&lt;/p&gt;

&lt;p&gt;あとページのデザイン難しいです。
CSS周りについても記事を書いてみたいですが、あまりに試行錯誤の連続なので何も書くことがないかもしれません……&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>highlight.jsをインライン要素にも適用できるようにした</title>
      <link>http://tatamo.81.la/blog/2015/12/12/apply-highlightjs-to-inline/</link>
      <pubDate>Sat, 12 Dec 2015 01:01:51 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2015/12/12/apply-highlightjs-to-inline/</guid>
      <description>
        

&lt;p&gt;このブログのシンタックスハイライトには&lt;a href=&#34;https://highlightjs.org/&#34;&gt;highlight.js&lt;/a&gt;を使用しています。&lt;/p&gt;

&lt;p&gt;デフォルトでは適用できないインラインのコードのハイライトも行えるようにしましたので、適用の流れなど。&lt;/p&gt;

&lt;h2 id=&#34;highlight-jsって何:dbe2fecfd9603c43589f9d37f36eba56&#34;&gt;highlight.jsって何&lt;/h2&gt;

&lt;p&gt;JavaScriptによって、Webページ内のソースコードを色付けしてくれるものです。
たとえば:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(1,101) :
	print (&amp;quot;Fizz&amp;quot; if not i%3 else &amp;quot;&amp;quot;) + (&amp;quot;Buzz&amp;quot; if not i%5 else &amp;quot;&amp;quot;) or i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://highlightjs.org/static/demo/&#34;&gt;highlight.js demo&lt;/a&gt;を見れば、どのようにハイライトされるのか、どのようなテーマがあるのかが簡単にわかるので良いと思います。
(しかし思うのですが、自分のサイトに導入を検討する際に、この濃い赤色の背景色だと白色の背景と感覚が違ってくるのでやや選びにくいのではないでしょうか……。
コンソールから&lt;code&gt;document.body.style.backgroundColor=&amp;quot;#FFFFFF&amp;quot;;&lt;/code&gt;とでも入力して、背景を白く変更してから見てみるのがいいかもしれません。)&lt;/p&gt;

&lt;h2 id=&#34;インライン要素でもハイライトできるようにしてみた:dbe2fecfd9603c43589f9d37f36eba56&#34;&gt;インライン要素でもハイライトできるようにしてみた&lt;/h2&gt;

&lt;p&gt;通常では、highlight.jsによるハイライトは&lt;code&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&lt;/code&gt;から&lt;code&gt;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/code&gt;で囲まれたブロック要素にのみ適用され、インライン要素に適用することはできません。1行の中にコードを埋め込みたいことも多いので、これではやや不便です。&lt;/p&gt;

&lt;p&gt;Markdownの展開方法に適用できるように、&lt;code&gt;&amp;lt;code&amp;gt;&amp;lt;/code&amp;gt;&lt;/code&gt;で囲まれた要素をハイライトすることにします。
既に先人たちが記事を書いてくれているので、基本的にはそれを参考にするだけでした。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://kenzauros.com/blog/apply-highlight-js-to-inline-source-code/&#34;&gt;highlight.jsでインラインのソースコードもハイライトする | blog@kenzauros.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://swiftrithm.com/blog/highlightjs-install/&#34;&gt;軽いとうわさのhighlight.jsをTwenty Fifteenに導入、ソースコードを綺麗に表示 &amp;#8211; SWIFTRITHM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上記のサイトでは共にJQueryを用いていますが、このサイトでは特にJQueryを導入する気もなかったため、生のJavaScript+DOMで適当に書き直しました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script&amp;gt;
// hljs.initHighlightingOnLoad();
window.addEventListener(&amp;quot;DOMContentLoaded&amp;quot;, function(){
	var elements = document.getElementsByTagName(&amp;quot;code&amp;quot;);
	var l=elements.length;
	for(var i=0; i&amp;lt;l;i++){
		var el = elements[i];
		hljs.highlightBlock(el);
		if(el.parentNode.tagName.toLowerCase() != &amp;quot;pre&amp;quot;) {
			el.style.display = &amp;quot;inline&amp;quot;;
			el.style.margin = &amp;quot;0 2px&amp;quot;;
			el.style.padding = &amp;quot;1px 3px&amp;quot;;
		}
	}
}, false);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常&lt;code&gt;hljs.initHighlightingOnLoad();&lt;/code&gt;を呼ぶところを、上記のコードで置き換えるだけで完了です。
親要素が&lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;ではない場合にインライン化するようにしています。
またスタイルの指定も同時に行っているので、別途CSSを記述する必要はありません。&lt;/p&gt;

&lt;p&gt;既に記事内で何回も使用しているので今更感はありますが、実際にインラインのコードがハイライトされるか見てみましょう。
たとえば、このように:&lt;code&gt;print &amp;quot;\n&amp;quot;.join([&amp;quot;Fizz&amp;quot;*(not i%3)+&amp;quot;Buzz&amp;quot;*(not i%5) or str(i) for i in range(1,101)])&lt;/code&gt;1行のコードでもうまくハイライトされているのがわかります。
やったね。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>ブログはじめました</title>
      <link>http://tatamo.81.la/blog/2015/12/11/hello-world/</link>
      <pubDate>Fri, 11 Dec 2015 00:00:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2015/12/11/hello-world/</guid>
      <description>
        &lt;p&gt;ブログはじめました。&lt;/p&gt;

&lt;p&gt;まだデザインや機能が十分ではないような感じがしますが、少しずつ改良していこうと思います。&lt;/p&gt;

&lt;p&gt;以下はシンタックスハイライトのテストです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for x in range(10) :
	print x
&lt;/code&gt;&lt;/pre&gt;

      </description>
    </item>
    
    <item>
      <title>About</title>
      <link>http://tatamo.81.la/blog/about/</link>
      <pubDate>Wed, 28 Oct 2015 21:21:25 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/about/</guid>
      <description>
        

&lt;p&gt;黒歴史は塗り替えてなんぼデスッ！！&lt;/p&gt;

&lt;h2 id=&#34;about-this-blog:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;about this blog&lt;/h2&gt;

&lt;p&gt;日記や技術的なことなど、まとまった文章を書くために使用する予定です。&lt;/p&gt;

&lt;h2 id=&#34;about-me:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;about me&lt;/h2&gt;

&lt;p&gt;プログラミングやゲームをします。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/__tatamo__&#34;&gt;twitter&lt;/a&gt;やってます&lt;/p&gt;

&lt;p&gt;これまで作ったものなどはこちらにまとめています: &lt;a href=&#34;http://tatamo.81.la/&#34;&gt;Tatamo&amp;rsquo;s works&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>