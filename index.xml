<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>わたしろぐ</title>
    <link>http://tatamo.81.la/blog/</link>
    <description>Recent content on わたしろぐ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sun, 27 Aug 2017 23:54:42 +0900</lastBuildDate>
    <atom:link href="http://tatamo.81.la/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>セキュリティキャンプ全国大会2017に参加してきました</title>
      <link>http://tatamo.81.la/blog/2017/08/27/seccamp-2017/</link>
      <pubDate>Sun, 27 Aug 2017 23:54:42 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/08/27/seccamp-2017/</guid>
      <description>
        

&lt;p&gt;8/14から8/18まで開かれたセキュリティキャンプに参加してきました。
応募用紙に書いた内容は&lt;a href=&#34;http://tatamo.81.la/blog/2017/05/29/seccamp-2017-seet/&#34;&gt;こちら&lt;/a&gt;の記事に書いてあります。&lt;/p&gt;

&lt;p&gt;今日中に感想文を上げないといけないらしいので、参加記を書きます。&lt;/p&gt;

&lt;h2 id=&#34;0日目:d32a538f907a1c066600df8908f4c6c9&#34;&gt;0日目&lt;/h2&gt;

&lt;p&gt;開始日前日がC92最終日だったのでもしかしたらコミケ行けるのでは？などと思っていましたが、大学の試験期間中は事前課題に全く手をつけていなかったのでいろいろ山積していてだめでした。&lt;/p&gt;

&lt;p&gt;夕方のうちに名刺を刷っておこうと思っていたのですが、Windows 10 Creators Updateが入ってノートPCが数時間使えなくなった上にGRUBが上書きされてデュアルブート環境が壊れました。
修復用のディスクの用意やGRUBの再インストールなどでかなり時間を使ってしまい、睡眠時間を削って名刺を刷る羽目になりました。&lt;/p&gt;

&lt;h2 id=&#34;1日目:d32a538f907a1c066600df8908f4c6c9&#34;&gt;1日目&lt;/h2&gt;

&lt;p&gt;すいみん不足。&lt;/p&gt;

&lt;p&gt;休憩時間に軽く寝てたら名刺交換出遅れたりしました。
名刺は60枚ほどは交換できたかな、という感じです。
JSON形式のプロフィール文をcatしたものを印刷しただけ、という名刺を持っていきましたが、意外とネタ被りしている人が少なく(一人はいた)、名刺を覚えてもらいやすかったので重複して交換することを防げました。
100枚ほどは用意したので、流石に名刺入れに収まりきらないだろうと思ってデッキケースに入れていったところ、同じことをしている決闘者を発見できました。&lt;/p&gt;

&lt;p&gt;初日なのでありがたいお話をひたすら聞くだけでした。
支給されたハンドスピナーを回したりしながら耐えていましたが、2つ目の全体講義は記憶から完全に飛んでいます。
まあそれ以外の講義もろくに覚えちゃいませんが。
何人かのチューターの方の圧倒的進捗の報告を聞いて圧倒されたのは覚えています。&lt;/p&gt;

&lt;p&gt;お夕飯を食べましたが、お夕飯にしては控えめな量だった気がします。
その後グループワークになり、ぼんやりしたお題だなあと一抹の不安を感じつつ、ひとまずノルマとして課せられた講師やチューターへの聞き込みを各自で進めることに決めました。
グループワークでの情報のやりとりにはTwitterのグループDMとGoogle Docsを使いました。&lt;/p&gt;

&lt;p&gt;22時に終了したので風呂に入ってそのまま寝ました。&lt;/p&gt;

&lt;h2 id=&#34;2日目:d32a538f907a1c066600df8908f4c6c9&#34;&gt;2日目&lt;/h2&gt;

&lt;p&gt;最初の講義は8:30開始でしたが、目が覚めたのは8:20でした。
空腹だったので食堂に行き(8:24)、時間がなかったので、ひと皿だけ取って食べて講義の教室に入り(8:29)ました。&lt;/p&gt;

&lt;h3 id=&#34;c1-ブラウザの脆弱性とそのインパクト:d32a538f907a1c066600df8908f4c6c9&#34;&gt;C1 ブラウザの脆弱性とそのインパクト&lt;/h3&gt;

&lt;p&gt;ブラウザの脆弱性を見つけて生計を立てていた人がどのように脆弱性を見つけていたのか、を教えてもらいました。
やっぱり場数かなあ、と思いました。
リリースノートを監視していくのは単純に面白そう。&lt;/p&gt;

&lt;h3 id=&#34;d2-3-カーネルエクスプロイトによるシステム権限奪取:d32a538f907a1c066600df8908f4c6c9&#34;&gt;D2~3 カーネルエクスプロイトによるシステム権限奪取&lt;/h3&gt;

&lt;p&gt;講師の方が同じ大学の先輩なのですが、リアルでは会ったことがなくセキュキャン会場ではじめてお会いしました。
グループワークの聞き込みで名前と所属を聞かないといけなかったのですが、「ああ知ってます、イノベーションなんとか科のるくすくん(&lt;a href=&#34;https://twitter.com/RKX1209&#34;&gt;@RKX1209&lt;/a&gt;)さんですよね？」って言ったら覚えてろよって言われました。&lt;/p&gt;

&lt;p&gt;応募用紙でカーネルエクスプロイト問を選択したのでその延長という感覚で受講を決めた講義です。
事前課題でROPの組み方を予習して、講義ではそれを使ってエクスプロイトを書くという感じだったので、ひたすらROP職人っぽいことをしていたという感じの印象があります。&lt;/p&gt;

&lt;p&gt;前半はWebKitの脆弱性で遊びました。
32bitの範囲内の数値しか扱えないJavaScriptで64bitメモリ空間のROPをやるにはこうすればいいのかーなどど思いました。&lt;/p&gt;

&lt;p&gt;後半はBadIRETでユーザー空間とカーネル空間のGSレジスタがswapされてしまう脆弱性を突いたエクスプロイトを記述しようと試みました。
&lt;a href=&#34;https://speakerdeck.com/rkx1209/kaneruekusupuroitoniyorusisutemuquan-xian-duo-qu&#34;&gt;講義資料&lt;/a&gt;のP65の任意アドレス書き込みのためのパディングの大きさを調べようとしたところ、当該箇所の構造体の定義部分が200行ぐらいあって詰みました。
ちゃんとカーネルデバッグかけてサイズを吐かせる必要があるようです。
講義時間だけではとても足りなかったのでもう少し自分で続きをやりたいところです。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;この日は早めに寝ました。&lt;/p&gt;

&lt;h2 id=&#34;3日目:d32a538f907a1c066600df8908f4c6c9&#34;&gt;3日目&lt;/h2&gt;

&lt;p&gt;朝6:30に起きてグループで集まって話し合いをしました。
聞き取り結果などをまとめて部屋に戻ったら、ちょうどけものフレンズが始まったところだったので見ました。
早起きしたのでちょっと睡眠が足りていないかな？という感じでした。&lt;/p&gt;

&lt;h3 id=&#34;e4-サイバー犯罪捜査の現場:d32a538f907a1c066600df8908f4c6c9&#34;&gt;E4 サイバー犯罪捜査の現場&lt;/h3&gt;

&lt;p&gt;事前学習スレに講師からの投稿が100件以上あってヒーヒー言ってました。&lt;/p&gt;

&lt;p&gt;千葉県警の協力のもと、家宅捜索してDFして逮捕するという流れを一通りやりました。
チームのリーダーをやらせてもらったのですが、座って時々指示を出して情報をまとめるお仕事をしていたら捜査フェイズが終わったのでフォレンジックらしいことはチームのメンバーに丸投げする形になってしまいました。&lt;/p&gt;

&lt;p&gt;家宅捜索フェイズでは証拠品を探し回ったのですが、見つけさせる気無いだろうというぐらい手の込んだ隠し方でした。
役得というか、容疑者の自室前で捜査令状を突きつけたり、後半で容疑者に逮捕状を突きつけたりできたので、単純にひたすら楽しかったです。
令状を持って容疑者宅の前まで行ったら報道陣まで待機していて笑いました。&lt;/p&gt;

&lt;p&gt;その後の昼食で担当してもらった(というか逮捕した)警察の方に色々と話を聞かせてもらったのもとても楽しかったです。&lt;/p&gt;

&lt;h3 id=&#34;c5-暗号運用技術:d32a538f907a1c066600df8908f4c6c9&#34;&gt;C5 暗号運用技術&lt;/h3&gt;

&lt;p&gt;なかなか重い講義が多いセキュキャンでしたが、これは入門講義という感じで割とふんわりしていました。
ちょっと座学が多かった(=眠くなった)気がします。
普段使ってる「証明書」って何なの？という感じだったので、運用面まで含めて教えてもらえたのは良かったです。
ある二つのRSA鍵が共通の秘密鍵を使っている場合、公開鍵同士の最大公約数は簡単に求まるためクラック可能だというのはなるほどと思いました。&lt;/p&gt;

&lt;h3 id=&#34;bof-企業プレゼン:d32a538f907a1c066600df8908f4c6c9&#34;&gt;BoF、企業プレゼン&lt;/h3&gt;

&lt;p&gt;BoFが終わったら既に企業プレゼンが始まっている時間でした。&lt;/p&gt;

&lt;p&gt;セキュリティ、というかITに関係のない人の話を聞きましたが、なんか既視感があったので同じ人もしくは似たような人の話を以前聞いたことがあるのではないかという気がします。
結構強烈だったのでしばらく感覚がセキュキャンから引き離されました。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;その後はグループワークをして終了。
最初はなかなか方向性を絞りきれずに話が脱線しがちだったのですが、話し合っているうちになぜかテーマがまとまってきていて不思議でした。&lt;/p&gt;

&lt;p&gt;お酒が飲みたくても飲めないのでふてくされつつ、ゆっくりお茶をいれてお菓子を食べていたら寝る時間が削れました。&lt;/p&gt;

&lt;h2 id=&#34;4日目:d32a538f907a1c066600df8908f4c6c9&#34;&gt;4日目&lt;/h2&gt;

&lt;p&gt;選択講義は4日目が最終日です。&lt;/p&gt;

&lt;h3 id=&#34;c6-スマートフォン向けゲームのセキュリティ:d32a538f907a1c066600df8908f4c6c9&#34;&gt;C6 スマートフォン向けゲームのセキュリティ&lt;/h3&gt;

&lt;p&gt;超楽しかったです。&lt;/p&gt;

&lt;p&gt;まずはWeb上のゲームのハック。
事前課題で出ていたものの難易度を少し上げたものに挑戦しました。
難読化されたソースコードをデコードして(これは想定外だったらしい)、リクエストを飛ばす関数をそのまま呼び出して突破。&lt;/p&gt;

&lt;p&gt;次にAndroidエミュレータ上でいろいろな手段でゲームアプリのクラックを試みました。&lt;/p&gt;

&lt;p&gt;まずはメモリの書き換え。
うさみみハリケーンとかスペシャルねこまんま57号とか、使ったことありますよね。
あれでJava上で動いているソフトを攻略できたためしがないので、もしかして仮想マシンなどの上で動くソフトはメモリ書き換えに耐性があるのかな、などと思いました。
メモリ書き換えまでしっかり対策したプログラムを書くのは大変そうです。&lt;/p&gt;

&lt;p&gt;次にパケットの改竄。
当然通信は暗号化されているのですが、「バイナリコードを覗いてみたらXCHG命令があって、しかもその部分に謎の定数が置かれているのでこれがXORの鍵っぽい」とかいうやり方で突破していてまじかってなりました。&lt;/p&gt;

&lt;p&gt;これ一般に出回っているゲームアプリに普通にチート仕掛けられるのでは？と心配になるほどいろいろやったので、全体講義で口うるさく言われたセキュリティ倫理を早くも試されているのか、という気持ちになりました。&lt;/p&gt;

&lt;h3 id=&#34;a7-ファジング実習:d32a538f907a1c066600df8908f4c6c9&#34;&gt;A7 ファジング実習&lt;/h3&gt;

&lt;p&gt;ファジング #とは という感じだったうえに事前課題でルータを渡されて「調査してみてください」と言われ、資料通りに何時間かファジングしてみたものの何も起こらず、？？？という気持ちだったので不安でしたが、講義では詳細に教えてもらえてむしろ事前課題とは何だったのか、という感じになりました。&lt;/p&gt;

&lt;p&gt;ルータをファジングしましょうと言われたのでファジングとはネットワーク系の検査に使うものなのかな、などと思っていたのですが、実際にはソフトウェアに対しても行うことができ、なかなか強力なようです。
自分が作ったソフトの脆弱性発見にも役立ちそうなので、使いこなせるようになってみたいと思います。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;その後はグループワークをしたあと、技術書のプレゼントが行われました。
年齢が若い人から順に早いもの勝ちで、私はほぼ最高齢だったので人権はありませんでした。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;うらやましくなんてないのです、我々は大人なので &lt;a href=&#34;https://twitter.com/hashtag/seccamp?src=hash&#34;&gt;#seccamp&lt;/a&gt;&lt;/p&gt;&amp;mdash; たたもさん@がんばらない (@&lt;strong&gt;tatamo&lt;/strong&gt;) &lt;a href=&#34;https://twitter.com/__tatamo__/status/898157958206377985&#34;&gt;2017年8月17日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;E4の講義で中のコインの内側にMicroSDが隠されていた豚の貯金箱がまだ残っていたので、一つもらっておきました。&lt;/p&gt;

&lt;p&gt;他の日より一時間程度早く終わりましたが、グループワークが間に合っているはずもなく、風呂に入ってからまたグループで集まりました。
とはいえ方向性はまとまりつつあったので、一時間程度話し合った時点で解散。
夜遅くまでグループでの話し合いを続けることは免れました。&lt;/p&gt;

&lt;p&gt;我々のグループはかなり早めに解散できたのですが、プレゼン担当の人はその後数時間作業してくれていたようで頭が上がりません。&lt;/p&gt;

&lt;p&gt;早めに寝ようと思っていたのですが、ちょっとtwitterを開いたばかりに40分ほど持って行かれました。&lt;/p&gt;

&lt;h2 id=&#34;5日目:d32a538f907a1c066600df8908f4c6c9&#34;&gt;5日目&lt;/h2&gt;

&lt;p&gt;最終日です。
まずはグループワークの総仕上げと発表で、我々のチームは既にプレゼンも仕上げてもらっていたので、最後の作業時間はのんびりと過ごしていました。&lt;/p&gt;

&lt;p&gt;グループワークの発表は、我々のチームは割と全体を通してまとまりのある雰囲気の発表が出来た気がするので良かったと思います。
5000兆円フォントがネタとして被りまくっていたので、使わなかったのは正解でした。&lt;/p&gt;

&lt;p&gt;その後昼食を挟んで成果報告、その後閉会式でした。
終始時間に追われていたセキュキャンで何をどうやれば閉会式に90分も割り当てられるのか不思議でたまりません。&lt;/p&gt;

&lt;h2 id=&#34;感想:d32a538f907a1c066600df8908f4c6c9&#34;&gt;感想&lt;/h2&gt;

&lt;p&gt;2000字書かないといけないらしいです。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;まず、全体的にハードな時間配分だったように感じます。
8:30の講義開始に間に合わせるように起床して、次に自由が得られるのは22:00です。
それから部屋に戻って風呂に入って筋トレをして寝るので、8時間睡眠を得るには困難が伴います。&lt;/p&gt;

&lt;p&gt;昼食時間は基本的に参加者やチューター、講師との交流にあてられるため、休憩をしている余裕はあまりなかったように感じます。
これは余談ですが、3日目ぐらいに一度「食事会」があり、チューターや講師と相席になるようにして交流をするという企画でした。
スケジュール表には他の食事と全く同じように表示されており、また人が揃ってから一斉に食べるという方針でしたが、まあ伝達が行き届かなくて人が揃いきるのは無理だろうという感じで、せめて時間を他の日の食事時間よりも多めに取ったほうが良かったのではないかという気がします。&lt;/p&gt;

&lt;p&gt;それも含めてではありますが、全体的に過密スケジュールになっているので、どこにしわ寄せが来るかというと睡眠時間、休憩時間、そして参加者同士の交流の時間が削られていくのかなという感じでした。&lt;/p&gt;

&lt;p&gt;まあ単純に、もう少し寝られたら良かったなあという感じです。
演習がなければやっていることは大学の講義に似ているので、当然眠くなります。
初日の全体講義は席が決まっているし、企業プレゼンは名簿を取られていたのでサボるための抜け道に欠けます。&lt;/p&gt;

&lt;p&gt;とはいえグループワークで一緒になったメンバーとは思った以上に話をする機会が多く、いろいろな情報を共有できたのは良かったです。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;一番上の年齢層の私が言うのも、ですが、大学生や20歳以上の人が多いなあというのは感じました。
私は中高生のときに尻込みしてセキュキャン応募できなかったので最後のチャンスに応募したというのが理由ですが、聞く限りではリアルの知り合いからセキュキャンのことを知って応募したという人が多く、ネットなどで存在を知った私のような人はどうやら少ないらしいです。
なんででしょうね。&lt;/p&gt;

&lt;p&gt;応募用紙の課題をこなせる力量という面で言えば大学生や高専生の上の方の学年の人間は比較的有利だろうなあという気はしますが、そのあたりは運営の方でうまく加味してもらっているのではないかとも思いますし謎です。&lt;/p&gt;

&lt;p&gt;中高生が多いほうが良いんじゃないかなあ、とは思います。
大学生と中高生(と小学生)が同居できるイベントでは中高生が主役になるべきです。&lt;/p&gt;

&lt;hr /&gt;

      </description>
    </item>
    
    <item>
      <title>HIROic Freeciv Challengeの参加結果</title>
      <link>http://tatamo.81.la/blog/2017/07/11/freeciv-arago-challenge-02/</link>
      <pubDate>Tue, 11 Jul 2017 15:03:07 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/07/11/freeciv-arago-challenge-02/</guid>
      <description>
        

&lt;p&gt;&lt;a href=&#34;https://www.arago.co/hiro-freeciv&#34;&gt;aragoのFreeciv Strategy Challenge&lt;/a&gt;の企画である&lt;a href=&#34;https://freeciv-leader-board.hiro.community/about&#34;&gt;HIRO-ic Challenge&lt;/a&gt;に参加していましたが、結果が出ました。&lt;/p&gt;

&lt;h2 id=&#34;結果:978a3bb5c6b03edc57663e490ab06a5b&#34;&gt;結果&lt;/h2&gt;

&lt;p&gt;それぞれのゲームプレイをもとにして、各プレイヤーの行動を模したAIが作成されます。
そのAI同士で対戦を行うことで、順位が決定されます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://freeciv-leader-board.hiro.community/ladder&#34;&gt;順位表&lt;/a&gt;によると、私は全プレイヤー中2位の結果となりました。世界ランク2位(自称)です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://freeciv-leader-board.hiro.community/battle-grid&#34;&gt;BATTLE GRID&lt;/a&gt;を見ると、私のAIのみが唯一すべてのプレイヤーのAIに対して勝ち越しまたは引き分けており、1位のプレイヤー相手にも勝ち越していることがわかります。
1位のAIと比べると、私のAIは格下相手に稼ぎ負けたために2位になったといえます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://freeciv-leader-board.hiro.community/detailed/Tatamo&#34;&gt;個人スコア&lt;/a&gt;を見ると、各国家が小島からスタートするルールでのスコアが非常に低く、ほとんどの対戦で負け越しています。
これは交易路主体の戦略がこのルールでは弱く、またある程度国土を広げると拡大を止めるために他の国家と都市数の面で不利になったこと、これらが合わさって都市の成長速度が遅いために十分にスコアを稼ぐ前に終了ターンに達してしまったことなどが考えられます。&lt;/p&gt;

&lt;p&gt;さらに自分のゲームプレイから考えると、自分がプレイしたゲームでは近い位置に隣国がいるようなマップを引かなかったので、完全に内政寄りのAIになっていてゲーム序盤から戦争を仕掛けられた場合に不利になっていたのではないかと考えられます。
また、都市数を抑えて交易路で準備を整えてから祝祭ブーストによって国力を一気に引き上げるため、準備が整うまでにゲーム終了となると都市数を多く増やした国家に勝つことができません。&lt;/p&gt;

&lt;h2 id=&#34;報酬:978a3bb5c6b03edc57663e490ab06a5b&#34;&gt;報酬&lt;/h2&gt;

&lt;p&gt;初期のアナウンスによると、上位数人の参加者には&lt;a href=&#34;http://south.paxsite.com/&#34;&gt;PAX South 2017&lt;/a&gt;へ招待されるとのことでしたが、結果発表時には既に開催日を過ぎていたので、後のアナウンスによって&lt;a href=&#34;https://www.e3expo.com/&#34;&gt;E3 2017&lt;/a&gt;のチケットがもらえるという報酬に変更されました。
また、上位20名にはCiv6が提供されるとのことです。&lt;/p&gt;

&lt;p&gt;私は2位ですので、その両方の報酬がもらえます。&lt;/p&gt;

&lt;h2 id=&#34;ゲームプレイ:978a3bb5c6b03edc57663e490ab06a5b&#34;&gt;ゲームプレイ&lt;/h2&gt;

&lt;p&gt;前回の記事では紹介しなかったゲームについても振り返ってみたいと思います。&lt;/p&gt;

&lt;h3 id=&#34;2回目:978a3bb5c6b03edc57663e490ab06a5b&#34;&gt;2回目&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/09/29/freeciv-arago-challenge-01/&#34;&gt;以前の記事&lt;/a&gt;で1度目のプレイを紹介しましたが、以降もう一度後半戦のゲームプレイを行いました。&lt;/p&gt;

&lt;p&gt;基本的にはルールは同じで、民族を再割当てしてのゲームでしたが、割り当てられた民族は北米大陸のアメリカ人で、なんと前回プレイしたスー族と数タイルしか変わらない初期位置からのスタートでした。
そのため最初の動きは前回のゲームとほぼ変わらず。
南米大陸にブラジル人がいたのですが遠いのでそこまで進出するつもりはなく、初心者用AIなので戦士を数ユニットほど送り込むだけで空都市をいくつか破壊・占領できました。
対ブラジルの最前線以外には北米大陸の外に都市は建てず、前回のプレイ同様の都市配置を行っていきました。&lt;/p&gt;

&lt;p&gt;どうせなので前回とは研究ルートを変更し、共和制に直行して祝祭ブーストを行ってから他国に交易路を引いていきました。
マップが広いことから交易路が強いのでこれはあまり強くなく、結果としてゲーム終了まで数十ターン余計にかかりました。&lt;/p&gt;

&lt;p&gt;また敵文明をすべて根絶やしにするのがひたすら面倒なことを前回のゲームで実感したので、今回は宇宙勝利を目指しました。
コンピュータまで直行してニュートン+SETIで研究をブーストし、一気にロケットを打ち上げます。
ロケット打ち上げ後に首都防衛のためこちらから他国家に打って出たところ、「あとはロケットの到着を待つだけなのになぜ戦争をするのか？」と担当者に不思議がられました。&lt;/p&gt;

&lt;h3 id=&#34;3回目:978a3bb5c6b03edc57663e490ab06a5b&#34;&gt;3回目&lt;/h3&gt;

&lt;p&gt;本来ゲームプレイは2回で終了のはずだったのですが、2回めのゲーム終了からしばらくして先方からまた連絡が入りました。
曰く、もっとプレイを見せてほしいとのこと。&lt;/p&gt;

&lt;p&gt;結果として追加で2回のゲームプレイをすることになりました。&lt;/p&gt;

&lt;p&gt;3回目のマップは、それまでの地球型マップという点では同じでしたが、それまでとは違って全国家が5タイル前後の広さの小島からのスタートでした。
英国スタートだったので普通に地図に直行して欧州大陸に殖民したのですが、大陸が広すぎるので10都市前後で殖民を停止。
キャラバンを生産して他国家に交易路を引きに行ったのですが、AIはまだ大半が初期位置の小島から外に出ておらず、距離が遠い上に交易相手となる都市が少ないために交易に苦労しました。
実際、交易優先よりもこの時代のうちに他国を攻め滅ぼしたほうが早かったような気がします。&lt;/p&gt;

&lt;p&gt;戦闘機の時代になった時点で攻勢に出ることにして、圧倒的技術差から特に問題なく勝利。&lt;/p&gt;

&lt;h3 id=&#34;4回目:978a3bb5c6b03edc57663e490ab06a5b&#34;&gt;4回目&lt;/h3&gt;

&lt;p&gt;4回目のマップは、それまでとは全く違ったマップでした。
国家は2つしか存在せず、それぞれが別の広大な大陸からのスタート。
さらに大陸と大陸の間には広い海とやたら多い島があったのですが、大陸内に10都市建ててもまだ大陸の半分程度しか埋まらない広さだったので、ある程度植民してから島嶼部は無視して他大陸と交易。
大砲を使って敵大陸に殴りこみ、物量差で押し込んで征服し勝利。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>セキュリティキャンプ2017の応募用紙</title>
      <link>http://tatamo.81.la/blog/2017/05/29/seccamp-2017-sheet/</link>
      <pubDate>Mon, 29 May 2017 12:00:01 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/05/29/seccamp-2017-sheet/</guid>
      <description>
        

&lt;p&gt;&lt;a href=&#34;https://www.ipa.go.jp/jinzai/camp/2017/zenkoku2017.html&#34;&gt;セキュリティ・キャンプ2017&lt;/a&gt;の応募用紙を提出したので、どうせなので公開します。
私はこの記事がアップロードされたことを確認したら寝ます。
いい加減期限が迫ってから焦って取り組もうとするのはやめたほうが良いと思います。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;追記: 受かりました。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;推敲まで行っている余裕がとてもなかったため、悪文・乱文が多い可能性があります。
審査員の方々には申し訳ない限りです。&lt;/p&gt;

&lt;p&gt;その上分量が多く、また最低限の整形しか行っていないため見づらいことがあるかと思いますがご容赦ください。
フォームに直接書いた生の文字列と、Markdownに則った形式とでは見え方が違うためです。
いずれ直そうと思いますが、私ははやく寝たいのです。&lt;/p&gt;

&lt;p&gt;(追記：全体的に整形を加えました。
すべての行に改行を入れたり見出しやリストによる整形も行おうかと考えましたが、前者は画面右端の改行と被ってしまうため、後者はもともとの回答と見え方がずれてしまうためどちらも行っていません。)&lt;/p&gt;

&lt;p&gt;また、応募用紙そのものに対する感想、注釈、検閲等については&lt;code&gt;/* */&lt;/code&gt;で囲った部分、または&lt;code&gt;//&lt;/code&gt;に続く箇所に書いているものとします。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;共通問題:ba10b11125a0bfb60081de5c3341fee7&#34;&gt;共通問題&lt;/h2&gt;

&lt;h3 id=&#34;共-1-1:ba10b11125a0bfb60081de5c3341fee7&#34;&gt;共-1（1）.&lt;/h3&gt;

&lt;p&gt;あなたが今まで作ってきたものにはどのようなものがありますか？
いくつでもいいので、ありったけ自慢してください。
プログラミングを始めた頃に作ったものから順に紹介していきます。&lt;/p&gt;

&lt;p&gt;1.まさおコンストラクションと呼ばれる、ユーザーが自由にアクションゲームのステージを作成してWebページ上で公開することができるJavaアプレットゲーム上で作ったたくさんのステージ。また、それを公開するために作成したWebサイト。&lt;/p&gt;

&lt;p&gt;これは基本的にはHTMLのparamタグにマップデータを配置したり、専用のマップエディタを用いてステージを作成できる機能が提供されているJavaアプレットですが、それに加えてJavaScriptを用いてJavaアプレット内のゲームの状態を取得したり、画像描画の命令を呼び出すことのできるAPIが提供されていました。
私は単に与えられた機能の範囲内で遊んでいて楽しいゲームを作るだけでなく、このJavaScript拡張の機能によって新しい仕掛けや敵キャラクター、強化された演出などを追加したゲームを作成し、自分のWebサイトで公開しました。&lt;/p&gt;

&lt;p&gt;2.マルチプラットフォームで動作する、ソケット通信を使った小型のGUIチャットソフト。&lt;/p&gt;

&lt;p&gt;一人がホストモードでソフトを起動し、他の人がホストに対してソケット接続を行うと、ホストが接続されているすべてのクライアントに通信を転送し、全員がリアルタイムでチャットを行うことができます。
Pythonから起動するほか、Windows用にexe形式の実行ファイルも用意されています。&lt;/p&gt;

&lt;p&gt;3.Windows上で動作する、いわゆる「テトリス」のソフト。&lt;/p&gt;

&lt;p&gt;GUIアプリケーションとして作ったものであり、ろくに活動実績のなかった廃部寸前の高校コンピュータ部において文化祭出展用の目玉プログラムの座を3年間維持し続けたものです。
コンパクトなUIでありながらゲームとして完結しており、落ちてくる四角い物のバリエーションの偏りの排除、次に落ちてくる物の予告、必要な時に一つだけ保持しておいたものと入れ替えるホールド、一度にたくさん消滅させたときのスコアの上昇とその連鎖、スコアとゲーム時間に応じた難易度の上昇、およびハイスコア登録が可能と、何度でも繰り返し遊べるような機能を備えています。&lt;/p&gt;

&lt;p&gt;4.ブラウザ上で動作し、同時にそのページにアクセスしているプレイヤーとリアルタイムでの対戦ができる2Dアクションゲーム。&lt;/p&gt;

&lt;p&gt;ブラウザ上でプレイすることができるジャンプアクションゲームを作成し、これをネットワークを介した人間のプレイヤー同士での対戦ができるように、リアルタイム通信機能を付け加えたものです。
一秒間におよそ14フレーム、1フレームあたり70msごとに画面が更新されてプレイヤーキャラクターを移動させることができる純粋なアクションゲームとしての性格を備えながら、ネットワーク越しの相手も同様にリアルタイムで移動し、お互いに攻撃しあうことで対戦が可能な通信ゲームとなっています。
アクションゲームとしては14fpsと、一般的な30fpsや60fpsよりも画面の更新周期がやや遅い設定であるものの、それでも完全なリアルタイム通信を行いたい場合は70msの遅延しか許されません。
プレイヤーの入力データが相手に届くまでにこれ以上の時間がかかった場合は、たとえば本当は自分と相手は同時に移動をしたはずなのに、相手からのデータが届いていないために自分だけが動いているように見えるというような事態が起こります。
これでは相手のクライアントが見ているゲーム画面と自分が見ているゲーム画面の間に差異が生じてしまううえ、このような誤差が蓄積されていくと同じキャラクターでもクライアントによって位置がどんどんずれていってしまう恐れがあります。
このゲームでは、行動を入力してから1~3フレーム程度の間だけ待機時間を持たせ、その間に入力データを先に送ってしまうことでロスを防ぐしくみを組み込んでいます。
そしてそれだけではなく、実際に通信が遅れて届いた場合でも、過去数フレーム分のプレイヤーキャラクターの位置や状態を逆算可能にしておくことで、本来正しく通信が受信されていたはずの時点まで巻き戻して再計算を行い、結果として相手に見えているはずの、正しいキャラクターの位置や状態に修正することができるようになっています。
とはいえこの場合でも、やはり一瞬の時間だけプレイヤー間で見えているものが違うという状態が起こり得ます。
たとえば敵のキャラクターがこちらのキャラクターに向かって攻撃を行い、明らかに敵の攻撃に当たってしまったとき、やられた！と思った瞬間に、実は敵のキャラクターの移動の入力データが届いておらず、本当は相手は全く違う方向に攻撃をしていたのだ、ということが判明したなら、これはゲームとしては楽しくないといえます。
そのため、キャラクターの移動は入力(と通信)が行われてから1フレームだけ後に行動に移され、ジャンプは2フレーム、攻撃動作は3フレームというように、そのデータが届かなかったときの影響の大きさによって入力から実際の行動までの間隔を調整しています。
これは単に通信が届かない確率を減らす効果が得られるだけではなく、それに加えて、3フレームの間隔が開くような動作に対しては、次のフレームでは2フレーム以下の間隔を持つような入力は無視され、その次のフレームでは1フレーム以下の間隔を持つような入力は無視される、という仕組みを取り入れることで、より同期ずれによる不都合が軽減できるようになっています。
たとえば、キャラクターが右を向いている状態で攻撃の入力を行い、即座に左に振り向こうとしたとします。
攻撃の入力が行われたのが0フレーム目だとすると、0,1,2フレームの間は入力から行動までの間隔が1である移動入力は無視され、結果として左方向への移動の入力は3フレーム目に有効になります。
この3フレーム目で実際の攻撃動作が行われ、3フレーム目に入力された移動動作は4フレーム目に行われることから、「攻撃の入力から実際に攻撃の動作が行われるまでの間、キャラクターが急に方向転換することはない」といえるようになります。
結果として、方向転換の通信が正しく届かなかったとしても、右を向いて攻撃をしようとしているキャラクターが攻撃の瞬間には左を向いている、という可能性を除外することができます。
ゲームをプレイしているプレイヤーは、キャラクターが動き始めるのが1フレーム遅れた、ということはあまり気になりませんが、右方向に発射された攻撃が一瞬後には左方向の攻撃に変わっていた、という事態には大きく戸惑うことが予想されます。
このように、プレイヤーが気にならないような誤差はあえて許容しつつ、深刻なずれが生じる可能性を極力減らすような設計とすることで、見かけ上はリアルタイムに同期がとれているかのようなゲームプレイを実現しています。&lt;/p&gt;

&lt;p&gt;5.Freecivのユニット間の戦闘の勝率を計算するソフト。&lt;/p&gt;

&lt;p&gt;私が約5年の間、週末に3時間から10時間程度は必ずプレイしているFreecivというゲームがあります。
「シヴィライゼーション」シリーズをもとにして20年前につくられたこのGPLソフトウェアでは、プレイヤーの帝国の手足となる軍事ユニットが絶えず他国のユニットと戦闘を行います。
この戦闘は、互いのユニットの戦闘力に加え、ユニットの熟練度の差、様々な地形の補正効果、要塞や城壁による防御効果、ユニット間の相性による能力値の変化、港湾都市に停泊中の艦船ユニットが敵からの攻撃に対して脆弱になる特殊補正など、様々な要素によって勝敗が決まります。
都市の中に籠っている複数体の相手ユニットに対し、こちらが何ユニットの攻城兵器を用意すれば撃破が可能なのか？という問いに答えることは、敵都市の防御ユニットをすべて倒すことができればその都市を占領して大きな優位性が得られ、一方で1ユニットでも相手が生き残ってしまえばただ自国軍が全滅しただけの大損害になってしまうというハイリスク・ハイリターンさから、攻撃の計画を立てる上で非常に重要となってきます。
そのため、戦闘の発生する状況を入力すれば、その戦闘での勝率、与えられるダメージの期待値などをweb上で算出できるアプリケーションを作成しました。
予めFreecivのルールセットに対応したユニット能力値や補正効果などのデータセットを作成しておくことで、複雑になりがちな補正効果の計算をすべて自動的に行うことができます。
またFreecivは自由度の高いゲームでもあり、ユーザーが自由にルールセットを改造して独自のユニットや効果を持った新しいルールセットを作ることができるようになっていますが、この計算ソフトではユーザーが計算に用いるためのデータセットを改変して新しいルールセットに対応したものとできるという柔軟性を持っています。
このソフトによって、経験によって「勘」で攻撃に必要なユニット数を把握できるような熟練プレイヤーのみでなく、このゲームの初心者であっても実際の数値をもとに戦略を立てることができるようになるため、プレイヤー全体のスキル向上に寄与できると考えています。&lt;/p&gt;

&lt;p&gt;6.HTML5 Canvas上で動くアクションゲームと、そのフレームワーク。&lt;/p&gt;

&lt;p&gt;先述した4.のブラウザ上で動くゲームはC#+Silverlightで開発していたのですが、気付けばSilverlightがほとんどのブラウザで動かなくなってきていたため、TypeScript+Canvasでの書き直しと、その洗練を試みたものです。ただし、通信に関する機能は含んでいません。
(なおSilverlightが動かなくなったためにJavaScript関連の技術に移植したのは、先述した5.の計算ソフトも同じ流れをたどっています)&lt;/p&gt;

&lt;p&gt;7.いくつかのWebサイト。&lt;/p&gt;

&lt;p&gt;スマートフォンでアクセスしたり、ウィンドウサイズが小さくなったりすると自動的にメニューが画面端に格納され、隅のボタンをクリックすることでメニューがアニメーションしながら開閉する、いわゆるハンバーガーメニューをJavaScriptを用いずにCSSのみで実装したWebサイトを作成しました。
また、ブログを作ってGitHubにMarkdownで書いた記事をpushすればビルドしてアップロードしてくれるようにもしました。
他に、wikiの設置・管理も行っています。&lt;/p&gt;

&lt;p&gt;8.LALR(1)パーサジェネレータ。&lt;/p&gt;

&lt;p&gt;漠然と「構文解析がしたい」と思ったので作りました。
構文ファイルを与えることでそれを構文木に変換できるようなパーサを生成し、解析を行うことができます。
また、パーサ生成時に構築される構文解析表と、それを読み取って解析を行う部分のみを取り出してソースコードとして出力することで、パーサの生成処理だけを予め行っておくこともできます。
このパーサジェネレータでは、構文規則を記述するための構文ファイル自体の規則もこのパーサジェネレータによって生成されています。
構文ファイルに使うための構文規則が自分自身の構文を定義しているため、構文を表現する方法を拡張したり、別の表現を用いることができるようにすることが容易です。
また、作っているうちにこれはYaccやBisonとよばれるパーサジェネレータの二番煎じにしかならないことに早々に気付いたため、単にパーサジェネレータの開発を進めるだけでなく、並行して開発の流れや理論的概略を紹介する記事をブログに書くことにしました。&lt;/p&gt;

&lt;h3 id=&#34;共-1-2:ba10b11125a0bfb60081de5c3341fee7&#34;&gt;共-1（2）.&lt;/h3&gt;

&lt;p&gt;それをどのように作りましたか？
ソフトウェアの場合には、どんな言語で作ったのか、どんなライブラリを使ったのかなども教えてください。追加したい機能や改善の案があれば、それも教えてください。&lt;/p&gt;

&lt;p&gt;1.&lt;br&gt;
当時は個人サイトが活発な時代だったため、同じようなステージを作って公開している人と掲示板などで交流をしながらステージ作りやWebサイト作りをしました。
このゲームのJavaScript拡張がプログラミングに触れたはじめてのきっかけでした。
初めはJavaScript拡張機能のサンプルを見て、そこに登場する敵キャラクターの動きの新鮮さに驚き(用意されている敵キャラクターはたいてい同じ動きや攻撃を繰り返すだけのものだったが、そのキャラクターは残りのHPに応じて動きを変えるボスキャラクターだった)、どのようにして攻撃を切り替えているのか、プログラムのどの部分が攻撃を出す部分なのか、などが気になり、ソースコードを書き替えては実行してを繰り返しました。
何度もエラーを出したりしながら攻撃を出す部分(関数呼び出し)を見つけ、その引数の数値を変えると攻撃の種類が変わることに気付くと、いろいろな攻撃を試したくなって朝方近くまでずっとそのサンプルコードで遊んでいました。
以前のそのゲームでは考えられなかったような目新しい動きをする強力なボスキャラクターに惹かれ、見よう見まねで自分なりのボスを作って公開したり、新しい仕掛けが作れないかどうか考えを巡らせたりしていました。
いくつかそういった機能を追加していくうちに、配列を使うことを覚えたり、ボスをオブジェクトにして、しかもそれを配列に入れてしまえば、わざわざ変数を分けて書かなくてもたくさんのボスキャラクターを出現させられることに気付いたりして、次第にプログラミングというものに興味が沸いていきました。&lt;/p&gt;

&lt;p&gt;近年ではJavaアプレットはほぼ駆逐されつつあるため、このゲームもそのままでは遊ぶことができなくなってきています。
一方、このゲームをJavaからJavaScript+Canvasコードに変換した移植プロジェクトが存在しており、高い互換性から既存のステージのCanvas版への移行が進んでいます。
しかしもともとJavaScriptによる拡張を施していたステージについてはそのままでは移行できないこともあり、私が作ったそのようなステージは現在遊ぶことができない状態になっています。
そのため、いずれこのようなステージを遊ぶことができるように移行作業を行いたいと考えています。&lt;/p&gt;

&lt;p&gt;2.&lt;br&gt;
JavaScript以外のプログラミング言語にも触れてみたいと思っていた時にハッカーになろう(&lt;a href=&#34;http://cruel.org/freeware/hacker.html&#34;&gt;http://cruel.org/freeware/hacker.html&lt;/a&gt; )を読む機会があり、まんまと影響されたためにPythonを使って何か作ろうと思い、作りました。
Pythonと、Pythonで使用できるGUIツールであるTkinterを用いて作成しました。
exe形式の実行ファイルへの変換は、py2exeを使用しています。&lt;/p&gt;

&lt;p&gt;3.&lt;br&gt;
高校1年の文化祭の展示物として、GUIアプリケーションを作成できるQtを用いて、C++で作成しました。
元ネタが非常に洗練されたゲームであるため、ゲームとして必要な機能はおおよそまとまっているように思えるので、何か機能を追加するとしたら(ソースコードを紛失していることも忘れるとしたら)、演出を強化してより見栄えの良いものにしたいと思います。&lt;/p&gt;

&lt;p&gt;4.&lt;br&gt;
1.でとりあげたJavaアプレットゲームでは、私はあくまでJavaScriptを使って外側からゲームに手を加えている立場でしたが、自分でもアクションゲーム自体を作ってみたいと思うようになり、またどうせならJavaアプレットよりも新しい技術を使い、新しい機能を付け加えてみたい、と考えました。
そこで、当時新しく登場していたHTML5、Socket.io、Silverlightといった技術に目を付け、複数人で通信してゲームができればきっと楽しいだろうと思い、ブラウザ上でオンラインプレイ可能なアクションゲームを作ろうと思って作り始めました。
この当時はまだCanvasの仕様や実装が固まっていなかったため、C#+Silverlightを使って開発することに決めました。
またこの頃socket.ioのリアルタイム通信が騒がれていたため、これを使ってリアルタイムで通信をさせようと思いましたが、結局のところ生のWebSocketのほうがsocket.ioを使うよりも高速に通信できることから、サーバー側もC#で書き、WebSocketでの通信を行うことにしました。
(しかしながら、ただでさえ主要ブラウザの一部に実装されたばかりのような状態であるWebSocketが至る所で繋がらなかったり、それに加えてSilverlightのセキュリティポリシーのためclientaccesspolicy.xmlを別ポートで配信しておかないとクロスドメイン通信はできず、かつこのSilverlight上でWebSocket通信を確立しようと試みたため、実際のゲーム面のみならずインターネットを介して通信を確立させるというただ一点についてもかなり苦労することとなりました)&lt;/p&gt;

&lt;p&gt;現在はSilverlightを動かすことさえ困難になりつつある一方で、Canvasを使えないブラウザはほとんどなくなり、またUDP上で構築されているためにWebSocketよりも速度が期待できるWebRTCが広まってきたことなどから、今後改善するとすればまずはHTML5への移植であると考えられます。&lt;/p&gt;

&lt;p&gt;また、ブラウザ上での(見かけ上)同期のとれたリアルタイム通信は、いずれ再挑戦したい点だと考えています。
(1)で述べたようにこのプログラムには通信遅延による影響を抑えるために様々な工夫が凝らしてあるのですが、それ以前の問題があります。
たとえば互いに0.2秒ずれていても通信が成り立つとしても、そのずれが小さくなっていく方向に修正していく機能がなければ、恒常的に0.2秒ずれた状態で通信がつながっていて、たまたまそのずれが0.21秒に広がったときに破綻してラグが生じる、ということが起こりますから、こういった点は改善の余地があると思います。&lt;/p&gt;

&lt;p&gt;5.&lt;br&gt;
このソフトは現在Web上で公開していますが、バージョン番号に2がついています。
バージョン1はC#+Silverlightで、バージョン2はTypeScript+jQuery(+jQueryUI)となっています。
またバージョン2では、タスクランナーであるgulp.jsを用いることで、ソースコードの更新を検知して即座にコンパイルしてブラウザ上に反映しながら開発しました。
ユニットの戦闘は、戦闘力比をもとにした確率でどちらかがダメージを受け、それを片方が倒れるまで繰り返すという処理によって行われるため、二項係数を用いて計算することができます。
とはいえ数式上では120C60などの値が登場し、これを実際に計算しようと思えばlong型の最大値も越えてしまいます。
バージョン1では(ごく限られた機能の)多倍長整数演算ができるようなクラスを自作して頑張って計算していましたが、バージョン2では競技プログラミングに少し触れていたこともあって、二項係数はメモ化しておけば高速化できる上に、複数回計算を行った場合に前の計算の結果を使えばすぐ結果が返せる、また結果の勝率はせいぜい小数点3位程度までが正確であればよいので、double型の精度で生じるような誤差は無視して構わないと考えたことなどから、バージョン1よりも簡潔かつ高速に処理ができるようにしました。&lt;/p&gt;

&lt;p&gt;バージョン2の開発時、ユニットをリストから選ぶことでも、名前を直接入力することでも、また名前の一部を入力することで表示されるサジェストを選択することでもユニットが選択できるようなコンボボックスを利用したかったため、この要件を満たせるようなUIが提供されるJavaScriptライブラリを探していたところjQueryUIが見つかりました。
そのためにバージョン2にはjQueryを使っていますが、この前同じようなコンボボックスがReact系のライブラリでも実現できることを知ったため、今後はこれをReactで書き直してみたいと思っています。&lt;/p&gt;

&lt;p&gt;また、データセットにはJSONを読み込んでおり、その一部の文字列を正規表現で読み取って独自記法のようにしている部分があります。
今の私には8.で作った自作のパーサジェネレータがあるため、それを使って生成したパーサを用いてより簡潔かつ拡張性に富んだ形でデータセットが記述できるようにしたいと考えています。
UI部分のReactでの書き直しと合わせて、早いうちにバージョン3の開発に取り掛かりたいと思います。&lt;/p&gt;

&lt;p&gt;6.&lt;br&gt;
アクションゲームを作成するのと並行して、そのゲームを作成できるフレームワークを作り、アクションゲームだけでなくほかの種類のゲームの開発も容易に行えるようにしたい、と考えたため、単にゲームを実装しているのではなく、フレームワーク部分とゲーム部分の2つにプロジェクトを分け、フレームワーク部分の持つべき役割を考えながら作成していました。
外部のデータを読み込むローダーをそれ単体で利用しやすい形に設計したり、あるクラスを多様な用途に使えるようにするために、どこまでの役割をそのクラスに持たせて、残りを別のクラスの役割とするべきなのかを考えながら作っていましたが、これぞといった設計を捻りだすのは難しく、ウンウン唸ってばかりでなかなか開発が進まなかったりしていました。&lt;/p&gt;

&lt;p&gt;7.&lt;br&gt;
Freecivプレイヤーの知人が新しく常設ゲームサーバーを作ろうとしていたので、その公式サイトの作成を担当しました。
HTML5やCSS3の新機能はある程度追いかけていたのですが、実際にWebページを作った経験はHTML4.1の時代で止まっていたので、HTML5の仕様に準拠したモダンな作りのWebサイトにできるよう心がけました。
またデザインも自分が考えることになったので、派手にならず、かつ味気ないものにならないような見た目のページにするにはどのようにすればいいかを考えながら作りました。&lt;/p&gt;

&lt;p&gt;ブログは、Twitter等ではあまり長い文章を書くことができないため、何らかの形で長めの文章や技術的な話題について発進&lt;code&gt;/* 誤字 -&amp;gt; 発信 */&lt;/code&gt;できるような場所が欲しいと思ったことから作りました。
このブログには静的サイトジェネレータであるHugoを使用しています。
コメント機能やトラックバック機能などは必要ないと考えたため、サーバーサイドでブログ用のプログラムは走らせず、手元で記事を書くたびにサイトをビルドしてそれをアップロードするようにしました。
Hugoのテンプレートエンジン機能を利用して、さまざまなブログ向けのテンプレートが公開されていたのですが、あまりしっくりくるものがなかったため、テンプレートを自分で記述してブログのデザインを行いました。
また、ビルドからアップロードまでの手順を自動化しようと思い、CIサービスであるWerckerを利用してそちらでビルドが行えるようにしました。
手元で記事を書き、Markdownファイルを追加したコミットを作成してGitHubにpushすることで、Wercker側でビルドが行われ、用意しておいた別のGitHubリポジトリにビルド結果のコミットが行われて、その内容がサーバーにアップロードされることで記事が反映されます。
ブログのデザインや、カテゴリ・タグ表示の機能にはもっと見やすくするための改善の余地があると思っています。&lt;/p&gt;

&lt;p&gt;8.&lt;br&gt;
どうすれば構文解析ができるのかよくわからなくて調べたところ、Yaccなどのツールを使えばいいということがわかりましたが、どうもプログラミングっぽさに欠けるなあと思い、もう少し調べると、そのようなツールが用いているLR法などの手法を用いることで構文解析が実現できるとわかりました。
構文解析に関する大学の講義を受けていた上級生の知人がいたため、その方に理論を教えてもらったり、web上に上がっていた言語解析に関する大学の講義スライドを読んだりしてLR法について勉強し、これをコードに落とし込みました。
実装はTypeScriptによるフルスクラッチです。
LR法による構文解析は行う手順が多く、それらの手順が明確に分離されているため、「とりあえずこの機能さえ動けば次に進める」ような箇所が多くありました。
そのため、とにかく動作するように開発を進めていくことでテンポよく開発を進めていきましたが、その分だけ複雑な処理をしている部分のコードが非効率的なままになってしまう傾向がありました。
それでもまずは完成させることを優先して開発を進め、構文解析の成功に至った段階ですべてのソースコードの見直しを行ってリファクタリングと最適化を進めました。
結果として、自分自身の構文ファイルを解析してパーサーを生成する処理に2秒程度かかっていたのが、最終的に100msから50msにまで処理時間を減らすことができました。&lt;/p&gt;

&lt;p&gt;追加していきたい機能は複数あります。
まず、このパーサジェネレータではLA(1)文法&lt;code&gt;/* 誤字 -&amp;gt; LR(1)文法 */&lt;/code&gt;に厳密に従ったあいまいさのない構文しか処理することができません。
具体的には、 S -&amp;gt; S+S | x というような構文があったとき、x+x+xという入力の(x+x)+xとx+(x+x)の2通りを区別できないためにこの構文はコンフリクトを起こし、パーサの生成に失敗します。
演算子に右結合・左結合の設定を行ったり、演算子の優先順位の設定を行える機能を搭載し、例のような構文も処理できるようにしたほうが実用的になると考えています。&lt;/p&gt;

&lt;p&gt;また、実際にパーサに入力を与えたときに構文解析に失敗した場合、失敗したという事実は通知されますが、どこでどのような失敗が起こったのかというエラーメッセージを表示する機能がないので、パーサがただ構文解析表を読み取っていくだけでなくどのような失敗が発生したのかも検知できるようにしたいと思っています。&lt;/p&gt;

&lt;p&gt;そして、ただ構文木を作るだけでなく、規則ごとに割り当てられたコードをその場で実行できるように、構文ファイルに処理を書き込めるような機能も追加したいです。
現状ではコールバックを渡すことで同様の処理が可能ですが、渡した関数の中で今どの規則の解析を行ったのかを判断しないといけないため、煩雑になりがちです。
そのため、規則とコードを直接結びつけて構文ファイルに記述できるようにするのがよいと考えています。&lt;/p&gt;

&lt;h3 id=&#34;共-1-3:ba10b11125a0bfb60081de5c3341fee7&#34;&gt;共-1（3）.&lt;/h3&gt;

&lt;p&gt;開発記のブログ、スライドなどの資料があれば、それも教えてください。コンテストなどに出品したことがあれば、それも教えてください。&lt;/p&gt;

&lt;p&gt;4.は、立命館大学主催のソフトウェアコンテストであるICT Challenge+R2013高校版(&lt;a href=&#34;http://www.2013.ict-challenger.jp/&#34;&gt;http://www.2013.ict-challenger.jp/&lt;/a&gt; )に出品してファイナリストに選ばれ、2つの企業賞を受賞しています。
またこれに参加した際のスライド発表の様子は、youtube上に公開されています(&lt;code&gt;/*検閲により削除。探せば見れます。*/&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;7.のブログの構築については、ブログ上の記事でその流れを公開しています(&lt;a href=&#34;http://tatamo.81.la/blog/tags/blog/&#34;&gt;http://tatamo.81.la/blog/tags/blog/&lt;/a&gt; )。&lt;/p&gt;

&lt;p&gt;また、8.のパーサジェネレータについても、構文解析入門、およびパーサジェネレータの自作方法の解説という体裁で紹介記事を同じブログで公開しています(&lt;a href=&#34;http://tatamo.81.la/blog/tags/parser-generator/&#34;&gt;http://tatamo.81.la/blog/tags/parser-generator/&lt;/a&gt; )。&lt;/p&gt;

&lt;h3 id=&#34;共-1-4:ba10b11125a0bfb60081de5c3341fee7&#34;&gt;共-1（4）.&lt;/h3&gt;

&lt;p&gt;Twitterアカウント、Github、ブログをお持ちでしたら、アカウント名、URL等を記載してください。&lt;/p&gt;

&lt;p&gt;Twitter: @__tatamo__ &lt;a href=&#34;https://twitter.com/__tatamo__&#34;&gt;https://twitter.com/__tatamo__&lt;/a&gt;&lt;br /&gt;
GitHub: &lt;a href=&#34;https://github.com/tatamo&#34;&gt;https://github.com/tatamo&lt;/a&gt;&lt;br /&gt;
ブログ: &lt;a href=&#34;http://tatamo.81.la/blog/&#34;&gt;http://tatamo.81.la/blog/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;共-2-1:ba10b11125a0bfb60081de5c3341fee7&#34;&gt;共-2（1）.&lt;/h3&gt;

&lt;p&gt;あなたが経験した中で印象に残っている技術的な壁はなんでしょうか？
（例えば、C言語プログラムを複数ファイルに分割する方法など）&lt;/p&gt;

&lt;p&gt;GoFの23のデザインパターンについてインターネットで調べ、どのような設計のしかたが一般に行われているのかを勉強しました。
また、ゲームのプログラムをどのように構成すればよいのかを知るために、「ゲームプログラマになる前に覚えておきたい技術」「ゲームエンジン・アーキテクチャ」を読みました。
そして、実際にいろいろな言語で提供されているゲーム制作用のライブラリのリファレンスやソースコードを読んで、どのような機能が提供されていて、他の機能とどこで分けられているのか、それがどのような使い方をされるように作られているのかを調べました。
そして実際に、ゲームを作るというよりゲームのフレームワークを作るようにすれば、それを使って簡潔にゲームが作れるようになるのではないかと思い、自分でプログラムを作っていきました。&lt;/p&gt;

&lt;h3 id=&#34;共-2-2:ba10b11125a0bfb60081de5c3341fee7&#34;&gt;共-2（2）.&lt;/h3&gt;

&lt;p&gt;また、その壁を乗り越えるためにとった解決法を具体的に教えてください。
（例えば、知人に勧められた「○○」という書籍を読んだなど）&lt;/p&gt;

&lt;p&gt;GoFの23のデザインパターンについて調べ、そしてその前提として必要ならば、オブジェクト指向についての理解を深めるようにアドバイスをします。
そしてその上で、この壁についてあまり深く考えることはやめたほうがいい、と言いたいと思います。&lt;/p&gt;

&lt;p&gt;ゲームのフレームワークを作らなくてもゲームを作ることはできますし、一般に個人的にゲームプログラムを作るぐらいなら、コード全体に影響を及ぼすような破壊的な変更を含む大幅な仕様変更はそう何度も行われるものではない(または、行われるべきではない)と思います。
そのような場合は、「そこそこ」の設計であってもゲームは正しく動作すると思われるので、設計に頭を悩ませるよりも、その時間でゲーム自体にどのような機能を追加できるか、それによってゲームを面白いものにできるかを考えるべきだと思います。
つまり、ゲームを作りたいのか、それともゲームのフレームワークを作りたいのか、自分がそのどちらを望んでいるのかを見失うべきではないです。&lt;/p&gt;

&lt;p&gt;また、ただ考え続けるよりは実際に動くプログラムを書いたほうが、設計があいまいであっても全体がどのように動くのかを把握できるため、次に似たものを作るときによりよい設計が浮かびやすくなると思います。
プログラミングが好きだからゲームを作りたい、と思っていると、「既存のライブラリやフレームワークを使ってゲームを作るよりも、自分のプログラムでゲームを動かしたい」という気持ちになりがちだと思います。
しかしながら、既存の良く考えて設計されたフレームワークを使えば、その設計に触れ親しむことにもなり、また肝心のゲームを面白くすることにより注意を払うことができるようになります。
そのため、まずはあまり深く考えるのをやめて、とにかく動くゲームを作ってみたり、既存のライブラリやフレームワークを使ってみたりするほうがいい、とアドバイスしたいです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
お察しの通り、入力フォームに1箇所ずれて回答を貼り付けてしまっており、共-2 (1)の回答が消滅しています。
ここに書いたところで何の意味もありませんが、以下に本来の2(1)の回答を掲載しておきます。

作りたいプログラムを書くときに、機能をどのように分け、クラスをどのように設計すればよいか。
特に、ゲームを作る際のキャラクターやエンティティを表すクラスについて、それぞれがゲーム全体の情報にどこまでアクセスできるようにするべきか、
またほかのゲーム内エンティティを表しているオブジェクトに対してどのようにメッセージのやりとりを行うべきか、
そして、どのようにゲームプログラム内のクラスの継承関係や依存関係を構築していけば、
全体の見通しを良くすることができたり、可能な限りコードクローンの量を小さくでき、
可能な限り多くの処理コードをスーパークラスや他のクラスから引き継げるのか。
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;共-2-3:ba10b11125a0bfb60081de5c3341fee7&#34;&gt;共-2（3）.&lt;/h3&gt;

&lt;p&gt;その壁を今経験しているであろう初心者にアドバイスをするとしたら、あなたはどんなアドバイスをしますか？&lt;/p&gt;

&lt;p&gt;GoFの23のデザインパターンについて調べ、そしてその前提として必要ならば、オブジェクト指向についての理解を深めるようにアドバイスをします。
そしてその上で、この壁についてあまり深く考えることはやめたほうがいい、と言いたいと思います。&lt;/p&gt;

&lt;p&gt;ゲームのフレームワークを作らなくてもゲームを作ることはできますし、一般に個人的にゲームプログラムを作るぐらいなら、コード全体に影響を及ぼすような破壊的な変更を含む大幅な仕様変更はそう何度も行われるものではない(または、行われるべきではない)と思います。
そのような場合は、「そこそこ」の設計であってもゲームは正しく動作すると思われるので、設計に頭を悩ませるよりも、その時間でゲーム自体にどのような機能を追加できるか、それによってゲームを面白いものにできるかを考えるべきだと思います。
つまり、ゲームを作りたいのか、それともゲームのフレームワークを作りたいのか、自分がそのどちらを望んでいるのかを見失うべきではないです。&lt;/p&gt;

&lt;p&gt;また、ただ考え続けるよりは実際に動くプログラムを書いたほうが、設計があいまいであっても全体がどのように動くのかを把握できるため、次に似たものを作るときによりよい設計が浮かびやすくなると思います。
プログラミングが好きだからゲームを作りたい、と思っていると、「既存のライブラリやフレームワークを使ってゲームを作るよりも、自分のプログラムでゲームを動かしたい」という気持ちになりがちだと思います。
しかしながら、既存の良く考えて設計されたフレームワークを使えば、その設計に触れ親しむことにもなり、また肝心のゲームを面白くすることにより注意を払うことができるようになります。
そのため、まずはあまり深く考えるのをやめて、とにかく動くゲームを作ってみたり、既存のライブラリやフレームワークを使ってみたりするほうがいい、とアドバイスしたいです。&lt;/p&gt;

&lt;h3 id=&#34;共-3-1:ba10b11125a0bfb60081de5c3341fee7&#34;&gt;共-3（1）.&lt;/h3&gt;

&lt;p&gt;あなたが今年のセキュリティ・キャンプで受講したいと思っている講義は何ですか？（複数可）
そこで、どのようなことを学びたいですか？なぜそれを学びたいのですか？&lt;/p&gt;

&lt;p&gt;■C1　ブラウザの脆弱性とそのインパクト&lt;br /&gt;
私はJavaScript(やSilverlight)によってWeb上で動作するアプリケーションを開発しているので、実際に自分が作ったものが動いている基盤であるブラウザに関連した攻撃は他人事とは思えません。
また、ブラウザはサーバーサイドとクライアントサイドの間に立っているもので、かつ十分すぎるほどの複雑さを持ったものです。
サーバー側のセキュリティ、それに接続するクライアント側のセキュリティについて考えることは当然ですが、そこに介在しているブラウザの、その脆弱性が悪用されることについて見落とすべきではないといえるはずです。
しかしブラウザはいつも使っているものでありながら、その内側については何も知らないというような気がします。
そのため、ブラウザの脆弱性について具体的に考えられるようになるための知識、そして考え方を学びたいと思っています。&lt;/p&gt;

&lt;p&gt;■D2~3　カーネルエクスプロイトによるシステム権限奪取&lt;br /&gt;
問題の出題順とは前後しますが、私はこの回答を選択問題A-5に取り組んでから書いています。
そして率直に言って、あの選択問題はさっぱりわかりませんでした。
カーネル部分のコードの脆弱性の発見、それを利用したコード実行、さらに実際に権限昇格を行うためのコードの作成、そしてそれを防ぐためのセキュリティの回避、これらについて私は全くといっていいほど知見を持っていません。
カーネルのソースコードを読むだけでなく、カーネルモードやユーザ―モードといったCPU・OSの動作の仕組み、仮想メモリの展開や領域確保のされかたなど、膨大かつ細部に渡るような知識を持っていなければ、このような脆弱性を見つけ出し、そして悪用することはとてもできないのではないかと感じました。
しかしながら、実際にセキュリティに携わる人々、そして攻撃を行う人々は大勢います。
つまり、すごい人たちがたくさんいるんだなあと実感しました。そのような世界についてとても学びたいです。&lt;/p&gt;

&lt;p&gt;■E4　サイバー犯罪捜査の現場&lt;br /&gt;
サイバー攻撃は犯罪ですから、当然攻撃した人は逮捕されないといけません。
とはいえセキュリティの世界は、(何も知らない私から見た考えですが、)たとえばセキュリティソフトを開発している民間の企業や、脆弱性に対してパッチをあてる開発者、攻撃を受けたことを調べるネットワーク管理者など、警察とは関係のない人々が大半のように思えます。
このようなセキュリティの世界において犯罪捜査をどのように行っていくのか、ということは興味深く、そしてこれを学べる機会は貴重なものだと思います。
攻撃と防御だけでなく、捜査という観点からセキュリティについての理解を深めたいと思っています。&lt;/p&gt;

&lt;p&gt;■A6　ハードウェアセキュリティ最前線&lt;br /&gt;
「暗号回路で実行される処理中に発生する副次的（サイドチャネル）な情報を取得し、それらの信号にどのような情報が埋め込まれていたかをデジタルオシロスコープを用いて観測し、実際に暗号解読を試みる」。
ワクワクする響きだと思いました。暗号をオシロスコープを使って解読する。
処理中に発生する情報、そしてそれを取得し利用するという発想は、ソフトウェアをプログラミングする観点からではそう出てくるものではないと思います。
結果として得られる暗号がソフトウェア的に利用されるものだとしても、それを生成するハードウェアから情報を盗み出せるという観点に興味を抱いたため、ぜひ受講したいと思っています。&lt;/p&gt;

&lt;p&gt;■D7　ゲームセキュリティ入門&lt;br /&gt;
ブラウザの脆弱性同様、自分がこれまで触れてきたことに関係する分野であり、それでいてセキュリティと結びつけて考えたことはありませんでした。
ゲームとセキュリティをどのように結び付けて考えればいいのか？どのように解析されうるのか？といったことを実際に行って学び取ることができればと思います。&lt;/p&gt;

&lt;h3 id=&#34;共-3-2:ba10b11125a0bfb60081de5c3341fee7&#34;&gt;共-3（2）.&lt;/h3&gt;

&lt;p&gt;あなたがセキュリティ・キャンプでやりたいことは何ですか？　身につけたいものは何ですか？（複数可）
自由に答えてください。&lt;/p&gt;

&lt;p&gt;私がセキュリティキャンプでやりたいことは、わかりません。
身に着けたいことも、よくわかりません。
このような積極性に欠ける姿勢はよくないだろうと思われるかもしれませんが、実際に私はセキュリティキャンプに対して受け身な姿勢で臨むだろうと思います。
そもそも私はこれまでセキュリティというものにほとんど触れたことがありません。
リバースエンジニアリングを行って実行ファイルを解析したこともありませんし、バイナリハックなども(フリーゲームのセーブデータをバイナリエディタで弄ってチートをしようと思ったことはありますが)全然やったことがありませんし、暗号技術がどのように運用されているかも知りません。
Linuxカーネルのソースコードを読んだこともなければ、流れているパケットをキャプチャしたこともありません。&lt;/p&gt;

&lt;p&gt;私はこの回答を、選択問題をほとんど回答した後に記述しています。
適切な表現かはわかりませんが&lt;code&gt;/* 何を今更 */&lt;/code&gt;、選択問題について、これはよくできた問題だなあ、ということを幾度となく感じました。
OSとCPUがどのように協調して動作しているのか、仮想メモリはどのように展開されているのか、TCP/IPはどのように構築されているのかということから始めて、それに関連してどのような脆弱性が存在するのか、それをどのように悪用して攻撃につなげるのか、など一つの問題の中で段階を踏んで何度もわからない箇所が現れ続けるので、壁の高さを感じました。
一方で、それを少しずつ紐解こうとしているうちに、基礎から実践、応用と幅広い範囲についてわずかではあるものの見通せるようになったような気がしました。&lt;/p&gt;

&lt;p&gt;一般になにかの技術について勉強しようと思ったら、本を読んだり、実際に試してみたりして理解を深めていくものだと思います(勉強会に行ったりする人もいると思いますが、私は行ったことがありません)。
しかしながら、たとえば私がカーネルエクスプロイトなどについて勉強しようと思ったとして、まず何から手を付けていいかわからないでしょうし、知見が足りないためにこなすべき問題の設定も適切にできるとはいえないでしょう。
また、その分野について詳しい人が身の回りにいるとも限りません。
セキュリティキャンプの応募用紙の問題に取り組んでいて、この問題設定はよくできている、と思った点はそこにあります。
全くの知見がない私であっても、適切な問題が与えられることで基礎から応用まで俯瞰しながら取り組むことができたからです。&lt;/p&gt;

&lt;p&gt;私はこのような受け身の姿勢でもってセキュリティキャンプに対して期待を持っています。
つまり、私の知らないことに対して、驚くほど適切に学ぶべき道を示してくれるだろうという期待です。&lt;/p&gt;

&lt;p&gt;限りなく抽象的に述べるならば、私がセキュリティキャンプでやりたいこととは、何を学べばいいのかを見つけることであり、身に着けたいものはそのようにして与えられたものです。
当然、それらの与えられたものについては全力で学び取っていこうと思います。&lt;/p&gt;

&lt;p&gt;もちろん、同じように学んでいける人々とつながりを持つということも求めていきたいです。
一緒に学んでいける人がいるということには、数えきれないほどのメリットがあるからです。
そしてそのような人々が詳しいこと、私が詳しいことは人によって皆違うはずなので、詳しい人からたくさん学ぶことができるようになり、セキュリティキャンプが終わった後も良い影響を及ぼしあうようになることができればと考えています。&lt;/p&gt;

&lt;h2 id=&#34;選択問題:ba10b11125a0bfb60081de5c3341fee7&#34;&gt;選択問題&lt;/h2&gt;

&lt;h3 id=&#34;選-a-1:ba10b11125a0bfb60081de5c3341fee7&#34;&gt;選-A-1.&lt;/h3&gt;

&lt;p&gt;添付したファイルに記録された通信を検知しました。この通信が意図するものは何か、攻撃であると判断する場合は何の脆弱性を狙っているか。また、通信フローに欠けている箇所があるがどのような内容が想定されるか、考えられるだけ全て回答してください。なお、通信内容を検証した結果があれば評価に加えます。&lt;/p&gt;

&lt;p&gt;.pcapについて調べると、パケットキャプチャを記録しておくためのファイルだということが分かったため、Wiresharkを使用して開きました。
192.168.74.1および192.168.74.130の二者の間での14件のパケットが記録されており、そのうちの13件がTCPプロトコル、1件がHTTPプロトコルによるものだということがまず分かりました。
また、Wireshark上で警告表示のあるパケット4件も含まれていました。
理由は後述しますが、私は結論としてこの通信が攻撃であると判断しているため、簡単のために192.168.74.1を攻撃側、192.168.74.130をサーバー側と呼称することにします。
これらのパケットは、攻撃側55522番ポートとサーバー側8080番ポートの間の9件の通信、および攻撃側53653番ポートとサーバー側22番ポートの間の5件の通信に分けられます。
8080番ポートは80番ポートの代替としてHTTP用に用いられており、実際にこのポートに対してHTTPリクエストが行われていることからHTTPサーバーが起動しているものと考えられます。
また22番ポートはSSHに割り当てられたwell-knownポートであり、サーバー側に対して攻撃側がSSHに関連した接続を行っているものと思われます(ただしキャプチャされたパケットにはssh通信は記録されていません)。
192.168.74.130がこれらの既知のポートで通信を行っていることから、こちらが攻撃を受ける側であると考えられます。&lt;/p&gt;

&lt;p&gt;まずは、8080番ポートに関連した通信に絞って調べました。
最初の3つのパケットは交互にSYN,SYN・ACK,ACKの通信が行われており、これはTCPの3ウェイハンドシェイクによる接続の確立だと判断できます。&lt;/p&gt;

&lt;p&gt;次に、/struts2-rest-showcase/orders.xhtml に対してGETメソッドによるHTTPリクエストが行われています。
このリクエストは、HTTPヘッダのContent-Typeの項目に明らかにMIMEタイプやcharsetの定義ではない、何らかのコードであると思われる文字列を含んでいます。
リクエスト先にstruts2という文字列が含まれている点、およびContent-Type部分にコードが書き込まれていることから、これはStrtus2の脆弱性であるCVE-2017-5638(S2-045/S2-046)を狙ったものであると考えられます。
この脆弱性によってContent-Typeに含まれるOGNL式が評価されるため、OGNLによって表現された任意のコードが実行可能となります。
今回検知された通信に含まれているコードは、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;cat /etc/passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というコマンドの実行を行うものです。
これにより、脆弱性に対する対策が取られていなかった場合、サーバー側は攻撃側に対して/etc/passwdの中身を送信します。
このGETリクエストに対するACKのパケットの次に検知されたパケットは、攻撃側からサーバー側に対してのACKであり、Wiresharkはこのパケットに対して警告を出しています。
このパケットでは攻撃側からサーバー側に対して、何らかの通信へのACKが行われ、Acknowledgment numberは最前の攻撃側からのパケットでの数値が1だったにもかかわらず1464となっています。
またこれより後に続くサーバー側の通信(11番目のパケットである、FIN・ACKの応答)に目を遣ると、Sequence numberが1464となっていることもわかります。
よって、このパケットの直前に攻撃側はサーバー側から長さ1463のデータを受け取っており、そのパケットは記録から欠けていると判断できます。
この失われたパケットは、攻撃側からのHTTPリクエストに対するサーバーからの返答であると考えられます。
ただし、TCP接続確立に用いられた最初の2つのパケットを確認すると、双方ともに最大セグメントサイズを1460バイトと規定していることがわかります。
このため、長さ1463のデータで通信する場合、パケットは2つに分割されていたのではないかと考えられます。
よって、ここで欠けているパケットは1つとは限らず、2分割された2つのパケット、またはそれらに加えて分割されたうち1つ目のパケットに対するACK応答などが含まれていた可能性があります。&lt;/p&gt;

&lt;p&gt;このACKのパケットに続いて、FIN・ACKフラグがセットされた通信が攻撃側から行われています。
このパケットのAcknowledgment numberも1464であるため、HTTPレスポンスの通信を検知していないWiresharkはTCP ACKed unseen segmentの警告を出しています。
TCPヘッダにFINフラグがセットされているため、これは通信終了を示しています。
その次の通信はサーバー側からの通信であり、FIN・ACKフラグがセットされています。
このパケットに対しWiresharkはTCP Previous segment not captured警告を発しており、またTCPの通信終了の際はサーバー側からのFIN・ACKフラグのセットされた通信の前に、攻撃側からのFINに対するACKのパケットが送られるべきであることから、この直前の通信が欠けており、その内容は長さ0のACKであると判断できます。
その後攻撃側からACK応答が届き、このポートでの通信は終了しています。&lt;/p&gt;

&lt;p&gt;次に、22番ポートにおける通信に着目します。
このポートでの通信は5回検知されていますが、そのすべてが攻撃側からサーバー側への、長さ0のACK応答となっています。
最初に検知されたパケットのTCPヘッダを確認すると、Sequence numberおよびAcknowledgment numberがともに1となっています。
ハンドシェイクによる接続確立のパケットは確認できないため、既に接続を確立した後のものであると考えられますが、何らかのデータの受信に対してACKの応答を行った場合、Acknowledgment numberは1より大きくなっているのではないかと推測されます。
よって、このACK応答は3ウェイハンドシェイクのうちの最後の1つであり、この前に攻撃側からのSYN→サーバー側からのSYN・ACKの通信が行われており、記録ではその2つのパケットが欠けていると考えることができます。
その後の4回の通信は、900から2500バイトのデータをサーバー側から連続して受け取ったことに対するACK応答であるように見えます。
しかしサーバー側から攻撃側に送信されたデータは記録されておらず、確認できません。
また、この間常に攻撃側のパケットのSequence numberは1のため、攻撃側が能動的にリクエストを発した形跡はないと考えられます。
また、実際にdockerでSSHを待ち受け、その接続の様子をキャプチャしてみましたが、SSHの接続処理によって攻撃側とサーバー側双方のSequence numberおよびAcknowledgment numberは1より大きくなったため、この攻撃者はSSHでの接続は行っていないと思いました。
一方でtelnetでSSHに接続を行ったところ、サーバー側からのSSHプロトコル通信によってやはりSequence numberおよびAcknowledgment numberの両方が1にはなりませんでした。
そのため、この一連の接続において攻撃側が何を行ったのかはわかりませんでした。&lt;/p&gt;

&lt;p&gt;以上の通信記録より、これはCVE-2017-5638を悪用した攻撃であると判断します。
攻撃者がcat /etc/passwdというコマンドの実行を試みたこと、SSHに使用されるポートに対する接続を行っていることから、この通信の意図は3つ考えられます。&lt;/p&gt;

&lt;p&gt;まず1つ目に、攻撃者が/etc/passwdに格納されている情報の利用を試みた可能性についてです。
この脆弱性が存在する最も古いバージョンであるStruts2.3.5のリリースは2012年であることから、パスワードハッシュが/etc/shadowではなく/etc/passwdに格納されているような大昔のUNIXシステム上で脆弱性のあるStruts2が動作していると考えるのは困難です。
またシステム管理者がシャドウパスワードを無効化するような設定を行っていたり、パスワードなしでログイン可能なユーザーが存在すれば攻撃対象とすることができますが、やはり非現実的であるように考えられます。&lt;/p&gt;

&lt;p&gt;もう1つは、この通信は攻撃対象のシステムがCVE-2017-5638脆弱性を含んでいるかどうか調査するための通信であるという可能性です。
サーバー側からのレスポンスによって任意コード実行が成功したかどうかを判別できるので、この通信によってCVE-2017-5638を利用した攻撃が可能かどうかを知ることができます。
しかしながら、今回の通信時に攻撃用のコードを直接実行しなかったこと、SSHに使用されるポートに対しても接続を行っていることについては疑問が残るように思われます。
前者については、このシステムだけでなく複数のシステムに対しての調査を行い、攻撃可能な対象の情報が十分に集まってから攻撃に移ることを意図しているのではないか、後者については、別の脆弱性を利用して特権昇格を行うことで、rootの乗っ取りを図ろうとしているのではないか、またはそもそもSSHポートが開いているのかどうかを調査しようと考えたのではないかと考えることができます。&lt;/p&gt;

&lt;p&gt;そして最後に、これらの一連の通信はサーバー管理者によるペネトレーションテストなのではないかという可能性です。
実行されたコードが攻撃性の少ないものであることに加え、通信している両者は同じローカルネットワーク上に存在しており、Ethernetヘッダに含まれているMACアドレスはどちらもVmware上の仮想システムを示しています。
そのため、この通信は管理者が本番環境に使われているのと同じ構築の仮想環境を用意し、自らが管理しているシステムに脆弱性が含まれているかどうかを実際に攻撃を行うことで調べようとして行ったものである可能性が考えられます(もっとも、その場合はこの通信が「攻撃」なのかどうか、という判断が揺らぎかねないような気もしますが)。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://io.cyberdefense.jp/entry/2016/06/22/Docker%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%80%81Apache_Struts2%E3%81%AE%E8%84%86%E5%BC%B1%E6%80%A7S2-037%E3%81%AE%E3%82%84%E3%82%89%E3%82%8C%E7%92%B0%E5%A2%83%E3%82%92%E6%89%8B%E8%BB%BD%E3%81%AB%E4%BD%9C&#34;&gt;http://io.cyberdefense.jp/entry/2016/06/22/Docker%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%80%81Apache_Struts2%E3%81%AE%E8%84%86%E5%BC%B1%E6%80%A7S2-037%E3%81%AE%E3%82%84%E3%82%89%E3%82%8C%E7%92%B0%E5%A2%83%E3%82%92%E6%89%8B%E8%BB%BD%E3%81%AB%E4%BD%9C&lt;/a&gt;
に記載されている方法によって、Docker上で脆弱性を含んだバージョンであるStruts2.5.10のサンプルアプリケーション(struts-2.5.10-apps.zip)を構築し、インターネットに接続していないコンピュータ上でこれを実行しました。
その上でtelnetを用い、localhostに向けて記録されたHTTPリクエストと同じ内容のリクエストを送信したところ、/etc/passwdの内容が返っており、この通信をキャプチャすると記録されたログとほぼ同じものであることが確認できました。
また、脆弱性が修正されたバージョンで同様にリクエストを送信したところ、このコードは無視され、本来返されるべきHTMLが正常に返されていることが確認できました。
また、リクエストが/struts2-rest-showcase/orders.xhtml であることから、記録された通信においても私が検証に用いたのと全く同じサンプルアプリケーションが使われていたのではないかと推測できます。
仮にそうであるならば、このアクセスに対する正常なレスポンスではデータ長が1000バイト前後に収まるはずであるため、Acknowledgment numberが1463も増えている今回の通信においては、このサーバー側システムには脆弱性が存在し、攻撃者は任意コード実行に成功したものと考えられます。&lt;/p&gt;

&lt;h3 id=&#34;選-a-3:ba10b11125a0bfb60081de5c3341fee7&#34;&gt;選-A-3.&lt;/h3&gt;

&lt;p&gt;自分がソフトウェア・ハードウェアを実装した部分について、自分とは意見が異なる実装を提案してきた人が現れた場合、あなたはどうしますか。&lt;br /&gt;
- 自分の実装のほうが優れていると思った場合どうしますか？&lt;br /&gt;
- 自分の実装のほうが優れていないと思った場合どうしますか？&lt;br /&gt;
- 相手の母国語が自分と違うために正確に議論が進まない場合はどうしますか？&lt;br /&gt;
- 相手がものすごく強硬で石頭でこちらのいうことを何も聞かず実装を勝手に修正してしまった場合どうしますか？&lt;/p&gt;

&lt;p&gt;意見が異なる実装が提案された場合、まず互いに議論を進めることが最優先だと考えます。
自分の実装と相手の実装それぞれについて、それを採用する利点は何か、そして欠点は何かをお互いに理解し、その上でどちらを採用するかを決めるのが理想的です。
異なる実装を提案してくるということは、既存の(自分の)実装に対して差別化できる何らかの理由があるものと考えられます。
そのうえで自分の実装の方が優れていると思った場合、以下の状況が想定できます。&lt;/p&gt;

&lt;p&gt;1.
自分の実装には、自分が見逃している欠点がある。&lt;br /&gt;
2.
自分の実装に存在する欠点を、自分は理解していない。&lt;br /&gt;
3.
自分の実装について、自分が思っている利点が相手にとっては小さく、欠点が相手にとっては大きく感じられている(または、人によってどちらが良いか意見が割れるような問題である)。&lt;br /&gt;
またこれは相手にとっても同様のことがいえます。&lt;/p&gt;

&lt;p&gt;ここで議論を交わすことによってそれぞれの実装の利点と欠点を互いに理解することができれば、1,2のパターンだった場合は誤った認識を正すことで合意に至れるのではないかと思います。または、3のようなパターンに移行する可能性もあります。
議論を進めた結果として3のようなことが争点になった場合、そのソフトウェア・ハードウェアの利用方法について自分と相手の想定が食い違っているのではないか、という可能性についてまず考慮したいと思います。
たとえば自分が想定している利用方法では特定の関数を数回しか呼び出さないものであり、一方で相手にとってはその関数が数万回呼び出されるべきものであった場合、自分にとっては少しのオーバーヘッドなら無視できるが、相手にとってはそれが大きな問題となるため、少しでも高速な実装を採用するべきだということになります。
このような利用方法の想定の違いについての齟齬を正すことは、お互いの認識をすりあわせるという点ももちろんですが、実装をしているときに考慮していなかったことについて気付かせてくれる機会でもあるため、相手がどのような利用を考えているのかは知るようにするべきだと思います。&lt;/p&gt;

&lt;p&gt;また、その分野について自分や相手よりも詳しいと思われる第三者に意見を求めるのも重要だと考えます。
自分と相手の二者では、いくら意見を交換してもその問題についての知識が足りないために適切な決定に至れないおそれがあり、また自分と相手の両方が認識していなかった別の要素が存在している可能性もあるからです。&lt;/p&gt;

&lt;p&gt;そして、自分と相手の実装がどのぐらい異なっているのかによっても、対処の仕方が変わってくると思います。
小規模な修正で、変更する範囲が小さいとか、パフォーマンスが大きくは変わらない、全体にとっては些細な修正であるというような場合には、実際には「どちらでもいい」可能性もあります。
また小規模な修正であっても、先述した利用シーンの想定での例のように、状況や使う人にとっては明確な違いが出る場合もあります。
相手が異なる実装の提案をしているという時点で、「どちらでもいい」の基準の閾値を越えている可能性の方が高いだろうと想定できるのですが(両者の誤解や見逃しが解消されたうえでのことで、ですが)、そうであるならば、両方の案を採用して設定で切り替えをできるようにするとか、ケースによって使い分けるようにするのが最も適切である、という可能性があることについては忘れないようにしたいです(もっとも、ハードウェアではこれは難しいことも多いかと思います)。
また大規模な修正であるならば、相手が単なる提案だけをしているのか、それとも実際に代替となる実装を用意しているのかも重要になってきます。
まだその代案での実装が存在しないのであれば、その実装にかかるコストや、その実装を行った場合に他の箇所に予期しない影響が出ないかどうか、既に自分が作った実装を使っている人やものに影響が出ないかどうかについても考える必要があります(これは小規模な修正であっても起こりうることですが、大規模な修正であればそのリスクは増えていくと思います)。
変更の範囲が大規模であればあるほど、変更を加えることによって全体の設計思想の一貫性が崩れてしまう可能性を含んでいることについても考えるべきで、もしかしたら、その部分の変更だけではなく全体の見直しも含めた修正が必要になることがあるかもしれないと思います。
このような場合、全体の設計思想と照らし合わせて本当にメリットになるのかどうか、ということについても相手の考えを問うべきだと思います。
逆に、自分が、またはチーム全体が、どのような設計思想のもとでそれを作ろうとしているのか、それをしっかりと意識したうえでの実装であったのかを自分に問うことも同様に必要です。&lt;/p&gt;

&lt;p&gt;相手の母国語が自分と違っていて議論が正確に進まないというのは、かなり難しい状況だと思います。
(もっとも技術の世界では、とにかく英語が使えるなら相手の言っていることが全くわからない、ということにはなりづらいのではないかと思います。
実際にそのような状況が起こった場合には仕方のないことではあるのですが、まずこのような状況が発生しにくくなるように、個々人が、つまり私が、より高い英語のスキルを身に着けられるように努力することを忘れないようにしたいです。)
やはり基本的には、これまで述べてきたような観点から相手の&lt;code&gt;/* 誤字 -&amp;gt; 相手と */&lt;/code&gt;議論が進められるように根気よく議論していくのが一番であると思っています。
その上で、言語の違いが原因でなかなか議論が進まないのであれば、議論を行っている方法についても見直しをします。
たとえば口頭で議論をしている場合、発言の内容はログとして残ることがなく、聞き間違え、単語の意味がわからない、相手の言っている意味を理解しようとするのに必死になってその中身を吟味する余裕がない、などの副次的な問題が発生します。
また、メールや掲示板の形式で議論をしている場合、技術的な問題だけでなく言語間の差異による認識の違いを正すための発言がどうしても多くなってしまうため、やりとりの件数が増えてしまって本筋の議論が見失われがちになり、また一つのやりとりで多くの内容のメッセージを送るためやりとりの間隔が長くなるので、時間も多く必要になります。
ただし、メールおよびツリー型のBBSならば、言語の差のために正しく伝わらなかった情報を修正するために議論が脱線したとしても、もともとの発言に戻って本筋の議論を続けることができるという利点があります。
IRCのようなテキストチャットは、発言のログが残り、かつリアルタイムにやりとりをすることができるので、このような場合には比較的適していると思います。
しかしながら、チャットのログが増えるとやはり問題の本筋に関する発言が(文字通り)見失われてしまう可能性があります。
以上のメリットとデメリットから、このような場合の議論はできるだけテキストベースで行うようにして、またリアルタイム性が確保できるようにチャットの形をとりながら、要所ごとにそれまでの議論をまとめた文章をどこか別の場所に置くようにすれば、言語の違いを克服して議論を進めやすくなるのではないかと思います。&lt;/p&gt;

&lt;p&gt;もしも、相手がものすごく強硬で石頭でこちらのいうことを何も聞かず実装を勝手に修正してしまった場合、これは難しいというより厄介な状況だと思います。
まず、相手が別の箇所の実装やプロジェクトでも同じようなふるまいをしているのかどうかを調べます。
そして、やはり別の箇所でも強硬で石頭なふるまいをしているようであれば、その相手自体が厄介な相手なのではないかという懸念が生まれるので、できるだけ自分と相手だけではなく第三者にも議論に参加してもらえるように助けをもとめたほうがよいと思います。
そのような様子があまり見当たらないのであれば、その相手にとってその実装はかなりの重要性を持っているのではないかと推測できます。
そのため、なぜ相手がその実装に拘ろうとしているのかについて聞くことで理由を知ることができるかもしれません。
とはいえ、相手が勝手に実装を修正してしまったのなら、ゆっくり話し合いをしている場合ではないことも多いのではないかと思います。
それをもともと実装した人である自分の同意を得ないうちに修正をしてしまうという状況は、チームや開発コミュニティ内でのルールや作法に違反している可能性が高いので、そのような場合は自分と相手だけで片付けようとせずに、ほかのメンバーにも相談して適切な対処方法を決めるようにします(チームの外にいる人間が既存の実装への修正の権限を持ちながら突然やってきて変更を加えていく、というのはむしろその状況自体が理解に苦しむので考えないことにします)。&lt;/p&gt;

&lt;p&gt;全体を通して、できるだけお互いに間違った認識がないように注意を払いながら議論を続けていくことで合意を目指す、というのが基本的な方針です。
そして、状況が難しくなりそうならできるだけ早く第三者にも意見を求めていくべきだと思っています。&lt;/p&gt;

&lt;h3 id=&#34;選-a-5:ba10b11125a0bfb60081de5c3341fee7&#34;&gt;選-A-5.&lt;/h3&gt;

&lt;p&gt;以下のプログラムはLinuxカーネル3.8〜4.4に存在する脆弱性を悪用しています。このプログラムの実行により発生する不具合を説明してください。また、この脆弱性をさらに悪用することでroot権限昇格を行うエクスプロイトを記述し、自分が試した動作環境や工夫点等を説明してください。加えて、このような攻撃を緩和する対策手法をなるべく多く挙げ、それらを説明してください。
完全には分からなくても構いませんので、理解できたところまでの情報や試行の過程、感じた事等について自分の言葉で記述してください。また参考にしたサイトや文献があれば、それらの情報源を明記してください。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;lt;stddef.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;keyutils.h&amp;gt;
 
int main(int argc, const char *argv[])
{
    int i = 0;
    key_serial_t serial;
 
    serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, &amp;quot;leaked-keyring&amp;quot;);
    if (serial &amp;lt; 0) {
        perror(&amp;quot;keyctl&amp;quot;);
        return -1;
    }
 
    if (keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL) &amp;lt; 0) {
        perror(&amp;quot;keyctl&amp;quot;);
        return -1;
    }
 
    for (i = 0; i &amp;lt; 100; i++) {
        serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, &amp;quot;leaked-keyring&amp;quot;);
        if (serial &amp;lt; 0) {
            perror(&amp;quot;keyctl&amp;quot;);
            return -1;
        }
    }
 
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このプログラムは、CVE-2016-0728を悪用しています。
プロセスが使用しているセッションキーリングを、システムコール呼び出しによって別のキーリング(leaked-keyring)に切り替えたのち、それと同じ名前のキーリングへの切り替えを複数回試みています。
結果として、同じ名前のキーリングへの切り替えを行おうとした際に、keyctlシステムコール内に存在する脆弱性のために、内部的に生成された新しいキーリング(つまりleaked-keyring)の解放が行われず、このキーリングに対する参照が残り続けてしまいます。
keyctlシステムコールは鍵保存サービスの一部分であり、鍵保存サービスはそれぞれの鍵が使用されている数を表す参照カウントを持っていますが、上記の解放漏れのために、同じkeyring名でのkeyctl(KEYCTL_JOIN_SESSION_KEYRING,name)呼び出しが行われると、そのたびに参照カウントがインクリメントされ、この参照はプログラムが終了しても残り続けます。
よってこのキーリングは鍵保存サービスに残り続けてしまいます。&lt;/p&gt;

&lt;p&gt;そこでまず、キーリングの参照リークが発生することを確かめようと、実際にDebian8.6のインストールされたマシン上でこのプログラムの実行を試みました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;$ uname -srvmo
Linux 3.16.0-4-amd64 #1 SMP Debian 3.16.36-1+deb8u2 (2016-10-19) x86_64 GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Linuxカーネルのバージョンが3.16であることから、脆弱性が存在しているバージョンであると思われます。
しかしながら/proc/keysの内容はこのプログラムの実行前と実行後で変化がなく、参照のリークを確かめることはできませんでした。
これは、DebianがこのLinuxカーネルの脆弱性に対してセキュリティアップデートを行っているため、パッチによって既に修正されているのだと考えました。
そこで、環境をVirtualBox上のDebian8.8に移し、
&lt;a href=&#34;https://www.debian.org/releases/jessie/mips/ch08s06.html.ja&#34;&gt;https://www.debian.org/releases/jessie/mips/ch08s06.html.ja&lt;/a&gt; &lt;a href=&#34;https://www.hiroom2.com/2016/05/18/ubuntu-16-04%E3%81%A7%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E3%82%92%E5%86%8D%E3%83%93%E3%83%AB%E3%83%89%E3%81%99%E3%82%8B/&#34;&gt;https://www.hiroom2.com/2016/05/18/ubuntu-16-04%E3%81%A7%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E3%82%92%E5%86%8D%E3%83%93%E3%83%AB%E3%83%89%E3%81%99%E3%82%8B/&lt;/a&gt; &lt;a href=&#34;http://d.hatena.ne.jp/adsaria/20081104/1225766991&#34;&gt;http://d.hatena.ne.jp/adsaria/20081104/1225766991&lt;/a&gt;
というようなWebページを参考にして、Linuxカーネル3.18.25のビルドおよびインストールを行い、このカーネルを脆弱性のあるカーネルで上書きすることを試みました。&lt;/p&gt;

&lt;p&gt;カーネルのビルド前に、/security/keys/process_keys.cのjoin_session_keyring関数を調べ、このカーネルが脆弱性を含んでいることを確認しました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;$cat security/keys/process_keys.c | grep &amp;quot;keyring == new-&amp;gt;session_keyring&amp;quot; -4 -n
792-		}
793-	} else if (IS_ERR(keyring)) {
794-		ret = PTR_ERR(keyring);
795-		goto error2;
796:	} else if (keyring == new-&amp;gt;session_keyring) {
797-		ret = 0;
798-		goto error2;
799-	}
800-
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;keyringがnew-&amp;gt;session_keyringと等しかった際の処理にkey_put(keyring);の行が存在しないことから、このソースコードは脆弱性を含んでいることがわかります。&lt;/p&gt;

&lt;p&gt;さらに、KEYCTL_SETPERMを第一引数としてkeyctlを呼び出したときに実行されるであろう部分にprintkを仕込んで、カーネルの上書きが成功していることを確かめようと考えました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;$ cat security/keys/keyctl.c | grep &amp;quot;Hello&amp;quot; -A 3 -B 6 -n
910-long keyctl_setperm_key(key_serial_t id, key_perm_t perm)
911-{
912-	struct key *key;
913-	key_ref_t key_ref;
914-	long ret;
915-
916:	printk(&amp;quot;Hello, World!&amp;quot;);
917-
918-	ret = -EINVAL;
919-	if (perm &amp;amp; ~(KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この状態でカーネルのビルドを行い、インストールしてカーネルの再構築を行いました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;$ uname -r
3.18.25-leak-test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再起動後にlinuxバージョンの確認を行ったところ、バージョン3.18.25に変化していることからカーネルの再構築が完了したと考え、再度プログラムの実行を行いました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;$ cat /proc/keys
3840ddc9 I--Q---   100 perm 3f3f0000  1000  1000 keyring   leaked-keyring: empty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお、dmesgでカーネルの出力を調べたところ、 Hello, World! の文字列が出力されているのが確認できました。&lt;/p&gt;

&lt;p&gt;また、VirtualBox上でCD版KNOPPIXバージョン7.2.0を実行し、この環境で参照リークの再現が可能かどうかを調べました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;$ uname -nr
Microknoppix 3.9.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Linuxバージョン3.9.6であり、このバージョンのリリースはCVE-2016-0728発見前の2013年であるためやはり脆弱性を含んでいることが予想され、結果としてkeyringの参照漏れが確認できました。&lt;/p&gt;

&lt;p&gt;次に、この脆弱性を用いたroot権限昇格を行うエクスプロイトを&amp;rdquo;記述&amp;rdquo;します。&lt;/p&gt;

&lt;p&gt;(おおよそ自明なものであるため回答可能文字数確保を目的として省略) &lt;code&gt;// 原文ママ&lt;/code&gt;&lt;br /&gt;
(&lt;a href=&#34;https://gist.github.com/PerceptionPointTeam/18b1e86d1c0f8531ff8f#gistcomment-1682326&#34;&gt;https://gist.github.com/PerceptionPointTeam/18b1e86d1c0f8531ff8f#gistcomment-1682326&lt;/a&gt;)&lt;br /&gt;
(gistで公開されているコードではなく、コメントで投稿されていたループ回数を2回減らしたほうのコードであることに注意)&lt;/p&gt;

&lt;p&gt;これは、&lt;a href=&#34;http://perception-point.io/2016/01/14/analysis-and-exploitation-of-a-linux-kernel-vulnerability-cve-2016-0728/&#34;&gt;http://perception-point.io/2016/01/14/analysis-and-exploitation-of-a-linux-kernel-vulnerability-cve-2016-0728/&lt;/a&gt; で紹介されていたものです。&lt;/p&gt;

&lt;p&gt;「基礎からわかるTCP/IP ネットワークコンピューティング入門」によると、CPUはユーザーモード、カーネルモード(スーパーバイザモード)といった状態を持っており、ユーザーモードで動くアプリケーションがシステムコールを呼び出すと、動作モードがカーネルモードに変化します。
ユーザーモードでは特定のアドレス空間にしかアクセスできない一方、カーネルモードでは任意のメモリアドレスを参照することができ、任意の命令の実行が可能になります。
そのため、CPUがカーネルモードにあるときに任意のコードが実行された場合、容易に特権昇格を行うことができるようになります。
たとえば、commit_creds(prepare_kernel_cred(0));を実行すると、prepare_kernel_credはNULLが与えられた場合にデフォルト値としてuid=0,gid=0となるようなroot権限のcredentialsを返し(&lt;a href=&#34;http://elixir.free-electrons.com/linux/v3.18.25/source/kernel/cred.c#L35&#34;&gt;http://elixir.free-electrons.com/linux/v3.18.25/source/kernel/cred.c#L35&lt;/a&gt; , &lt;a href=&#34;http://elixir.free-electrons.com/linux/v3.18.25/source/kernel/cred.c#L600&#34;&gt;http://elixir.free-electrons.com/linux/v3.18.25/source/kernel/cred.c#L600&lt;/a&gt; )、commit_credsによってそのcredentialsを現在のタスクに適用する(&lt;a href=&#34;http://elixir.free-electrons.com/linux/v3.18.25/source/kernel/cred.c#L401&#34;&gt;http://elixir.free-electrons.com/linux/v3.18.25/source/kernel/cred.c#L401&lt;/a&gt; )ため、以後そのアプリケーションはroot権限で実行されるようになります。&lt;/p&gt;

&lt;p&gt;CVE-2016-0728を用いたroot権限昇格のエクスプロイトでも、このカーネルモードでの任意コード実行を目指します。&lt;/p&gt;

&lt;p&gt;この脆弱性によって発生することは、キーリングの参照が残り続けること、そしてそれによって参照カウントのインクリメントが可能であることです。
key構造体(&lt;a href=&#34;http://elixir.free-electrons.com/linux/v3.18.25/source/include/linux/key.h#L132&#34;&gt;http://elixir.free-electrons.com/linux/v3.18.25/source/include/linux/key.h#L132&lt;/a&gt; )は32bit整数値で参照カウントを持っているため、参照カウントのインクリメントを0x100000000回行うことでオーバーフローが発生し、参照カウントが0となるためにそのキーリングがもはや使われていないと判断され、ガベージコレクション機能によってキーが解放されます。
ただし、keyctl(KEYCTL_JOIN_SESSION_KEYRING,name)呼び出しによってjoin_session_keyring関数(&lt;a href=&#34;http://elixir.free-electrons.com/linux/v3.18.25/source/security/keys/process_keys.c#L753&#34;&gt;http://elixir.free-electrons.com/linux/v3.18.25/source/security/keys/process_keys.c#L753&lt;/a&gt; )が呼ばれて参照リークが発生する場合、内部的に新しいキーリングを作ろうと試みるため、prepare_creds();が呼ばれてキーリングの参照カウントが1加算され、そしてjoin_session_keyring関数から抜ける際にabort_creds関数によって再び参照カウントが1減少します。
しかしながら、abort_creds関数は内部的にcall_rcuを呼び出し(&lt;a href=&#34;http://elixir.free-electrons.com/linux/v3.18.25/source/kernel/cred.c#L141&#34;&gt;http://elixir.free-electrons.com/linux/v3.18.25/source/kernel/cred.c#L141&lt;/a&gt; )、そのコールバック内でput_keyを遅延実行しようとします。
そのため、参照カウントのインクリメントに対してデクリメントが遅れ、カウントが現在のループ回数よりも多くなってしまうので、予期しないタイミングで参照カウントがオーバーフローを起こして0となってしまうおそれがあります。
そのため、残りのループ回数が半分になるたびにsleep(1)を呼び出して待機することで、意図しないオーバーフローを防ぐ必要があります(参照カウントのデクリメントが遅れても、呼び出した回数の2倍より大きくはならないためオーバーフローが起きることがない)。
このようにしてキーリングのメモリ空間を解放すれば、そのメモリ空間を上書きし、さらにキーリング構造体が持っている関数ポインタの位置に実行したい関数のアドレスを書き込み、システムコール内でその関数を呼び出させることで、CPUがカーネルモードの状態で任意のコードを実行可能になります。&lt;/p&gt;

&lt;p&gt;そのため、先ほど参照カウンタが0になったことによって解放されたメモリアドレスを確保する必要があります。
エクスプロイトコードでは、fork()によってプロセスを分け、メッセージキューを「たくさん」用意して、そこにちょうどkey構造体と同じだけのサイズを持つ構造体を用いてメッセージ送信を「たくさん」行っています。
メッセージはlong型のヘッダと自由な長さのメッセージ内容からなる構造体である(&lt;a href=&#34;http://www.geocities.co.jp/Athlete-Samos/7760/study/msgkyu1.html&#34;&gt;http://www.geocities.co.jp/Athlete-Samos/7760/study/msgkyu1.html&lt;/a&gt; )ため、メッセージ内容の長さをsizeof(key)-sizeof(long)にすれば、ちょうど全体がkey型の構造体と同じサイズになるようにすることが可能です。
その上で、本来revoke関数へのポインタが配置されている位置にcommit_creds(prepare_kernel_cred(0));を実行する関数のアドレスを格納しておきます。
それにより、解放された領域にこのメッセージが割り当てられた場合、システムコール内でrevoke関数が呼ばれた際に特権昇格の命令が実行されます。&lt;/p&gt;

&lt;p&gt;ただし、本来ユーザーモードではcommit_credsおよびprepare_kernel_credはメモリ保護されていて使用できないため、いくら実行時にカーネルモードで処理が行われるとしても、その命令を記述することができません。
そのため、予めこれらの命令が仮想メモリ空間上のどの位置に配置されるのかを調べておき、そのアドレスを直接参照することでcommit_credsとprepare_kernel_credを示すことができます。
仮想メモリ空間において、カーネル領域は同じLinuxカーネルならば同じ仮想アドレス上に展開される上、そのアドレスは/proc/kallsymsで確認可能なため、その中身を見ることで調べたり、攻撃の前に別のマシンで調べておくこともできます。&lt;/p&gt;

&lt;p&gt;実際にこのエクスプロイトを用いて特権昇格を試みた結果を書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;$ gcc exploit.c -o exploit -lkeyutils -Wall
$ ./exploit attack
uid = 1000, euid = 1000
[+] increfs...
[+] finish increfs
[+] fork...
exploit...
強制終了
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スタックトレースは、以下のようになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;[  +0.000003] Stack:
[  +0.000001]  ffffffff81091da6 0000000000400ae8 8948818f00000000 ffff880157
[  +0.000002]  0000000000000000 ffff880157c65280 ffff880157c652a1 ffffffff81
[  +0.000002]  00007fff92148680 ffff880157c65280 00000000fffffffd ffffffff81
[  +0.000001] Call Trace:
[  +0.000004]  [&amp;lt;ffffffff81091da6&amp;gt;] ? wait_task_inactive+0xa6/0x160
[  +0.000004]  [&amp;lt;ffffffff81244657&amp;gt;] ? key_revoke+0x37/0x80
[  +0.000002]  [&amp;lt;ffffffff81247380&amp;gt;] ? keyctl_revoke_key+0x30/0x70
[  +0.000003]  [&amp;lt;ffffffff81548e0d&amp;gt;] ? system_call_fastpath+0x16/0x1b
[  +0.000001] Code: c0 48 83 c4 30 5b 5d 41 5c 41 5d 41 5e c3 66 83 43 08 01
[  +0.000016] RIP  [&amp;lt;ffffffff81548345&amp;gt;] _raw_spin_unlock_irqrestore+0x5/0x20
[  +0.000002]  RSP &amp;lt;ffff8800db31bf08&amp;gt;
[  +0.000001] CR2: 00000000004009d0
[  +0.000002] ---[ end trace c403a12e9768e731 ]---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;wait_task_inactiveで終了しているようでしたが、カーネルのkey_revokeのソースコードからwait_task_inactiveへの呼び出しは見つけられず、何らかのセキュリティによって強制的にプロセスを遮断されたのではないかと思いましたが、よくわかりませんでした。
また、/proc/kallsymsでkey_revokeやkeyctl_revoke_keyのアドレスを表示しましたが、このスタックトレースに表示されているアドレスとは異なっており、またその差もばらばらであったため一定のオフセット値によってずれているわけでもなさそうなので、ここで手詰まりとなりました。&lt;/p&gt;

&lt;p&gt;同じプログラムを何回か試したところ、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;$ ./exploit attack
uid = 1000, euid = 1000
[+] increfs...
[+] finish increfs
[+] fork...
exploit...
[+] keyctl_revoke: Input/output error
uid = 1000, euid = 1000
$ whoami
tatamo
$ exit
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-BASH&#34;&gt;tatamo@debian:~$ ./exploit exp
uid = 1000, euid = 1000
[+] increfs...
[+] finish increfs
[+] fork...
exploit...
[+] keyctl_revoke: Required key not available
uid = 1000, euid = 1000
$ whoami
tatamo
$ exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように、異なるエラーメッセージが出てroot権限を得られないままプログラムが終了することがありました。
これは、オーバーフローを発生させた瞬間もやはりabort_credsの非同期性のために予期せぬオーバーフローが発生しうること、直後にfork()を行ったことによってさらに参照カウンタが動いていること、また解放されたメモリアドレスへの再割り当てを試みたが結果として何も割り当てられなかったこと、が原因なのではないかと推測します。&lt;/p&gt;

&lt;p&gt;このような攻撃を防ぐための技術として、Supervisor Mode Execution Prevention(SMEP)とSupervisor Mode Access Prevention(SMAP)が挙げられます。
これはともに、カーネルモードのCPUがユーザー空間からの攻撃を防ぐために設計されたものです。
SMEPは、ユーザー空間上にあるコードをカーネルモードで動作しているCPUから実行することを禁止させます。
SMAPはIntel製のCPUでサポートされている機能であり、SMEPの実装でもあります。
これはカーネルモードで動作しているCPUのユーザー空間上のメモリに対しての読み書きを禁止します(&lt;a href=&#34;https://en.wikipedia.org/wiki/Supervisor_Mode_Access_Prevention&#34;&gt;https://en.wikipedia.org/wiki/Supervisor_Mode_Access_Prevention&lt;/a&gt; )。
これによって、カーネルが意図しない形でユーザー空間にアクセスした場合にはページフォールトを発生させ、今回の脆弱性を悪用したコードによるカーネルモードでの任意コード実行を防止することができます。
またubuntuでは、Kernel Address Display Restrictionと呼ばれる機能により、一般ユーザーが/proc/kallsymsを表示しようとした場合、すべてのアドレスが0で埋められて表示されるようになっています(&lt;a href=&#34;http://inaz2.hatenablog.com/entry/2015/03/21/175433&#34;&gt;http://inaz2.hatenablog.com/entry/2015/03/21/175433&lt;/a&gt; )。
攻撃者が多くのLinuxディストリビューション上で動作するようなエクスプロイトコードを書きたいと思った場合、/proc/kakllsymsから動的にcommit_credsなどのメモリアドレスを取得しようとすることが考えられるため、そのような攻撃に対しての効果が期待されます。&lt;/p&gt;

&lt;p&gt;以降、この問題を解こうとして感じたことを述べます。
まず、私はこの回答欄にエクスプロイトコードを&amp;rdquo;記述&amp;rdquo;しましたが、それは調べたら見つかっただけのものであって&amp;rdquo;作成&amp;rdquo;してはいません。
それどころか、このコードの一部は理解することすらできませんでした(なぜfork()をしているのか、メモリ確保のルールをどのように利用して解放されたアドレスに再び別のオブジェクトを割り当てるのか？)。
今の私にはこのようなエクスプロイトを作成することは逆立ちしても不可能であると感じたので、せめてできるだけ理解しようと試みました。
しかしそもそも、実際に脆弱性の再現を行ううえで、Linuxカーネルのソースコードを読むこと、そして再ビルドしてインストールすることはこれまで一度も行ったことがなかったため、なかなかスムーズに進まず、スタートラインにすら立てていない感覚に焦りを覚えていました。&lt;/p&gt;

&lt;p&gt;実はカーネルを再構築して問題のコードを実行した後、/proc/keysをroot権限で表示するとユーザー側で実行していた参照リークを起こしているキーリングを見ることができないことを知らず、sudo catで表示していたために失敗したと思い込んでいました。
同様にdmesg -Hを実行するとlessされて表示されましたが、マウススクロールで表示が下に下がらなかったために一画面目の一番下の行が最新のカーネルログだと思い込んでしまい、実際にはカーネルに仕込んだ”Hello, World!”のメッセージが表示されていたにもかかわらず見落とし、しばらくカーネルの再構築に失敗したのではないかと考えていました。
これで悩んでかなりの時間を費やしたのですが、本当は想定通りに参照リークが発生していたこと、メッセージが表示されていたことに気付いたときは、なんだ成功していたのか、という気持ちと同時に、静かな興奮が沸き上がってくるのを感じました。
問題には直接関係なく、正しくカーネルの再構築ができているか確かめるのに役立つだろうと思って、ビルドの前にカーネルのソースコードを改変し、keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL)システムコールが呼ばれたときにprintk(“Hello, World!”);が実行されるようにしていたことです。
実際にやってみれば(ビルドにかなりの時間がかかるものの)Linuxカーネルのインストールは思った以上に簡潔な手順で完了し、しかも自分が書き換えたコードがこうも容易にOSの中核部分で動いているのだ、これだけ自分がセキュリティを破るのに苦労しているカーネルというものはプログラミング可能なものなのだ、と実感したときのワクワク感はしばらく忘れられないと思います。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;お目汚し失礼致しました。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第6回:パーサの実装と構文解析の実行</title>
      <link>http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-06/</link>
      <pubDate>Tue, 04 Apr 2017 23:41:09 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-06/</guid>
      <description>
        

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-05/&#34;&gt;前回&lt;/a&gt;ではLR(1)法による構文解析表の実装を済ませました。
今回はいよいよ、構文解析表をもとに実際に構文解析を行うことのできる構文解析器を実装し、実際に構文解析を行ってみます。&lt;/p&gt;

&lt;p&gt;概略は&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;第4回&lt;/a&gt;で示した通りであり、ステートマシンの仕様に沿って構文解析表を解析できるようにします。
第4回でアルゴリズム面まで踏み込んで解説してしまったため、あまり書くことがなくてやや後悔しています。&lt;/p&gt;

&lt;h2 id=&#34;astの定義:bed37c78c27b269093985160c6797817&#34;&gt;ASTの定義&lt;/h2&gt;

&lt;p&gt;パーサを実装する前に、パーサの出力結果となる抽象構文木の定義を行います。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/ast.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/ast.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/// ast.ts
export interface ASTNode{
	type: Token;
	value: string|null;
	children: Array&amp;lt;ASTNode&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;構文木は再帰的な木構造によって表されます。
それぞれのノードにはそれが何の記号かを示すトークン、およびそのトークンに紐つけられている実際の入力文字列(そのトークンが非終端記号である場合はnull)、自身の子となるノードの配列を持ちます。&lt;/p&gt;

&lt;p&gt;たとえば、&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;第3回&lt;/a&gt;で定義した構文規則によって&lt;code&gt;1+1&lt;/code&gt;を解析した場合、結果として得られる抽象構文木は以下のようになるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;{&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
    {&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
        {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
            {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
                {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;, &amp;quot;value&amp;quot;:&amp;quot;1&amp;quot;, &amp;quot;children&amp;quot;:[]}
            ]}
        ]}
    ]}, 
    {&amp;quot;type&amp;quot;:&amp;quot;PLUS&amp;quot;, &amp;quot;value&amp;quot;:&amp;quot;+&amp;quot;, &amp;quot;children&amp;quot;:[]}, 
    {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
        {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
            {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;, &amp;quot;value&amp;quot;:&amp;quot;1&amp;quot;, &amp;quot;children&amp;quot;:[]}
        ]}
    ]}
]}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;簡単ですね。&lt;/p&gt;

&lt;h2 id=&#34;パーサの実装:bed37c78c27b269093985160c6797817&#34;&gt;パーサの実装&lt;/h2&gt;

&lt;p&gt;ではParserクラスを作っていきます。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/parser.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/parser.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/// parser.ts
export interface TerminalCallbackArg {
        token: string;
        value: string;
        terminal: true;
}
export interface NonterminalCallbackArg {
        token: string;
        children: Array&amp;lt;any&amp;gt;;
        pattern: Array&amp;lt;string&amp;gt;;
        terminal: false;
}
export declare type ParserCallbackArg = TerminalCallbackArg | NonterminalCallbackArg;
export declare type ParserCallback = (arg: ParserCallbackArg) =&amp;gt; any;
export declare class Parser {
        private lexer;
        private syntax;
        private parsingtable;
        private default_callback;
        constructor(lexer: ILexer, syntax: SyntaxDefinitions, parsingtable: ParsingTable, default_callback?: ParserCallback | null);
        setDefaultCallback(default_callback?: ParserCallback | null): void;
        parse(input: string, cb?: ParserCallback): any;
        private _parse(inputs, cb?);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;できました。&lt;/p&gt;

&lt;p&gt;構文解析処理を行う処理は、110行程度に及ぶ&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/parser.ts#L40&#34;&gt;Parser#_parse()メソッド&lt;/a&gt;の内部で完結しています。
これは、&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;第4回&lt;/a&gt;に示したオートマトンの動作を仕様通りに実装しています。
入力を前から順に読み込み、現在スタックに積まれている状態番号を取得し、構文解析表の該当する位置に書かれている命令を実行していくだけです。&lt;/p&gt;

&lt;p&gt;ここでは、構文解析の実行中に衝突した命令が存在した場合、その時点で解析失敗としてエラーを返すようにしています。
コンフリクトが発生した際の対処についても&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;第4回&lt;/a&gt;で触れていますが、一般に使用されているパーサジェネレータでは、構文規則を定義するファイルの中に演算子の優先度や右結合/左結合の指定を行うことができたり、指定のない場合はshift/reduceのいずれかを優先するようになっていたりします。&lt;/p&gt;

&lt;p&gt;このあたりのコンフリクト回避処理や、エラーが発生した際の詳細なエラー情報の検知・回避などの機能面には大きく改善の余地があります。&lt;/p&gt;

&lt;p&gt;あとは、このParserをParserGeneratorから利用できるようにするため、適当にファクトリクラスを作ります。
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/factory.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/factory.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/// factory.ts
export class ParserFactory{
	public static create(grammar: GrammarDefinition, parsing_table: ParsingTable, default_fallback?: ParserCallback):Parser{
		let lexer = new Lexer(grammar.lex);
		return new Parser(lexer, grammar.syntax, parsing_table, default_fallback);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/parsergenerator.ts#L32&#34;&gt;ParserGenerator#getParser()メソッド&lt;/a&gt;には、以下のような記述を行います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/// parsergenerator.ts
public getParser(default_callback?: ParserCallback):Parser{
	return ParserFactory.create(this.grammar, this.parsing_table, default_callback);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで完成です。&lt;/p&gt;

&lt;h2 id=&#34;構文解析を実行する:bed37c78c27b269093985160c6797817&#34;&gt;構文解析を実行する&lt;/h2&gt;

&lt;h3 id=&#34;構文木を生成する:bed37c78c27b269093985160c6797817&#34;&gt;構文木を生成する&lt;/h3&gt;

&lt;p&gt;では、実際に構文解析を実行してみましょう。
与える構文は、以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;const syntax:SyntaxDefinitions = [
	{
		ltoken: &amp;quot;EXP&amp;quot;,
		pattern: [&amp;quot;EXP&amp;quot;, &amp;quot;PLUS&amp;quot;, &amp;quot;TERM&amp;quot;]
	},
	{
		ltoken: &amp;quot;EXP&amp;quot;,
		pattern: [&amp;quot;TERM&amp;quot;]
	},
	{
		ltoken: &amp;quot;TERM&amp;quot;,
		pattern: [&amp;quot;TERM&amp;quot;, &amp;quot;ASTERISK&amp;quot;, &amp;quot;ATOM&amp;quot;]
	},
	{
		ltoken: &amp;quot;TERM&amp;quot;,
		pattern: [&amp;quot;ATOM&amp;quot;]
	},
	{
		ltoken: &amp;quot;ATOM&amp;quot;,
		pattern:[&amp;quot;DIGITS&amp;quot;]
	},
	{
		ltoken: &amp;quot;ATOM&amp;quot;,
		pattern:[&amp;quot;LPAREN&amp;quot;, &amp;quot;EXP&amp;quot;, &amp;quot;RPAREN&amp;quot;]
	}
];
const lex:LexDefinitions = [
	{token:&amp;quot;DIGITS&amp;quot;, pattern:/[1-9][0-9]*/},
	{token:&amp;quot;PLUS&amp;quot;, pattern:&amp;quot;+&amp;quot;},
	{token:&amp;quot;ASTERISK&amp;quot;, pattern:&amp;quot;*&amp;quot;},
	{token:&amp;quot;LPAREN&amp;quot;, pattern:&amp;quot;(&amp;quot;},
	{token:&amp;quot;RPAREN&amp;quot;, pattern:&amp;quot;)&amp;quot;},
	{token:null, pattern:/(\r\n|\r|\n)+/},
	{token:null, pattern:/[ \f\t\v\u00a0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]+/},
	{token:&amp;quot;INVALID&amp;quot;, pattern:/./},
];

const grammar:GrammarDefinition = {
	lex: lex,
	syntax: syntax,
	start_symbol: &amp;quot;EXP&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt;という式を解析するためには、以下のように実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;new ParserGenerator(grammar).getParser().parse(&amp;quot;9 + 11 * (2 + 1)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すると、結果として以下のようなオブジェクトが得られます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;{&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
    {&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
    {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
        {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;9&amp;quot;,&amp;quot;children&amp;quot;:[]}
            ]}
        ]}
    ]},
    {&amp;quot;type&amp;quot;:&amp;quot;PLUS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;+&amp;quot;,&amp;quot;children&amp;quot;:[]},
    {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
        {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
            {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;11&amp;quot;,&amp;quot;children&amp;quot;:[]}
            ]}
        ]},
        {&amp;quot;type&amp;quot;:&amp;quot;ASTERISK&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;*&amp;quot;,&amp;quot;children&amp;quot;:[]},
        {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
            {&amp;quot;type&amp;quot;:&amp;quot;LPAREN&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;(&amp;quot;,&amp;quot;children&amp;quot;:[]},
            {&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                {&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                    {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                        {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                            {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;2&amp;quot;,&amp;quot;children&amp;quot;:[]}
                        ]}
                    ]}
                ]},
                {&amp;quot;type&amp;quot;:&amp;quot;PLUS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;+&amp;quot;,&amp;quot;children&amp;quot;:[]},
                {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                    {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                        {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;children&amp;quot;:[]}
                    ]}
                ]}
            ]},
            {&amp;quot;type&amp;quot;:&amp;quot;RPAREN&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;)&amp;quot;,&amp;quot;children&amp;quot;:[]}
        ]}
    ]}
]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どこからどう見ても成功ですね。
おめでとうございます。&lt;/p&gt;

&lt;h3 id=&#34;コールバックを利用して構文木のさらなる解析を行う:bed37c78c27b269093985160c6797817&#34;&gt;コールバックを利用して構文木のさらなる解析を行う&lt;/h3&gt;

&lt;p&gt;ついに、本記事の目標である構文木の取得を達成しました。
あとはこれに適当な再帰的処理を挟めば、良い感じに数式処理ができるでしょう。&lt;/p&gt;

&lt;p&gt;確かに一度構文木を生成してからそれを解析してもよいのですが、パーサに適当なコールバックを渡し、構文木を生成する代わりに数式処理を行ってしまうという手もあります。&lt;/p&gt;

&lt;p&gt;先ほどのparsergenerator.tsに、以下のような定義が含まれていました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;export interface TerminalCallbackArg {
        token: string;
        value: string;
        terminal: true;
}
export interface NonterminalCallbackArg {
        token: string;
        children: Array&amp;lt;any&amp;gt;;
        pattern: Array&amp;lt;string&amp;gt;;
        terminal: false;
}
export declare type ParserCallbackArg = TerminalCallbackArg | NonterminalCallbackArg;
export declare type ParserCallback = (arg: ParserCallbackArg) =&amp;gt; any;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Parserのコンストラクタ引数、ParserGeneratorのgetParserメソッドの引数、またはParserのparseメソッドの引数としてコールバックを与えると、reduce処理が行われた際にそれを呼び出すことができます。
処理するべきトークンが終端器号であった場合はそのトークンの種類と実際の入力が、非終端記号であった場合は対応する規則の情報、およびその子ノードの情報が引数として与えられます。&lt;/p&gt;

&lt;p&gt;実際に、数式の処理を行うための関数を書いてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;let solve_terminal = (arg:TerminalCallbackArg)=&amp;gt;{
	switch(arg.token){
		case &amp;quot;DIGITS&amp;quot;:
			return +arg.value;
		default:
			return null;
	}
}
let solve_nonterminal = (arg:NonterminalCallbackArg)=&amp;gt;{
	switch(arg.token){
		case &amp;quot;EXP&amp;quot;:
			if(arg.children.length == 1) return arg.children[0];
			else return arg.children[0] + arg.children[2];
		case &amp;quot;TERM&amp;quot;:
			if(arg.children.length == 1) return arg.children[0];
			else return arg.children[0] * arg.children[2];
		case &amp;quot;ATOM&amp;quot;:
			if(arg.children.length == 1) return arg.children[0];
			else return arg.children[1];
	}
}
let solve = (arg:ParserCallbackArg)=&amp;gt;{
	if(arg.terminal) return solve_terminal(arg);
	else return solve_nonterminal(arg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをもとに、以下のように実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;new ParserGenerator(grammar).getParser(solve).parse(&amp;quot;9 + 11 * (2 + 1)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果は、以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これにて、パーサジェネレータの実装および構文解析が完了しました。
ここまでお付き合いいただき、ありがとうございました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回:かんたん構文解析入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-05/&#34;&gt;前回:LR(1)パーサジェネレータの実装&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第5回:LR(1)パーサジェネレータの実装</title>
      <link>http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-05/</link>
      <pubDate>Tue, 04 Apr 2017 21:54:01 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-05/</guid>
      <description>
        

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;前回&lt;/a&gt;の記事ではLR(1)法の解説を行いました。
今回は前回解説した部分の実装を行います。&lt;/p&gt;

&lt;p&gt;今回はひたすらパーサジェネレータの実装をしていきます。
概略やアルゴリズムは既に紹介しているため、基本的に省略します。
適宜&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;前回&lt;/a&gt;の記事を参照してください。&lt;/p&gt;

&lt;p&gt;今回取り上げる部分は特にパフォーマンスに与える影響が大きいため、処理速度を重視した設計を行っています。
そのため、天下り的な解説となる箇所が増えるかもしれませんがご了承ください。&lt;/p&gt;

&lt;h2 id=&#34;syntaxdbクラスの作成:3aec03ed6d530aa5eea872bb2e906074&#34;&gt;SyntaxDBクラスの作成&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;第3回&lt;/a&gt;で終端記号と非終端記号の区別を行ったり、First集合を求めたりしたように、与えられた構文から様々な情報を得る必要があります。&lt;/p&gt;

&lt;p&gt;そこで、それらの情報取得を担うクラスとしてSyntaxDBクラスを作成します。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/syntaxdb.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/syntaxdb.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/// syntaxdb.d.ts
export declare class SyntaxDB {
    private syntax;
    private _start_symbol;
    private _first;
    private _symbols;
    private tokenmap;
    private tokenid_counter;
    private defmap;
    constructor(grammar: GrammarDefinition);
    private initDefMap();
    readonly start_symbol: Token;
    readonly first: FirstSet;
    readonly symbols: SymbolDiscriminator;
    findDef(x: Token): Array&amp;lt;{
        id: number;
        def: SyntaxDefinitionSection;
    }&amp;gt;;
    getTokenId(token: Token): number;
    get(id: number): SyntaxDefinitionSection;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SyntaxDBクラスの読み取り専用メンバとして第3回で作成したFirstSetとSymbolDiscriminatorを持たせており、このクラスから終端記号の区別、First集合の取得が可能です。
また、開始記号の取得も行えるようにします。
さらに、構文id(上から何番目かを表す番号)を与えるとそれに対応する規則を返す&lt;code&gt;get&lt;/code&gt;メソッド、記号を与えるとそれが左辺に現れる規則すべてを、構文idとともに返す&lt;code&gt;findDef&lt;/code&gt;メソッド、そして記号を与えるとそれに対応した一意なトークンidを返す&lt;code&gt;getTokenId&lt;/code&gt;メソッドを持ちます。&lt;/p&gt;

&lt;p&gt;findDefメソッドは愚直に実装した場合、複数回呼ばれるとそのたびに&lt;code&gt;O(n)&lt;/code&gt;程度の計算量がかかります。
そのため、SyntaxDBインスタンスの初期化時に非終端記号と規則群を対応付けたMapを生成する(計算量は&lt;code&gt;O(n)&lt;/code&gt;程度)ことで、findDefの呼び出し時にはMapの中身をそのまま返すだけで済むようにします。&lt;/p&gt;

&lt;p&gt;getTokenIdメソッドは後述するアイテム集合部分で使用する必要がありますが、特に厳密なシリアライズや復元可能性を求めているわけではなく、単にハッシュ代わりに使用されます。
そのため、同一のSyntaxDBインスタンスのgetTokenIdメソッドにトークンを与えると、同一のトークンならば必ず同じ番号が返ってくるようになっていればそれで構いません。
よって、以下のような単純な実装で事足ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;// Tokenを与えると一意なidを返す
public getTokenId(token: Token): number{
	if(!this.tokenmap.has(token)) this.tokenmap.set(token, this.tokenid_counter++);
	return this.tokenmap.get(token)!; /// ※ !はTypeScriptのnon-nullable注釈
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このSyntaxDBクラスは、パーサジェネレータ全体を通して一つのインスタンスのみを使いまわすようにします。&lt;/p&gt;

&lt;h2 id=&#34;アイテム集合とクロージャー展開:3aec03ed6d530aa5eea872bb2e906074&#34;&gt;アイテム集合とクロージャー展開&lt;/h2&gt;

&lt;p&gt;まずは、LRアイテムおよびその集合を表現するクラスを作っていきます。
アイテム集合クラスには、自身をクロージャー展開する機能を持たせることとします。&lt;/p&gt;

&lt;p&gt;また、DFAの構築において、「既存のアイテム集合の中に、新しく生成されたアイテム集合と一致するものが存在するかどうか判定する」処理が必要とされます。
愚直に実装すると、この処理を1回行うだけで&lt;code&gt;O(n^3)&lt;/code&gt;程度の計算量が必要となり、パーサジェネレータの処理全体の中で最大のボトルネックとなりえます。
そのため、2つのアイテム集合の高速な一致判定を行えるようにする必要があります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/closure.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/closure.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/// closure.d.ts
export declare class ClosureItem {
    private syntax;
    private _syntax_id;
    private _dot_index;
    private _lookaheads;
    private _lr0_hash;
    private _lr1_hash;
    constructor(syntax: SyntaxDB, _syntax_id: number, _dot_index: number, _lookaheads: Array&amp;lt;Token&amp;gt;);
    readonly syntax_id: number;
    readonly dot_index: number;
    readonly lookaheads: Array&amp;lt;Token&amp;gt;;
    private sortLA();
    private updateHash();
    getLR0Hash(): string;
    getLR1Hash(): string;
    isSameLR0(c: ClosureItem): boolean;
    isSameLR1(c: ClosureItem): boolean;
    merge(c: ClosureItem): ClosureItem | null;
}
export declare class ClosureSet {
    private syntax;
    private closureset;
    private _lr0_hash;
    private _lr1_hash;
    constructor(syntax: SyntaxDB, closureset: Array&amp;lt;ClosureItem&amp;gt;);
    private sort();
    readonly size: number;
    getArray(): ClosureItem[];
    includes(item: ClosureItem): boolean;
    isSameLR0(c: ClosureSet): boolean;
    isSameLR1(c: ClosureSet): boolean;
    private updateHash();
    getLR0Hash(): string;
    getLR1Hash(): string;
    mergeLA(cs: ClosureSet): ClosureSet | null;
    private expandClosure();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ClosureItemクラスはLRアイテム1つに対応し、構文id、&lt;code&gt;.&lt;/code&gt;の位置、および先読み記号の情報を持ちます。
ClosureSetクラスは複数のClosureItemをまとめた集合を表し、自身をクロージャー展開することが出来ます。
さらに、後述するハッシュに関連した機能、および先読み部分のマージ機能などを持ちます。&lt;/p&gt;

&lt;h3 id=&#34;クロージャー展開:3aec03ed6d530aa5eea872bb2e906074&#34;&gt;クロージャー展開&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;// クロージャー展開を行う
// TODO: リファクタリング
private expandClosure(){
	// 展開処理中はClosureItemのlookaheadsの要素数を常に1に保つこととする
	// 初期化
	let set:Array&amp;lt;ClosureItem&amp;gt; = [];
	// ClosureItemをlookaheadsごとに分解する
	for(let ci of this.closureset){
		for(let la of ci.lookaheads){
			set.push(new ClosureItem(this.syntax, ci.syntax_id, ci.dot_index, [la]));
		}
	}
	this.closureset = set;
	this.sort();

	// 変更がなくなるまで繰り返す
	let i=0;
	while(i&amp;lt;this.closureset.length){
		let ci = this.closureset[i++];
		let {ltoken, pattern} = this.syntax.get(ci.syntax_id);

		if(ci.dot_index == pattern.length) continue; // .が末尾にある場合はスキップ
		let follow = pattern[ci.dot_index];
		if(!this.syntax.symbols.isNonterminalSymbol(follow)) continue; // .の次の記号が非終端記号でないならばスキップ

		// クロージャー展開を行う

		// 先読み記号を導出
		// ci.lookaheadsは要素数1のため、0番目のインデックスのみを参照すればよい
		let lookaheads = [...this.syntax.first.get(pattern.slice(ci.dot_index+1).concat(ci.lookaheads[0])).values()];
		lookaheads.sort((t1:Token, t2:Token)=&amp;gt;{
			return this.syntax.getTokenId(t1) - this.syntax.getTokenId(t2);
		});

		// symbolを左辺にもつ全ての規則を、先読み記号を付与して追加
		let definitions = this.syntax.findDef(follow);
		for(let {id, def} of definitions){
			for(let la of lookaheads){
				let new_ci = new ClosureItem(this.syntax, id, 0, [la]);
				// 重複がなければ新しいアイテムを追加する
				let flg_duplicated = false;
				for(let existing_item of this.closureset){
					if(new_ci.isSameLR1(existing_item)){
						flg_duplicated = true;
						break;
					}
				}
				if(!flg_duplicated){
					this.closureset.push(new_ci);
				}
			}
		}
	}
	this.sort();

	// ClosureItemの先読み部分をマージする
	let tmp = this.closureset;
	this.closureset = [];
	let lookaheads = [];
	for(let i=0; i&amp;lt;tmp.length; i++){
		lookaheads.push(tmp[i].lookaheads[0]);
		if(i == tmp.length-1 || !tmp[i].isSameLR0(tmp[i+1])){
			this.closureset.push(new ClosureItem(this.syntax, tmp[i].syntax_id, tmp[i].dot_index, lookaheads));
			lookaheads = [];
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まだリファクタリングしていません。
すみません。&lt;/p&gt;

&lt;p&gt;ClosureItemは本来複数の先読み記号を保持することができるのですが、クロージャー展開の初期化段階では、まずそれを分解し、一つのClosureItemが必ず一つの先読み記号のみを持つようにします。&lt;/p&gt;

&lt;p&gt;この制約がなければ、たとえば&lt;code&gt;[x,y]&lt;/code&gt;という先読み記号を持ったAというClosureItemの展開処理が済んだあと、BというClosureItemを展開したところ、&lt;code&gt;[y,z]&lt;/code&gt;という先読み記号を持ち、先読み部分以外はAと全く同じClosureItemが生成される、といった自体が発生する可能性があります。
この場合、先読み記号&lt;code&gt;y&lt;/code&gt;については2度展開されてしまったり、それを防ぐために処理済みのClosureItemの走査を行うことで余計な計算が必要になってしまうなど、様々な弊害が発生します。
クロージャー展開の処理中だけはClosureItemの先読み記号は常に一つであるという制約を設けてることで、展開処理が非常に簡潔になります。&lt;/p&gt;

&lt;p&gt;処理が終わった段階で、ClosureItemの先読み部分をマージすることによってクロージャー展開後のClosureSetが完成します。&lt;/p&gt;

&lt;h3 id=&#34;ハッシュ:3aec03ed6d530aa5eea872bb2e906074&#34;&gt;ハッシュ&lt;/h3&gt;

&lt;p&gt;先述したように、2つのClosureSetの高速な比較を可能とする必要があります。
そこで、ClosureItemおよびClosureSetにハッシュ文字列の生成機能を追加し、構文番号、&lt;code&gt;.&lt;/code&gt;の位置、先読み記号という要素が一致していれば同じ文字列を生成するようにすれば、同一性の比較を文字列比較に落としこむことができ、非常に高速になります。
ハッシュといっても、SHA-1やMD5のようなビット列を出力する必要はなく、要素が同じなら同じ結果が得られ、かつ衝突が発生しなければそれでよいので、単純に要素を文字列化してしまえば事足ります。&lt;/p&gt;

&lt;p&gt;たとえば、構文番号1、&lt;code&gt;.&lt;/code&gt;の位置が左から2番目、先読み記号が&lt;code&gt;[$,x]&lt;/code&gt;のClosureItemなら、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;&amp;quot;1,2,[$,x]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような文字列を出力すれば目的は果たせます。
ClosureItemの集合であるClosureSetの場合は、まず自身の持っているClosureItemを、このハッシュ文字列を使ってソートした上で、以下のような文字列を生成します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;&amp;quot;1,2,[$,x]|2,3,[$]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ClosureItemが常にソートされていると仮定したならば、こちらも同一性の判定に用いることができます。&lt;/p&gt;

&lt;p&gt;ただしこの場合、ひとつだけ問題が生じます。
もし上記の&lt;code&gt;x&lt;/code&gt;のかわりに、&lt;code&gt;x]|2,2,[y&lt;/code&gt;という名前の終端記号があったとすると、さきほどのClosureSetのハッシュ文字列は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;&amp;quot;1,2,[$,x]|2,2,[y]|2,3,[$]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となってしまい、&lt;code&gt;2,2,[y]&lt;/code&gt;というClosureItemが存在した時に衝突が発生してしまう可能性があります。
これを防ぐため、先ほどのSyntaxDBを用いて、それぞれの終端記号を個別の数値に直してしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;&amp;quot;1,2,[0,1]&amp;quot;
&amp;quot;1,2,[0,1]|2,3,[1]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにすることで、危険性は回避できます。&lt;/p&gt;

&lt;p&gt;また、LALR(1)法のDFAマージの際に、先読み記号を除いた部分が一致しているかどうか調べる必要もあるため、ハッシュ文字列は先読み部分を除いたLR(0)ハッシュと、先読み部分も含めたLR(1)ハッシュの2種類を用意しておきます。&lt;/p&gt;

&lt;h4 id=&#34;closureitemおよびclosuresetのconst性:3aec03ed6d530aa5eea872bb2e906074&#34;&gt;ClosureItemおよびClosureSetのconst性&lt;/h4&gt;

&lt;p&gt;ハッシュの再生成や、それに伴うClosureSetのソート処理を回避するため、ClosureItemおよびClosureSetは、初期化終了後は自身の状態を変化させることがないようにします。&lt;/p&gt;

&lt;p&gt;たとえば、クロージャー展開を行うとClosureSetの中身は変化しますが、この処理はコンストラクタ呼び出し時に行うようにすることで、オブジェクトの初期化が終了した時点でクロージャー展開は終わっており、それ以降ClosureSetの状態が変化することはありません。
また、ClosureSetおよびClosureItemは、LR(0)部分(先読み部分を除いた部分)が同じなら先読み記号をマージするmergeメソッドを持っていますが、このメソッドもそのオブジェクト自身の状態を変更するのではなく、新しいオブジェクトを生成してそれを返すようにしています。&lt;/p&gt;

&lt;h2 id=&#34;dfaの構築:3aec03ed6d530aa5eea872bb2e906074&#34;&gt;DFAの構築&lt;/h2&gt;

&lt;p&gt;アイテム集合を扱えるようになったため、次はDFAの構築です。
DFAGeneratorクラスを作っていきます。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/dfagenerator.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/dfagenerator.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/// dfagenerator.d.ts
export declare type DFAEdge = Map&amp;lt;Token, number&amp;gt;;
export declare type DFANode = {
    closure: ClosureSet;
    edge: DFAEdge;
};
export declare type DFA = Array&amp;lt;DFANode&amp;gt;;
export declare class DFAGenerator {
    private syntax;
    private lr_dfa;
    private lalr_dfa;
    constructor(syntax: SyntaxDB);
    getLR1DFA(): DFA;
    getLALR1DFA(): DFA;
    private generateNewClosureSets(closureset);
    private indexOfDuplicatedNode(dfa, new_node);
    private generateDFA();
    private mergeLA(dfa);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とはいえ、やるべきことはDFAの構築処理、およびLALR(1)法のDFAを生成するためのマージ処理のみです。&lt;/p&gt;

&lt;p&gt;DFAは、DFANodeの配列として表現します。
DFANodeは、一つのClosureSetとDFAEdgeを持ちます。
DFAEdgeはトークンをキーとしてDFANodeのインデックスを持つMapであり、これはトークンをラベルとして他のDFANodeに向けて張られた辺の情報を意味します。&lt;/p&gt;

&lt;p&gt;前回紹介したアルゴリズムをそのままコードにするだけなので、DFAの構築処理は特に解説する点はありません。&lt;/p&gt;

&lt;h2 id=&#34;構文解析表の構築:3aec03ed6d530aa5eea872bb2e906074&#34;&gt;構文解析表の構築&lt;/h2&gt;

&lt;p&gt;構文解析表と、それに必要な四種類の命令群を定義しておきます。
また、コンフリクトが発生したことを表す命令も定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/// parsingtable.ts
export type ShiftOperation = {type: &amp;quot;shift&amp;quot;, to: number};
export type ReduceOperation = {type: &amp;quot;reduce&amp;quot;, syntax: number};
export type ConflictedOperation = {type: &amp;quot;conflict&amp;quot;, shift_to:Array&amp;lt;number&amp;gt;, reduce_syntax:Array&amp;lt;number&amp;gt;};
export type AcceptOperation = {type: &amp;quot;accept&amp;quot;};
export type GotoOperation = {type : &amp;quot;goto&amp;quot;, to: number};
export type ParsingOperation = ShiftOperation|ReduceOperation|ConflictedOperation|AcceptOperation|GotoOperation;
export type ParsingTable = Array&amp;lt;Map&amp;lt;Token, ParsingOperation&amp;gt;&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;構文解析表の構築処理は、ParserGeneratorクラスのメソッドとして実装します。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/parsergenerator.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/parsergenerator.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/// parsergenerator.d.ts
export declare class ParserGenerator {
    private grammar;
    private parsing_table;
    private syntax;
    private dfa_generator;
    constructor(grammar: GrammarDefinition);
    init(): void;
    getParser(default_callback?: ParserCallback): Parser;
    getParsingTable(): ParsingTable;
    private generateParsingTable(dfa);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これも前回紹介したアルゴリズムの通り、DFAを読み取って適切な命令を配置していくだけです。
ParserGeneratorクラスは、初期化時にSyntaxDBおよびDFAGeneratorのインスタンスを生成し、DFAGeneratorから得られたDFAをもとに構文解析表の生成を行います。&lt;/p&gt;

&lt;p&gt;ここまでで構文解析表の構築まで終了したので、パーサジェネレータはほぼ完成となります。
あとは、この構文解析表を読み取ることのできるパーサの実装が必要です。
次回はパーサの実装を行いますが、そのパーサの動作等についても前回の記事である程度解説しているため、やはり実装中心となります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回:かんたん構文解析入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;前回:かんたんLR(1)法入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-06/&#34;&gt;次回:パーサの実装と構文解析の実行&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第4回:かんたんLR(1)法入門</title>
      <link>http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/</link>
      <pubDate>Wed, 22 Mar 2017 15:58:04 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/</guid>
      <description>
        

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;前回&lt;/a&gt;で構文解析器を生成する際に必要となる準備を済ませたため、LR(1)法ベースのパーサジェネレータを作る用意が整いました。
ですが相変わらず本題のパーサジェネレータ作成には入らず、まずはLR(1)法のおおまかな理論的概略の紹介を行います。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回&lt;/a&gt;では構文解析全体の流れを解説しましたが、実際にどのような過程でパーサを、またパーサジェネレータを作成するかについては触れませんでした。
今回は、LR法による構文解析の流れを解説するとともに、これからどのような流れでパーサジェネレータを作成していくのかを紹介します。
今回は解説のみのためソースコードが載りません。&lt;/p&gt;

&lt;h2 id=&#34;lr-1-構文解析の流れ:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;LR(1)構文解析の流れ&lt;/h2&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;字句規則を用意して字句解析器にかけてトークン列を取得したあと構文規則をもとにFIRST関数とFOLLOW関数を求め、それをもとにgotoグラフを導出することによってLR表を作成して、構築したLRパーサでトークン列を解析して得た抽象構文木を処理すれば構文解析ができると知ったわたし &lt;a href=&#34;https://t.co/aIbxqSf5qj&#34;&gt;pic.twitter.com/aIbxqSf5qj&lt;/a&gt;&lt;/p&gt;&amp;mdash; たたも (@&lt;strong&gt;tatamo&lt;/strong&gt;) &lt;a href=&#34;https://twitter.com/__tatamo__/status/798837425313189888&#34;&gt;2016年11月16日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;FOLLOW関数はSLR法などで使用する概念のため、LR(1)法を用いる今回の記事では用いません。忘れてください。&lt;/p&gt;

&lt;p&gt;LR構文解析の流れは、以下の通りとなります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;First関数を求める&lt;/li&gt;
&lt;li&gt;アイテム集合およびDFA(gotoグラフ)を作成する&lt;/li&gt;
&lt;li&gt;(LALR法のみ)DFAの先読み部分をマージし、より状態数が少なく軽量なDFAにする&lt;/li&gt;
&lt;li&gt;DFAをもとに構文解析表(LR表)を構築する&lt;/li&gt;
&lt;li&gt;構文解析表を実行できるパーサを作成する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1.のFirst関数については、&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;前回&lt;/a&gt;の記事で紹介を済ませているため割愛します。&lt;br /&gt;
LALR法のLR(1)法との相違点は3.のみで、他はLR(1)法と全く同じ処理を行います。&lt;/p&gt;

&lt;p&gt;パーサジェネレータを作成して解析する構文を自由に決定できるようにする場合、3.の構文解析表までを与えられた構文に合わせて自動的に生成できるようにします。&lt;/p&gt;

&lt;h2 id=&#34;アイテム集合とdfa:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;アイテム集合とDFA&lt;/h2&gt;

&lt;p&gt;LR法による構文解析のためには、DFA(決定性有限オートマトン)の作成を行う必要があります。&lt;/p&gt;

&lt;p&gt;LR法によって作られるDFAは、それぞれの状態(ノード)に、アイテム集合と呼ばれる情報と、他の状態への遷移ルールを示すトークンをラベルとした辺情報とを持ちます。
このLRアイテム集合は、構文解析表やDFA自身の構築のために必要な情報として使用されます。&lt;/p&gt;

&lt;p&gt;アイテム集合は、文字通りアイテム(便宜的にLRアイテムと呼称します)からなる集合です。&lt;/p&gt;

&lt;h3 id=&#34;lrアイテム:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;LRアイテム&lt;/h3&gt;

&lt;p&gt;個別のLRアイテムは、以下のようなものです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;X -&amp;gt; A . B C [x,y,$]
Xは非終端記号
A,B,Cは終端記号または非終端記号
x,yは終端記号
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一見すると&lt;code&gt;X -&amp;gt; A B C&lt;/code&gt;のような構文規則のルールのように見えますが、相違点があります。&lt;/p&gt;

&lt;p&gt;まず、規則の右辺に&lt;code&gt;.&lt;/code&gt;という記号が存在します。
これは終端記号でも非終端記号でもなく、「現在この部分まで解析した」ということを示すマーカーです。
上記の場合、&lt;code&gt;X&lt;/code&gt;という記号の解析の途中で既に&lt;code&gt;A&lt;/code&gt;を読み終え、次は&lt;code&gt;B C&lt;/code&gt;が与えられることが期待されているということを意味します。&lt;/p&gt;

&lt;p&gt;次に、規則の右辺のさらに右に、&lt;code&gt;[x,y,$]&lt;/code&gt;という表記が存在します。
これはLR(1)法の(1)先読みのために用いる先読み記号の集合を表しています。
解析が進んで&lt;code&gt;X&lt;/code&gt;の解析が終わった場合、つまり&lt;code&gt;.&lt;/code&gt;の位置が右端まで移動した場合、その次には&lt;code&gt;x&lt;/code&gt;,&lt;code&gt;y&lt;/code&gt;,&lt;code&gt;$&lt;/code&gt;のいずれかの記号が来ることを意味します。
先読み記号は常に終端記号であることに注意してください。
また、&lt;code&gt;$&lt;/code&gt;は「入力の終わり」を表す記号で、これは便宜的に終端記号として扱います(&lt;a href=&#34;http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/&#34;&gt;第2回&lt;/a&gt;で内部的に追加したSymbol(EOF)トークンのことです)。&lt;/p&gt;

&lt;h3 id=&#34;dfaの構築:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;DFAの構築&lt;/h3&gt;

&lt;p&gt;まず、DFAを最初の状態で初期化します。
このとき、DFAのノード数は一つのみであり、そのノードは、以下のようなLRアイテム一つのみを要素とするアイテム集合を持ちます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;S&#39; -&amp;gt; . S [$]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただし、&lt;code&gt;S&lt;/code&gt;は開始記号であり、&lt;code&gt;S&#39;&lt;/code&gt;は便宜的に追加した新しい非終端記号です。
便宜的には、&lt;code&gt;S&#39;&lt;/code&gt;について以下の規則が成り立つこととみなします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;S&#39; -&amp;gt; S $
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを自己展開させることによって、構文解析のためのDFAを構築していきます。&lt;/p&gt;

&lt;h4 id=&#34;クロージャー展開:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;クロージャー展開&lt;/h4&gt;

&lt;p&gt;まず、初期化時点で存在するこのDFAノードは、まだ完全な状態にはなっていません。
一定のルールに従い、アイテム集合を「クロージャー展開」する必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;X -&amp;gt; α . Y β [x]
X,Yは非終端記号(X=Yであってもよい)
xは終端記号
α,βは任意の長さの終端記号または非終端記号の列
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というLRアイテムが存在する場合、&lt;code&gt;Y&lt;/code&gt;を左辺として&lt;code&gt;.&lt;/code&gt;が右辺の左端にあるような新しいLRアイテムを、アイテムセットに追加します。
ただし、先読み記号はFirst(βx)で得られる記号全てとします。
つまり、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;Y -&amp;gt; γ
γは任意の長さの終端記号または非終端記号の列
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような規則があった場合、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;Y -&amp;gt; . γ [First(βx)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というLRアイテムを新しく追加します。&lt;/p&gt;

&lt;p&gt;これを、新しいアイテムが追加されなくなるまで繰り返します。&lt;/p&gt;

&lt;p&gt;具体的に見て行きましょう。
以下の規則を仮定します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;S -&amp;gt; 0
S -&amp;gt; X 1
X -&amp;gt; 0
Sは開始記号
S,Xは非終端記号
0,1は終端記号
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、開始記号は&lt;code&gt;S&lt;/code&gt;なので、最初のLRアイテムは以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;S&#39; -&amp;gt; . S [$]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.&lt;/code&gt;の次にある&lt;code&gt;S&lt;/code&gt;を展開します。
先読み記号は&lt;code&gt;First($)=[$]&lt;/code&gt;です。
以下のアイテムを追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;S -&amp;gt; . 0 [$]
S -&amp;gt; . X 1 [$]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに、新しく追加されたアイテムにも同様の処理を行うと、&lt;code&gt;.&lt;/code&gt;の次に&lt;code&gt;X&lt;/code&gt;があるため、これを展開します。
&lt;code&gt;0&lt;/code&gt;は終端記号のため、展開は行いません。
先読み記号は、&lt;code&gt;First(1$)=[1]&lt;/code&gt;です(First関数は終端記号の列の左端の記号を得るので、ここでは&lt;code&gt;1&lt;/code&gt;のみとなります)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;X -&amp;gt; . 0 [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上の規則では&lt;code&gt;0&lt;/code&gt;は終端記号のため、ここで展開は終了します。&lt;/p&gt;

&lt;p&gt;結果として、最初のDFAノードの持つアイテム集合は以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;S&#39; -&amp;gt; . S [$]
S -&amp;gt; . 0 [$]
S -&amp;gt; . X 1 [$]
X -&amp;gt; . 0 [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上がクロージャー展開の処理です。
こうして展開したアイテム集合をもとに、新しいDFAノードを生成していきます。&lt;/p&gt;

&lt;h4 id=&#34;新しいdfaノードの生成:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;新しいDFAノードの生成&lt;/h4&gt;

&lt;p&gt;クロージャー展開が完了したアイテム集合から、一定のルールのもとで新しいDFAノードを生成します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;X -&amp;gt; α . A β [x]
Xは非終端記号
Aは終端記号または非終端記号(X=Aであってもよい)
xは終端記号
α,βは任意の長さの終端記号または非終端記号の列
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というLRアイテムが存在する場合、以下の新しいLRアイテムを生成します(そのDFAノードのアイテムセットには追加しません)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;X -&amp;gt; α A . β [x]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そのDFAノードの持つ全てのLRアイテムについてこの処理が終わったら、&lt;code&gt;.&lt;/code&gt;の左隣の記号、つまり&lt;code&gt;A&lt;/code&gt;の位置の記号ごとに新しいアイテム集合を作り、それを情報としてもつ新しいDFAノードを生成します。
そして既存のDFAノードから、&lt;code&gt;A&lt;/code&gt;をラベルとして新しいノードに対して辺を張ります。&lt;/p&gt;

&lt;p&gt;具体的には、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;S&#39; -&amp;gt; . S [$]
S -&amp;gt; . 0 [$]
S -&amp;gt; . X 1 [$]
X -&amp;gt; . 0 [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というアイテム集合を持つDFAからは、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;S&#39; -&amp;gt; S . [$]
S -&amp;gt; 0 . [$]
S -&amp;gt; X . 1 [$]
X -&amp;gt; 0 . [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という4つのLRアイテムが生成され、これは以下の3つに分けられます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;1. ラベル: S
S&#39; -&amp;gt; S . [$]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;2. ラベル: 0
S -&amp;gt; 0 . [$]
X -&amp;gt; 0 . [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;3. ラベル: X
S -&amp;gt; X . 1 [$]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このようにして新しく3つのDFAノードを生成し、もとのノードからそれぞれの記号をラベルとした辺を張ります。
あとは、新しいノード全てについて、同様にクロージャー展開を行い、さらに新しいDFAノードを生成していきます。
ただし、その過程で既存のノードと全く同じアイテム集合を持つDFAノードが作られた場合は、新しいノードとしてそこに辺を張るのではなく、かわりに重複する既存のノードに対して辺を張るものとします。&lt;/p&gt;

&lt;p&gt;この処理を繰り返し、DFAノードが新しく生成されなくなればDFAの構築は終了です。&lt;/p&gt;

&lt;h4 id=&#34;lalr法のみ-先読み部分のマージ:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;(LALR法のみ)先読み部分のマージ&lt;/h4&gt;

&lt;p&gt;LALR法では、この時点でDFAのサイズ縮小を行います。
そのアルゴリズムは、以下の通りです。&lt;/p&gt;

&lt;p&gt;まず、DFAの持つアイテム集合から、それぞれのLRアイテムの先読み部分のみを除いた場合に、全く同じアイテム集合を持つようなDFAノードの組を見つけます。
そして、そのようなDFAノードの組において、LRアイテムの先読み部分をそれぞれの和集合とするような新しいDFAノードを作り、それらのノードに対して辺を張っていたノードがあれば、その辺を新しいノードに対して張り直します。&lt;/p&gt;

&lt;p&gt;具体的に、以下のようなアイテム集合を持つ2つのDFAノードを考えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;DFAノードA:
X -&amp;gt; .Y Z [x]
Y -&amp;gt; .V W [x,y]

DFAノードB:
X -&amp;gt; .Y Z [z]
Y -&amp;gt; .V W [y,z]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この2つのDFAノードは、先読み部分を除けば一致しているため、マージして次のDFAノードCを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;DFAノードC:
X -&amp;gt; .Y Z [x,z]
Y -&amp;gt; .V W [x,y,z]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、DFAノードAまたはBに対して辺を張っているDFAノードが存在するならば、それらの辺をDFAノードCに向けたものに書き換えます。&lt;/p&gt;

&lt;h2 id=&#34;構文解析表と構文解析器:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;構文解析表と構文解析器&lt;/h2&gt;

&lt;p&gt;DFAが完成したら、それをもとにして構文解析表を生成していきます。
構文解析表はそれ自体がステートマシンの動作仕様を表すものであり、構文解析表が完成してしまえば、それに沿ってステートマシンを動作させることで構文解析が可能となります。&lt;/p&gt;

&lt;h3 id=&#34;構文解析を行うステートマシン:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;構文解析を行うステートマシン&lt;/h3&gt;

&lt;p&gt;構文解析表には、ステートマシンの現在の状態、および次の入力に応じて、4種類の命令のいずれかが記述されます。
構文解析を行うステートマシンは、現在の状態を示すスタックと、構文解析の結果を保持するスタックの2つのスタックを持ちます。
また、入力を一文字だけ確認するか、入力を消費して一文字先に進めることができます。
(この仕様自体は変更の余地があります。)&lt;/p&gt;

&lt;p&gt;ステートマシンは、構文解析表から(状態スタックの一番上にある状態, 現在見ている入力)の命令を実行します。
最初は(初期状態, 一文字目の入力)となります。&lt;/p&gt;

&lt;p&gt;以下に、4つのそれぞれの命令の説明を記します。
とはいえ、ステートマシンの仕様なんざ読んでいて動きが分かるわけもなく楽しくも何ともないため、参考資料の&lt;a href=&#34;http://www.slideshare.net/ichikaz3/lr-parsing&#34;&gt;LR parsing&lt;/a&gt;のスライドを確認していただくことをおすすめします。
ステートマシンの動きを視覚的に追いかけることができて非常にわかりやすいです。&lt;/p&gt;

&lt;h4 id=&#34;shift命令:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;shift命令&lt;/h4&gt;

&lt;p&gt;shift命令を受けると、ステートマシンは入力を一つ消費します。
shift命令には状態番号が付与されているので、ステートマシンは状態スタックにその数値を追加します。&lt;/p&gt;

&lt;h4 id=&#34;reduce命令:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;reduce命令&lt;/h4&gt;

&lt;p&gt;reduce命令は文法idが付与されています。
ステートマシンがreduce命令を受けると、示された文法規則を確認し、その右辺の記号の数だけ状態スタックからポップして取り除きます。
さらに、結果スタックからも右辺の記号の数だけ取り除き、取り除いた結果すべてを現在見ている規則の左辺の記号を親とする木構造の子にして、そうしてできた木を結果スタックに追加します(または、取り除いた結果および文法idを引数として何らかのプログラムを実行し、その結果をスタックに追加する場合もあります)。&lt;/p&gt;

&lt;p&gt;そしてその処理の終了後、構文解析表の(状態スタックの一番上にある状態、規則の左辺の記号)の位置にあるgoto命令を実行させます。&lt;/p&gt;

&lt;h4 id=&#34;goto命令:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;goto命令&lt;/h4&gt;

&lt;p&gt;goto命令は、reduce命令の直後に実行されることが期待されます。
goto命令には状態番号が付与されているので、ステートマシンは状態スタックにその数値を追加します。
shift命令と異なり、入力の消費は行いません。&lt;/p&gt;

&lt;h4 id=&#34;accept命令:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;accept命令&lt;/h4&gt;

&lt;p&gt;ステートマシンがaccept命令を受けると、それは構文解析が終了したことを意味します。
理想的な入力が与えられた場合、入力は全て消費され、結果スタックには最終的な構文解析結果のみが入っていることが期待されます。&lt;/p&gt;

&lt;h3 id=&#34;構文解析器:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;構文解析器&lt;/h3&gt;

&lt;p&gt;構文解析器は、上記の仕様をなぞって構文解析表を読み取ることのできるステートマシンそのものです。
よって、構文解析表さえ個々の構文にあわせて生成することができれば、それを構文解析器に与えることによってさまざまな構文の解析が可能になります。&lt;/p&gt;

&lt;h3 id=&#34;構文解析表の構築:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;構文解析表の構築&lt;/h3&gt;

&lt;p&gt;完成したDFAをもとにして、構文解析表を生成することができます。&lt;/p&gt;

&lt;h4 id=&#34;shiftおよびgotoオペレーションの登録:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;shiftおよびgotoオペレーションの登録&lt;/h4&gt;

&lt;p&gt;それぞれのDFAノードは、ステートマシンの状態と対応しています。
簡単のため、個々のDFAノードには一意なid(ステートマシンの状態番号)が割り振られているものとします。
すべてのDFAノードについて、そのノードから張られている辺を参照します。&lt;/p&gt;

&lt;p&gt;その辺のラベルの記号が終端記号であるならば、構文解析表の(そのDFAノードのid, ラベルの記号)の部分にshift命令を書き込み、その辺の向かう対象となるDFAノードのidを付与します。&lt;/p&gt;

&lt;p&gt;その辺のラベルの記号が非終端記号であるならば、同様にしてgoto命令を書き込みます。&lt;/p&gt;

&lt;h4 id=&#34;acceptおよびreduceオペレーションの登録:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;acceptおよびreduceオペレーションの登録&lt;/h4&gt;

&lt;p&gt;すべてのDFAノードについて、そのアイテム集合の持つLRアイテム一つ一つを確認していきます。
もしも&lt;code&gt;.&lt;/code&gt;の位置が右辺の末尾にある場合、そのLRアイテムの持つ先読み記号それぞれについて、以下の処理を行います。&lt;/p&gt;

&lt;p&gt;構文解析表の(そのDFAノードのid, 先読み記号)の部分にreduce命令を書き込み、そのLRアイテムのもととなっている規則のidを付与。&lt;/p&gt;

&lt;p&gt;ただし、その規則が&lt;code&gt;S&#39;&lt;/code&gt;に対応するものであった場合、かわりにaccept命令を書き込みます。&lt;/p&gt;

&lt;h4 id=&#34;shift-reduceコンフリクト:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;shift/reduceコンフリクト&lt;/h4&gt;

&lt;p&gt;shiftオペレーションおよびreduceオペレーションは、表の同じ位置に競合して書き込まれてしまうことがあります。
このような状況を、shift/reduceコンフリクトと呼びます。
なお、shift/reduceコンフリクトだけでなく、reduce/reduceコンフリクト、複数回競合しあった3つ以上の命令のコンフリクト等も発生する可能性があります(shift/shiftコンフリクトも発生する可能性があると聞きましたが、上記のアルゴリズムでshiftを登録している場合はDFAが壊れていない限り発生し得ない気がします)。&lt;/p&gt;

&lt;p&gt;コンフリクトが発生してしまった場合の対処法は、大きく分けて二種類存在します。&lt;/p&gt;

&lt;p&gt;まずひとつは、諦めることです。
コンフリクトが発生した時点でそれはLR(1)文法を逸脱しているため、もともと解析可能な構文ではありません。
構文規則を等価になるようにいろいろ書き換えるとうまくコンフリクトが消せる(かもしれない)ので、与える構文の見直しをします。&lt;/p&gt;

&lt;p&gt;もうひとつは、規則ごとにオペレーションの優先度を設定し、コンフリクトが発生した場合は強制的にどちらかの命令を実行すると決めてしまうことです。
これは一般的に行われている方法であり、かなり乱暴ですが大抵の場合はまあなんとかなります。&lt;/p&gt;

&lt;h2 id=&#34;参考資料:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;参考資料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回&lt;/a&gt;で紹介したものを今回もそのまま参考資料としているため、基本的にはそちらをご覧ください。
今回紹介した内容の理解を深めるのに特に役立つと思われるおすすめの資料を抜粋しておきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.cornell.edu/courses/cs412/2003sp/lectures/lec09.pdf&#34;&gt;Cornell CIS Introduction to Compilers Lecture 9: LR(1) Parsing&lt;/a&gt;&lt;br /&gt;
LR(1) DFA、クロージャー展開、構文解析表等について詳細な定義や図解等が記載されています。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/ichikaz3/lr-parsing&#34;&gt;LR parsing&lt;/a&gt;&lt;br /&gt;
クロージャー展開やDFAの構築、実際のステートマシンの動きに至るまで実際の動作過程を見ることができます。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;今回でおおまかなLR(1)構文解析器作りの解説を済ませたので、次回からは実装をしていくだけです。
誰も他人のソースコードの解説なんて読む気は起きないでしょうし、これ以上続ける意味があるのか大いに疑問ではあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回:かんたん構文解析入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;前回:儀式の下準備&lt;/a&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-05/&#34;&gt;次回:LR(1)パーサジェネレータの実装&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第3回:儀式の下準備</title>
      <link>http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/</link>
      <pubDate>Tue, 21 Mar 2017 00:29:18 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/</guid>
      <description>
        

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/&#34;&gt;前回&lt;/a&gt;は字句解析器の作成を行ったので、次にLR(1)法による構文解析のためのパーサジェネレータの作成に入っていきます。
今回は、LR(1)構文解析器の構築のために必要な、終端記号と非終端記号の区別、Nulls集合、First集合の導出等を行えるようにしていきます。&lt;/p&gt;

&lt;p&gt;いよいよ構文解析部分の実装にとりかかるため、今後はLR(1)法に焦点を絞って解説していきます。&lt;/p&gt;

&lt;p&gt;今回はその準備段階として必要になる部分を作っていくため、どんどん実装を進めていきます。&lt;/p&gt;

&lt;h2 id=&#34;構文規則を定義する:54819cf28b4a2703da41ec17803c8ec7&#34;&gt;構文規則を定義する&lt;/h2&gt;

&lt;p&gt;まずは、前回字句規則を定義したように、構文規則を定義していく必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;export interface LexDefinitionSection{
	token: Token|null;
	pattern: string|RegExp;
}
export type LexDefinitions = Array&amp;lt;LexDefinitionSection&amp;gt;;

export interface SyntaxDefinitionSection{
	ltoken: Token;
	pattern: Array&amp;lt;Token&amp;gt;;
}
export type SyntaxDefinitions = Array&amp;lt;SyntaxDefinitionSection&amp;gt;;

export interface GrammarDefinition{
	lex: LexDefinitions;
	syntax: SyntaxDefinitions;
	start_symbol: Token;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字句規則と構文規則を合わせて、上記のように定義しておきましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回&lt;/a&gt;で定義した構文規則をこのデータ形式に直すと、以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;const syntax:SyntaxDefinitions = [
	{
		ltoken: &amp;quot;EXP&amp;quot;,
		pattern: [&amp;quot;EXP&amp;quot;, &amp;quot;PLUS&amp;quot;, &amp;quot;TERM&amp;quot;]
	},
	{
		ltoken: &amp;quot;EXP&amp;quot;,
		pattern: [&amp;quot;TERM&amp;quot;]
	},
	{
		ltoken: &amp;quot;TERM&amp;quot;,
		pattern: [&amp;quot;TERM&amp;quot;, &amp;quot;ASTERISK&amp;quot;, &amp;quot;ATOM&amp;quot;]
	},
	{
		ltoken: &amp;quot;TERM&amp;quot;,
		pattern: [&amp;quot;ATOM&amp;quot;]
	},
	{
		ltoken: &amp;quot;ATOM&amp;quot;,
		pattern:[&amp;quot;DIGITS&amp;quot;]
	},
	{
		ltoken: &amp;quot;ATOM&amp;quot;,
		pattern:[&amp;quot;LPAREN&amp;quot;, &amp;quot;EXP&amp;quot;, &amp;quot;RPAREN&amp;quot;]
	}
];
const lex:LexDefinitions = [
	{token:&amp;quot;DIGITS&amp;quot;, pattern:/[1-9][0-9]*/},
	{token:&amp;quot;PLUS&amp;quot;, pattern:&amp;quot;+&amp;quot;},
	{token:&amp;quot;ASTERISK&amp;quot;, pattern:&amp;quot;*&amp;quot;},
	{token:&amp;quot;LPAREN&amp;quot;, pattern:&amp;quot;(&amp;quot;},
	{token:&amp;quot;RPAREN&amp;quot;, pattern:&amp;quot;)&amp;quot;},
	{token:null, pattern:/\s/},
	{token:&amp;quot;INVALID&amp;quot;, pattern:/./},
];
const grammar:GrammarDefinition = {
	lex: lex,
	syntax: syntax,
	start_symbol: &amp;quot;EXP&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ルール一行ごとに一つのオブジェクトを割り当てています。
また、&lt;code&gt;start_symbol&lt;/code&gt;の定義を加えていることに注意してください。
これは文字通り開始記号のことであり、最初にどの記号から構文解析を開始するか表すために必要です。
最終的に構文解析を行った結果として構文木を得た場合、この開始記号が構文木の根となります。&lt;/p&gt;

&lt;h2 id=&#34;終端記号と非終端記号を区別する:54819cf28b4a2703da41ec17803c8ec7&#34;&gt;終端記号と非終端記号を区別する&lt;/h2&gt;

&lt;p&gt;構文解析器を作るためには、与えられた構文から終端記号と非終端記号を区別できるようにする必要があります。
定義を再確認しておくと、規則の左辺に現れることのない記号が終端記号、現れる記号が非終端記号です。&lt;/p&gt;

&lt;p&gt;実装上難しい点は特にないので、簡単に済ませてしまいましょう。&lt;/p&gt;

&lt;p&gt;ひとまず、SymbolDiscriminatorというクラスを作って終端記号と非終端記号の問い合わせをできるようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/// symboldiscriminator.d.ts
export declare class SymbolDiscriminator {
    private terminal_symbols;
    private nonterminal_symbols;
    constructor(syntaxdef: SyntaxDefinitions);
    getTerminalSymbols(): Set&amp;lt;Token&amp;gt;;
    getNonterminalSymbols(): Set&amp;lt;Token&amp;gt;;
    isTerminalSymbol(symbol: Token): boolean;
    isNonterminalSymbol(symbol: Token): boolean;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際のコードは以下を参照してください。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/symboldiscriminator.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/symboldiscriminator.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/// コンストラクタの実装のみ抜粋
constructor(syntaxdef:SyntaxDefinitions){
	this.terminal_symbols = new Set&amp;lt;Token&amp;gt;();
	this.nonterminal_symbols = new Set&amp;lt;Token&amp;gt;();

	// 左辺値の登録
	for(let sect of syntaxdef){
		let symbol = sect.ltoken;
		// 構文規則の左辺に現れる記号は非終端記号
		this.nonterminal_symbols.add(symbol);
	}
	// 右辺値の登録
	for(let sect of syntaxdef){
		for(let symbol of sect.pattern){
			if(!this.nonterminal_symbols.has(symbol)){
				// 非終端記号でない(=左辺値に現れない)場合、終端記号である
				this.terminal_symbols.add(symbol);
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2つのSetを用意し、コンストラクタの呼び出し時に左辺に現れる記号とそうでない記号で分けています。
これで、トークンを与えるとそれが終端記号かどうか、非終端記号かどうかを判別できるようになりました。&lt;/p&gt;

&lt;p&gt;なおこの記事において、「トークン」と「記号」は概念上は同様の意味を持ちますが、前者はプログラム内で記号を表すための構造として扱い、理論的な概念について触れる際は後者を使うものとします。&lt;/p&gt;

&lt;h2 id=&#34;nulls集合とfirst集合:54819cf28b4a2703da41ec17803c8ec7&#34;&gt;Nulls集合とFirst集合&lt;/h2&gt;

&lt;p&gt;構文解析器の作成のためには、First集合というものを求める必要があります。
そしてFisrt集合を求めるためには、Nulls集合が必要です。&lt;/p&gt;

&lt;p&gt;First集合はFirst関数などとも呼ばれます。
まあ名前なんてどうでもいいのですが、とにかくFirstとNullsを導出しなければなりません。
順を追って見て行きましょう。
例に漏れず、&lt;a href=&#34;https://twitter.com/ki6o4&#34;&gt;うさぎさん(@ki6o4)&lt;/a&gt;の&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kimiyuki.net/blog/2016/08/03/context-free-grammar/&#34;&gt;文脈自由文法とその構文解析法 &amp;middot; うさぎ小屋&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が詳しいので厳密な定義等はそちらを参照してください(First,NullableはLL(1)の項で紹介されています)。&lt;/p&gt;

&lt;h3 id=&#34;nulls集合を求める:54819cf28b4a2703da41ec17803c8ec7&#34;&gt;Nulls集合を求める&lt;/h3&gt;

&lt;h4 id=&#34;nulls集合とは:54819cf28b4a2703da41ec17803c8ec7&#34;&gt;Nulls集合とは&lt;/h4&gt;

&lt;p&gt;ある終端記号または非終端記号について、それが「Nullableである」かどうかを判別する必要があります。
「Nullableな記号」を集めた集合をNulls集合ということにします。
記号がNullableであるとは、その記号から空列が導かれうることを意味します。&lt;/p&gt;

&lt;p&gt;今回題材としている数式の構文規則には、「右辺が存在しない」ルールはありません。
しかし、解析したい構文によっては、右辺が存在しない、つまり左辺から空列が導かれるルールが存在することがあります。
空列とはスペース(空白)等を意味するのではなく、長さ0の入力を意味します。
具体的には、次のようなルールを見てみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;X -&amp;gt; Y &amp;quot;0&amp;quot;
Y -&amp;gt; &amp;quot;1&amp;quot;
Y -&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;構文規則の三行目の右辺には何も書かれていません。
このような場合、&lt;code&gt;Y&lt;/code&gt;は&lt;code&gt;1&lt;/code&gt;もしくは空列となり得ます。
よって&lt;code&gt;X&lt;/code&gt;は、&lt;code&gt;10&lt;/code&gt;と&lt;code&gt;0&lt;/code&gt;の2通りが許容されるのです。
ここで、&lt;code&gt;Y&lt;/code&gt;は空列となり得るため、Nulls集合に含まれます。
さらに、次のような例を見てください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Z -&amp;gt; Y
Y -&amp;gt; &amp;quot;1&amp;quot;
Y -&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、&lt;code&gt;Z&lt;/code&gt;は&lt;code&gt;1&lt;/code&gt;と空列の2通りとなる可能性があります。
よって、&lt;code&gt;Z&lt;/code&gt;もNullableであるといえます。
このように、その記号自体が空列となるルールを指定していなくても、右辺の記号次第では空列となることがあります。
ひとつでも空列となるパターンが存在する場合、Nulls集合に含まなければなりません。
また当然ですが、左辺に現れることのない終端記号はNullableではありません。&lt;/p&gt;

&lt;h4 id=&#34;nulls集合を実装する:54819cf28b4a2703da41ec17803c8ec7&#34;&gt;Nulls集合を実装する&lt;/h4&gt;

&lt;p&gt;なにやら面倒そうですが、実装はそう複雑ではありません。
NullableSetクラスを作ってみましょう。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/nullableset.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/nullableset.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/// nullableset.ts
export class NullableSet{
	private nulls:Set&amp;lt;Token&amp;gt;;
	constructor(private syntax: SyntaxDefinitions){
		this.generateNulls();
	}
	// nulls初期化
	private generateNulls(){
		// 制約条件を導出するために、
		// 空列になりうる記号の集合nullsを導出
		this.nulls = new Set&amp;lt;Token&amp;gt;();
		for(let rule of this.syntax){
			// 右辺の記号の数が0の規則を持つ記号は空列になりうる
			if(rule.pattern.length == 0){
				this.nulls.add(rule.ltoken);
			}
		}

		// 変更が起きなくなるまでループする
		let flg_changed:boolean = true;
		while(flg_changed){
			flg_changed = false;
			for(let rule of this.syntax){
				// 既にnullsに含まれていればスキップ
				if(this.isNullable(rule.ltoken)) continue;

				let flg_nulls = true;
				// 右辺に含まれる記号がすべてnullableの場合はその左辺はnullable
				for(let token of rule.pattern){
					if(!this.isNullable(token)){
						// 一つでもnullableでない記号があるならnon-nullable
						flg_nulls = false;
						break;
					}
				}
				if(flg_nulls){
					flg_changed = true;
					this.nulls.add(rule.ltoken);
				}
			}
		}
	}
	public isNullable(x:Token){
		return this.nulls.has(x);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アルゴリズムは以下の通りです。&lt;br /&gt;
まず、右辺の記号の数が0になるような規則を持っている記号は明らかにNullableです。
そのため、初期化段階として、そのような規則を探してNulls集合に追加します。&lt;br /&gt;
次に、それ以外の記号がNullableであるためには、規則の右辺がすべてNullableな記号である必要があります。
そこで、すべての規則を調べ、その右辺の記号がすべて既存のNull集合に含まれているならば、その記号もNulls集合に追加します。&lt;br /&gt;
この処理を、一巡しても新しいNullableな規則が追加されなくなるまで繰り返せば終了です。&lt;/p&gt;

&lt;h3 id=&#34;first集合を求める:54819cf28b4a2703da41ec17803c8ec7&#34;&gt;First集合を求める&lt;/h3&gt;

&lt;h4 id=&#34;first集合とは:54819cf28b4a2703da41ec17803c8ec7&#34;&gt;First集合とは&lt;/h4&gt;

&lt;p&gt;たとえば先ほど挙げた&lt;code&gt;X&lt;/code&gt;が&lt;code&gt;10&lt;/code&gt;や&lt;code&gt;0&lt;/code&gt;となるように、非終端記号は規則をたどっていくと終端記号のみの列に変換することができます。
構文解析を行うためには、ある非終端記号から得られるそのような終端記号の列のうち、最も左側にどのような終端記号が来るのかを知る必要があります。
今解析している記号の次に非終端記号が来るときに、実際にどのような終端記号が来るのかを調べることによって、(1)先読み(&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回&lt;/a&gt;参照)が可能となるわけです。&lt;/p&gt;

&lt;p&gt;このように、ある非終端記号と、そこから得られる可能性のある終端記号の列の先頭に来る記号の集合を対応付けたものを、First集合またはFirst関数と呼びます。
たとえば、先ほどの&lt;code&gt;X&lt;/code&gt;を例にすると、&lt;code&gt;First(X)&lt;/code&gt;は、&lt;code&gt;10&lt;/code&gt;と&lt;code&gt;0&lt;/code&gt;のそれぞれ左端の記号をとって&lt;code&gt;{1, 0}&lt;/code&gt;となります。&lt;/p&gt;

&lt;p&gt;Aが終端記号であるなら、&lt;code&gt;First(A)&lt;/code&gt;は&lt;code&gt;{A}&lt;/code&gt;(A自身のみを要素とする集合)です。
また、Firstに与える引数は記号だけでなく記号列である可能性もあります。
&lt;code&gt;First(YA)&lt;/code&gt;なら、&lt;code&gt;Y&lt;/code&gt;がNullableであるため、&lt;code&gt;YA&lt;/code&gt;から得られうる文字列の左端になりうるのは&lt;code&gt;1&lt;/code&gt;と&lt;code&gt;A&lt;/code&gt;なので、&lt;code&gt;{1, A}&lt;/code&gt;のようになるでしょう。&lt;/p&gt;

&lt;h4 id=&#34;first集合の実装:54819cf28b4a2703da41ec17803c8ec7&#34;&gt;First集合の実装&lt;/h4&gt;

&lt;p&gt;話がごちゃごちゃしてきましたが、実装に移りましょう。
基本的なアルゴリズムは、以下のようになります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ある記号&lt;code&gt;A&lt;/code&gt;が終端記号なら、&lt;code&gt;First(A)&lt;/code&gt;は&lt;code&gt;{A}&lt;/code&gt;である。全ての終端記号についてそのように初期化する。&lt;/li&gt;
&lt;li&gt;非終端記号に対応するFirst集合は、まず空集合で初期化する。&lt;/li&gt;
&lt;li&gt;ルール &lt;code&gt;X -&amp;gt; Y1 Y2 ... Yi&lt;/code&gt; について、以下の制約を生成する。

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;First(X) ⊇ First(Y1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Y1&lt;/code&gt;がNullableなら &lt;code&gt;First(X) ⊇ First(Y2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Y1&lt;/code&gt;および&lt;code&gt;Y2&lt;/code&gt;がともにNullableなら &lt;code&gt;First(X) ⊇ First(Y3)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Y1&lt;/code&gt;および&lt;code&gt;Y2&lt;/code&gt;および&lt;code&gt;Y3&lt;/code&gt;がともにNullableなら &lt;code&gt;First(X) ⊇ First(Y4)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;以下繰り返し&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;生成した制約に従い、スーパーセット側にサブセット側の集合の持つ記号を追加していく(制約の解消)。&lt;/li&gt;
&lt;li&gt;制約の解消を全ての集合に変化がなくなるまで繰り返す。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;わかりにくいですね。
ちなみにこのアルゴリズムは、言葉で定義するよりもプログラムを書いたほうがわかりやすい類のものです。&lt;/p&gt;

&lt;p&gt;とはいえちょっとコードが長いので、URLから参照をお願いします。
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/firstset.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/firstset.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/// firstset.d.ts
export declare class FirstSet {
    private syntax;
    private symbols;
    private first_map;
    private nulls;
    constructor(syntax: SyntaxDefinitions, symbols: SymbolDiscriminator);
    private generateFirst();
    get(arg: Token): Set&amp;lt;Token&amp;gt;;
    get(arg: Array&amp;lt;Token&amp;gt;): Set&amp;lt;Token&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実のところNulls集合はFirst集合を求める時にしか使わないので、First関数のprivateメンバとしてNullableSetインスタンスを生成して使用します。
SymbolDiscriminatorは他でも使いまわす必要があるので、コンストラクタ引数による依存性の注入を行います。&lt;/p&gt;

&lt;p&gt;また、First関数の引数には単一の記号だけでなく、記号列も与えられるようにする必要があります。
getメソッドではトークンを引数にとるだけでなく、トークンの配列も引数として与えることができるようにします。
トークンの配列が与えられた場合は、左から順に個別のトークンのFirst関数を呼び、そのトークンがNullableである限り、その右隣のFirst関数も呼び出し、その結果として得られた記号全てを要素とする集合を返すものとします。&lt;/p&gt;

&lt;p&gt;説明が適当かつわかりにくくて申し訳ありませんが、どうせ準備段階なので軽く飛ばして先に進めていきましょう(&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回&lt;/a&gt;に参考資料をまとめてあるため、詳細かつ厳密に知りたい方はそちらを参照してください)。&lt;/p&gt;

&lt;p&gt;これでひとまずFirst集合の導出まで終わったので、次回からは構文解析表の作成にとりかかります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回:かんたん構文解析入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/&#34;&gt;前回:字句解析器の実装&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;次回:かんたんLR(1)法入門&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第2回:字句解析器の実装</title>
      <link>http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/</link>
      <pubDate>Sat, 11 Feb 2017 18:13:48 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/</guid>
      <description>
        

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;前回&lt;/a&gt;は構文解析の概略を紹介したので、今回から実装に移っていきたいと思います。
まずは字句解析器を用意する必要があるため、今回は字句解析器の作成について紹介します。&lt;/p&gt;

&lt;p&gt;なお今回から実際のプログラムを記述していきますが、使用言語はTypeScriptとします。&lt;/p&gt;

&lt;p&gt;パーサジェネレータを作るのに比べれば字句解析器を作るのは非常に単純です。
早速はじめていきましょう。&lt;/p&gt;

&lt;h2 id=&#34;字句解析器の仕様を確認する:33ced0e1bdc35ac00ed380cf2d7265fa&#34;&gt;字句解析器の仕様を確認する&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;前回&lt;/a&gt;の記事でも紹介しましたが、字句解析器の行う処理は以下のような流れになります。&lt;/p&gt;

&lt;p&gt;まず、解析するべき入力を文字列として受け取ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;9 + 11 * (2 + 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに加えて、字句規則を用意します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;数字: /[1-9][0-9]*/
プラス: &amp;quot;+&amp;quot;
アステリスク: &amp;quot;*&amp;quot;
左括弧: &amp;quot;(&amp;quot;
右括弧: &amp;quot;)&amp;quot;
(読み捨て): /\s/
(不正): /./
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字句解析器は受け取った入力を先頭から順に字句規則にあてはめ、マッチするものがあればそのトークンを割り当てます。
結果として得られる出力は、以下のようなリストになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;数字: 9
プラス: +
数字: 11
アステリスク: *
左括弧: (
数字: 2
プラス: +
数字: 1
右括弧: )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得られたトークンのリストを構文解析器の入力として渡すことで、構文解析器は文法の解析のみに注力することができます。&lt;/p&gt;

&lt;h2 id=&#34;字句規則を定義する:33ced0e1bdc35ac00ed380cf2d7265fa&#34;&gt;字句規則を定義する&lt;/h2&gt;

&lt;p&gt;実際に解析を行うタイミングでは文字列のみを入力として受け取りますが、字句解析器の生成時には字句規則が必要です。
そのため、予め字句規則を別の設定ファイルなどに書いておくなどして用意しておかなければなりません。
ただし、&lt;strong&gt;字句規則の解析には構文解析器が必要&lt;/strong&gt;となるため、現時点ではプログラム内にハードコーディングしておくなどする必要があります。
今回は、字句規則を内部的に以下のようなデータ構造で扱うこととして、しばらくは字句規則をその内部データの形式で直接書くことにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;// 定義
export type Token = string|symbol;
export interface LexDefinitionSection{
	token: Token|null;
	pattern: string|RegExp;
}
export type LexDefinitions = Array&amp;lt;LexDefinitionSection&amp;gt;;

// 実際の字句規則
const lex: LexDefinitions = [
	{token:&amp;quot;DIGITS&amp;quot;, pattern:/[1-9][0-9]*/},
	{token:&amp;quot;PLUS&amp;quot;, pattern:&amp;quot;+&amp;quot;},
	{token:&amp;quot;ASTERISK&amp;quot;, pattern:&amp;quot;*&amp;quot;},
	{token:&amp;quot;LPAREN&amp;quot;, pattern:&amp;quot;(&amp;quot;},
	{token:&amp;quot;RPAREN&amp;quot;, pattern:&amp;quot;)&amp;quot;},
	{token:null, pattern:/\s/},
	{token:&amp;quot;INVALID&amp;quot;, pattern:/./},
];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この字句規則の定義について、実用上の理由で追加したいくつかの仕様に注意する必要があります。&lt;/p&gt;

&lt;p&gt;Tokenの型定義にsymbolを含めている点についてはここで説明せずに後述することとします。&lt;/p&gt;

&lt;h3 id=&#34;入力の読み捨て:33ced0e1bdc35ac00ed380cf2d7265fa&#34;&gt;入力の読み捨て&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;{token:null, pattern:/\s/}
// (読み捨て): /\s/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この部分は、何らかの空白文字が入力に存在していればマッチングされます。
&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; を解析する際、ここに含まれている空白は文法上何の意味も持たず、&lt;code&gt;9+11*(2+1)&lt;/code&gt; のように入力が与えられたとしても解析結果は変化しません。
このような場合、構文解析器に空白の情報を与えることすらせずに、字句解析器上で空白を検知した段階でその情報を捨ててしまったほうが、構文解析器に余計な処理をさせずに済みます。&lt;/p&gt;

&lt;p&gt;今回は、トークンのラベル部分にnullを指定することで、読み取った結果をトークンとして保持することなく読み捨てることを表すようにしています。&lt;/p&gt;

&lt;h3 id=&#34;正規表現パターンと文字列パターンの使い分け:33ced0e1bdc35ac00ed380cf2d7265fa&#34;&gt;正規表現パターンと文字列パターンの使い分け&lt;/h3&gt;

&lt;p&gt;(ごちゃごちゃ書いている割に小手先のテクニックという感じが強いため、よくわからなければ読み飛ばしてください)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{token:&amp;quot;PLUS&amp;quot;, pattern:&amp;quot;+&amp;quot;}&lt;/code&gt; のように、パターン部分に正規表現ではなく文字列を用いて記述している箇所があります。
すべて正規表現を使って記述するのではなく文字列も許容している理由として、まず&lt;code&gt;/\+/&lt;/code&gt;のように特殊記号をエスケープせずに済む点が挙げられます。
そして、「文字列でパターンを記述した場合は、アルファベットの途中でトークンを区切らないようにする」というルールを用いることで、一部のパターンを簡潔に書くことが可能になります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vwxyz&lt;/code&gt; という入力を考えてみましょう。
ここでもし、&lt;code&gt;&amp;quot;vwx&amp;quot;&lt;/code&gt; にマッチする規則と、&lt;code&gt;&amp;quot;vwxyz&amp;quot;&lt;/code&gt; にマッチする規則の2つが存在した場合、&lt;code&gt;&amp;quot;vwxyz&amp;quot;&lt;/code&gt; の規則を先に書かない限り、入力&lt;code&gt;vwxyz&lt;/code&gt; は&lt;code&gt;&amp;quot;vwx&amp;quot; + yz&lt;/code&gt; とみなされ、&lt;code&gt;&amp;quot;yz&amp;quot;&lt;/code&gt; に対応する規則が存在しなければエラーとなります。
これを回避するためには、よりマッチするパターンが長い規則を常に短い規則よりも先に書くようにする必要がありますが、面倒です。
そこで、正規表現ではなく文字列で&lt;code&gt;&amp;quot;vwx&amp;quot;&lt;/code&gt; などのパターンが定義され、かつその末尾の文字が&lt;code&gt;\w&lt;/code&gt; にマッチする場合、マッチした部分の一文字先の文字が&lt;code&gt;\w&lt;/code&gt; 以外でなければマッチしないようにします。
これは、正規表現で&lt;code&gt;/vwx(?!\w)/&lt;/code&gt; 、&lt;code&gt;/vwxyz(?!\w)/&lt;/code&gt; というような否定的前方先読みをパターンの最後に追加することに相当します。
このルールを追加することで、正規表現を用いる場合よりも簡潔に記述可能となります。&lt;/p&gt;

&lt;h2 id=&#34;字句解析器を実装する:33ced0e1bdc35ac00ed380cf2d7265fa&#34;&gt;字句解析器を実装する&lt;/h2&gt;

&lt;p&gt;ではLexerクラスを作っていきましょう。
とはいえ字句規則さえ定義してしまえば、やることはほとんどありません。
コンストラクタ引数として字句規則データを受け取って保持しておくようにして、解析実行時に上から順に字句規則のマッチングを試みるだけです。&lt;/p&gt;

&lt;p&gt;今回はコード量が少ないので、 &lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/lexer.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/lexer.ts&lt;/a&gt; 全体をそのまま貼り付けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/// token.ts
export type Token = string|symbol;
export const SYMBOL_EOF:Token = Symbol(&amp;quot;EOF&amp;quot;);
export const SYMBOL_SYNTAX:Token = Symbol(&amp;quot;S&#39;&amp;quot;);
export const SYMBOL_DOT:Token = Symbol(&amp;quot;.&amp;quot;);

export type TokenList = Array&amp;lt;{token:Token, value:string}&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/// lexer.ts
/// LexDefinitionsの定義は先述のものと同一
import {Token, SYMBOL_EOF, TokenList} from &amp;quot;./token&amp;quot;;
import {LexDefinitions} from &amp;quot;./grammar&amp;quot;;

export interface ILexer{
	exec(str: string):TokenList;
}

export class Lexer implements ILexer{
	constructor(public def: LexDefinitions){
		// 正しいトークン定義が与えられているかチェック
		for(var i=0; i&amp;lt;this.def.length; i++){
			var token_pattern = this.def[i].pattern;
			if(typeof token_pattern == &amp;quot;string&amp;quot;){
				continue;
			}
			else if(token_pattern instanceof RegExp){
				// フラグを整形する
				let flags:string = &amp;quot;&amp;quot;;
				// gフラグは邪魔なので取り除く
				// i,m,uフラグがあれば維持する
				if(token_pattern.ignoreCase){
					flags += &amp;quot;i&amp;quot;;
				}
				if(token_pattern.multiline){
					flags += &amp;quot;m&amp;quot;;
				}
				if(token_pattern.unicode){
					flags += &amp;quot;u&amp;quot;;
				}
				// yフラグは必ずつける
				flags += &amp;quot;y&amp;quot;;
				// フラグをつけなおして新しい正規表現オブジェクトにする
				this.def[i].pattern = new RegExp(token_pattern, flags);
				continue;
			}
			throw new Error(&amp;quot;invalid token definition: neither string nor RegExp object&amp;quot;);
		}
	}
	exec(str: string):TokenList{
		var result:TokenList = [];
		let lastindex = 0;
		while(lastindex &amp;lt; str.length){
			for(var i=0; i&amp;lt;this.def.length; i++){
				var token:Token|null = this.def[i].token;
				var token_pattern = this.def[i].pattern;
				var match:string;
				if(typeof token_pattern == &amp;quot;string&amp;quot;){
					let last_tmp = lastindex+token_pattern.length;
					if(str.substring(lastindex,last_tmp) != token_pattern) continue;
					if(last_tmp &amp;lt; str.length &amp;amp;&amp;amp; /\w/.test(token_pattern.slice(-1)) &amp;amp;&amp;amp; /\w/.test(str[last_tmp])) continue; // ヒットした文字の末尾が\wで、そのすぐ後ろが\wの場合はスキップ
					match = token_pattern;
					lastindex += token_pattern.length;
				}
				else{
					// token_pattern: RegExp
					token_pattern.lastIndex = lastindex;
					let m = token_pattern.exec(str);
					if(m === null) continue; // マッチ失敗
					match = m[0];
					lastindex = token_pattern.lastIndex; // lastindexを進める
				}
				// tokenがnullなら処理を飛ばします
				if(token != null){
					result.push({token:token, value:match});
				}
				break;
			}
		}
		// 最後にEOFトークンを付与
		result.push({token:SYMBOL_EOF, value:&amp;quot;&amp;quot;});
		return result;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まずコンストラクタでは、与えられた字句規則に簡単な型チェックと正規表現の整形を行っています。
グローバルマッチは今回は邪魔なだけなので、与えられた正規表現にgフラグがついていれば取り除きます。
ES2015でRegExpに追加されたstickyフラグ(&lt;strong&gt;ほぼ&lt;/strong&gt;全ての主要モダンブラウザ上で実装済み)を使うと楽なので、ここでyフラグの追加も行います。&lt;/p&gt;

&lt;p&gt;execメソッドでは入力を読み終えるまでマッチングを繰り返し、&lt;code&gt;{token:Token, value:string}&lt;/code&gt; というオブジェクトを結果の配列に追加していきます。
先述のようにパターンが文字列であれば&lt;code&gt;\w&lt;/code&gt;が連続した場所では区切らないようにして、マッチングが成功するたびにインデックス位置を先に進めていきます。&lt;/p&gt;

&lt;p&gt;また、すべての入力を読み終えた後、最後にSymbol(EOF)を名前としたトークンを結果に追加します。
これは入力の末尾を意味するトークンで、構文解析の際に内部的に使用されます。&lt;/p&gt;

&lt;p&gt;(Symbolは、それ自身と比較しない限り&lt;code&gt;==&lt;/code&gt;や&lt;code&gt;===&lt;/code&gt;の評価結果が常にfalseになるプリミティブ型で、ES2015で追加されたものです。
字句規則で定義されたトークンとの衝突が発生しないようにここでSymbolを使用していますが、Symbolそのものはオブジェクトのプロパティとして使用することで後方互換性を維持することを目的としてJavaScriptに追加された型であるため、この用途で用いるのに適しているのかどうかは議論の余地があります。
とはいえプログラミング言語個別の問題はこの記事の主題とは関係がないため、詳しくは言及しません。)&lt;/p&gt;

&lt;p&gt;この字句解析器に先ほどの字句規則を与え、&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; を入力すると、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;[
	{token:&amp;quot;DIGITS&amp;quot;, value:&amp;quot;9&amp;quot;},
	{token:&amp;quot;PLUS&amp;quot;, value:&amp;quot;+&amp;quot;},
	{token:&amp;quot;DIGITS&amp;quot;, value:&amp;quot;11&amp;quot;},
	{token:&amp;quot;ASTERISK&amp;quot;, value:&amp;quot;*&amp;quot;},
	{token:&amp;quot;LPAREN&amp;quot;, value:&amp;quot;(&amp;quot;},
	{token:&amp;quot;DIGITS&amp;quot;, value:&amp;quot;2&amp;quot;},
	{token:&amp;quot;PLUS&amp;quot;, value:&amp;quot;+&amp;quot;},
	{token:&amp;quot;DIGITS&amp;quot;, value:&amp;quot;1&amp;quot;},
	{token:&amp;quot;RPAREN&amp;quot;, value:&amp;quot;)&amp;quot;},
	{token:Symbol(EOF), value:&amp;quot;&amp;quot;}
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という結果が得られます。
これでトークンの並びを得ることに成功したので、次回以降はいよいよパーサジェネレータの作成に移っていくことになります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;前回:かんたん構文解析入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;次回:儀式の下準備&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第1回:かんたん構文解析入門</title>
      <link>http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/</link>
      <pubDate>Thu, 22 Dec 2016 03:03:09 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/</guid>
      <description>
        

&lt;p&gt;この記事は&lt;a href=&#34;http://www.adventar.org/calendars/1881&#34;&gt;Kobe University Advent Calendar 2016&lt;/a&gt;の21日の記事です。また遅刻か。
なお私は当該大学の学部2年(2016年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;構文解析ができるプログラマはちょっとかっこいいですよね。
「構文解析？ああ、できますよ」とか言って自分のスキルを自慢できそうな印象があります。&lt;/p&gt;

&lt;p&gt;(ほぼ)フルスクラッチでTypeScriptによるLR(1)パーサジェネレータを実装した(ついでにLALR(1)パーサも作れる)ので、これを完成させるまでの流れを紹介していこうと思います。&lt;/p&gt;

&lt;p&gt;今回は構文解析自体の入門編となります。&lt;/p&gt;

&lt;p&gt;自作したパーサジェネレータは &lt;a href=&#34;https://github.com/Tatamo/parsergenerator&#34;&gt;https://github.com/Tatamo/parsergenerator&lt;/a&gt; にあります。&lt;br /&gt;
今のところパーサジェネレータ部分は完成、基本的な構文解析なら問題なくこなせるので構文規則や字句規則を外部から読み取って構文解析してパーサジェネレータに渡すような処理や、全体の見通しを良くするための設計の見直しやリファクタリング等を行っている段階です。
ドキュメント作ってなくてすみません。&lt;/p&gt;

&lt;h2 id=&#34;構文解析をしたい:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;構文解析をしたい&lt;/h2&gt;

&lt;p&gt;構文解析、時々見かけるフレーズです。
プログラマなら覚えておいて損はない技術……かどうかはわかりませんが、そういう類のスキルに(傍からは)見えます。&lt;br /&gt;
ぜひやりましょう。&lt;/p&gt;

&lt;p&gt;ひとまず、何をやりたいのかを明確にする必要があります。&lt;br /&gt;
この記事では、「入力として与えられるLR(1)文法に属する文法に従ったトークン列をパース(構文解析)することで、その構造を構文木として出力する」ことを目標とします。
何を言っているのかさっぱりわかりませんね、わからなくていいです。&lt;/p&gt;

&lt;p&gt;順を追って説明する必要がありますが、詳細は適宜省略します。
そのため、まずは今回主に参照した資料を列挙しておきます。&lt;/p&gt;

&lt;h2 id=&#34;参考資料一覧:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;参考資料一覧&lt;/h2&gt;

&lt;p&gt;より詳しく知りたい方は、下記に挙げる資料やそこで紹介されている参考文献などを参照されるのが良いと思われます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.cornell.edu/courses/cs412/2003sp/lectures/lec09.pdf&#34;&gt;Cornell CIS Introduction to Compilers Lecture 9: LR(1) Parsing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jaist.ac.jp/~kshirai/lec/i223/04a.pdf&#34;&gt;JAIST 自然言語処理論Ｉ 4.文法2(構文解析) その1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jaist.ac.jp/~kshirai/lec/i223/04b.pdf&#34;&gt;JAIST 自然言語処理論Ｉ 4.文法2(構文解析) その2&lt;/a&gt;
(注：「LR法による構文解析」として紹介されているアルゴリズムはSLR法)&lt;br /&gt;
上記3つはネット上にアップロードされている特定の大学の講義資料ですが、公開の規定等を確認していないためリンクを張ることに不都合があるようなら知らせていただけると助かります。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Canonical_LR_parser&#34;&gt;Canonical LR parser - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/ichikaz3/lr-parsing&#34;&gt;LR parsing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kimiyuki.net/blog/2016/08/03/context-free-grammar/&#34;&gt;文脈自由文法とその構文解析法 &amp;middot; うさぎ小屋&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/uhyo_&#34;&gt;うひょ(@uhyo_)さん&lt;/a&gt; 生き字引。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;構文解析とは-ざっくり:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;構文解析とは？(ざっくり)&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; という数式を考えてみます。
構文解析をすることによる最終的な目的は、この数式を(たとえば)文字列として与えると、結果としてこの数式の答えが&lt;code&gt;42&lt;/code&gt;であることを導く、といったことです。&lt;/p&gt;

&lt;p&gt;そのためには、以下のものが必要になります：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数式を表現する構文規則&lt;/li&gt;
&lt;li&gt;上記構文規則を解析するように作られた構文解析器(Parser)&lt;/li&gt;
&lt;li&gt;解析された構文を処理するプログラム&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さらに、これらの構文解析に入る前の下準備のために以下が必要です：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;文字列をトークンとして分割して表現するための字句規則&lt;/li&gt;
&lt;li&gt;上記字句規則をもとに、文字列を読み取ってトークンを返す字句解析器(Lexical Analyzer、略してLexer)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ちなみに、今回の記事の目標は、それらに加えて以下のものを実装することです：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;構文規則および字句規則を入力として与えることで、構文解析器そのものを自動生成するパーサジェネレータ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;実際の構文解析を行う手順とはずれてしまいますが、紹介した順番に沿って構文解析器→字句解析器の順に解説していきます。&lt;/p&gt;

&lt;h3 id=&#34;構文解析器-パーサ:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;構文解析器(パーサ)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; という数式を解析するためには、まずこの数式がどのようなルールで記述されているのかを(再)定義する必要があります。
そのルールをを表すのが構文規則です。
構文規則を書き表すルールは、たとえば&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%90%E3%83%83%E3%82%AB%E3%82%B9%E3%83%BB%E3%83%8A%E3%82%A6%E3%82%A2%E8%A8%98%E6%B3%95&#34;&gt;BNF&lt;/a&gt;など様々な種類がありますが、基本的な発想としては&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;S -&amp;gt; X Y Z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように左辺の記号を右辺の記号の並びによって定義することで行います。&lt;/p&gt;

&lt;p&gt;具体的に見てみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;式 -&amp;gt; 式 &amp;quot;+&amp;quot; 項
式 -&amp;gt; 項
項 -&amp;gt; 項 &amp;quot;*&amp;quot; 因子
項 -&amp;gt; 因子
因子 -&amp;gt; 数
因子 -&amp;gt; &amp;quot;(&amp;quot; 式 &amp;quot;)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;妥当ですね。
&lt;code&gt;式 -&amp;gt; 式 + 項&lt;/code&gt; と &lt;code&gt;式 -&amp;gt; 項&lt;/code&gt;の２つの規則が、再帰的な繰り返しを表現していることに注意してください。
たとえば、&lt;code&gt;項&lt;/code&gt;は当然&lt;code&gt;式&lt;/code&gt;ですし、&lt;code&gt;項 + 項&lt;/code&gt;も&lt;code&gt;式(-&amp;gt;項) + 項&lt;/code&gt; より&lt;code&gt;式&lt;/code&gt;となります。
さらに、&lt;code&gt;項 + 項 + 項&lt;/code&gt;は最初の&lt;code&gt;項 + 項&lt;/code&gt;が&lt;code&gt;式&lt;/code&gt;なので、&lt;code&gt;式(-&amp;gt;項 + 項) + 項&lt;/code&gt; より&lt;code&gt;式&lt;/code&gt;です。
よって、&lt;code&gt;式&lt;/code&gt;は&lt;code&gt;項&lt;/code&gt;を&lt;code&gt;&amp;quot;+&amp;quot;&lt;/code&gt;によって任意の回数だけ繋げたものであり、同様に&lt;code&gt;項&lt;/code&gt;は&lt;code&gt;因子&lt;/code&gt;を&lt;code&gt;&amp;quot;*&amp;quot;&lt;/code&gt;で繋げたものとなります。
最後に、&lt;code&gt;因子&lt;/code&gt;は単なる&lt;code&gt;数&lt;/code&gt;かもしれませんし、または&lt;code&gt;&amp;quot;(&amp;quot;&lt;/code&gt;と&lt;code&gt;&amp;quot;)&amp;quot;&lt;/code&gt;で囲まれた&lt;code&gt;式&lt;/code&gt;かもしれません。
これは括弧で囲まれた部分の式が他の部分よりも高い優先順位となることを表現しています。&lt;/p&gt;

&lt;p&gt;たとえば&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt;は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;式{ [9] [+] [11 * (2 + 1)] }
式{ 項{ [9] } &amp;quot;+&amp;quot; 項{ [11] [*] [(2 + 1)] } }
式{ 項{ 因子{9} } &amp;quot;+&amp;quot; 項{ 因子{11} &amp;quot;*&amp;quot; 因子{ [(] [2 + 1] [)] } } }
式{ 項{ 因子{9} } &amp;quot;+&amp;quot; 項{ 因子{11} &amp;quot;*&amp;quot; 因子{ &amp;quot;(&amp;quot; 式{ [2] [+] [1] } &amp;quot;)&amp;quot; } } }
式{ 項{ 因子{9} } &amp;quot;+&amp;quot; 項{ 因子{11} &amp;quot;*&amp;quot; 因子{ &amp;quot;(&amp;quot; 式{ 項{ [2] } &amp;quot;+&amp;quot; 項{ [1] } } &amp;quot;)&amp;quot; } } }
式{ 項{ 因子{9} } &amp;quot;+&amp;quot; 項{ 因子{11} &amp;quot;*&amp;quot; 因子{ &amp;quot;(&amp;quot; 式{ 項{ 因子{2} } &amp;quot;+&amp;quot; 項{ 因子{1} } } &amp;quot;)&amp;quot; } } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように展開されます(こうして得られた構造をどう解析するかについては省略します)。この、解析対象→構文木の変換を自動で行うのがパーサです。&lt;/p&gt;

&lt;p&gt;ちなみにですが、この構文規則は解析したい対象ごとにあなたが一から書き上げる必要があります。&lt;/p&gt;

&lt;h3 id=&#34;字句解析器-レキシカルアナライザ:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;字句解析器(レキシカルアナライザ)&lt;/h3&gt;

&lt;p&gt;上記構文規則では、&lt;code&gt;+&lt;/code&gt;や&lt;code&gt;*&lt;/code&gt;のような演算子、&lt;code&gt;数&lt;/code&gt;についての規定はありません。
これらの「左辺に現れない記号」を、「終端記号」と呼びます。左辺に現れる記号は非終端記号と呼ばれます。&lt;/p&gt;

&lt;p&gt;通常、&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; のような入力は文字列で与えられますが、記号と記号の間には複数もしくは0個の空白が挿入されている可能性もあります。
しかし以下のような構文規則を定義するのは本質的ではありません：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;空白 -&amp;gt; &amp;quot; &amp;quot;
空白 -&amp;gt; &amp;quot; &amp;quot; 空白
数字 -&amp;gt; &amp;quot;0&amp;quot; | &amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | ... | &amp;quot;9&amp;quot;
数字 -&amp;gt; (&amp;quot;0&amp;quot; | &amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | ... | &amp;quot;9&amp;quot;) 数字
数 -&amp;gt; (&amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | &amp;quot;3&amp;quot; ... | &amp;quot;9&amp;quot;) 数字
ただし、|は「または」を表す
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そこで、通常は「入力として与えられた文字列」を「終端記号として分類されたトークンの列」に変換する処理をはさみ、これによって得られたトークンを構文解析器に与えます。
トークンとは終端記号と、必要ならばそれに紐付いた元々の情報を保持しておいたものです。たとえば、&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt;は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;数字: 9
プラス: +
数字: 11
アステリスク: *
左括弧: (
数字: 2
プラス: +
数字: 1
右括弧: )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような9つのトークンの列に分けることができます。
構文解析器はそのトークンがどのような終端記号に対応しているかは見ますが、たとえば個々の数字が何であるかを判断することはしません。
これによって、構文解析器は本質的な文法の解析のみに注力することができます。&lt;/p&gt;

&lt;p&gt;この処理をするのが字句解析器で、どのような文字や文字列が与えられた場合に何という終端記号かを判別するための規則が字句規則です。&lt;/p&gt;

&lt;p&gt;字句規則は、例えば以下のような書き方になるでしょう：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;数字: /[1-9][0-9]*/
プラス: &amp;quot;+&amp;quot;
アステリスク: &amp;quot;*&amp;quot;
左括弧: &amp;quot;(&amp;quot;
右括弧: &amp;quot;)&amp;quot;
(読み捨て): /\s/
(不正): /./
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでは字句規則の表現のために、文字列および正規表現を使用しています。
通常(?)字句規則は上から順に文字列の先頭部分を当てはめていき、マッチするものがあればその終端記号に対応付けます。
そのため、&lt;code&gt;(不正)&lt;/code&gt;の部分は入力された文字全てにマッチする正規表現&lt;code&gt;/./&lt;/code&gt;が使用されていますが、これは上の規則のいずれにも当てはまらなかった場合にのみマッチします。&lt;/p&gt;

&lt;p&gt;与えられた文字列を前から順番に見ていくだけなので、字句解析器の実装はパーサやパーサジェネレータの実装と比べると単純です。&lt;/p&gt;

&lt;h3 id=&#34;パーサジェネレータ:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;パーサジェネレータ&lt;/h3&gt;

&lt;p&gt;ここまで構文解析器(パーサ)と字句解析器(レキシカルアナライザ)について見てきました。
基本的にはこの2つによって構文解析を行うことができ、基本的な流れとしては&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;入力となるような解析したい言語を用意する&lt;/li&gt;
&lt;li&gt;字句規則を用意して、それをもとにしたレキシカルアナライザを用意する&lt;/li&gt;
&lt;li&gt;レキシカルアナライザに入力を与え、トークンの列を取得する&lt;/li&gt;
&lt;li&gt;構文規則を用意して、それをもとにしたパーサを用意する&lt;/li&gt;
&lt;li&gt;パーサにトークンの列を与え、解析結果を得る&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となります。
パーサジェネレータとは何かというと、この 4. の部分を自動化するものです。
(LR法の)構文解析器は、内部的には入力を受け取ってスタックに積みながら状態遷移を繰り返すオートマトンにすぎません。
そのため、どの入力が与えられればどのような状態に遷移するかを示す「構文解析表」を得ることができれば、その構文を解析するパーサを作成することができます。
パーサジェネレータは、構文規則を読み取ることでこの構文解析表をつくり上げるという処理を主に行います。&lt;/p&gt;

&lt;p&gt;字句解析器程度ならわざわざジェネレータを作らなくても、字句規則そのものを字句解析器に渡せば良い感じに字句解析してくれるようにできますが、パーサジェネレータも「構文解析表の構築後、それをもとにして構文解析を行う」ような機能がついていればそれはパーサであるとも言えます。
わざわざパーサとパーサジェネレータが分けられているのは、一つには計算資源の乏しかった昔はパーサジェネレータがオンメモリで展開した構文解析表をもとにそのままパーサとして振る舞うというようなことが少なく、構文解析表を与えることで「パーサのソースコード」を出力するようなものが一般的だったからではないかと思われます(適当な思いつきを言っています)。
もっとも、パーサジェネレータがパーサを生成する際の処理にかかる時間を省略したい場合、予めパーサをコンパイルしておけるようにするのは妥当といえるでしょう。
字句解析器のための「字句解析器ジェネレータ」も実際に存在していますが、ここでは簡単のために字句解析器はコンストラクタに字句規則を与えれば勝手に良い感じの字句解析を行ってくれるようになるものと思ってもらえればよいです。&lt;/p&gt;

&lt;h3 id=&#34;文脈自由言語について:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;文脈自由言語について&lt;/h3&gt;

&lt;p&gt;構文解析器が解析対象とする「言語」がどのようなものであるかについてはいろいろな定義がなされています。&lt;/p&gt;

&lt;p&gt;これについては、参考資料でも紹介した&lt;a href=&#34;https://twitter.com/ki6o4&#34;&gt;うさぎさん(@ki6o4)&lt;/a&gt;の&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kimiyuki.net/blog/2016/08/03/context-free-grammar/&#34;&gt;文脈自由文法とその構文解析法 &amp;middot; うさぎ小屋&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が詳しいため、こちらを参照していただくことをおすすめします。
ここでは、厳密な話はあまりせずにごくごく簡単に触れていこうと思います。&lt;/p&gt;

&lt;p&gt;構文解析の対象とするのは、基本的に文脈自由言語となります。
構文解析の手法にも様々なものがありますが、それらの手法の中には文脈自由言語すべてを解析できるわけではないものも多く、たとえばLR(1)法ならLR(1)文法やLR(1)言語というように、ある手法で解析できる文法や、解析できる言語全体をその手法の名前で表される言語として表現することがあります。&lt;/p&gt;

&lt;h3 id=&#34;解析手法と言語のクラス:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;解析手法と言語のクラス&lt;/h3&gt;

&lt;p&gt;いくつかの手法を主観を交えて乱暴に紹介していきます。&lt;/p&gt;

&lt;h4 id=&#34;先読み:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;先読み&lt;/h4&gt;

&lt;p&gt;**この項は下のLR法などの項を「先読み」してから戻ってきて読むことをおすすめします**&lt;/p&gt;

&lt;p&gt;たとえばLR(1)法のように、数字を括弧でくくって(k)と表現している手法がいくつかあります。このkは何文字先読みするかを示していて、たとえば(1)ならば1文字先読みするという意味です。
先読み数については、たとえばLR法については以下のようなことが言われています。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;LR(k)で表せる文法のクラス ⊆ LR(k+1)先読みで表せるクラス である&lt;/li&gt;
&lt;li&gt;LR(k)文法によって受理可能な言語のクラスは、LR(1)のそれと等しい&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.より、基本的には(1)について考えることが多いようです。&lt;/p&gt;

&lt;h4 id=&#34;ll-1-法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;LL(1)法&lt;/h4&gt;

&lt;p&gt;「再帰を使って構文解析する」という発想としては単純なもの。
LL(1)文法のクラスはLR(1)よりも大幅に小さいものの、それでもLALR(1)文法を外れた文法を解析できたりします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;S -&amp;gt; S + E
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような、右辺の一番左の場所に左辺の記号が登場するような「左再帰則」を読むことができません。ナンセンス。&lt;/p&gt;

&lt;h4 id=&#34;lr-0-法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;LR(0)法&lt;/h4&gt;

&lt;p&gt;先読み数が0なのでよわい。&lt;/p&gt;

&lt;h4 id=&#34;slr法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;SLR法&lt;/h4&gt;

&lt;p&gt;SLRのSはSimpleの意味です。LR(0)から単純な先読みを加えることでLR(0)よりも解析可能な文法が増えますが、それでもLALR(1)には及びません。&lt;/p&gt;

&lt;h4 id=&#34;lr-1-法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;LR(1)法&lt;/h4&gt;

&lt;p&gt;LR(0)に対し、1文字だけ先読みして次にどのような入力が期待されるかを判断。
LR(1)文法がそれなりに広いという点で優秀な一方、LR(0)に比べて構文解析表の大きさが爆発しやすいという欠点がある、と言われています。
しかし今の時代はそんなものは大した欠点になり得ない気がします。&lt;/p&gt;

&lt;h4 id=&#34;lalr-1-法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;LALR(1)法&lt;/h4&gt;

&lt;p&gt;プログラミング言語を解析するコンパイラなどによく使われている手法です。
LALR(1)のLAはLook-Aheadの略で、まずLR(1)法で構文解析表を作ってから、文法部分が同じで先読み記号だけが違うような状態をマージするという点がLR(1)法と異なります。
表を併合してしまうためにLR(1)法よりも解析可能な文法のクラスが小さくなるものの、実用上はほとんど問題にならず、LR(1)法の構文解析表が大きくなりすぎるという欠点を補える手法です。&lt;/p&gt;

&lt;p&gt;ただし、一度LR(1)法の表を作ること変わりはないのでメモリ消費量はそう変わらないし、大きなデータも問題なく扱える今の時代にわざわざ構文解析表を数十パーセント程度削減したところで何の意味があるのかという疑問があります。&lt;/p&gt;

&lt;p&gt;また、LALR法のLAはLook-Aheadの略だと言いましたが、注意しなければならないのは&lt;strong&gt;Look-Ahead(先読み)を行うのはLALR法固有の手法ではない&lt;/strong&gt;ということです。  先読み自体はLR(1)法でもやりますし、LALR(1)はあくまでLR(1)の先読み部分をマージしたものにすぎません。
私はLALR法の名前の付け方はあまり良くないと思っていて、MLR法(Merged Look-Ahead LR法)とかなんとか、そういう感じの名前に変えたほうが良いと思います。&lt;/p&gt;

&lt;h4 id=&#34;glr法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;GLR法&lt;/h4&gt;

&lt;p&gt;「あいまいな」解釈が可能な文法があった場合、考えられうるすべての可能性を探索してしまうことによって解決する手法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;「お魚くわえた猫を追いかけるサザエさん」&lt;/code&gt;で魚をくわえているのが猫とサザエさんの両方に解釈できるように、一つの入力に対して複数の結果が得られることがあります。
どちらかというと自然言語処理向きかもしれません。&lt;/p&gt;

&lt;h4 id=&#34;cyk法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;CYK法&lt;/h4&gt;

&lt;p&gt;強力なアルゴリズムにより、文脈自由言語すべてを比較的高速に解析可能。
ただし、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;S -&amp;gt; NP VP
VP -&amp;gt; v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように、チョムスキー標準形といわれるような、「右辺が非終端記号ちょうど2つか終端記号1つでなければならない」、つまり結果として得られる構造が二分木になっていなければならないというナンセンスにも程がある制約を課されます(アルゴリズムの改良や規則の変換、得られた木構造の後処理などによって回避は可能ですが)。&lt;/p&gt;

&lt;p&gt;このCYK法の計算量オーダーは&lt;code&gt;O(n^3)&lt;/code&gt;程度で、文脈自由言語全てを解析可能なアルゴリズムの中では高速ですが、この記事で紹介されている他のアルゴリズムよりは低速となります。
たとえばLR(1)法は文脈自由言語全体を解析出来ないかわりに&lt;code&gt;O(n)&lt;/code&gt;で解析が可能です。&lt;/p&gt;

&lt;p&gt;プログラミング言語の解析では、言語の開発者が文法自体をある程度自由に定義することができるため、文脈自由言語の一部だけでなく全体を解析したいという需要はあまり発生しません。&lt;/p&gt;

&lt;h2 id=&#34;lr-1-パーサジェネレータをつくろう:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;LR(1)パーサジェネレータをつくろう&lt;/h2&gt;

&lt;p&gt;構文解析の大まかな流れはわかりました。
とりあえず字句規則と構文規則を用意して、あとはどうにかしてこの構文を読んでくれるようなパーサを用意すれば構文解析ができそうです(字句解析器なんてのは適当にやってもすぐ用意できます)。&lt;/p&gt;

&lt;p&gt;先ほど紹介したような手法によって構文ごとに一からパーサをプログラミングするようなことはやりたくないので、パーサジェネレータを用いてパーサを自動的に生成してもらえば事は済みそうですね。&lt;/p&gt;

&lt;p&gt;ここに&lt;a href=&#34;https://www.gnu.org/software/bison/&#34;&gt;Bison&lt;/a&gt;という有名なパーサジェネレータがあります。
今の時代にわざわざCやC++で構文解析なんてしたくないのでしたら、Pythonで&lt;a href=&#34;http://www.dabeaz.com/ply/&#34;&gt;PLY&lt;/a&gt;とか、JavaScriptの&lt;a href=&#34;https://github.com/zaach/jison&#34;&gt;jison&lt;/a&gt;というものなど、いくらでも選択肢があります。
これらのうち一つを選んで、チュートリアルを読んでパーサを作っていくのがいいでしょう。&lt;/p&gt;

&lt;p&gt;というわけで、前段を書いていると結構分量が膨らんでしまったため、今回はここで区切ります。&lt;/p&gt;

&lt;p&gt;では次回からは、構文解析を行えるようになるため、LR(1)法を用いたパーサジェネレータを実際に作っていく流れを紹介していきたいと思います。&lt;/p&gt;

&lt;p&gt;えっちょっとまって、今パーサジェネレータは既存のものを使えばいいって言ったよね、ねえ&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/&#34;&gt;次回:字句解析器の実装&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Javaのリフレクションを悪用してクラス設計してみる</title>
      <link>http://tatamo.81.la/blog/2016/12/15/java-generics-and-reflection/</link>
      <pubDate>Thu, 15 Dec 2016 01:11:23 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/12/15/java-generics-and-reflection/</guid>
      <description>
        

&lt;p&gt;この記事は&lt;a href=&#34;http://www.adventar.org/calendars/1881&#34;&gt;Kobe University Advent Calendar 2016&lt;/a&gt;の14日の記事です。遅刻です。
なお私は当該大学の学部2年(2016年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最近、大学の授業などで少しだけJavaに触れる機会があったので、ちょっとした黒魔術っぽいことでもやってみようと思います。&lt;/p&gt;

&lt;p&gt;と思ったのですが、記事を書こうとして調べていたら普通に書きたかったことをわかりやすく書いている記事がありました。&lt;br /&gt;
* &lt;a href=&#34;http://d.hatena.ne.jp/Nagise/20131121/1385046248&#34;&gt;new T()したいケースへの対処法 - プログラマーの脳みそ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;もう帰っていいですかね。&lt;/p&gt;

&lt;h2 id=&#34;総称型tに対してt-classやnew-t-したい:c600ddb79433125511402a932eb728b1&#34;&gt;総称型Tに対してT.classやnew T()したい&lt;/h2&gt;

&lt;h3 id=&#34;ジェネリクスとは:c600ddb79433125511402a932eb728b1&#34;&gt;ジェネリクスとは&lt;/h3&gt;

&lt;p&gt;わざわざ書くまでもないとは思いますが、ジェネリクスについておさらいをしておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;ArrayList&amp;lt;String&amp;gt; strlist = new ArrayList&amp;lt;String&amp;gt;();
ArrayList&amp;lt;Integer&amp;gt; intlist = new ArrayList&amp;lt;Integer&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ArrayList&lt;T&gt;に対し、ジェネリクスとしてStringやIntegerなど、リストの要素として入れたい型をTの部分に具体的に書くことで、一つのクラスであるArrayListに利用者側が好きな要素を入れることができるようになります。&lt;/p&gt;

&lt;p&gt;ジェネリクスを用いて自分でメソッドを定義する場合は、以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public &amp;lt;T&amp;gt; void doSomething(T arg){
	// doSomething
}

// TをSomeClassのサブクラスに限定する
public &amp;lt;T extends SomeClass&amp;gt; void notDoAnything(T arg){
	return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらのメソッドを呼び出すときは、&lt;code&gt;hoge.&amp;lt;SomeClass&amp;gt;doSomething();&lt;/code&gt;のようになります。&lt;br /&gt;
どうして&lt;code&gt;hoge.doSomething&amp;lt;SomeClass&amp;gt;();&lt;/code&gt;じゃないんだろう。&lt;/p&gt;

&lt;h3 id=&#34;ジェネリクスはt-classやnew-t-をさせてくれない:c600ddb79433125511402a932eb728b1&#34;&gt;ジェネリクスはT.classやnew T()をさせてくれない&lt;/h3&gt;

&lt;p&gt;Javaのジェネリクスでは、以下のコードはコンパイルエラーとなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public &amp;lt;T extends SomeClass&amp;gt; List&amp;lt;T&amp;gt; getSubClassList(List&amp;lt;SomeClass&amp;gt; list){
	return list
		.stream()
		.filter(value -&amp;gt; value instanceof T) // ここでlistの要素valueがTのインスタンスかどうか判別したい -&amp;gt; error
		.collect(Collectors.toList());
}

public &amp;lt;T extends SomeClass&amp;gt; List&amp;lt;T&amp;gt; getSubClassList2(List&amp;lt;SomeClass&amp;gt; list){
	return list
		.stream()
		.filter(value -&amp;gt; value.getClass() == T.class) // instanceofがだめならclassを取得して判別したい -&amp;gt; error
		.collect(Collectors.toList());
}

public &amp;lt;T&amp;gt; void doSomething(String arg){
	T foo = new T(arg); // T型の新しいインスタンスfooを作りたい -&amp;gt; error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ジェネリクス型に対して、hoge instanceof T、T.class、new T()といった操作を行うことはできません。
残念でしたね。&lt;/p&gt;

&lt;h2 id=&#34;なぜしたいのか:c600ddb79433125511402a932eb728b1&#34;&gt;なぜしたいのか&lt;/h2&gt;

&lt;h3 id=&#34;もしかして-設計が間違っている:c600ddb79433125511402a932eb728b1&#34;&gt;もしかして： 設計が間違っている&lt;/h3&gt;

&lt;p&gt;先ほどのgetSubClassListメソッドを見てみましょう。
正しく動くかどうかはさておき、やりたいことは以下の通りです：&lt;br /&gt;
* SomeClassとそのサブクラスを含んだリストlistの要素のうち、SomeClassのサブクラスTのインスタンスだけを要素とする新しいリストを取得したい。&lt;/p&gt;

&lt;p&gt;そもそも、抽象化された集合から具体的なクラスのインスタンスを取り出そうとすること自体がオブジェクト指向やポリモーフィズムの考え方に対する反逆である可能性があります。&lt;/p&gt;

&lt;p&gt;SomeClassのリストであるlistをイテレートして、それぞれの要素のdoSomething()メソッドを呼べば、あとはそれがSomeClassのインスタンスであろうと、もしくはSomeClassを継承した別のクラスのインスタンスであろうと、外部からはただdoSomething()メソッドを呼ぶだけで操作が完結していなければなりません。
それがサブクラス固有のふるまいをするとしても、その実装はそのクラス自身に隠蔽されるべきなのです。&lt;/p&gt;

&lt;p&gt;よって、サブクラスだけを取り出そうとする試み自体がナンセンスなものである可能性が非常に高く、まずそのような試みが必要になる設計そのものを見直す必要があります。&lt;/p&gt;

&lt;p&gt;終わり。&lt;/p&gt;

&lt;h3 id=&#34;そうも言っていられない:c600ddb79433125511402a932eb728b1&#34;&gt;そうも言っていられない&lt;/h3&gt;

&lt;p&gt;実際その通りなのですが、それではこの記事が続きません。&lt;/p&gt;

&lt;p&gt;ここからは、少し具体的なプログラムの設計を例にとって考えてみたいと思います。&lt;br /&gt;
あなたはちょっとしたゲームを作るためのフレームワークを作っています。
その一部分が以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;// 抽象的なゲーム内エンティティクラス
public abstract class Entity {
	private int x;
	private int y;
	public Entity(int x, int y){
		this.setX(x);
		this.setY(y);
	}
	public int getX() { return x; }
	public void setX(int x) { this.x = x; }
	public int getY() { return y; }
	public void setY(int y) { this.y = y; }

	public abstract void update(EntityManager manager);
}

// なんでもかんでも××Managerという名前を付けるのはやめましょう
public class EntityManager {
	private ArrayList&amp;lt;Entity&amp;gt; all_entities;
	public EntityManager(){
		this.all_entities = new ArrayList&amp;lt;Entity&amp;gt;();
	}
	public void add(Entity e){
		this.all_entities.add(e);
	}
	public ArrayList&amp;lt;Entity&amp;gt; getAll() {
		return new ArrayList&amp;lt;Entity&amp;gt;(this.all_entities);
	}
	public void updateAll(){
		this.all_entities.forEach(e-&amp;gt;e.update(this));
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なんのことはありませんね。
ゲーム内に登場するエンティティを表す抽象クラスEntityを作り、それをEntityManagerで管理します(なんでもかんでも××Managerという名前を付けるのはManagerクラスの肥大化を招きかねないため避けるべきであるなどという話もありますが、今回は置いておきます)。
たとえば毎フレームごとにメインループ内で&lt;code&gt;EntityManager#updateAll()&lt;/code&gt;を呼び出すことで、全てのエンティティの更新を行ったりすることが想定されます。
オーソドックスなループ駆動型のゲームプログラム設計です。&lt;br /&gt;
Entityインスタンスを作成するためのFactory Methodパターンを使うべきとか、そういう話もあっちでやってください。&lt;/p&gt;

&lt;p&gt;あとは、このフレームワークの利用者にはEntityクラスを継承したクラスを作らせ、それをもとにゲームを作ってもらえればいいだけです。
以下のクラスを追加してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;// あなたです
public class Player extends Entity{
	private int hp; // プレイヤーはヒットポイントを持ちます
	public Player(int x, int y, int hp){
		super(x, y);
		this.setHp(hp);
	}
	public int getHp() { return hp; }
	public void setHp(int hp) { this.hp = hp; }
	@Override
	public void update(EntityManager manager){
		// プレイヤーが動きます
	}
}

// 敵です
public class Enemy extends Entity {
	private int damage; // 敵がプレイヤーに与えることのできるダメージ値です
	public Enemy(int x, int y, int damage){
		super(x, y);
		this.setDamage(damage);
	}
	public int getDamage() { return damage; }
	public void setDamage(int damage) { this.damage = damage; }
	@Override
	public void update() {
		// 敵が動きます
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プレイヤーと敵を登場させました。
常命の者であるプレイヤーにはヒットポイントが定められており、敵はこれを脅かすダメージ値を持っています。&lt;/p&gt;

&lt;p&gt;注意しておく必要があるのは、これらのクラスはあくまでフレームワークの利用者が作るものだということです。
よって、EntityクラスやEntityManagerクラスからはこのようなEntityサブクラスの存在を知ることはできません。&lt;br /&gt;
知る必要もないというのがオブジェクト指向の考え方だったはずです。
そうですよね？&lt;/p&gt;

&lt;p&gt;ここで、「敵のダメージ値を参照して、プレイヤーのヒットポイントを減らす」処理をしたいという需要が当然生まれます。
実装の方法はいろいろあると思いますが、ひとまずこの処理を、Enemyのメソッドとして書いてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;// 敵です
public class Enemy extends Entity {
	private int damage; // 敵がプレイヤーに与えることのできるダメージ値です
	public Enemy(int x, int y, int damage){
		super(x, y);
		this.setDamage(damage);
	}
	public int getDamage() { return damage; }
	public void setDamage(int damage) { this.damage = damage; }
	@Override
	public void update(EntityManager manager) {
		// 敵が動きます
		// プレイヤーがいたらダメージを与えます
		manager.getAll().forEach((entity)-&amp;gt;{ // 全てのエンティティを調べる
			if(entity instanceof Player){ //  エンティティがプレイヤーなら
				if(this.getX() == entity.getX() &amp;amp;&amp;amp; this.getY() == entity.getY()){ // プレイヤーと敵の座標が同じなら
					this.doDamage((Player) entity); // ダメージを与える
				}
			}
		});
	}
	public void doDamage(Player p){
		p.setHp(p.getHp() - this.getDamage()); // プレイヤーのヒットポイントをダメージ値分だけ減らします
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここであなたは気を利かせます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;manager.getAll().forEach((entity)-&amp;gt;{
	if(entity instanceof Player){
		if(...){
			...
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この部分です、どう見ても冗長ですし、いちいち全エンティティのリストをforEachで回しているので高速化も望めませんし、同様のコードクローンが至る所に発生するのは目に見えています。&lt;/p&gt;

&lt;p&gt;できるならたとえばこう書きたい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;manager.&amp;lt;Player&amp;gt;getAllOfSubClass().forEach((player)-&amp;gt;{
	if(...){
		...
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでPlayerクラスだけが得られるなら、呼び出し側のコード量は減りますし、もしあなたがO(n^2)の処理をO(nlogn)に落とすような作業に慣れているなら、Managerクラスの内側でより高速になるような最適化を行い、その実装も内部に隠蔽することができます。&lt;/p&gt;

&lt;p&gt;また、ゲームのセーブとロードをするときのことも考えてみます。
たとえばデータのセーブを行うときはとりあえずオブジェクトを文字列化するとして、&lt;br /&gt;
&lt;code&gt;public String Entity#serialize()&lt;/code&gt;などといったメソッドを作ってセーブし、ロード時には文字列配列を引数として受け取るようオーバーロードされたコンストラクタを使用してオブジェクトを再生成するといったことが考えられます。
そういうことはFactory Methodあたりに委譲するべきな気もしますし、うまくやらないとフレームワークの利用者側の負担が増える気もしますが、今は置いておきます。&lt;/p&gt;

&lt;p&gt;結局、セーブデータのロード時にこのようなコードを書くことになるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;	public &amp;lt;E extends Entity&amp;gt; E createEntity(List&amp;lt;String&amp;gt; args){ // 可変長引数としてもよい
		return new E(args); // ジェネリクス型はnewできない -&amp;gt; error
	}
	public loadSaveData(SaveData savedata){
		// セーブデータから1行ずつ読み込んでオブジェクトを再生成する
		... {
			entityManager.add(this.createEntity(agrs));
		}
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかしジェネリクス型はnewできないため、コンパイルエラーとなります。&lt;/p&gt;

&lt;h2 id=&#34;解決策:c600ddb79433125511402a932eb728b1&#34;&gt;解決策&lt;/h2&gt;

&lt;p&gt;さて、だいぶん勿体つけたが、解決編に入ろう。&lt;/p&gt;

&lt;p&gt;……というか、例として取り上げた題材が無理やりすぎた気がしてやる気が尽きかけてきました。&lt;/p&gt;

&lt;h3 id=&#34;リフレクションを使用する:c600ddb79433125511402a932eb728b1&#34;&gt;リフレクションを使用する&lt;/h3&gt;

&lt;p&gt;Javaにはリフレクションという機能があり、プログラムの実行中にクラス名やメソッド名を動的に取り扱うことができます。
これのClass&lt;T&gt;型を、ジェネリクスと併用しましょう。
&lt;code&gt;EntityManager#getAllOfSubClass&lt;/code&gt;メソッドを考えてみます。
実装は以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;	@SuppressWarnings(&amp;quot;unchecked&amp;quot;)
	public &amp;lt;E extends Entity&amp;gt; List&amp;lt;E&amp;gt; getAllOfSubClass(Class&amp;lt;E&amp;gt; cls){
		return (List&amp;lt;E&amp;gt;) all_entities.stream()
			.filter(entity -&amp;gt; entity.getClass() == cls)
			.collect(Collectors.toList());
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを呼び出す際は、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;entityManager.getAllOfSubClass(Player.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにして、Class型の&lt;code&gt;クラス名.class&lt;/code&gt;を引数として与えます。
ここで型推論が働くので、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;entityManager.&amp;lt;Player&amp;gt;getAllOfSubClass(Player.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにPlayerクラス名を2度も書く必要はありません。&lt;/p&gt;

&lt;p&gt;また、Playerクラスだけでなく、Playerクラスを継承したクラスも含めて判別したいときは、以下のようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;	@SuppressWarnings(&amp;quot;unchecked&amp;quot;)
	public &amp;lt;E extends Entity&amp;gt; List&amp;lt;E&amp;gt; getAllOfSubClass(Class&amp;lt;E&amp;gt; cls){
		return (List&amp;lt;E&amp;gt;) all_entities.stream()
			.filter(entity -&amp;gt; cls.isAssignableFrom(entity.getClass()))
			.collect(Collectors.toList());
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;createEntity&lt;/code&gt;メソッドも、以下のようにすれば書くことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;	public &amp;lt;E extends Entity&amp;gt; E createEntity(Class&amp;lt;E&amp;gt; cls, List&amp;lt;String&amp;gt; args){
		// cls型のString[]を引数にとるコンストラクタを呼び出す
		return cls.getConstructor(new Class&amp;lt;?&amp;gt;[] { String[].class }).newInstance(args);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やや黒魔術じみてきました。
実際にはE型がString[]を引数にとるコンストラクタを持つということが担保されていないためこれだけでは動かず、例外回避のためにいろいろやる必要があります。&lt;/p&gt;

&lt;p&gt;最初の例に戻ってみましょう。&lt;code&gt;getSubClassList&lt;/code&gt;は、以下のように書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public &amp;lt;T extends SomeClass&amp;gt; List&amp;lt;T&amp;gt; getSubClassList(List&amp;lt;SomeClass&amp;gt; list, Class&amp;lt;T&amp;gt; cls){
	return list
		.stream()
		.filter(value -&amp;gt; value.getClass() == cls)
		.collect(Collectors.toList());
}

// 呼び出し側
getSubClassList(list, SubClassOfSomeClass.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;めでたしめでたし。&lt;/p&gt;

&lt;h3 id=&#34;おまけ:c600ddb79433125511402a932eb728b1&#34;&gt;おまけ&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public &amp;lt;T&amp;gt; int getStaticValue(Class&amp;lt;T&amp;gt; cls) throws Exception{ // なにがthrows Exceptionだやる気あんのか
	return (int) cls.getMethod(&amp;quot;getStaticValue&amp;quot;).invoke(null);
}

// 呼び出し
getStaticValue(SomeClass.class); // SomeClass.getStaticValue() を呼んでいるのと同じになる
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;staticメソッドも呼び出し可能なうえ、「そのクラスに与えられた名前のstaticメソッドが存在しない場合、その親クラスの同名のstaticメソッドを呼び出す」というようなふるまいを疑似的に再現することも可能です。&lt;/p&gt;

&lt;h2 id=&#34;おわり:c600ddb79433125511402a932eb728b1&#34;&gt;おわり&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Class&amp;lt;T&amp;gt; cls&lt;/code&gt;を引数にとり、&lt;code&gt;value.getClass() == cls&lt;/code&gt;で比較を行うのは、実質的にはinstanceofの迂回といえます。&lt;br /&gt;
この程度なら型安全性は一応担保されますが、コンストラクタやメソッドの取得と呼び出しまで始めた場合、throw宣言やcatch節が山のように膨らんだり、メソッドの存在確認や型の確認などに多大なコストを支払う必要がありそうです。
実際に使用するには相当の覚悟を必要とするでしょう。&lt;strong&gt;やめましょう。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;自分でプログラムを組んでいる際にこのような需要が発生することが時々あったので、Javaではリフレクションを使うことで強引に解決できると知って記事を書いてみましたが、自分の中ではむしろ「設計が悪い」の一言に実感が沸くという結果となった気がします。&lt;br /&gt;
今回例に挙げたゲームプログラムの設計はまさしく昔私が作ったものそのものなのですが、記事を書く上で「リフレクションを使いたい理由付け」を明確にしようとすればするほど、その理由が無理やりなものにしかならないのではないかという気持ちに陥りました。
途中まで書いた記事がグダグダになりそうな予感がしてくると結構精神的につらい。&lt;br /&gt;
……うーん。Abstract Factoryパターンとか、もととなるクラスが増えるとそれに合わせてFactoryクラスも増やさないといけないのがあまり好きじゃないので、そのあたりも動的になんとかできないかなどと思っていたのですが、なかなか難しいようです。&lt;/p&gt;

&lt;p&gt;私感としては、instanceof Tの代用としてClass型を使用する程度は許容できますが、普通のプログラムを書くならそれ以上は安易に手を出すべきではないという印象です。&lt;/p&gt;

&lt;p&gt;プログラミングをするときはまともな設計をするようにしましょう。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>自作PCの紹介</title>
      <link>http://tatamo.81.la/blog/2016/12/07/intro-my-homebuilt-pc/</link>
      <pubDate>Wed, 07 Dec 2016 13:53:12 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/12/07/intro-my-homebuilt-pc/</guid>
      <description>
        

&lt;p&gt;この記事は&lt;a href=&#34;http://www.adventar.org/calendars/1881&#34;&gt;Kobe University Advent Calendar 2016&lt;/a&gt;の7日の記事です。
なお私は当該大学の学部2年(2016年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;私は自作PCerなので、この機会に普段使用しているPCのパーツ構成を紹介していきたいと思います。
趣味の中でも結構金がかかっている分野です。&lt;/p&gt;

&lt;h2 id=&#34;外観:14cdc902344e522bd60455484bb9d961&#34;&gt;外観&lt;/h2&gt;

&lt;p&gt;クリックすると別タブで拡大表示します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/12/07/img01.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/12/07/img01.jpg&#34; alt=&#34;自作PC外観(筐体)&#34; height=&#34;600&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/12/07/img02.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/12/07/img02.jpg&#34; alt=&#34;自作PC外観(卓上)&#34; width=&#34;600&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;使用用途-スペック:14cdc902344e522bd60455484bb9d961&#34;&gt;使用用途・スペック&lt;/h2&gt;

&lt;p&gt;ごく普通のプログラミングやネットサーフィンに加え、ゲームを多くプレイするため、少なくとも比較的新しいゲームを高画質設定でプレイ出来るだけのスペックを目指して構築しています。&lt;/p&gt;

&lt;h2 id=&#34;パーツ構成-本体:14cdc902344e522bd60455484bb9d961&#34;&gt;パーツ構成(本体)&lt;/h2&gt;

&lt;p&gt;おおよそ5年前の2011年年末から2012年の年始に組み上げ、そこからパーツを少しずつ更新して現在に至ります。
当時のパーツで残っているのはCPUとM/B、およびメモリとHDD程度。&lt;/p&gt;

&lt;h3 id=&#34;cpu-マザーボード:14cdc902344e522bd60455484bb9d961&#34;&gt;CPU・マザーボード&lt;/h3&gt;

&lt;p&gt;CPU: Phenom II X6 1065T&lt;br /&gt;
M/B: GIGABYTE GA-990FXA-UD5&lt;/p&gt;

&lt;p&gt;AMD機体です。
マザーボードは当時Socket AM3+が登場した頃だったため、採用しているCPUはSocket AM3のPhenom II X2ですが将来的な性能向上を見越してSocket AM3/AM3+の両方に対応しているGA-990FXA-UD5を採用。M/Bはパーツ交換の頻度が最も低くなると思ったので、ここは金を掛けるべきと判断してUD3ではなく一つ上のUD5にしています。&lt;/p&gt;

&lt;p&gt;一方でCPUはコストパフォーマンスを重視し、6コア帯の中でも消費電力の低いモデルであるPhenom II X6 1065Tを採用。2011年当時でもやや古めのモデルではあるものの、ミドルクラス構成としては悪くないものだと思っています。
6コアまたは4コア8スレッド以上の性能を持つCPUを求める場合、Intel製品では2万円台から3万円台以上は見る必要があった中で、1万7000円前後で6コアを得られるPhenom II X6シリーズは魅力的でした。
この性能に対する価格のパフォーマンスの高さが、AMDを選択する理由の一つになっています。&lt;/p&gt;

&lt;p&gt;現在でもSocket AM3+対応で2012年から2014年にかけて展開されたAMD FX8xxx/9xxxシリーズはミドルクラスからハイクラスにかけて良好な性能を誇る上に、同等の性能帯のIntel製CPUに比べて1万円から2万円程度安く入手できます。
一方でそれよりも上の性能を目指す場合はIntelの一強状態となっており、ハイエンドでもAMDが多少は追随できていた2011年当時とは状況が異なっています。
そのため、今からPCを組む場合は何も考えずにAMD製品を選ぶというわけにはいかないように思います。&lt;/p&gt;

&lt;h3 id=&#34;メモリ:14cdc902344e522bd60455484bb9d961&#34;&gt;メモリ&lt;/h3&gt;

&lt;p&gt;PC3-12800の4GBを4枚 計16GB&lt;br /&gt;
→最近1枚壊れたため3枚12GB&lt;/p&gt;

&lt;p&gt;Minecraftあたりのメモリを食いまくるゲームをやっていたり、Chromeでやたらとタブを開いたりしていると、8GBではやや足りない状況があるので16GB。
普通に使っていると8GBで足りるか足りないか程度だと思うので、8GBから多少上であればいいと思います。
今のところ16GBから12GBに減ってもほとんど影響を感じることはありません。&lt;/p&gt;

&lt;h3 id=&#34;グラフィックボード:14cdc902344e522bd60455484bb9d961&#34;&gt;グラフィックボード&lt;/h3&gt;

&lt;p&gt;SAPPHIRE R9 270 2G GDDR5&lt;/p&gt;

&lt;p&gt;やはりAMDの、Radeon R9 270です。特筆することは少ないですが一応は現在でもミドルクラス上位レベルの性能らしいですし、2万円台前半と、悪くない価格帯でもあります。
新しいゲームでも普通に1080pで悪くない画質設定で遊べますし、コストパフォーマンスも良いです。
Batman:Arkham Knightは画質設定を低にしないと遊べませんでしたが… VRAMが2GBというのがそろそろ時代遅れになってきているのかもしれません。
PCを組んだ当初は二束三文で売られていたRadeon HD4xxxか5xxxあたりのグラボを使っていましたが、そのVRAMが512MBぐらいしかなかったことを考えると隔世の感があります。&lt;/p&gt;

&lt;p&gt;当然ながらVRをプレイしようと考えるのは無理があります。&lt;/p&gt;

&lt;h3 id=&#34;電源:14cdc902344e522bd60455484bb9d961&#34;&gt;電源&lt;/h3&gt;

&lt;p&gt;どのモデルだったか忘れました。
500Wのものですが、一度壊れたので換装しています。&lt;/p&gt;

&lt;h3 id=&#34;ストレージ:14cdc902344e522bd60455484bb9d961&#34;&gt;ストレージ&lt;/h3&gt;

&lt;p&gt;SSD: CFD CSSD-S6T512NHG6Q (512GB)&lt;br /&gt;
HDD1: HGST HDS721050CLA362 (500GB)&lt;br /&gt;
HDD2: TOSHIBA DT01ACA300 (3TB)&lt;/p&gt;

&lt;p&gt;最初は500GBのHDD1個のみで、2015年春に512GBのSSDを、そして今年に入って3TBのHDDを増設しました。
現在はSSD上にWindows10をインストールして使用しています。
SSDは登場当初に比べて随分安くなった印象です。
5年ほどひたすら値下がりを待ってようやく私が512GBのSSDを購入した時点で3万円程度でしたが、今は512GBを2万円台前半で買えるようです。&lt;/p&gt;

&lt;p&gt;SSD化までは500GBのHDD1本だけで運用していましたが、通電時間2万時間越えのこのHDDは今でも不良セクタが1つもなくとても健康な状態のようです。&lt;/p&gt;

&lt;h3 id=&#34;光学ドライブ:14cdc902344e522bd60455484bb9d961&#34;&gt;光学ドライブ&lt;/h3&gt;

&lt;p&gt;Pioneer BDR-207JBK&lt;/p&gt;

&lt;p&gt;BD対応ドライブです。光学ドライブもやはり交換頻度は少ないだろうと踏み、やや性能の高いものを採用しています。
1万円台中盤程度で、十数万円をどうにか絞り出してPCを組んだ当初これを買っている余裕はなかったため、OSのインストール等は手元にあったUSB外付けDVDドライブでなんとかしのぎ、資金力の回復を待った上で後付けで購入しました。
耐久性も良好ですし性能も高く良い感じですが、PCケースと干渉してディスクトレイがうまく開かないことがあるのが玉に瑕。&lt;/p&gt;

&lt;h3 id=&#34;pcケース:14cdc902344e522bd60455484bb9d961&#34;&gt;PCケース&lt;/h3&gt;

&lt;p&gt;Antec SOLO II&lt;/p&gt;

&lt;p&gt;音が静かで、見た目が好みで、作りが良いです。
最初は似た価格帯のケースが半額で売っていたので買って使っていましたが、サイドパネルがペラペラだったり購入後すぐ前面の開閉部分が壊れたりあまり作りが良くなかったり裏側配線ができなかったりして投げ捨てたので、今使っているこのケースは非常に満足しています。
唯一前面パネルのUSBポートの作りがやや甘かったのか、購入から1年しないぐらいでUSB2.0のポートが1つ潰れました。&lt;/p&gt;

&lt;h2 id=&#34;周辺機器構成:14cdc902344e522bd60455484bb9d961&#34;&gt;周辺機器構成&lt;/h2&gt;

&lt;p&gt;画像再掲&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/12/07/img02.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/12/07/img02.jpg&#34; alt=&#34;自作PC外観(卓上)&#34; width=&#34;600&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;モニタ:14cdc902344e522bd60455484bb9d961&#34;&gt;モニタ&lt;/h3&gt;

&lt;p&gt;EIZO FORIS FS2333 2枚&lt;/p&gt;

&lt;p&gt;23.5インチ2枚のデュアルディスプレイ編成です。
最近FS2333の同ディスプレイ2枚体制の構築を達成しました。
このディスプレイは使い勝手もよく文句なしです。&lt;/p&gt;

&lt;h3 id=&#34;スピーカー:14cdc902344e522bd60455484bb9d961&#34;&gt;スピーカー&lt;/h3&gt;

&lt;p&gt;Logicool Speakers Z130&lt;/p&gt;

&lt;p&gt;とくにこだわりもなくずっと使ってますが、モニタ内臓のスピーカーよりはよっぽど良いですし値段も安かったため満足しています。
音楽は作業中にアニソンを流す程度であまり聴きません。&lt;/p&gt;

&lt;h3 id=&#34;トラックボール:14cdc902344e522bd60455484bb9d961&#34;&gt;トラックボール&lt;/h3&gt;

&lt;p&gt;サンワサプライ MA-TB38&lt;br /&gt;
エレコム M-DT1URBK&lt;/p&gt;

&lt;p&gt;トラックボーラーです。&lt;br /&gt;
サンワサプライのMA-TB38は私の愛機で、5年ぐらい使い続けた結果ホイールが壊れたため現在は2機目です。
標準の金属支持球をセラミック球に交換した上でゴムシートによる安定化を図る改造も施しており、何度も試行錯誤した結果改造ノウハウもたまっています。&lt;br /&gt;
大玉トラックボールとしては珍しいマウスホイール搭載機であり、多くのトラックボールが抱える「ホイールクリックボタンがない」という重大な欠点を解消しつつも非常に良好な操作性を誇り、また個体差や欠陥構造を有しているものの簡単な改造でそれを補えるため、現状これ以外の選択肢はほとんど考えられません。
現時点で既に製造終了モデルとなっているのが残念なところです。&lt;/p&gt;

&lt;p&gt;エレコムのトラックボールは1代目のMA-TB38が故障した頃にちょうど新しく出たモデルだったので、ちょっと気になってつなぎ兼予備として購入。有線モデル特有の欠点として、耳を近づけるとわずかにコイル鳴きが聞こえるのが難点。
使い勝手は悪くないですが、結局2代目のMA-TB38を確保してからはほとんど使っていません。&lt;/p&gt;

&lt;h3 id=&#34;キーボード:14cdc902344e522bd60455484bb9d961&#34;&gt;キーボード&lt;/h3&gt;

&lt;p&gt;Skydigital NKEY-P&lt;/p&gt;

&lt;p&gt;買い換えよう買い換えようと思いつつ、なかなか良いキーボードが見つからないため結局5年ぐらい使い続けています。
安価かつゲーミング向きという観点からこのキーボードを選びましたが、5000円程度で全キー同時押し対応、反応速度が向上するゲームモード搭載、着脱式のパームレスト付きと、値段に対してやたらと尖った性能をしておりコストパフォーマンスは非常に高かったのでは無いかと思っています。&lt;/p&gt;

&lt;p&gt;流石にスペースキーの調子が悪かったり一部キーが押しづらくなったりしてきているので、いい加減に買い換えを検討中です。&lt;/p&gt;

&lt;p&gt;現在の買い換え候補は、2017年に発売が予定されている&lt;a href=&#34;http://www.realforce.co.jp/&#34;&gt;REALFORCE RGB&lt;/a&gt;の日本語配列版です。
REALFORCEシリーズのゲーミング向けモデルがついに発売されるということで、非常に注目しています。&lt;/p&gt;

&lt;h3 id=&#34;ゲームパッド:14cdc902344e522bd60455484bb9d961&#34;&gt;ゲームパッド&lt;/h3&gt;

&lt;p&gt;Microsoft Xbox 360 Controller for Windows&lt;/p&gt;

&lt;p&gt;もはやデファクトスタンダードといってもよさそうな定番コントローラーで、値段の安さも驚くべきことです。
ただドライバ周りに少し癖があり、公式ドライバと非公式ドライバの両方を使い分けたほうがいい場合があったりする点には注意が必要です。&lt;/p&gt;

&lt;h2 id=&#34;今後:14cdc902344e522bd60455484bb9d961&#34;&gt;今後&lt;/h2&gt;

&lt;p&gt;一度自作PCを組むと、いくらでも機能を向上させたくなるために際限なく金が吸われます。&lt;/p&gt;

&lt;p&gt;今最も買い換えたいのはキーボードで、Razerの&lt;a href=&#34;http://www.razerzone.com/jp-jp/gaming-keyboards-keypads/razer-blackwidow-chroma&#34;&gt;BlackWidow Chroma&lt;/a&gt;を購入候補として検討していましたが、Razerの緑軸はやや打鍵音が強すぎますし、一方でオレンジ軸は自分の好みとは遠い感じでした。
そこで前述したように&lt;a href=&#34;http://www.realforce.co.jp/&#34;&gt;REALFORCE RGB&lt;/a&gt;が近々発売されるということを知ったため、今のところはこれの発売と評価を待っている状況です。
あまりに期待値を下回った場合は&lt;a href=&#34;http://www.razerzone.com/jp-jp/gaming-keyboards-keypads/razer-blackwidow-chroma&#34;&gt;BlackWidow Chroma&lt;/a&gt;を買うことになるかも。
そんなにキーボードを光らせたいのか。&lt;/p&gt;

&lt;p&gt;あとはグラフィックボードのVRAMまわりに若干の力不足を感じていますが、そんなに最新のゲームをやりまくるわけでもないですし(Steamでなかなか割引されないので)、最新かつ高いグラフィックを要求するゲームのプレイ頻度がそう高くないので今のところ現状で問題はあまりない気もしています。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>aragoのHIROic ChallengeでのFreecivプレイレポ 前編</title>
      <link>http://tatamo.81.la/blog/2016/09/29/freeciv-arago-challenge-01/</link>
      <pubDate>Thu, 29 Sep 2016 23:00:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/09/29/freeciv-arago-challenge-01/</guid>
      <description>
        

&lt;p&gt;&lt;a href=&#34;https://www.arago.co/hiro-freeciv&#34;&gt;aragoのFreeciv Strategy Challenge&lt;/a&gt;の企画である&lt;a href=&#34;http://hiroic.arago.co/&#34;&gt;HIRO-ic CHALLENGE&lt;/a&gt;に参加しています。
これは「人間の思考をコンピュータ向けに翻訳する」といわれるHIROというAIのトレーニングを行うための企画です。
私はゲームをプレイする参加者として、aragoのメンバーから担当者を一人割り当てられ、その人に観戦してもらいながら通常のAIとの対戦を行います。&lt;/p&gt;

&lt;p&gt;決められた2回のゲームのうち1回を既に終えたので、プレイレポ的なものを書きます。
とはいえ、ゲーム自体は単なるAI戦なのであまり面白みはないかもしれません。&lt;/p&gt;

&lt;p&gt;ゲーム外に付随する要素として、ゲーム中は担当者とSkypeで常に通話(webカメラなどは持ってないのでAndroidのアプリを使用)、さらにWebexのミーティング機能を使用してスクリーンを担当者と共有しながらプレイします。
また、プレイヤーの行動に対して担当者がいろいろと聞いてくるので、行動の理由や目的などについて説明しながらプレイを続けます。
始まってからしばらくすると、特に求められるでもなく自分から現在行っている行動とその意図を解説し、さらに質問をされた場合に適宜答える、といった形式でゲームが進んでいくように。3時間喋りっぱなし。まるで実況者とかそういう人みたい。
なお、担当者とのやりとりはメール、Skypeでの通話ともにすべて英語で行っています。&lt;/p&gt;

&lt;p&gt;「人にもよるが、一回のプレイには8時間から12時間かかる」という旨を伝えられましたが、私は一度目のゲームは3時間のセッション2回の計6時間で終わりました。&lt;/p&gt;

&lt;p&gt;以下プレイレポ。&lt;/p&gt;

&lt;h2 id=&#34;ゲーム概要:991cc667eabf7ea7d3c5eb1f19c43440&#34;&gt;ゲーム概要&lt;/h2&gt;

&lt;p&gt;人間1、AI3の計4プレイヤーでの対戦。AIの難易度はnormal。
シナリオマップの「地球(古典的/小型)」を使用。
それ以外は基本的にすべてデフォルト設定。&lt;/p&gt;

&lt;h3 id=&#34;スクリーンショット:991cc667eabf7ea7d3c5eb1f19c43440&#34;&gt;スクリーンショット&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/09/29/bd3929d405c6b3f99b07fcbf734d8468.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/09/29/bd3929d405c6b3f99b07fcbf734d8468.png&#34; alt=&#34;スコア&#34; width=&#34;700&#34;&gt;&lt;/a&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/09/29/b959cf03d4fe11810910486956610ac7.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/09/29/b959cf03d4fe11810910486956610ac7.jpg&#34; alt=&#34;本土&#34; width=&#34;700&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;序盤:991cc667eabf7ea7d3c5eb1f19c43440&#34;&gt;序盤&lt;/h2&gt;

&lt;p&gt;自分に割り当てられた民族はスー族。ほかのプレイヤーはケルト、シュメール、それからエチオピアあたりの民族だったので、自分だけ北米大陸、ほかは全員ユーラシアという恵まれた立地。
五大湖の西岸付近でスタートしたので、湖岸に首都を建設し、さらに東に進んでカナダ東岸付近に第二都市を建設。
研究は陶器→アルファベット→筆記→葬儀→地図→法律→君主とし、神秘主義・航海・兵法を適当なタイミングでとりつつ交易を取得する方針。&lt;/p&gt;

&lt;p&gt;最序盤は基本的に全都市で開拓者を生産し続け、労働者はひたすら道路建設。また陶器の完了後は開拓者だけでなく労働者も作成し、北米大陸全土を繋ぐ道路網の建設を進める。
小屋がないので最序盤に科学が急にジャンプしたりすることもないため、ゆったりとした立ち上がりとなり、道路を引き切るだけの時間は十分に得られた。
道路を引き終えた後は、大量の労働者を使って大陸各地で地形改善を行わせる。
ちょうど10都市作れたら開拓者の生産をストップさせ、このころには地図を取得していたのでトライリームを生産して探検を進める。&lt;/p&gt;

&lt;p&gt;北極海に沿って東に進み、他大陸の文明であるケルトと接触。またしばらく後になってケルトよりも大陸の東に位置するシュメールと接触する。
ケルトの南のそう遠くない位置にエチオピアも存在したが、中盤以降になるまで接触は持たず。
この新しい大陸のことを&amp;rdquo;New World&amp;rdquo;、つまり新大陸と呼ぶことにした。
新しく接触した文明とは基本的に停戦を維持。のちにケルト・シュメールから和平を求められたので合意。&lt;/p&gt;

&lt;h2 id=&#34;中盤:991cc667eabf7ea7d3c5eb1f19c43440&#34;&gt;中盤&lt;/h2&gt;

&lt;p&gt;とりあえず税多めに振って全都市でキャラバン生産。それとトライリーム。
北極海ルートでキャラバンを全力輸送し、ケルトやシュメールと交易路を引く。
何を考えたかこの時期にケルトと和平を結んでしまったので、ケルト都市に接岸しづらくなり交易が少しばかり面倒に。
交易路を引き切ったあたりで工学→火薬→民主主義の研究が完了したので、得られた経済力と交易ボーナスを投入して港→市場を全都市に揃えつつ、民主化。&lt;/p&gt;

&lt;p&gt;民主化が完了した段階でプレイ開始から3時間が経過したため、ここで一日目は終了。およそターン90からターン100。&lt;/p&gt;

&lt;p&gt;二日目、民主化が終わった直後なのでそのまま祝典に突入。
研究を止めて上水道や必要な建造物なども買い揃え、全都市サイズ12に(実際は1都市だけサイズ11で止まった)。
のんびりと民主化して祝典まで済ませたにもかかわらず哲学はまだ発見されておらず、哲学ブーストで大学を取得。
ついでに経済も予め取っておき、また研究を止めて証券取引所と大学を買い揃える。&lt;/p&gt;

&lt;p&gt;そして研究を再開、爆薬および鉄道を取得、鉄道網を設置する。
その後磁気学を取得、鉄道網が完成しきらないうちに3本目の交易路を引き始め、それを引き切らないうちに工業化→株式会社の研究が完了して4本目の交易路もほぼ同時に引くことに。
また金も余り気味だったため適当にトラックを集めてニュートンの学士院を建てたり、トラックを作るのも面倒になってリチャードの十字軍遠征をそのまま購入したりした。
さらに株式会社取得後に下水道を研究、上陸戦→小型化→無線通信の研究を進めながら同時に2回目の祝典も行う。
そういえばダーウィン取るの忘れてた。&lt;/p&gt;

&lt;h2 id=&#34;終盤:991cc667eabf7ea7d3c5eb1f19c43440&#34;&gt;終盤&lt;/h2&gt;

&lt;p&gt;気が付けばロケット工学の研究まで終わっていたので、首都にマゼランの探検航海と自由の女神を建造。
空母2隻+AWACS1機+輸送艦3隻+イージス巡洋艦1隻+潜水艦数隻を用意する。
そしてケルトとの和平条約を破棄、手始めにケルトによってアメリカ大陸付近に建設されていた都市を占領。そしてついに、アメリカの先住民族であるスー族は戦闘機主体の空軍力によって「新大陸」への侵略を開始する。
とにかく大陸が大きいので占領作業に時間がかかるものの、同時期に実用化したヘリコプターや機甲部隊も使用して攻撃。
都市数が増えすぎたのでJSバッハの大聖堂なども建ててみたものの、それでも暴動が起きないようにするには60%程度の贅沢が必要だったのでこれは諦め、自由の女神パワーで体制転覆から即座に民主主義復活を繰り返す。&lt;/p&gt;

&lt;p&gt;大陸東部まで侵攻し、内戦によって新たに誕生したヴァイキング、バビロニアとともにケルトおよびシュメール滅亡。
そしてエチオピアにも攻撃を開始。
戦闘機の損耗が激しく30機程度しか残っていなかったうえ、エチオピア都市にマスケット兵が山ほど配置されていたためにやや苦戦する。しかし前線都市で巡航ミサイルを買って毎ターン撃ちまくっているうちに大陸全土の制圧を完了。
マダガスカルとかスリランカあたりに存在したエチオピア都市を空挺降下で占領し、エチオピア滅亡。&lt;/p&gt;

&lt;h2 id=&#34;ゲーム終了:991cc667eabf7ea7d3c5eb1f19c43440&#34;&gt;ゲーム終了&lt;/h2&gt;

&lt;p&gt;170T程度でスー族を除く全文明が滅亡したため、スー族の勝利でゲーム終了。
3時間のセッションのうちちょうど2時間50分を過ぎたあたりで、区切りよく2回のセッションで1ゲームが終わる形となった。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>FreecivCalc2を公開しました</title>
      <link>http://tatamo.81.la/blog/2016/05/26/freecivcalc2-released/</link>
      <pubDate>Thu, 26 May 2016 15:47:37 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/05/26/freecivcalc2-released/</guid>
      <description>
        

&lt;p&gt;Freecivのユニット同士の戦闘勝率を手軽に行えるソフトであるFreecivCalcの新バージョン、FreecivCalc2を公開しました。&lt;/p&gt;

&lt;p&gt;FreecivCalc2: &lt;a href=&#34;http://tatamo.81.la/freecivcalc2/&#34;&gt;http://tatamo.81.la/freecivcalc2/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以前から公開していた&lt;a href=&#34;http://m06t625.81.la/files/FreecivCalc.html&#34;&gt;FreecivCalc&lt;/a&gt;はSilverlight上で動作するソフトのため、現状では動作するブラウザがほとんどなくなってきています。&lt;/p&gt;

&lt;p&gt;そこでHTML5+JavaScript/TypeScriptに移植し、機能やインターフェースを大幅に見直したFreecivCalc2を開発しました。&lt;/p&gt;

&lt;p&gt;Chrome, Opera, Firefox, Edgeでの動作を確認しています。&lt;/p&gt;

&lt;h2 id=&#34;freecivcalc2の新機能:0fe09111c483b88d0d4fda3fcdc49d63&#34;&gt;FreecivCalc2の新機能&lt;/h2&gt;

&lt;p&gt;FreecivCalc2の画面からユニットを選択し、各種補正情報を入力することで戦闘勝率を表示できます。また詳細結果タブを開くことで、戦闘後のユニットHPの期待値を表示できるほか、タブを保持しておくことで復数の戦闘の予測結果を見比べることなどができます。&lt;/p&gt;

&lt;p&gt;従来バージョンでは、地形による防御ボーナスの適用の可否や特定のユニット同士の戦闘にかかる特殊補正などの補正の情報を手動で入力する必要がありました。
FreecivCalc2ではこれらの特殊補正は自動で適用されるため、Freecivの複雑な戦闘補正を十分に把握していない場合でも正確に戦闘勝率の予測が可能です。
ユニットにかけられている補正の一覧は、詳細結果タブ内で確認することができます。&lt;/p&gt;

&lt;h2 id=&#34;複数の言語-多様なルールセットに対応可能な拡張性:0fe09111c483b88d0d4fda3fcdc49d63&#34;&gt;複数の言語、多様なルールセットに対応可能な拡張性&lt;/h2&gt;

&lt;p&gt;戦闘補正の自動適用を実現するために、ユニットの情報や補正の条件など、ルールセットに関連するすべての情報を外部データ化しました。
これによってclassicルールセットだけでなく、多様なルールセットに対応することが可能です。
同時に、FreecivCalc2のインターフェース部分もテンプレートを用いて外部ファイルからコンテンツ内容を流し込んでいるため、容易に多言語化が可能になっています。&lt;/p&gt;

&lt;p&gt;現状では、classicルールセットを日本語および英語の2か国語で対応しています。&lt;/p&gt;

&lt;h2 id=&#34;開発について:0fe09111c483b88d0d4fda3fcdc49d63&#34;&gt;開発について&lt;/h2&gt;

&lt;p&gt;FreecivCalc2は三条項BSDライセンス下で公開されています。&lt;/p&gt;

&lt;p&gt;ローカル環境でのビルド、他のルールセットや言語に対応させるためのデータセットの文法などについては&lt;a href=&#34;https://github.com/Tatamo/freecivcalc2&#34;&gt;GitHubリポジトリ&lt;/a&gt;上で記述しているため、そちらを参照してください。&lt;/p&gt;

&lt;p&gt;FreecivCalc2は大半をTypeScriptで、jQuery UIのウィジェット定義など一部を生のJavaScriptで書いています。&lt;/p&gt;

&lt;p&gt;また使用したライブラリはjQuery, jQuery UI, amChartsです。
当初jQueryを使う予定はなかったのですが、ユニット選択用のUIとしてコンボボックスを実現するためのライブラリを探していたところjQuery UIが最も用途に適っていたため採用し、その流れでjQueryも使用することになりました。
amChartsは簡単にグラフを表示できるライブラリとして使いやすそうだったため使用しました。&lt;/p&gt;

&lt;p&gt;その他、外部JSONファイルからテンプレートを通してHTMLファイルを生成するためのテンプレートエンジンとしてEJSを使用しました。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Freecivオンラインプレイ解説 最初の都市を建設するまで</title>
      <link>http://tatamo.81.la/blog/2016/02/20/freeciv-build-first-cities/</link>
      <pubDate>Sat, 20 Feb 2016 02:39:08 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/02/20/freeciv-build-first-cities/</guid>
      <description>
        

&lt;p&gt;日本のオンライン環境で主流となっている一人一島の島嶼戦マップにおける、ゲーム開始直後のユニットの動かし方およびマップの探索についての解説です。
ゲームが開始してから、最初の2都市を建設するまでの流れを説明します。&lt;/p&gt;

&lt;h2 id=&#34;事前情報:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;事前情報&lt;/h2&gt;

&lt;p&gt;今回の本土となる島のスクリーンショットです。本来はゲーム開始時に知ることのできない情報ですが、題材とする島の広さを把握していただくために掲載します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img01.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img01.png&#34; alt=&#34;初期配置(観察状態)&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ゲーム設定は、マップの生成方法：島ベース、開始地点の決定方法：大陸のサイズに合わせる、サイズ1、プレイヤー数7、丘/山の量0、小屋(先住民の集落)なし、(科学タブ)科学技術係数200%。
最小限の設定変更で、かつ日本のオンライン対戦で主流の設定と近いマップが生成されるようにしています。&lt;/p&gt;

&lt;h2 id=&#34;0ターン目:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;0ターン目&lt;/h2&gt;

&lt;h3 id=&#34;生まれ落ちる:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;生まれ落ちる&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img02.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img02.png&#34; alt=&#34;初期配置&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;さて、あなたの文明がこの地に生まれ落ちたばかりの状態です。
一つ上の章でこの島の全景の画像が掲載されているようですが、忘れてください。
ゲーム開始直後、あなたはせいぜい周囲2タイル程度の情報しか知りません。&lt;/p&gt;

&lt;p&gt;今回の解説は、この状態から数ターンの間にどのようにユニットを動かし、マップを探索し、都市を建設するかを主眼に置いています。&lt;/p&gt;

&lt;h3 id=&#34;ユニットを動かす前に:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;ユニットを動かす前に&lt;/h3&gt;

&lt;p&gt;さて、あなたはすぐにでも手持ちの探検家ユニットを動かして、この暗い世界を少しでも明るく照らしたいと思ったかもしれません。
しかし、ちょっと待ってください。
どの方向にユニットを動かすのが最善なのでしょうか？&lt;/p&gt;

&lt;p&gt;探検家は1ターンに3タイル移動することができるので、最初のマップ探索の主力は探検家になります。
この貴重な探索ユニットを明後日の方角に向かわせてしまい、また元の場所に戻ってくるのに2ターンかかったとしたらどうでしょう？
より効率的に探索を行っていたならば、6タイルも向こう側の地形の情報を得られたかもしれません。
まずは、探検家をどの方角に向かわせるのが最善かを考えましょう。&lt;/p&gt;

&lt;p&gt;今得られている狭い視界だけで、今回の島がどのような形なのかを予想してみるのは良い方法です。
(もっとも、予想を立てるにしても、自分の島がおおよそどのくらいの広さなのかはおおよそ把握できておいたほうがいいと思われます。
しかしそれは、ゲームやゲームの設定に少し慣れていないと難しいことだと思います。
なので最初はだいたいでいいのです。)&lt;/p&gt;

&lt;p&gt;この島はどんな島なのでしょうか？わくわくしますね。&lt;/p&gt;

&lt;p&gt;おそらく、南東の方角に陸地がずっと続いている、というわけではないでしょう。
どう考えても南東には海が広がっています。こんな方向に探検家を向かわせる必要はありません。&lt;/p&gt;

&lt;p&gt;では北西は？
こちらはかなり向こうまで陸地が続いている可能性があります。
南東の海岸線がすでに見えているのですから、北西側の海岸までは距離が開いていると考えるのは妥当でしょう。
(もっとも、かなり細長い島が生成されることもそう珍しくはありません。だいたいの予想でいいのです。)&lt;/p&gt;

&lt;p&gt;北東、および南西方面はちょっと悩みどころです。
どちらの方向にも海岸線は見えていませんから、どれだけ陸地が続いているかはわかりません。
もちろん、陸地はいま見えている部分だけで、それより先は海、ということもあり得ます。&lt;/p&gt;

&lt;p&gt;どうやら、南東以外の方向に探検家を進ませるのがよさそうです。
といっても、北東、北西、南西と考えるだけでも、3つも選択肢が残っています。
ほかの情報も考慮して、どちらの方向へ探索を行えばいいのか考えていきましょう。
いったい、いつになればあなたのユニットは栄光ある一歩を踏み出すことができるのでしょう？&lt;/p&gt;

&lt;p&gt;まず、喫緊の課題として、あなたは帝国の最初の都市、つまり首都を建設する場所を決めなければいけません。
また初期ユニットの開拓者は2つありますから、2つ目の都市を建設する場所も考えてあげるべきでしょう。
文明に都市が1つもない状態を長く続けるべきではありません。
そのため、既に今見えているタイルのうちのいずれかに首都を建設するべきである可能性は高いと言えます。&lt;/p&gt;

&lt;p&gt;もう一度、あなたの狭い視界が何を捉えているかを確認しましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img02.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img02.png&#34; alt=&#34;初期配置&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;西側にキジがありますね？
キジは専制政治下でも2/2/0と、要求を満たせるだけの食料、そして森の高い生産を両立できるとても優秀なタイルです。
もっとも、キジの上に直接都市を立てるのはあまり得策ではなかったり、また丘都市や森都市と併用すると産出される交易が0になってしまったりもしますが。
しかしそれはこのキジ(変換ミスではありません)の趣旨からは外れるため、詳しい解説は行いません。&lt;/p&gt;

&lt;p&gt;ともかく、キジは首都の都市圏内に含めるタイルとしては非常に良い特産物です。
このキジを首都で利用できるようにすることを考えましょう。
では、探検家をこのキジの近くに移動させればいいでしょうか？
とはいっても、南西方向に向かえばいいでしょうか、それとも北西方向に向かえばいいでしょうか。
そろそろ考えるのが面倒になってきたでしょうし、とりあえず探検家をキジの真上に移動させてみるのなんてどうでしょう？&lt;/p&gt;

&lt;p&gt;ここで、特に島嶼戦マップにおいては、都市をより海岸に寄せて建設するべきであるというセオリーを思い出しましょう。
これまた本記事の趣旨ではないので詳しい解説は見送りますが、より海に寄せて都市を建設することで、将来的に多くの海洋タイルを利用できる、国家の総面積が広がる、遠くまで見渡せるなどのメリットがあります。
なので、意気揚々と探検家を向かわせた先が内陸部であったなら、島嶼戦マップではあなたはちょっとがっかりするべきです。&lt;/p&gt;

&lt;p&gt;となると、海岸線に沿って探検家を移動させれば、移動した先も海岸に違いありません。
これはだいたい正しいのですが、完全に海岸線沿いにユニットを移動させた場合、ユニットの視界には退屈で変わり映えしない海がずっと映りつづけることに注意してください。
海岸線を把握することと同等に、陸地に何があるかを知ることも重要です。
あまりにべったりと海に沿って探検家を移動させることは、やはり得策とは言えません。
また、海岸線沿いに探検家を移動させていった場合、ユニットが半島の袋小路に入ってしまうこともあります。
そうなると同じタイルを往復するぶんの移動が無駄になってしまうので、その点にも気を付けたほうが良いでしょう。&lt;/p&gt;

&lt;p&gt;また、先ほど島の形を大まかに予想した際、北西方向にはしばらく陸地が続いている可能性が高い、と考えました。
仮に3タイル進んでも対岸が見えなかったとして、そんな内陸部に首都を建設するのはややセオリー外です。&lt;/p&gt;

&lt;p&gt;というわけで、あなたのユニットの記念すべき一歩は、探検家を西に移動させることで決定です。&lt;/p&gt;

&lt;h3 id=&#34;記念すべき一歩:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;記念すべき一歩&lt;/h3&gt;

&lt;p&gt;では早速……&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img03.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img03.png&#34; alt=&#34;最初の移動?&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ちょっと待ってください！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;どれだけ引き延ばせば気が済むのか、と考えているかもしれませんが、ちょっと待ちましょう。
特に最初のターンは、一気に探検家を複数タイル移動させるべきではありません。
1タイル移動するだけでも視界は広がるので、それを考慮すれば次に移動する最善のタイルが変わってくるかもしれません。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img04.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img04.png&#34; alt=&#34;(今度こそ)最初の移動&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;まあ、大して驚愕の事実などはありませんでしたが。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img05.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img05.png&#34; alt=&#34;2歩目は何処へ?&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;マーカーをつけた2つのタイルのうち、次にどちらへ向かうかは難しい問題です。
つまり深く考える必要はないということです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img06.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img06.png&#34; alt=&#34;2歩目&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;南へ移動したところ、そこが半島になっていることがわかりました。
&lt;strong&gt;当然、&lt;/strong&gt;3歩目の移動は北西の草原にでも向かわせましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img07.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img07.png&#34; alt=&#34;3歩目&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;これで南西方向の視界は晴れました。
そしてあなたの探検家は疲れ果てています。
残りのユニットをどう動かすかを考える時間です。&lt;/p&gt;

&lt;h3 id=&#34;首都-予定地-に開拓者を向かわせる:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;首都(予定地)に開拓者を向かわせる&lt;/h3&gt;

&lt;p&gt;首都は南西部に建設すると大まかに決まっています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img08.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img08.png&#34; alt=&#34;首都建設候補地&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;クジラを都市圏内に入れることは良いことですし、普通は都市は草原か平野に建てるのが妥当です。
この2か所のうちどちらかに首都を建てることになるでしょう。
まあどちらにせよ開拓者を動かす場所は変わりません。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img09.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img09.png&#34; alt=&#34;首都のための開拓者移動&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ここで、2つの候補地のうちどちらに首都を建てるかを決めてしまう必要は&lt;strong&gt;ありません&lt;/strong&gt;。
次のターンになれば探検家を再度動かすことができ、それによってより多くの情報が得られるからです。
それらの情報も踏まえたうえで、どこに首都を建てるのかを判断します。&lt;/p&gt;

&lt;h3 id=&#34;2つ目の都市をどこに建てるかを考える:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;2つ目の都市をどこに建てるかを考える&lt;/h3&gt;

&lt;p&gt;さて、首都を建てる位置も(だいたいは)決まりました。
しかし、2つ目の都市をどこに建てるかはまだ考えていません。
考えましょう。&lt;/p&gt;

&lt;p&gt;都市と都市の間隔は、大いにプレイヤーの好みによるものの、桂馬飛びの場所に2つの都市が位置していても特に問題はないと一般に言われています。
問題ないというのは、2つの都市が遠すぎないという意味ではなく、近すぎないという意味です。
ここでは、記事を書いた人の好みのため、桂馬飛びよりも1タイルほど遠い位置に都市を配置していくことを考えたいと思います。&lt;/p&gt;

&lt;p&gt;もちろん、首都に向かった最初の開拓者と全く同じルートを2つ目の開拓者にも向かわせるのは得策とは言えません。
既に首都を建てる位置は(おおまかに)決まっているので、別の土地を探さなければいけませんし、そこはまだ闇の中です。
初期位置から東側に2つ目の都市を建てることを考えましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img10.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img10.png&#34; alt=&#34;第二都市建設候補地&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;考えるのもそろそろ面倒になってきています。
ちょうど初期地点の南東にいい感じの海岸があるので、ここに都市を建てるのがいいのではないでしょうか。&lt;/p&gt;

&lt;p&gt;おっと。この2つの候補地のうち、南側の草原に都市を建ててしまう場合、もし首都を南の平地に配置したならば桂馬飛びの位置になってしまいます。
実際、それは何の問題もないのですが、ここでは記事を書いた人がそれを嫌っているので、やめておくことにしましょう。
なんとも我が儘な理由ではありますが、都市の配置方法はプレイヤーによって非常に個性が出ると言われているもので、その個性というのも、だいたいこういった理由から生じているのです。&lt;/p&gt;

&lt;p&gt;では、平野のほうに2つ目の開拓者を向かわせることで良さそうです。
早速開拓者を1タイル東に向かわせて……&lt;/p&gt;

&lt;p&gt;本当にそれでいいのでしょうか？&lt;/p&gt;

&lt;p&gt;よく考えてみてください。
今検討しているのは、&lt;strong&gt;2番目の&lt;/strong&gt;都市の建設地点です。
このゲームでは最初に建設された都市が首都になりますから、2番目の都市は2番目に建設される必要があります。
(実際、これは非常に大きな問題です。
専制政治下では首都にのみ75%もの生産ボーナスが与えられる他、まあいろいろな違いが生じます。)&lt;/p&gt;

&lt;p&gt;ところで首都を建設するための開拓者は現在、まだその途上にいます。
次のターンに予定地に到達し、さらにその次のターンになってやっと首都が実際に建設されるでしょう。
ここで第二都市用の開拓者をすぐに予定地に向かわせても、1ターン余計に待っている時間が生じてしまうのです。&lt;/p&gt;

&lt;p&gt;たとえば、まだ見えていない北東部に、第二都市を建設するのにもっと適した場所があるかもしれません。
もちろん、そんなことを言っていて都市の建設が遅れては本末転倒です。
しかし現時点で1ターンの時間の余裕があるのですから、これは活用するべきです。&lt;/p&gt;

&lt;p&gt;非常に幸いなことに、初期地点から北東に向かって川が伸びています。
探検家以外の初期ユニットは通常、どれも1ターンに1タイルしか移動することができません。
しかし川に沿った移動は、移動力を1/3しか消費しません。
つまり川の上を移動する場合は、通常のユニットでも探検家のような移動力を得るというわけです。
この川を利用して、北東方向の視界を広げてみましょう。&lt;/p&gt;

&lt;p&gt;とはいえ、開拓者をいきなり探索に向かわせるのは、往々にして避けるべきです。
こんなところに移動するんじゃなかった、と思っても引き返すのに合計2ターンかかり、その遅れがそのまま都市建設の遅れに直結するためです。
なので、代わりに労働者を向かわせて先の様子を見させるのが良いでしょう。&lt;/p&gt;

&lt;p&gt;労働者の本分は労働なので、よくわからない未開の地に向かわせるよりも地形改善のための労働をするべきだ、と思われるかもしれません。
実際それは正しく、あまり長い間労働者に探検家の真似ごとをさせるべきではありません。
どこで労働者を探索に使うのをやめるか、というのはやや難しい問題です。
とはいえ、2都市目の建設予定地を探すために2体いるうちの片方の労働者を数ターン探索に割り当てるくらいは、全く問題ではないと言っていいでしょう。&lt;/p&gt;

&lt;p&gt;では早速……&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img11.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img11.png&#34; alt=&#34;労働者の探索?&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ちょっと待ってください！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;この期に及んで、1タイルずつ移動しろ、と言おうとしているのではありません。
そもそも、1タイル移動したところで見えるタイルが新しく増えるわけではなく、すべて既視圏内です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img12.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img12.png&#34; alt=&#34;ちょっとお得&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;川に沿っての移動は移動力を1/3しか消費せず、またユニットはたとえ移動力が1/3しか残っていなくても0でないならば移動ができます。
なのでこのように一度川に沿って移動した後に目的タイルに移動すれば、どちらも同じ1ターンの移動ですがより多く移動でき、見えるタイルが増えます。
小手先のテクニックですね。
とはいえ、ゲーム開始時の都市展開において、情報は非常に重要です。
1タイルでも広く見えるような、効率的な移動を心がけると良いでしょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img13.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img13.png&#34; alt=&#34;労働者の探索&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;北東方面では、あまり東のほうまで海岸線が続いているわけではなさそうです。
ところで、マーカーをつけた部分は視界外となっています。
まあこの海岸線の形を見れば、ここがきっと海だろうということは容易に想像できます。
なのでこのような場所を調べるために、特に最初の都市が建つ前は、わざわざ往復の手間をかけてユニットを向かわせるべきではないと言えます。&lt;/p&gt;

&lt;p&gt;もっとも、こういう海だろうと思った場所が海でなかった、ということは&lt;strong&gt;稀によくあります&lt;/strong&gt;。
仮にそのようなことが起こっても柔軟に対処できるよう、選択肢は広く持つようにしましょう。&lt;/p&gt;

&lt;p&gt;ここで良くないことに気付くのですが(実際のところ、とっくに気付いていておかしくなかったのですが)、先ほど想定していた平野に第二都市を建設した場合、どうやらクジラを得られないようです。
都市を建設したときに、食料2と生産1を産出するタイルを利用可能であることは非常に重要です。
当然本記事では詳しい解説は行いませんが。&lt;/p&gt;

&lt;p&gt;実際、都市を建ててみたら対岸にも土地があり、そこに付随していたクジラを利用できた、というラッキーは存在します。
しかしそれは都市を建ててはじめてわかることであり、頼るべきことではありません。
この場合、労働者を使って平野を灌漑する必要がありますが、平野の灌漑は意外と時間がかかり、その間都市は十分なタイル産出を得られないので、スタートダッシュに多少なりとも影響を及ぼします。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img14.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img14.png&#34; alt=&#34;第二都市の新たな建設候補地&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;このタイルに第二都市を建設してみるのはどうでしょうか？
もちろん、まだ周囲の視界が十分に得られていません。
次のターンに労働者を移動させることで、ようやく周囲のタイルがどのようであるかをある程度把握できるでしょう。
しかしここがなかなか良い立地である可能性もあります。
(その理由を問われればいろいろな要素を提示できますが、それはおおよそ、これまでのゲームの経験に基づいて類似する状況との関連性、および付随するマップ設定などの情報から有機的に導出したものであり、一般にそれは勘と呼ばれることがあります。)&lt;/p&gt;

&lt;p&gt;今労働者を動かした場所に開拓者を動かしたならば、どうでしょうか？
次のターンに労働者を北に1タイル動かして、そこが都市建設に適した場所かどうか知ることができます。
仮にそれが幻滅するような結果であった場合には、開拓者を南に動かせば元々の建設予定地に移動できますし、それでも首都が建つのと同じターンに第二都市を建設できます。
北のほうが都市建設に良さそうなタイルであれば、開拓者を北に動かすこともできます。&lt;/p&gt;

&lt;p&gt;優柔不断ではないか、と思われるかもしれませんが、1ターンのうちに得られる情報には限りがあります。
より多くの情報を得た状態で判断ができるなら、その選択肢を多めに用意しておくことは良いことではないでしょうか。&lt;/p&gt;

&lt;h3 id=&#34;最後の労働者を移動させる:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;最後の労働者を移動させる&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img15.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img15.png&#34; alt=&#34;移動していない最後のユニット&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;というわけで、2体目の開拓者もまた期待と不安の入り交じった旅路へと出発しました。
ところで、初期地点にまだ労働者が1ユニット残っています。
こいつを動かしましょう。&lt;/p&gt;

&lt;p&gt;ここで労働者をどう移動させるか、というのはやや難しい判断が必要なように思われます。
まず、第二都市がクジラを得られない可能性が高まっています。
その場合、近くの平野を速やかに灌漑しなければなりませんが、労働者2ユニットを同時に灌漑に充てれば作業時間は短く済みます。&lt;/p&gt;

&lt;p&gt;一方で、現時点で首都と第二都市の間は川で隔たりができています。
最初に2つの都市の間を道路で結ぶというのは悪くない選択であることが多いですが、今回は川に遮られるため道路を引くには迂回せざるを得ず、さらに次のターンの探索次第では都市と都市の距離が開く可能性もあります。
このような状況では、首都と第二都市との間でユニットを移動させるのに時間がかかります。
首都周辺でも地形改善の必要はありますが、労働者2ユニットともを東に向かわせてしまった場合、首都周辺のタイルを労働者で改善できるようになるまでにかなり時間がかかるでしょう。&lt;/p&gt;

&lt;p&gt;これらの状況や、今後どのタイルにどのような改善が必要か、ということも考慮して労働者をどう動かすか決める必要があります。
つまり、勘に頼るのがいいでしょう。&lt;/p&gt;

&lt;h3 id=&#34;0ターン目の移動の完了:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;0ターン目の移動の完了&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img16.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img16.png&#34; alt=&#34;最初のターン、移動終了&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首都周辺の地形改善ができない、例えば道路が引けないのは問題が多いと考えたため、2体目の労働者は西へ向かわせることにしました。&lt;/p&gt;

&lt;p&gt;これですべてのユニットが移動を終えました。
おめでとうございます。
あなたはようやく最初のターンを終えられます。&lt;/p&gt;

&lt;p&gt;まだ最初のターンであるにもかかわらず、これだけ多くのことを考えないといけないのか、とあなたはげんなりしているかもしれません。
ですが安心してください。
まず第一に、最初のターンだからこそ考えなければならないことが多くある、ということです。
次に、この記事の解説は無駄に冗長であるということです。
このようなろくでもない記事を長々と読む羽目になってしまったあなたの心中は察するに余りありますが、しかし記事が無駄に長ったらしいのであって、実際にたくさんのことをやらなければならないのだ、と悲観する必要はないと言えるでしょう。
では、最初のターンを終了しましょう。&lt;/p&gt;

&lt;h2 id=&#34;1ターン目:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;1ターン目&lt;/h2&gt;

&lt;h3 id=&#34;探索を進める:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;探索を進める&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img17.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img17.png&#34; alt=&#34;ターン1&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;さて、あなたのユニットは移動力を取り戻しました。
やはりまずは探検家を移動させましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img18.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img18.png&#34; alt=&#34;探検家を移動させる&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;やはり、1タイルずつ移動させていくのが良いと思われます。
しかしこれは、今探索している地域が最初に建てる都市から比較的近い距離にあるためです。
(つまり、探索の結果予期しない情報が手に入った場合には、都市を建設する位置を変更しなければならなくなる可能性も存在しているためです。)
一人一島ルールでは、序盤はほかのプレイヤーに干渉されることなく都市の展開が可能であり、先を越されるような心配はありません。
また初期ユニットの開拓者で都市を建ててから次の開拓者を生産できるようになるまでは、通常でも10ターン程度の時間がかかります。
それまでの間に探索を済ませ、次に都市を建てる場所を決められればいいのですから、次のターン以降は深く考えずに探検家を移動させて構いません。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img19.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img19.png&#34; alt=&#34;労働者による探索&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;さて、西岸の形がよりはっきりと明らかになってきました。
次は、島の東側の情報を得るために、労働者を移動させます。&lt;/p&gt;

&lt;h3 id=&#34;都市の建設地点を仮定してみる:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;都市の建設地点を仮定してみる&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img20.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img20.png&#34; alt=&#34;第二都市建設地点確定&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;労働者を北に移動させたところ、なんとクジラが発見されました。
また場所としても島の端にあたる位置のため、都市を建設するには最適といえます。
首都からの距離は開いてしまいますが、第二都市は北に建設することにしましょう。&lt;/p&gt;

&lt;p&gt;ところで、開拓者を北に移動させるのではなく、今開拓者が建っている場所に第二都市を建てる、という選択肢はないのでしょうか？
確かに首都の建設を待つためにこの開拓者は1ターンの間暇になりますが、それは大した問題とはいえません。
実際、ここに都市を建てたとしてもクジラは利用できます。ちょっとその場合を仮定してみましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img21.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img21.png&#34; alt=&#34;IF&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首都の位置を適当に決め、第二都市まで建設した状態です。
マーカーの地点に、「死角」が発生していることがわかるのではないでしょうか。
あなたの島の陸地に隣接した海タイルに死角をつくることは、非常に良くないことです。
これもまた詳しくは説明しませんが、ここに敵意を持った船が接岸してもあなたは気付くことができず、奇襲攻撃を受けて都市を占領されてしまう可能性があります。&lt;/p&gt;

&lt;p&gt;もっとも、少なくともあなたが島全体に都市を建設し終わるくらいまでは、船を出すことができるプレイヤーはいないでしょう。
そのため、3都市目以降でこの死角を埋めるような都市配置を行うことになります。
ですが今回の場合、この死角を埋めるのに妥当な都市の建設地点は一か所しかありません。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img22.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img22.png&#34; alt=&#34;編集モードで勝手に都市増やした&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;死角を埋めるためには、このように都市を配置することになります。
これらの都市はすべて桂馬飛びの位置になっていますから、距離が近すぎるということはありません。
なので、このような都市配置にすること自体はは何の問題もありません。
今回は記事を書いた人がもう少し都市の間隔が開いているほうが好きなので、この都市配置は採用しないというだけです。&lt;/p&gt;

&lt;p&gt;しかし、本当に注意していただきたいことは、&lt;strong&gt;最初の2都市を建てた時点で、次の都市の配置場所がただ一通りに決まってしまうことがある&lt;/strong&gt;ということです。
もちろん、その都市配置が良い都市配置であったなら、何も迷う必要はありません。
ただ、最初の2都市を建てた結果、次の都市を不本意な位置に建てなければならなくなるかもしれない、という可能性を頭に入れておいてください。&lt;/p&gt;

&lt;h3 id=&#34;首都を建設する場所を決める:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;首都を建設する場所を決める&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img23.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img23.png&#34; alt=&#34;結局、首都をどこに建てるのか&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;では、時間を巻き戻してみましょう。結局、あなたは首都をこの二か所のうち、どちらに建てるべきでしょうか？
実際のところ、それは私の知ったことではありません。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img24.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img24.png&#34; alt=&#34;首都IF&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;仮に、首都を草原に建てる場合を考えてみます。
ここに首都を配置した場合に死角となる海タイルをマーキングしています。
このタイルを視界内に収めるために考えられる次の都市の建設予定地は、草原マーカー二か所のいずれかとなります。
しかし、南西側の草原に都市を建てる場合は首都との距離が桂馬飛びの位置になってしまい、悪くはないのですが記事を書いた人の好みとは外れます。
また、北東側の草原はやや陸地がくぼんでいて湾のようになっています。
このような場所に都市を建てると、都市がやや内陸よりになってしまい、利用できる海タイルの数が減ってしまうということは直感的に感じられるのではないでしょうか。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img25.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img25.png&#34; alt=&#34;首都建設予定地&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;平野に首都を建設することを考えます。
この場合、マーカーをした地点の海タイルが死角となります。
都市の間隔が近くなりすぎることを嫌う場合、次に建設する都市はマーカーがしてある草原で確定します。
この草原は都市を建てるには良い場所のように思えるため、ここに首都を建ててしまうのは問題ないでしょう。&lt;/p&gt;

&lt;p&gt;以上の理由から、首都は平野に建設することに決定します。
もちろん決定のための判断材料には個人の好みが大いに含まれているため、実際にどのように都市を配置するかはあなたの考え次第です。
ですが重要なことは、最初に都市を建てる際、次の都市をどこに建てるのかも考慮に入れておくべきだ、ということです。
都市を建設した際の死角について考えることは、国防にとって重要であるだけでなく、次の都市の場所を大まかに想定するためにも役に立つため、意識しておくとよいと思われます。&lt;/p&gt;

&lt;p&gt;ところで、首都の北西部の草原に次の都市を建てることは決まりました。
しかし、この都市ではどうやらクジラを利用できなさそうです。
クジラがいない土地に都市を建てても良いのでしょうか？&lt;/p&gt;

&lt;p&gt;前述のとおり、最初の2都市を建てる際、クジラを都市圏内に収めることは重要です。
これは、食料2および生産1のタイルを都市建設直後から利用できるようにするためです。
しかし第三都市以降の建設までは、いちど都市で開拓者が完成するのを待つ必要があります。
つまり、それまでの間に労働者による地形改善で同等の産出を得られるタイルを用意することができます。
平野を灌漑すれば食料2、生産1が得られるので、都市圏内に平野が1つでも存在していれば3都市目以降の都市建設予定地としては次第点となるのです。
(なお仮に平野が存在しない場合、森を灌漑すれば平野に変化します。もちろん余計に時間ばかりかかるので、あまり嬉しい状況とは言えないでしょう。
森すら存在しないならば、湿地や草原を一度森に変え、そして平野に変える必要があります。もちろんこのような作業は完了までに非常に長い時間がかかります。
都市の圏内に草原と魚しかない、というような状況が予想される場合は、その都市の建設を後回しにし、先に他の場所に都市を建設するべきです。)&lt;/p&gt;

&lt;h3 id=&#34;1ターン目の移動の完了:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;1ターン目の移動の完了&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img26.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img26.png&#34; alt=&#34;ターン1移動終了&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;労働者の移動が残っていますが、首都からのユニットの移動が簡単になるように道路を建設するのがいいでしょう。
森や湿地といった険しい地形は道路を建設するのに時間がかかるため、可能であれば平地または草原に道路を引いていくのが良いかと思われます。
また、平地と草原は道路を引くことで交易にボーナスがつき、本来0ポイントの産出であるのが交易を1ポイント産出するようになります。
労働者の作業は1タイル移動→作業→1タイル移動を繰り返すのがよく、あまり移動に時間をかけてしまうと作業量が減ってしまいます。
なので道路を引きつつ、灌漑するべき平地にさしかかったときに道路建設と一緒に灌漑を行うのが良いでしょう。&lt;/p&gt;

&lt;p&gt;こうして、ターン1の行動も終了しました。&lt;/p&gt;

&lt;h2 id=&#34;2ターン目:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;2ターン目&lt;/h2&gt;

&lt;h3 id=&#34;はじめての都市建設:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;はじめての都市建設&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img27.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/20/img27.png&#34; alt=&#34;都市建設完了&#34; width=&#34;500&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;とうとう、都市の建設に成功しました！
このとき、首都から先に都市建設を行うことは絶対に忘れてはいけません。
(先に都市建設を行った都市が首都になるのですから、自己言及的な言い回しですね？)
キジがあることによって、首都は75%の生産ボーナスを得て、本来の生産3ではなく5もの生産力を得ているからです。
このように、生産ボーナスはもともとの生産が多ければ多いほど効果が高くなるので、キジや水牛といった高い生産が得られる特産物や、小麦などの多くの食料が得られる特産物(都市のサイズがより早く大きくなり、結果的に利用できるタイルが増えて生産力が上がります)が近くにあるほうを首都に選びましょう。&lt;/p&gt;

&lt;p&gt;なお、記事の趣旨からは外れますが、建設した直後の都市の生産物は二都市共に開拓者に変更しておきましょう。
また、研究する科学の決定を忘れてはいけません。
地図を研究目標にして、アルファベットの研究を開始しましょう！&lt;/p&gt;

&lt;p&gt;今回は開拓者がそれぞれ2回移動し、ターン2で都市を建てることができました。
最初の都市の建設はできるだけ早いほうがよく、今回は悪くないスタートだと言えるでしょう。
もっとも、開拓者の移動にもっと時間がかかることも、都市の建設に適した場所がなかなか見つからないこともあるでしょう。
ですが、T4くらいまでには第二都市の建設まで完了しておきたいものです。&lt;/p&gt;

&lt;h2 id=&#34;おわりに:cd98d413dde353aeb3f72d28458f2ca5&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;今回の記事ではゲーム開始時に十分な視界が得られていない状態から、どのように最初の都市を建設していくかを解説しました。
記事の中でも幾度か触れたように、結果として得られた都市配置はプレイヤー自身の好みにも大きく左右されます。
なので、この記事からはゲーム開始時の思考の流れを汲み取って頂ければ幸いです。&lt;/p&gt;

&lt;p&gt;さて、これでこの記事の役割も終わりです。
これからあなたは島の探索を進め、地形の改善を進め、さらに都市を増やしていかなければなりません。
とはいえ、それはこの記事の扱う内容ではありません。
どうか頑張ってください。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>うくらいなにっき(Freecivマルチレポ) 2016/01/30</title>
      <link>http://tatamo.81.la/blog/2016/02/17/freeciv-2016-01-30/</link>
      <pubDate>Wed, 17 Feb 2016 22:35:10 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/02/17/freeciv-2016-01-30/</guid>
      <description>
        

&lt;p&gt;以前&lt;a href=&#34;http://sns.prtls.jp/freecivsnsneo/&#34;&gt;FreecivSNS&lt;/a&gt;でプレイレポートを投稿していましたが、今回より&lt;a href=&#34;http://tatamo.81.la/blog/&#34;&gt;本ブログ&lt;/a&gt;上で再開することにします。&lt;/p&gt;

&lt;p&gt;SNSには外部ブログの読み込み機能を利用して本記事の内容を後日投稿する予定です。そちらではコメントをつけていただくこともできます。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;序盤から同盟国を援護しつつ1国滅ぼし、そのまま続けて世界大戦に突入して勝利。&lt;/p&gt;

&lt;h2 id=&#34;ゲーム概要:28daa66540c07a81521e24fffe429e66&#34;&gt;ゲーム概要&lt;/h2&gt;

&lt;p&gt;2ch定期鯖(土曜夜)。不平等大陸マップ、プレイヤー数6。&lt;/p&gt;

&lt;p&gt;スコアログ：&lt;a href=&#34;http://ux.getuploader.com/freeciv2145/download/540/2016-01-30.log&#34;&gt;http://ux.getuploader.com/freeciv2145/download/540/2016-01-30.log&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;スクリーンショット:28daa66540c07a81521e24fffe429e66&#34;&gt;スクリーンショット&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/17/96731aa4ad3bb2936445da24bda4be54.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/17/96731aa4ad3bb2936445da24bda4be54.png&#34; alt=&#34;スコア&#34; width=&#34;700&#34;&gt;&lt;/a&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/17/0ece8e0f23652cef29112fdee3f8b66a.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/17/0ece8e0f23652cef29112fdee3f8b66a.png&#34; alt=&#34;民族一覧&#34; width=&#34;700&#34;&gt;&lt;/a&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/17/b112e302b4aae27a9dab717ab8d1457d.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/17/b112e302b4aae27a9dab717ab8d1457d.jpg&#34; alt=&#34;本土&#34; width=&#34;700&#34;&gt;&lt;/a&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/17/e5fb33d2d0525688fc7b37fef5289b4d.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/17/e5fb33d2d0525688fc7b37fef5289b4d.jpg&#34; alt=&#34;本土,北極&#34; width=&#34;700&#34;&gt;&lt;/a&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2016/02/17/b76e1c6b699420316618810450b9951f.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2016/02/17/b76e1c6b699420316618810450b9951f.jpg&#34; alt=&#34;他国&#34; width=&#34;700&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;序盤:28daa66540c07a81521e24fffe429e66&#34;&gt;序盤&lt;/h2&gt;

&lt;h3 id=&#34;ゲーム開始:28daa66540c07a81521e24fffe429e66&#34;&gt;ゲーム開始&lt;/h3&gt;

&lt;p&gt;ウクライナの初期配置は大陸の東側付近。西にフィンランド、東にハッカーと接触する。
フィンランド首都とは距離が開いていたため、大陸を東西に分けるように流れていた川を境界として領土を分けることを提案。
フィンランドはこれに合意し、互いに衝突は発生せず停戦。&lt;/p&gt;

&lt;p&gt;フィンランドとの国境線が画定したため、自国領を広く獲得するためにハッカーと国土を接する大陸東部への入植を優先させることに。
しかしここで、防衛がおそろかになっていたハッカーの第二都市が、ハッカー領北西部に領土を持つアッシリアの攻撃によって破壊される。
ハッカーは1都市のみに追い込まれ、アッシリアがハッカー方面に都市を建設、領土を拡大させる姿勢を見せる。&lt;/p&gt;

&lt;h3 id=&#34;ハッカーとの同盟:28daa66540c07a81521e24fffe429e66&#34;&gt;ハッカーとの同盟&lt;/h3&gt;

&lt;p&gt;都市数1のハッカーはアッシリアに対して圧倒的に不利であることは明らかであった。
仮にアッシリアがハッカーを滅亡させた場合、アッシリアとウクライナの国境線が接し、さらにハッカー攻撃に用いた兵力をもってウクライナへの攻撃が行われる可能性があった。
そこでハッカーの都市がアッシリアに破壊された直後、即座にウクライナはハッカーに対し同盟を打診。アッシリア-ハッカー間の戦争への介入を決定する。&lt;/p&gt;

&lt;p&gt;まだ大陸内の入植が完了していたわけではなかったため、弓兵数ユニットをハッカー首都に派遣しつつ、都市展開を優先させる。
ハッカーの注意が対アッシリアに向いていたため、ハッカーとウクライナの間にあった大陸東端の地帯はほぼすべてウクライナ領となった。&lt;/p&gt;

&lt;p&gt;兵法→石工術を研究したあとは通常通り筆記→君主制を目指す。
フィンランドとは不戦を保ちつつ、ハッカーに数学の研究を指示。
一時的に都市をハッカーに貸与して研究を加速させる。
数学の研究完了に伴って、アッシリア侵攻のため全都市でカタパルトの生産に入る。&lt;/p&gt;

&lt;h3 id=&#34;対アッシリア侵攻:28daa66540c07a81521e24fffe429e66&#34;&gt;対アッシリア侵攻&lt;/h3&gt;

&lt;p&gt;こちらが数学を取得するのと同時にアッシリアは車輪の研究を完了させる。
チャリオットによる視界外からの奇襲が想定されるため、ハッカーに警戒するよう指示。
ハッカーが前線に都市を建設しようと試みるが、ハッカーとアッシリアのプレイヤーの技量差のため何度も迎撃され失敗に終わる。
その間に本国でカタパルト8が完成、弓兵4とともにハッカー領に派遣する。
外交官を用いて敵の前線都市を調査したところ想定よりも防御ユニットが少なかったため、カタパルトを突入させ2都市破壊。
これによって元ハッカー領よりアッシリアを追い出すことに成功する。&lt;/p&gt;

&lt;p&gt;さらに進軍するためには川を越える必要があり、そのまま進軍して攻撃を加えるのがやや難しいこと、また仮に攻撃が成功しても増援を送るのに1ターン以上かかることから、破壊したアッシリア都市と同地点に都市を建設するよう指示。
この川都市から川を伝ってアッシリア領に進軍する方針を固める。&lt;/p&gt;

&lt;p&gt;ところで、ウクライナが対アッシリア戦争に邁進している間に他国は地図の研究を完了させ、外洋への進出を開始していた。
そして、船を使ってやってきた大陸の反対側の端に位置しているアイスランドがウクライナと接触する。
アイスランドは元々の国土の狭さから隣国のアステカに圧迫されており、接触よりしばらくして本土の全都市が陥落。
大陸西部はアステカとフィンランドの2国のみが支配することとなった。
ウクライナはアッシリアとの戦争状態にあるためアイスランドに対する具体的支援は行えなかったが、北極へのアイスランドの入植を全面的に支持することとする。
北極へは大陸東部より航路が開いていたが、アッシリア・ハッカー・ウクライナが戦争状態にあるため競合国は少ないものと思われた。
実際にアイスランドはアステカの妨害を受けつつも、北極の入植可能地帯をすべて取得することに成功する。
また、南極は全く戦争を行わず内政に注力する余裕のあったフィンランドが獲得する。&lt;/p&gt;

&lt;h2 id=&#34;中盤:28daa66540c07a81521e24fffe429e66&#34;&gt;中盤&lt;/h2&gt;

&lt;h3 id=&#34;アッシリア制圧:28daa66540c07a81521e24fffe429e66&#34;&gt;アッシリア制圧&lt;/h3&gt;

&lt;p&gt;アイスランドが北極入植を行う際にアッシリア近海を航行し、防御ユニットのいない空都市が存在していることを伝えてきたため、弓兵2ユニット程度を派遣してこの都市を破壊。
アッシリアの後方を荒らして国力を削ぎつつ、主力をアッシリア国境の川へと集結させる。&lt;/p&gt;

&lt;p&gt;一切の戦争を経ず内政を続けていたフィンランド、そしてアイスランドを完全に追い出して大陸西部を統一したアステカがともに勢力を伸ばしており、この両国が比較的友好な関係にあるとの情報ももたらされていた。
実際、この両大国が今後のウクライナ、そして全世界にとって最大の脅威となることも容易に予想される。
アイスランドがアッシリアは講和に応じる構えを見せており、この仲介に入る用意があると打診してきた。
しかしすでにウクライナ軍の主力はアッシリアを射程に捉えていること、アッシリアは軍事に大半のリソースを割り振っていたために技術・内政が大幅に遅れており、講和して共闘関係をもつには国力が低すぎること、またここで停戦してもハッカーが本来の領土を回復するだけで得られるものが少ないことなどの理由より、この提案を退けて戦争の継続を決定。&lt;/p&gt;

&lt;p&gt;川伝いに進軍し、森川に弓兵を展開させてアッシリア前線の都市を半包囲。これによって敵の迎撃を防ぎつつ、後方にカタパルトの主力を展開させる。
敵都市をカタパルトの射程内に収めることに成功し、そのまま突入させ敵都市を破壊。続けて川沿いの都市を2つ破壊することに成功する。
ハッカーに前線都市建設を指示し、これの完成とユニットのHP回復を待ってから攻撃を再開。
敵首都は防御の堅い丘川だったため一度迂回して残りの都市をすべて破壊する。
アッシリア首都に全軍を突入させて占領、ターン116にアッシリアは滅亡した。
ちょうどアッシリア首都が破壊されずにウクライナの占領下におかれたため、元アッシリア領西部をウクライナの領土とし、これによってウクライナは10都市を領することとなった。&lt;/p&gt;

&lt;h3 id=&#34;終戦-そして次の戦争へ:28daa66540c07a81521e24fffe429e66&#34;&gt;終戦、そして次の戦争へ&lt;/h3&gt;

&lt;p&gt;とはいえ、この間にフィンランドは政体を共和制に移行、祝典状態に突入して国力を大幅に引き上げはじめていた。
また当然技術力でも長期にわたる戦争によってウクライナは遅れをとっていた。
しかし幸いなことに、フィンランドがアイスランドに技術支援として供与した技術がウクライナにもたらされ、一時的にではあるがフィンランドと同等の科学技術を得られた。
またアイスランドはアステカに対する敵意とフィンランド-アステカ陣営が脅威であるとの認識からウクライナと友好関係を深め、ウクライナ-ハッカー同盟とアイスランドとの視野の共有も成立した。&lt;/p&gt;

&lt;p&gt;フィンランドとアステカは頻繁に技術協力を行っており、完全に脅威となる存在だったが、この両国は航海術ルートへ研究を進めており、火薬ルートではむしろウクライナ-ハッカー同盟側のほうが先行していた。
ウクライナは戦後復興を進め内政を整えたい時期ではあったが、このまま互いに内政に注力した場合、南極を支配するとともに、既に交易を進め共和祝典に入っているフィンランド側が時間の経過とともに有利になっていくことは明白であった。
そこで、フィンランドが火薬を取得する前の、さらに生産力の弱まる共和制の時代のうちに先制攻撃を仕掛け、フィンランドの国力に打撃を与える以外に勝算はないと判断。急遽対フィンランド戦争の構えに入る。&lt;/p&gt;

&lt;p&gt;幸いなことに南極のアイスランド都市からキャラバンが送られており、最低限の交易路が開通していた。
11都市を擁し共和制下にあるフィンランドはアッシリア滅亡時点で経済力約60と、他国すべてを圧倒していたが、フィンランドの次には経済力30のウクライナが2位に立っていた。
ウクライナは橋梁建設の研究を行い、フィンランドの間にある川の上に道路を建設。
アッシリア滅亡と同時期に締結されたウクライナ-フィンランド間の停戦条約が期限切れとなると同時に渡河攻撃を開始、1都市の占領に成功してフィンランドとの戦争へと突入する。&lt;/p&gt;

&lt;p&gt;この時点で大陸西部と南極を手に入れたフィンランドとアステカが協力関係にあり、アッシリアを滅亡させ大陸東部を平定したウクライナはハッカーと同盟。
またアステカに大陸を追い出され、北極へ移住したアイスランドもウクライナ側との協力関係にあった。
残存する国家が2つの陣営に分かれており、ウクライナによるフィンランド攻撃は事実上世界大戦の始まりであったといえる。&lt;/p&gt;

&lt;h3 id=&#34;対フィンランド全面戦争:28daa66540c07a81521e24fffe429e66&#34;&gt;対フィンランド全面戦争&lt;/h3&gt;

&lt;p&gt;先制攻撃によって都市を奪取することに成功するが、川をまたいだ敵前線への攻撃であったため、この都市へ至る道路は建設されていなかった。
この都市とウクライナ本土との間に道路を建設しなければならず、それまでの数ターンは増援の投入も時間がかかるため、即座に次の都市への攻撃へ移ることはできなかった。
その間にフィンランドは対ウクライナ戦争の態勢へ移り、全都市に城壁を建設してウクライナの攻撃に備える構えに入る。&lt;/p&gt;

&lt;p&gt;そのため丘都市であるフィンランド首都は目前であったものの、城壁の存在からカタパルトをもってしても陥落させることは困難と思われた。
ウクライナが都市横に要塞を建設して広範囲の視野を得たためフィンランド側が都市奪還を狙うことは難しく、またウクライナ側の兵力も都市を落とすに足りなかった。
小規模のユニットの衝突や、本国から占領都市への補給線を絶とうとするフィンランド軍のウクライナ本土側への侵入などが繰り返されながらも戦線は膠着する。&lt;/p&gt;

&lt;p&gt;20ターン近くの間睨み合いが続くが、ここでウクライナが火薬の研究を完了。前線の弓兵をマスケット兵にアップグレードして攻勢に移る。
首都を迂回してフィンランド本土西側に食い込み、2都市を続けて占領。
この攻撃中にフィンランドが火薬を取得したため、これ以上の攻勢は困難となる。
フィンランド西部にまで食い込んだためアステカとも国境を接することになり、城壁が建っておらず平地であったアステカ都市が射程に入ったため、余剰のマスケット兵を投入して2都市を破壊することに成功する。
こちらにもマスケット兵がいるためにしばらくフィンランド側は都市の奪還ができないと判断し、ここで攻撃を中断して占領した都市の防御を固めることに。&lt;/p&gt;

&lt;p&gt;フィンランドの都市3つを奪取し、ウクライナ13都市とやや都市数が増えすぎたため、アッシリア領の3都市をハッカーに移譲する。
またフィンランドの注意が本土に向いていると考えたため、南極にマスケットおよびカタパルトを派遣、狙い通り1都市を占領することに成功する。
しかしこの攻撃によって逆に、こちらの注意が本土から離れてしまっており、次のターンにフィンランド軍およびアステカ軍の総攻撃を受けてフィンランド領の最も西側にある都市を奪還されてしまう。&lt;/p&gt;

&lt;h2 id=&#34;終盤:28daa66540c07a81521e24fffe429e66&#34;&gt;終盤&lt;/h2&gt;

&lt;h3 id=&#34;小康-内政への注力:28daa66540c07a81521e24fffe429e66&#34;&gt;小康、内政への注力&lt;/h3&gt;

&lt;p&gt;以降は、フィンランド領都市に対する外交官による城壁破壊工作に曝されつつも戦闘は小康状態となる。
民主主義を獲得したウクライナはこの機に政体を移行、即座に祝典に移る。&lt;/p&gt;

&lt;p&gt;互いに決定打を与えられるよう内政に注力し、ウクライナはその都市数を活かして世界最大の経済力を持つ国家へ成長する。
しかしその間、祝典の維持と都市建造物を揃えるために研究は停止し、共和制下で既に祝典を行っていたフィンランドが再び研究面で優位に立つ。&lt;/p&gt;

&lt;p&gt;祝典を終え経済基盤を整えたウクライナはフィンランドの倍近い研究速度を叩き出し、また相変わらずのアイスランドの工作によりフィンランドの技術がアイスランド、ハッカーを経由してウクライナに流入した。
これによってウクライナはフィンランドと同等の技術水準まで追いつくが、しかしフィンランドは一足先に冶金学および鉄道の研究を済ませ、ユニットの大量生産態勢に移行しつつあった。&lt;/p&gt;

&lt;p&gt;ウクライナが国力の大半を内政に注いでいたころ、アステカがハッカーの東端の都市を奇襲、占領。
ハッカーはこの都市を奪還できず、数十ターン後に何らかの交渉をまとめたらしくハッカーとアステカの間に休戦が成立する。
曰くアステカがアイスランドを滅亡させた暁にハッカーへ都市が返還されるとのことであり、またハッカーはこのアステカ側の提案を呑みつつも奪還の機会を伺っているとのことであった。
そんな果たされるはずもない交渉を表面的にでも受け入れてしまうあたり、ハッカーのプレイヤースキルがまだまだ成長の余地があるなと思いつつ、周囲の都市に防御ユニットが揃っており奇襲を受けたとしてもそう簡単には落ちないということを確認して放置。
実際、先の2度にわたる戦争においてハッカーの軍事力がろくに役立ったことはなく、実質的にほぼウクライナ単独の戦争であったため、大して同盟国であるハッカーを重要視していなかったのである。&lt;/p&gt;

&lt;p&gt;なお後に判明することであるが、この際ハッカーはウクライナ陣営の視界をアステカ側に横流ししており、完全にウクライナに対する裏切り者であった。&lt;/p&gt;

&lt;h3 id=&#34;2度目の開戦:28daa66540c07a81521e24fffe429e66&#34;&gt;2度目の開戦&lt;/h3&gt;

&lt;p&gt;先に祝典を済ませていたことによる内政の優位から、フィンランドはウクライナより先に戦争準備を完了させる。
全国土に張り巡らせた鉄道によって瞬時に大陸内すべてのカノン砲を集結させ、元フィンランド都市へ一斉攻撃をかけ占領。
さらにもう1都市を占領するが、ウクライナは態勢を整えてこれを即座に奪還。
ここに再び2大陣営間の戦争が勃発する。&lt;/p&gt;

&lt;p&gt;ウクライナ側およびフィンランド-アステカ同盟はともにカノン砲を大量生産し、鉄道の輸送力をもって兵力を集中させ敵都市へ攻撃を加えた。
戦局は先制したフィンランドの優位に進み、ウクライナ本国の都市3つが破壊される。
ハッカーは敵に十分な打撃を与えられる兵力を持っていたが、ウクライナおよびそれを海上より支援していたアイスランド軍と歩調を合わせることができず、ウクライナ・フィンランド互いにカノン砲を使い果たした状態でフィンランド都市の防御に隙ができるというチャンスに恵まれたも関わらず、ハッカー軍が動くことはなかった。
ハッカー軍はアステカ軍の2倍相当の損害を出しながらも、撃破したユニットはアステカ軍の撃破数の半分程度、この数はウクライナ陣営が2度目の開戦以後撃破したユニットのうち20%にも満たず、戦局にほとんど影響を与えなかった。
ウクライナは一時的に5都市にまで追い込まれるが、ウクライナの前線の都市が占領ではなく破壊されたことから敵の支配下には落ちておらず、反攻を行い3都市を再度獲得。
フィンランドとウクライナの国境線付近で都市の占領と奪還を繰り返す一進一退の戦況となる。
激しい戦闘が続く中ゲーム終了ターン直前となり、最後の攻勢をかけ互いに都市を占領しあいゲーム終了となった。&lt;/p&gt;

&lt;h2 id=&#34;ゲーム終了:28daa66540c07a81521e24fffe429e66&#34;&gt;ゲーム終了&lt;/h2&gt;

&lt;p&gt;2度目の戦争はフィンランド本土全都市の奪還およびウクライナ本国都市の破壊と、緒戦はフィンランドの優勢で始まったが、その後ウクライナ側が押し返し混戦状態となった。
ゲーム終了時にはウクライナ本国の都市2つが破壊された状態となり、一方でフィンランドも本土および南極の1都市ずつがウクライナの占領下にあるという状態であった。
結果としてウクライナの都市数はプラスマイナス0、フィンランドが2都市を失っていることとなる。
これはウクライナ-フィンランド両陣営間の2度にわたる戦争のうち2度目はフィンランド優位に推移したが、1度目の戦争においてウクライナはフィンランドの都市3つを占領するという大きな勝利を収めており、結果として2度目の戦争における損失が抑えられたことによるものと考えられる。&lt;/p&gt;

&lt;p&gt;最終的に、ウクライナのユニット撃破数が336と他国を大きく引き離しており、これがスコアに大きく影響し、ウクライナの勝利に繋がった。&lt;/p&gt;

&lt;p&gt;実際、ウクライナ陣営がアッシリアとの戦争で疲弊していた一方で、内政で上位にあったフィンランドとアステカの2国が手を組んだことはゲームの流れを決定づけるに値する出来事であったといえる。
その後戦争が発生せず世界的に内政を進める流れとなった場合、フィンランド陣営が圧倒的有利となっていただろう。
比較的早期にフィンランド-アステカに対して開戦し、一方的に都市を奪取するという戦果を挙げたことがこのゲームの流れを変え、後に全世界を巻き込む大戦へと発展しウクライナに勝利をもたらしたといえるだろう。&lt;/p&gt;

&lt;p&gt;なおハッカーはゲーム開始時からの同盟国であったが、その機会に恵まれた一方で内政は進まず、また3度も大戦争を繰り広げているウクライナの同盟国であるにもにもかかわらずユニット撃破数は100に達しておらず、さらには視界を敵陣営に横流しする重大な裏切りを働くなど、こいつ居ないほうが良かったんじゃないかという感は大いに否めないものがある。&lt;/p&gt;

&lt;p&gt;あと久々にプレイ日記書いたら例のごとくたくさん書きすぎました。ここまで読んでくださった方に感謝します。&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>