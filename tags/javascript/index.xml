<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on わたしろぐ</title>
    <link>http://tatamo.81.la/blog/tags/javascript/</link>
    <description>Recent content in Javascript on わたしろぐ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Fri, 09 Feb 2018 19:30:00 +0900</lastBuildDate>
    <atom:link href="/tags/javascript/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>JavaScript/TypeScriptで競技プログラミングをするには 後編</title>
      <link>http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-02/</link>
      <pubDate>Fri, 09 Feb 2018 19:30:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-02/</guid>
      <description>
        &lt;p&gt;主要コンテストサイトのJavaScript対応状況、および私がJavaScript/TypeScriptで競技プログラミングをする時に気をつけていることなどを書きます。
今回は後者についてです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-01/&#34;&gt;前回の記事&lt;/a&gt;ではコンテストサイトのJavaScript対応状況をメインに書きました。
この記事では、実際にJavaScript/TypeScriptで競技プログラミングをする際に気をつけている点について書いていきます。&lt;/p&gt;

&lt;h2 id=&#34;競技プログラミングにおけるjavascriptの致命的な問題点&#34;&gt;競技プログラミングにおけるJavaScriptの致命的な問題点&lt;/h2&gt;

&lt;p&gt;残念ながら、JavaScriptが競技プログラミングに向いていない理由となる仕様がいくつか存在します。&lt;/p&gt;

&lt;h3 id=&#34;末尾再帰最適化が実装されていない上にコールスタック上限が小さく-変更できない&#34;&gt;末尾再帰最適化が実装されていない上にコールスタック上限が小さく、変更できない&lt;/h3&gt;

&lt;p&gt;JavaScriptではPythonの&lt;code&gt;sys.setrecursionlimit()&lt;/code&gt;のように再帰呼び出し回数の最大値を変更することができません。
コールスタックの上限は処理系に依存しますが、たとえばnode.js v5.12.0 (x64)では15712です。
また、末尾再帰最適化はES2015の仕様に盛り込まれていた内容ですが、現在においてもこれを実装している処理系は非常に少ないのが現状です。&lt;/p&gt;

&lt;p&gt;これらの要因のため、要素数が数万程度の何かに対して手っ取り早く再帰でDFSを書こうとすると、ほぼ間違いなくMaximum call stack size exceededで落ちます。
自分で配列をスタックとして使ってBFSと同じような書き方で書くか、DFS専用のイテレータでも自作しましょう。&lt;/p&gt;

&lt;h3 id=&#34;64bit整数値を扱う手段が存在しない&#34;&gt;64bit整数値を扱う手段が存在しない&lt;/h3&gt;

&lt;p&gt;JavaScriptのすべての数値は、いわゆるdouble型で保持されています。
&lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt;で確認できますが、整数値としての精度が保証される最大値は2^53-1までです。
これはおよそ9.0*10^15程度なので、入力中に10^18ぐらいの数値が与えられるとその時点で詰みです。&lt;/p&gt;

&lt;p&gt;まあ&lt;a href=&#34;https://github.com/broofa/node-int64&#34;&gt;Int64&lt;/a&gt;とか&lt;a href=&#34;https://github.com/silentmatt/javascript-biginteger&#34;&gt;biginteger&lt;/a&gt;的なものを使う・作るしかないです。&lt;/p&gt;

&lt;p&gt;余談ですが、JavaScriptは歴史的経緯から複数のJavaScriptファイルをまとめて一つのソースコードとすることが頻繁に行われているため、browserifyやwebpackといったツールを使えばサードパーティのライブラリを使うことは割と平気で可能です(ソースコード上限を越えなければ)。
しかし競技プログラミング的にどうなのかよくわからないので、私は今のところ自作以外のライブラリを使ったことはないです。&lt;/p&gt;

&lt;p&gt;まあできないことを気にしても仕方がありませんので、以上のような問題点が存在することを把握しておく、ということが大切です。&lt;/p&gt;

&lt;h2 id=&#34;入出力テンプレート&#34;&gt;入出力テンプレート&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import * as fs from &amp;quot;fs&amp;quot;;

const input = (fs.readFileSync(&amp;quot;/dev/stdin&amp;quot;, &amp;quot;utf8&amp;quot;) as string).split(&amp;quot;\n&amp;quot;);
const n = +input[0];
// const [n] = input[0].split(&amp;quot; &amp;quot;).map((x: string): number =&amp;gt; +x);
const a = [];
for(let i=0;i&amp;lt;n;i++){
	a.push(input[i+1].split(&amp;quot; &amp;quot;).map((x:string):number=&amp;gt;+x));
}

console.log(input);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;入力部分は多少長くなってしまうので、テンプレートを用意しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;N M
A1 A2 ... A3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような入力に対しては、少し書き換えて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;const [n, m] = input[0].split(&amp;quot; &amp;quot;).map((x: string): number =&amp;gt; +x);
const a = input[1].split(&amp;quot; &amp;quot;).map((x: string): number =&amp;gt; +x);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすれば対応できます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fs.readFileSync(&amp;quot;/dev/stdin&amp;quot;, &amp;quot;utf8&amp;quot;)&lt;/code&gt;部分がWindowsでは動かない気がするので、適当にUNIX環境を用意しましょう。&lt;/p&gt;

&lt;p&gt;package.jsonやtsconfig.jsonについては、&lt;a href=&#34;https://github.com/Tatamo/comp/tree/master/template/ts&#34;&gt;このへん&lt;/a&gt;に上げています。&lt;/p&gt;

&lt;h2 id=&#34;typescript-複数のプログラムを同時にコンパイルする際の注意&#34;&gt;(TypeScript) 複数のプログラムを同時にコンパイルする際の注意&lt;/h2&gt;

&lt;p&gt;npm scripts等で自動コンパイルを行っている場合などに、&lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/modules.html&#34;&gt;モジュール&lt;/a&gt;でない複数のTypeScriptプログラムを同時にコンパイルすると、すべてのプログラムの変数が同一スコープ上で扱われるため、&lt;code&gt;input&lt;/code&gt;などの変数が衝突してエラーになります。&lt;/p&gt;

&lt;p&gt;これは、それぞれのプログラムがモジュールであると認識されれば解決されます。
そのためのワークアラウンドとして、1行目でfsを取得する際に&lt;code&gt;require()&lt;/code&gt;ではなく&lt;code&gt;import&lt;/code&gt;文を使うようにしています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import * as fs from &amp;quot;fs&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;export&lt;/code&gt;を行っていなくても、TypeScript的にはこれだけでモジュールとして扱われるようなので、複数のプログラムを同時にコンパイルすることができるようになります。&lt;/p&gt;

&lt;h2 id=&#34;array-prototype-shift-の計算量はo-n&#34;&gt;Array.prototype.shift()の計算量はO(n)&lt;/h2&gt;

&lt;p&gt;JavaScriptで計算量について触れられている資料は少ないので、下手をすると&lt;a href=&#34;http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.shift&#34;&gt;仕様書&lt;/a&gt;まで見に行かないと気付けないのですが、&lt;code&gt;shift()&lt;/code&gt;の計算量はO(n)です。
inputに10万行程度の入力を入れて、先頭から1行ずつ&lt;code&gt;shift()&lt;/code&gt;で取り出すと、それだけで2秒が過ぎます。
&lt;code&gt;push()&lt;/code&gt;および&lt;code&gt;pop()&lt;/code&gt;は高速でできるので、普通の配列はスタックとしてのみ使用し、キューは自前で実装する必要があります。&lt;/p&gt;

&lt;p&gt;参考までに、私は次のようなコードを使用しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;export default class Queue&amp;lt;T&amp;gt; {
	private _in: Array&amp;lt;T&amp;gt;;
	private _out: Array&amp;lt;T&amp;gt;;

	get length(): number {
		return this._in.length + this._out.length;
	}

	constructor(iterable?: Iterable&amp;lt;T&amp;gt;) {
		this._in = iterable === undefined ? new Array&amp;lt;T&amp;gt;() : [...iterable];
		this._out = new Array&amp;lt;T&amp;gt;();
	}

	private _fix() {
		this._out = this._in.reverse().concat(this._out);
		this._in = new Array&amp;lt;T&amp;gt;();
	}

	push(...values: Array&amp;lt;T&amp;gt;): void {
		this._in.push(...values);
	}

	shift(): T | undefined {
		if (this._out.length === 0) this._fix();
		return this._out.pop();
	}

	toArray(): Array&amp;lt;T&amp;gt; {
		this._fix();
		return this._out.slice().reverse();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;array-prototype-fill-は同一オブジェクトで埋められる&#34;&gt;Array.prototype.fill()は同一オブジェクトで埋められる&lt;/h2&gt;

&lt;p&gt;まあこれは気付かなかった私がよくないという例ですが、一応。&lt;/p&gt;

&lt;p&gt;0埋めされた3×3の二次元配列を用意しようとして、次のようなコードを書いたとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const a = new Array(3).fill(new Array(3).fill(0));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあ確かに0埋めされた3×3の二次元配列は得られますが、a[0]とa[1]とa[2]は同じ一次元配列を参照しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;a[0][0] = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすると、aの中身は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[[1,0,0]
 [1,0,0]
 [1,0,0]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となってしまいます。
そのため、多次元配列を初期化するときは横着せずにforで回すようにするか、適当な要素を入れてからmapで埋めます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const a = new Array(3);
for(let i=0; i&amp;lt;3; i++){
	a[i].push(new Array(3).fill(0));
}

const a = new Array(3).fill([]).map(()=&amp;gt;new Array(3).fill());
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;以上が、私がJavaScript/TypeScriptで競技プログラミングをする際に気をつけている点です。&lt;/p&gt;

&lt;p&gt;こうして書き出してみると、数値が大きくなると詰むとか再帰がろくに使えないだとかでろくな言語じゃないなという感じですね。
競技プログラミングの問題自体がC/C++で解くことを想定されている節があるので、仕方のないことではあります。&lt;/p&gt;

&lt;p&gt;とはいえ、以上のことさえ気に留めていれば、JavaScript/TypeScriptを使っていることが原因で詰むことはほとんどないと思います。
JavaScriptそのものは非常に書きやすい言語なので、ハマりどころを把握した上で選択肢にしていただける方が増えればいいなと思っています。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>JavaScript/TypeScriptで競技プログラミングをするには 前編</title>
      <link>http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-01/</link>
      <pubDate>Fri, 09 Feb 2018 17:25:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-01/</guid>
      <description>
        &lt;p&gt;主要コンテストサイトのJavaScript対応状況、および私がJavaScript/TypeScriptで競技プログラミングをする時に気をつけていることなどを書きます。
今回は前者についてです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;追記：&lt;a href=&#34;http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-02/&#34;&gt;後編&lt;/a&gt;書きました。&lt;/p&gt;

&lt;p&gt;競技プログラミングをやるのにC++を選択しない時点で物好きという気はしますが、私は普段からTypeScriptをメインに使って問題を解いています。
この前AtCoder Problemsに&lt;a href=&#34;http://kenkoooo.com/atcoder/?kind=lang&#34;&gt;Language Owners Ranking&lt;/a&gt;ができていたので見てみたらTypeScriptで1位を取っていました(2018年2月時点)。
ちなみにJavaScriptランカーのAC数と比較すると3位にも入れていません。&lt;/p&gt;

&lt;p&gt;AtCoderレーティングは水色、コンテスト参加回数もぎりぎり二桁に達する程度で、あまり真面目にやっているほうではないので参考になるかどうかはわかりませんが、JavaScriptまたはTypeScriptで競技プログラミングをするときに気をつけるべき点などを書いていきます。&lt;/p&gt;

&lt;h2 id=&#34;javascriptで競技プログラミングをすることについて&#34;&gt;JavaScriptで競技プログラミングをすることについて&lt;/h2&gt;

&lt;p&gt;こんな記事を書いていて言うのもどうかと思いますが、他の言語ではなくJavaScriptを競技プログラミングに使用することに、何かメリットはあるのか？と聞かれれば、おそらく目立った利点を挙げることはできないと思います。&lt;/p&gt;

&lt;p&gt;とはいえ、&lt;code&gt;function&lt;/code&gt;だらけの黒魔術のようなコードとスクリプト言語特有の遅さは、ここ数年のJavaScriptの目覚ましい進化によって克服されてきています。
現在のJavaScript処理系はJITコンパイルが主流のため、C++やJavaのような言語には敵わないとはいえ、PythonやRubyのようなスクリプト言語よりも圧倒的に高速です。
またECMAScript2015の登場により、もはや&lt;code&gt;function&lt;/code&gt;と書く必要はなくなりました。&lt;/p&gt;

&lt;p&gt;もっとも、JavaScriptが競技プログラミングに不向きな理由もいくつか存在することは事実です(次の記事で紹介します)。
ですが、近年のJavaScriptが以前とは見違えるほどに書きやすい言語になったことから、決して選択肢に入らない言語ではないと私は考えています。&lt;/p&gt;

&lt;p&gt;JavaScriptを使用する最大のモチベーションは、それが書きやすい・手慣れた言語であるからという点に尽きると思いますが、これは重要なことです。&lt;/p&gt;

&lt;h2 id=&#34;コンテストサイトのモダンjavascriptやtypescript対応状況&#34;&gt;コンテストサイトのモダンJavaScriptやTypeScript対応状況&lt;/h2&gt;

&lt;p&gt;JavaScript/TypeScriptで競技プログラミングをするためには、コンテストサイトのオンラインジャッジシステムが少なくともJavaScriptに対応している必要があります。
特にJavaScriptという言語は、ECMAScript2015の策定によって言語仕様が大きく拡張され、その後もECMAScript2016, ECMAScript2017と機能追加が進んでおり、ここ数年間での移り変わりが非常に激しい言語であるため、言語環境が整備されていることの重要性は大きいです。&lt;/p&gt;

&lt;p&gt;ACM-ICPCではC/C++, Java, Python2/3しか使えないのは周知の事実ですが、比較的多くの言語に対応しているコンテストサイトであってもJavaScriptの対応が行き届いていないのが現状です。&lt;/p&gt;

&lt;p&gt;まずは、日本である程度知名度がある(と思われる)コンテストサイトについて、2018年2月現在でのJavaScriptの対応状況を見ていきたいと思います。
なおTopCoderはJavaScript非対応のため除外しています。&lt;/p&gt;

&lt;h3 id=&#34;atcoder-http-atcoder-jp&#34;&gt;&lt;a href=&#34;http://atcoder.jp/&#34;&gt;AtCoder&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript node v5.12.0&lt;/li&gt;
&lt;li&gt;TypeScript 2.1.6&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TypeScriptについてはnode.jsのバージョンが記載されていなかったのですが、おそらく5.12.0であると思われます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://node.green&#34;&gt;node.green&lt;/a&gt;によると、5.12.0ではES2015の対応率は59%程度となっており、次の項目の6.4.0で対応率が95%まで上昇していることを見ると残念な感じです。
しかしAtCoderで注目するべきは、オンラインジャッジ系のサイトでは非常に珍しく、TypeScriptに対応していることです。
たとえば、分割代入構文はnode.js v5.12.0では未対応のため、以下のコードはシンタックスエラーとなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const [a, b, ...c] = [1, 2, 3, 4, 5];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかしこれをTypeScript2.1.6に食わせると、勝手にES5(= Bad Old DaysのJavaScript)仕様にpolyfillしてトランスパイルしてくれるため、以下のJavaScriptコードが生成されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var _a = [1, 2, 3, 4, 5], a = _a[0], b = _a[1], c = _a.slice(2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;つまり言語欄でTypeScriptを選択することで、ES2015の仕様をもう少し多く使うことができるようになります。&lt;/p&gt;

&lt;p&gt;もっともProxyなんかは全く使うことができないのですが、とはいえSet・Map、class、アロー関数および分割代入が使えるので、競技プログラミングで用いる範囲内なら十分にモダンなJavaScriptを書くことができます。
コンパイラオプションなしでTypeScript2.1.6にSetやMapを食わせると&lt;code&gt;Cannot find name &#39;Map&#39;.&lt;/code&gt;等のエラーが出たような気もするのですが、AtCoder上だと特にエラーメッセージは表示されずに無理矢理動かしてくれます。&lt;/p&gt;

&lt;p&gt;TypeScriptはJavaScriptの完全なスーパーセットであるため、すべてのJavaScriptコードはTypeScriptコードとみなすことができます。
TypeScriptの仕様を全く使っていないJavaScriptを書いたとしても、AtCoderではTypeScriptとして提出することをおすすめします。&lt;/p&gt;

&lt;p&gt;なんともいえない感じですが、これでもモダンJavaScriptの対応状況としてはよっぽどマシなほうです。&lt;/p&gt;

&lt;h3 id=&#34;yukicoder-https-yukicoder-me&#34;&gt;&lt;a href=&#34;https://yukicoder.me/&#34;&gt;yukicoder&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;(正直ここがどれくらいの知名度があるのかあまり把握していませんが)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript node v9.2.1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;調べた中で最も最新バージョンに近く、ES2017までのほぼすべての機能が使用可能なJavaScript環境が用意されています。
モダンなJavaScriptを書きながら競技プログラミングを楽しみたいなら、このサイトはおすすめといえます。
TypeScriptには対応していませんが、まあトランスパイルされた.jsファイルを提出すれば済む話でしょう。&lt;/p&gt;

&lt;h3 id=&#34;aizu-online-judge-http-judge-u-aizu-ac-jp-onlinejudge&#34;&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/&#34;&gt;AIZU ONLINE JUDGE&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript node 0.10.36&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/AOJ_tutorial.pdf&#34;&gt;http://judge.u-aizu.ac.jp/onlinejudge/AOJ_tutorial.pdf&lt;/a&gt; に書いてありました。&lt;/p&gt;

&lt;p&gt;ほぼ完全なES5時代の遺物です。
どうしてもJavaScriptが書きたいなら、babel-polyfillあたりをかませてJavaScriptからさらに古い時代のJavaScriptにトランスパイルして提出するのがいいでしょう。&lt;/p&gt;

&lt;h3 id=&#34;codeforces-http-codeforces-com&#34;&gt;&lt;a href=&#34;http://codeforces.com/&#34;&gt;Codeforces&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript V8 4.8.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;node.jsを使っていただきたいところです。
V8 4.8.0はnode.jsでは5.12と6.0.0の間ぐらいなので、ES2015の対応状況ではAtCoderのやや上といったところです。古いことにかわりはありませんが。&lt;/p&gt;

&lt;p&gt;最大の問題点は、標準入出力の方法がnode.jsとは全く異なるという点です。
node.jsでは&lt;code&gt;console.log()&lt;/code&gt;で出力しますが、V8の場合は&lt;code&gt;print()&lt;/code&gt;か&lt;code&gt;write()&lt;/code&gt;になります。&lt;/p&gt;

&lt;p&gt;JavaScriptの処理系としてnode.jsを使わずにわざわざV8を生で叩いている人間ってどれくらいいるんでしょうか？
ちょっと怖いのであまり触れたくない感じです。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;ここまで書いていて思った以上に分量が膨らんでしまいました。
&lt;a href=&#34;http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-02/&#34;&gt;後編&lt;/a&gt;では、実際にJavaScript/TypeScriptで問題を解く上で気をつけている点を書いていきます。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>ゲーム「じゃぱりうぉっち」を作りました</title>
      <link>http://tatamo.81.la/blog/2017/12/01/japari-watch/</link>
      <pubDate>Fri, 01 Dec 2017 17:35:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/12/01/japari-watch/</guid>
      <description>
        &lt;p&gt;この記事は&lt;a href=&#34;https://adventar.org/calendars/2491&#34;&gt;Kobe University Advent Calendar 2017&lt;/a&gt;の1日の記事です。
なお私は当該大学の学部3年(2017年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;ブラウザ上で動作するゲーム「&lt;a href=&#34;https://tatamo.github.io/japari-watch/&#34;&gt;じゃぱりうぉっち&lt;/a&gt;」を作ったので、開発記を書きます。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;じゃぱりうぉっち&#34;&gt;じゃぱりうぉっち&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://tatamo.github.io/japari-watch/&#34;&gt;https://tatamo.github.io/japari-watch/&lt;/a&gt; で公開しており、PCとモバイル端末のどちらでも遊ぶことができます。&lt;/p&gt;

&lt;h3 id=&#34;発端&#34;&gt;発端&lt;/h3&gt;

&lt;p&gt;期末試験前に現実逃避のためにTLを眺めていたところ、以下のツイートが流れてきました。
&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;フェネック「アライさんに似合いそうな帽子を見つけてきたよー」&lt;br&gt;アライグマ「ありがとうなのだ！」&lt;a href=&#34;https://twitter.com/hashtag/%E3%81%91%E3%82%82%E3%81%AE%E3%83%95%E3%83%AC%E3%83%B3%E3%82%BA?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#けものフレンズ&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/%E3%83%89%E3%83%83%E3%83%88%E7%B5%B5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#ドット絵&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/pixelart?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#pixelart&lt;/a&gt; &lt;a href=&#34;https://t.co/1VueMavObQ&#34;&gt;pic.twitter.com/1VueMavObQ&lt;/a&gt;&lt;/p&gt;&amp;mdash; 鬼雷 昇炎 (@kirai_s) &lt;a href=&#34;https://twitter.com/kirai_s/status/934412479597199361?ref_src=twsrc%5Etfw&#34;&gt;2017年11月25日&lt;/a&gt;&lt;/blockquote&gt;&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Version Upgrade Nanoda!! &lt;a href=&#34;https://t.co/IXSjV6A1PN&#34;&gt;pic.twitter.com/IXSjV6A1PN&lt;/a&gt;&lt;/p&gt;&amp;mdash; 鬼雷 昇炎 (@kirai_s) &lt;a href=&#34;https://twitter.com/kirai_s/status/934695920414765056?ref_src=twsrc%5Etfw&#34;&gt;2017年11月26日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;作品としての完成度が高く、実際にゲームとして遊べそうに見えたので、これをゲーム化してみました。&lt;/p&gt;

&lt;h3 id=&#34;素材&#34;&gt;素材&lt;/h3&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;原寸(128*128px)なのだ &lt;a href=&#34;https://twitter.com/hashtag/%E3%81%91%E3%82%82%E3%81%AE%E3%83%95%E3%83%AC%E3%83%B3%E3%82%BA?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#けものフレンズ&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/%E3%83%89%E3%83%83%E3%83%88%E7%B5%B5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#ドット絵&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/pixelart?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#pixelart&lt;/a&gt; &lt;a href=&#34;https://t.co/BJ0Mc27vR5&#34;&gt;pic.twitter.com/BJ0Mc27vR5&lt;/a&gt;&lt;/p&gt;&amp;mdash; 鬼雷 昇炎 (@kirai_s) &lt;a href=&#34;https://twitter.com/kirai_s/status/934699058542678016?ref_src=twsrc%5Etfw&#34;&gt;2017年11月26日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;元画像が上がっていたので使わせていただきました。&lt;/p&gt;

&lt;p&gt;背景に相当する部分の画像がなかったので自分で加工したり、そのまま矩形状にスプライトを切り出すと被ってしまう部分があったのでいくつかのパーツに分けたりしました。&lt;/p&gt;

&lt;h2 id=&#34;製作期間&#34;&gt;製作期間&lt;/h2&gt;

&lt;p&gt;ゲーム本体の作成(アセットの用意・環境構築含む)： 一晩&lt;br /&gt;
公開のためのWebページデザインやTwitterカード、faviconの用意：半日&lt;br /&gt;
公開後の難易度調整+自動モード機能の追加：半日&lt;/p&gt;

&lt;h2 id=&#34;フレームワーク選定&#34;&gt;フレームワーク選定&lt;/h2&gt;

&lt;p&gt;ブラウザで動作するゲームを作ろうと思ったため、基本的にはNode環境で開発を進めていくことになります。
高速に開発するためにTypeScriptで記述することとしたうえで、使用するツールを選定していきました。&lt;/p&gt;

&lt;h3 id=&#34;pixi-js&#34;&gt;PIXI.js&lt;/h3&gt;

&lt;p&gt;PC・モバイル両方のブラウザで動作するゲームという方針のため、HTML5 Canvas系のライブラリを使うことにしました。
npm上で型定義が用意されているものを使いたかったので、今回は&lt;a href=&#34;http://www.pixijs.com/&#34;&gt;PIXI.js&lt;/a&gt;を選択しました。&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;shell&#34;&gt;$ npm install --save-dev @types/pixi.js&lt;/code&gt;で型定義ファイルをインストールし、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import * as PIXI from &amp;quot;pixi.js&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でPIXI.jsの型情報を使用可能になります。&lt;/p&gt;

&lt;h4 id=&#34;ビルドシステム&#34;&gt;ビルドシステム&lt;/h4&gt;

&lt;p&gt;また、今回はブラウザを動作対象とするため、jsファイルのバンドルとBabel化のためにwebpackを使用しました。
実際のところwebpackもBabelもこれまで使ったことがなかったのですが、なんとかts-loaderとbabel-loaderでTypeScriptのソースコードをBabel化してバンドルするところまでやりました。&lt;/p&gt;

&lt;p&gt;期末試験直前であまり学習コストをかけられず、これ以上webpackであれこれするのは怖くなったので、jsファイル以外の静的ファイルのコピーなどはrimrafやcpxを使い、npm scriptsでビルドすることにしました。
また開発中の自動コンパイルのために、chokidarとbrowser-syncを使いました。&lt;/p&gt;

&lt;h2 id=&#34;設計&#34;&gt;設計&lt;/h2&gt;

&lt;p&gt;一定時間ごとにゲームループをまわし、大元のゲームオブジェクトから各マネージャのupdateメソッドを呼び出して処理を行い、最後にレンダリングを行うという基本的な設計としています。&lt;/p&gt;

&lt;p&gt;今回は、エンティティを管理するエンティティマネージャ、スコアを管理するスコアマネージャ、エンティティとスコア以外のゲーム内表示を管理するエフェクトマネージャ、ユーザーからの入力を受け取るインプットマネージャを用意しました。
また、スコアマネージャはインスタンスを2つ生成してそれぞれ取得スコアとミス回数を管理するようにしています。&lt;/p&gt;

&lt;p&gt;ステートマシンを用いてゲーム状態の遷移を管理する方法もありますが、今回はタイトルとゲーム中とゲームオーバーの三状態しかなく、また各エンティティも決まった動きしかしないため不要と判断しました。&lt;/p&gt;

&lt;p&gt;エンティティごとにスプライトのテクスチャを用意しておく必要があり、これはstaticメンバとして各エンティティのクラスに紐付けることにしました。
このテクスチャの生成はアセットのローディングが終わった後に行う必要があるため、エンティティマネージャの初期化時に各staticメソッドを呼び出すことで初期化するようにしました。&lt;/p&gt;

&lt;h3 id=&#34;eventemitterによるメッセージング&#34;&gt;EventEmitterによるメッセージング&lt;/h3&gt;

&lt;p&gt;PIXI.jsで用意されているクラスは&lt;a href=&#34;https://github.com/primus/eventemitter3&#34;&gt;EventEmitter&lt;/a&gt;を継承しており、イベント駆動でのオブジェクト間のメッセージングが可能です。
たとえば&lt;code&gt;アライさん&lt;/code&gt;オブジェクトは&lt;code&gt;Hat&lt;/code&gt;コレクションに対する参照を持ちませんが、イベントの発火にフックしてエンティティマネージャがメソッド引数にコレクションの参照を流し込むことで、&lt;code&gt;アライさん&lt;/code&gt;オブジェクトは外部の参照を持つことなく&lt;code&gt;Hat&lt;/code&gt;コレクションにアクセスし、当たり判定の処理を行うことができます。
これにより、ゲーム内エンティティを表すオブジェクト同士を疎結合に保つことができます。
&lt;code&gt;Hat&lt;/code&gt;のように複数のインスタンスが生成される場合、そのたびにイベントの登録を行う必要があるので、このようなクラスはファクトリを通して実体化するようにします。&lt;/p&gt;

&lt;p&gt;その他にも、インプットマネージャがキーボード入力を受け取ったり、ゲーム画面上に配置されている透明のスプライトに対するクリック・タッチ入力を受け取った場合に、入力された動作に応じたイベントを発火することで、入力の種類を隠蔽したうえでそれにフックする処理を定義可能になります。&lt;/p&gt;

&lt;h2 id=&#34;はまりどころ&#34;&gt;はまりどころ&lt;/h2&gt;

&lt;p&gt;ちょっとしたミスなどですが、詰まった点について。&lt;/p&gt;

&lt;h3 id=&#34;エンティティの消去&#34;&gt;エンティティの消去&lt;/h3&gt;

&lt;p&gt;ループ中にループ対象の配列を変更するな、というのは基本ですが、ゲームの場合当たり判定がヒットしたエンティティを消去したいという場面は多いです。
&lt;code&gt;Hat&lt;/code&gt;コレクションに対してループを回して&lt;code&gt;update()&lt;/code&gt;を呼び出し、その処理の中で&lt;code&gt;Hat&lt;/code&gt;オブジェクトを消去してしまい、それ以降のオブジェクトの処理がおかしくなるというバグが発生しました。&lt;/p&gt;

&lt;p&gt;対処として、まずエンティティに&lt;code&gt;alive&lt;/code&gt;フラグを持たせておき、エンティティを消去したいときには以下のような処理を呼び出すだけにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;die() {
    this.alive = false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、全エンティティのupdate処理終了後に再度ループを回し、ここでaliveフラグがfalseとなっているエンティティをコレクションから取り除きます。
ただし、死んだはずのオブジェクトの当たり判定が残ったりすることを防ぐため、一度aliveフラグがfalseになったエンティティは処理から除外するようにしておく必要があります。
また、結局ループ中の配列を弄ることになるので、このループの中でおかしなことが起きるかもしれないので注意が必要です(とはいえ削除処理を別のループに分けていることで、最悪でもエンティティの削除が次回以降のフレームに引き延ばされてしまう程度の影響しか起きません)。&lt;/p&gt;

&lt;p&gt;ループ中に配列から安全に要素を取り除く方法としては、要素の削除時にイテレータをうまく調整したり、ループインデックスをずらして対処するなどといった方法がありますが、イテレータの仕様を正しく理解している必要があったり、削除処理のタイミングで自分の外側のループのことを考えないといけなかったりするため、処理がやや煩雑になりがちです。
そこで技巧的な方法として、ループのインデックスを配列の末尾から順に0に向けてデクリメントしていけば、途中で要素が取り除かれてもループに影響が出ない、といったものがあります。
ただし処理順は逆になってしまうので、それが気になるなら先述したエンティティ削除用のループでのみ行うなどする必要があります(エンティティの削除処理程度なら順序が変わっても影響が出ないため)。
最も単純なのはループ前にコレクションをコピーしてループを回すことですが、ゲームプログラムで毎フレームごとに配列のコピーを生成するのはパフォーマンス的に避けたいところでもあります。
なお今回は、&lt;code&gt;Hat&lt;/code&gt;オブジェクトは同時に10個も存在することはないため、毎回配列をコピーして削除用のループを回すことにしました。&lt;/p&gt;

&lt;h3 id=&#34;faviconの配信&#34;&gt;faviconの配信&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;favicon.ico&lt;/code&gt;を配信しようと思ったのですが、&lt;a href=&#34;https://tatamo.github.io/japari-watch/&#34;&gt;https://tatamo.github.io/japari-watch/&lt;/a&gt; というURLのルートパスは&lt;a href=&#34;https://tatamo.github.io/&#34;&gt;https://tatamo.github.io/&lt;/a&gt; であるため、&lt;a href=&#34;https://tatamo.github.io/japari-watch/&#34;&gt;https://tatamo.github.io/japari-watch/&lt;/a&gt; 直下にfaviconを配置しても正しく読み込ませることができません。
そのため、&lt;code&gt;&amp;lt;link rel=&amp;quot;shortcut icon href=&amp;quot;favicon.ico&amp;quot; type=&amp;quot;image/x-icon&amp;quot;&amp;quot;&amp;gt;&lt;/code&gt;などとして明示的にfavicon.icoの位置を示す必要がありました。&lt;/p&gt;

&lt;p&gt;また、&lt;code&gt;manifest.json&lt;/code&gt;を&lt;a href=&#34;https://tatamo.github.io/japari-watch/favicons/manifest.json&#34;&gt;https://tatamo.github.io/japari-watch/favicons/manifest.json&lt;/a&gt; に、同様にandroid用のアイコン画像を&lt;code&gt;favicons/&lt;/code&gt;ディレクトリに配置していました。
&lt;code&gt;manifest.json&lt;/code&gt;中の相対パスは基準となるディレクトリが&lt;code&gt;manifest.json&lt;/code&gt;自身となることを知らなかったので、srcパスを&lt;code&gt;&amp;quot;favicons\/android-icon-***.png&amp;quot;&lt;/code&gt;としたところ、&lt;code&gt;favicons/favicons/&lt;/code&gt;が読まれてしまって正しくアイコンを配信できなかったりしました。&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.pixijs.com/&#34;&gt;PIXI.js&lt;/a&gt;はチュートリアルだけは読んだことがあるという状態で、一度実際に使ってみたいと思っていたので使用することができて良かったです。
ドキュメントをろくに読み込まずに使いたい機能だけ調べて使うといった感じでしたが、かなり高速にゲーム開発ができたので非常に便利でした。
またwebpackやBabel、npm scriptsをメインに用いたビルドなどもはじめてだったのですがいい感じにできました。&lt;/p&gt;

&lt;p&gt;使用した画像については作者である&lt;a href=&#34;https://twitter.com/kirai_s&#34;&gt;@kirai_s&lt;/a&gt;さんに確認を得ないまま加工して作り始めてしまったのですが、使用を快く承諾していただけました。
この場を借りてお礼申し上げます。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>ブログのシンタックスハイライトを改善しました</title>
      <link>http://tatamo.81.la/blog/2017/11/08/syntax-highlight-improvement/</link>
      <pubDate>Wed, 08 Nov 2017 18:00:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/11/08/syntax-highlight-improvement/</guid>
      <description>
        &lt;p&gt;このブログのシンタックスハイライトには&lt;a href=&#34;https://highlightjs.org/&#34;&gt;highlight.js&lt;/a&gt;を使用していますが、使い勝手を上げるために調整を行いました。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;コードの強調は不要だがhighlight-jsのテーマは使いたい&#34;&gt;コードの強調は不要だがhighlight.jsのテーマは使いたい&lt;/h2&gt;

&lt;p&gt;プログラムの実行結果など、プログラムそのもの以外を&lt;code class=&#34;html&#34;&gt;&amp;lt;code&amp;gt;&lt;/code&gt;タグで囲いたくなる場合が何度かありました。
class要素に&lt;code&gt;nohighlight&lt;/code&gt;を指定すればハイライトは行われなくなりますが、highlight.jsのCSSテーマも適用されなくなります。&lt;/p&gt;

&lt;h2 id=&#34;インライン要素のハイライトをデフォルトで無効化したい&#34;&gt;インライン要素のハイライトをデフォルトで無効化したい&lt;/h2&gt;

&lt;p&gt;さらに、インライン要素のハイライトを行う場合、対象となるコードが短いために言語の自動検出がうまく働かないことが多いです。
ブロック要素ではMarkdownでcode部分を囲う際に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;```javascript
/* code */
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすることで言語注釈をつけることができますが、インラインの場合はこれができないため言語を明示的に指定する場合には直接codeタグを書く必要があります。&lt;/p&gt;

&lt;h2 id=&#34;解決策&#34;&gt;解決策&lt;/h2&gt;

&lt;p&gt;今のところ&lt;code class=&#34;html&#34;&gt;&amp;lt;code&amp;gt;&lt;/code&gt;で囲った部分はすべてhighlight.jsのテーマを適用してしまって問題はないので、&lt;code&gt;nohighlight&lt;/code&gt;を指定した場合でもCSSテーマが適用されるようにします。
また、インライン要素の場合はデフォルトで&lt;code&gt;nohighlight&lt;/code&gt;にしてしまって、必要がある場合のみHTMLタグを記述して明示的に言語を指定することとしました。
&lt;a href=&#34;http://tatamo.81.la/blog/2015/12/12/apply-highlightjs-to-inline/&#34;&gt;highlight.jsをインライン要素にも適用できるようにした&lt;/a&gt; で書いたコードを、さらに手直しします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// hljs.initHighlightingOnLoad();
window.addEventListener(&amp;quot;DOMContentLoaded&amp;quot;, () =&amp;gt; {
	const elements = document.getElementsByTagName(&amp;quot;code&amp;quot;);
	for (const el of elements) {
		if (el.parentNode.tagName != &amp;quot;PRE&amp;quot;) {
			// インライン要素
			el.style.display = &amp;quot;inline&amp;quot;;
			el.style.margin = &amp;quot;0 2px&amp;quot;;
			el.style.padding = &amp;quot;1px 3px&amp;quot;;
			if (el.classList.length == 0) {
				// classが指定されていない場合はnohighlightとする
				el.classList.add(&amp;quot;nohighlight&amp;quot;);
			}
		}
		hljs.highlightBlock(el);
		// nohighlightでもテーマは適用する
		if (el.classList.contains(&amp;quot;nohighlight&amp;quot;) ||
			el.classList.contains(&amp;quot;lang-nohighlight&amp;quot;) ||
			el.classList.contains(&amp;quot;language-nohighlight&amp;quot;)) {
			el.classList.add(&amp;quot;hljs&amp;quot;);
		}
	}
}, false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、&lt;code class=&#34;html&#34;&gt;&amp;lt;code&amp;gt;&lt;/code&gt;タグでclassの指定が明示的に行われていない場合は自動的に&lt;code&gt;nohighlight&lt;/code&gt;クラスを追加しています。
この処理はhighlight.jsでのハイライト化の処理を行う前に持ってきました。
スタイルの適用も同じように前に持ってきましたが、特に問題はないようです。
次に、&lt;code&gt;nohighlight&lt;/code&gt;が指定されていてハイライトが行われていない要素に対して、classにhighlight.jsで使用されているクラスである&lt;code&gt;hljs&lt;/code&gt;を指定することでテーマの適用を行っています。&lt;/p&gt;

&lt;p&gt;あとは既存の記事をこの変更に合わせて修正しました。
ところどころ不自然なハイライトが行われていた箇所がありましたが、これで改善されました。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>highlight.jsをインライン要素にも適用できるようにした</title>
      <link>http://tatamo.81.la/blog/2015/12/12/apply-highlightjs-to-inline/</link>
      <pubDate>Sat, 12 Dec 2015 01:01:51 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2015/12/12/apply-highlightjs-to-inline/</guid>
      <description>
        &lt;p&gt;このブログのシンタックスハイライトには&lt;a href=&#34;https://highlightjs.org/&#34;&gt;highlight.js&lt;/a&gt;を使用しています。&lt;/p&gt;

&lt;p&gt;デフォルトでは適用できないインラインのコードのハイライトも行えるようにしましたので、適用の流れなど。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;highlight-jsって何&#34;&gt;highlight.jsって何&lt;/h2&gt;

&lt;p&gt;JavaScriptによって、Webページ内のソースコードを色付けしてくれるものです。
たとえば:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(1,101) :
	print (&amp;quot;Fizz&amp;quot; if not i%3 else &amp;quot;&amp;quot;) + (&amp;quot;Buzz&amp;quot; if not i%5 else &amp;quot;&amp;quot;) or i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://highlightjs.org/static/demo/&#34;&gt;highlight.js demo&lt;/a&gt;を見れば、どのようにハイライトされるのか、どのようなテーマがあるのかが簡単にわかるので良いと思います。
(しかし思うのですが、自分のサイトに導入を検討する際に、この濃い赤色の背景色だと白色の背景と感覚が違ってくるのでやや選びにくいのではないでしょうか……。
コンソールから&lt;code class=&#34;js&#34;&gt;document.body.style.backgroundColor=&amp;ldquo;#FFFFFF&amp;rdquo;;&lt;/code&gt;とでも入力して、背景を白く変更してから見てみるのがいいかもしれません。)&lt;/p&gt;

&lt;h2 id=&#34;インライン要素でもハイライトできるようにしてみた&#34;&gt;インライン要素でもハイライトできるようにしてみた&lt;/h2&gt;

&lt;p&gt;通常では、highlight.jsによるハイライトは&lt;code class=&#34;html&#34;&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&lt;/code&gt;から&lt;code class=&#34;html&#34;&gt;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/code&gt;で囲まれたブロック要素にのみ適用され、インライン要素に適用することはできません。1行の中にコードを埋め込みたいことも多いので、これではやや不便です。&lt;/p&gt;

&lt;p&gt;Markdownの展開方法に適用できるように、&lt;code class=&#34;html&#34;&gt;&amp;lt;code&amp;gt;&amp;lt;/code&amp;gt;&lt;/code&gt;で囲まれた要素をハイライトすることにします。
既に先人たちが記事を書いてくれているので、基本的にはそれを参考にするだけでした。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://kenzauros.com/blog/apply-highlight-js-to-inline-source-code/&#34;&gt;highlight.jsでインラインのソースコードもハイライトする | blog@kenzauros.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://swiftrithm.com/blog/highlightjs-install/&#34;&gt;軽いとうわさのhighlight.jsをTwenty Fifteenに導入、ソースコードを綺麗に表示 &amp;#8211; SWIFTRITHM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上記のサイトでは共にJQueryを用いていますが、このサイトでは特にJQueryを導入する気もなかったため、生のJavaScript+DOMで適当に書き直しました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script&amp;gt;
// hljs.initHighlightingOnLoad();
window.addEventListener(&amp;quot;DOMContentLoaded&amp;quot;, function(){
	var elements = document.getElementsByTagName(&amp;quot;code&amp;quot;);
	var l=elements.length;
	for(var i=0; i&amp;lt;l;i++){
		var el = elements[i];
		hljs.highlightBlock(el);
		if(el.parentNode.tagName.toLowerCase() != &amp;quot;pre&amp;quot;) {
			el.style.display = &amp;quot;inline&amp;quot;;
			el.style.margin = &amp;quot;0 2px&amp;quot;;
			el.style.padding = &amp;quot;1px 3px&amp;quot;;
		}
	}
}, false);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常&lt;code&gt;hljs.initHighlightingOnLoad();&lt;/code&gt;を呼ぶところを、上記のコードで置き換えるだけで完了です。
親要素が&lt;code class=&#34;html&#34;&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;ではない場合にインライン化するようにしています。
またスタイルの指定も同時に行っているので、別途CSSを記述する必要はありません。&lt;/p&gt;

&lt;p&gt;既に記事内で何回も使用しているので今更感はありますが、実際にインラインのコードがハイライトされるか見てみましょう。
たとえば、このように:&lt;code class=&#34;py&#34;&gt;print &amp;ldquo;\n&amp;rdquo;.join([&amp;ldquo;Fizz&amp;rdquo;&lt;em&gt;(not i%3)+&amp;ldquo;Buzz&amp;rdquo;&lt;/em&gt;(not i%5) or str(i) for i in range(1,101)])&lt;/code&gt;1行のコードでもうまくハイライトされているのがわかります。
やったね。&lt;/p&gt;
      </description>
    </item>
    
  </channel>
</rss>