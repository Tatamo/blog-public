<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Competitive Programming on わたしろぐ</title>
    <link>http://tatamo.81.la/blog/tags/competitive-programming/</link>
    <description>Recent content in Competitive Programming on わたしろぐ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Fri, 07 Dec 2018 23:22:00 +0900</lastBuildDate>
    <atom:link href="/tags/competitive-programming/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>atcoder-cli チュートリアル</title>
      <link>http://tatamo.81.la/blog/2018/12/07/atcoder-cli-tutorial/</link>
      <pubDate>Fri, 07 Dec 2018 23:22:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/12/07/atcoder-cli-tutorial/</guid>
      <description>
        &lt;p&gt;&lt;a href=&#34;https://www.npmjs.com/package/atcoder-cli&#34;&gt;atcoder-cli&lt;/a&gt;の使用方法を解説していきます。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;atcoder-cliは、&lt;a href=&#34;https://beta.atcoder.jp/&#34;&gt;AtCoder&lt;/a&gt;用のコマンドラインツールです。
このツールの特徴については、&lt;a href=&#34;http://tatamo.81.la/blog/2018/12/07/atcoder-cli/&#34;&gt;紹介記事&lt;/a&gt;をご覧ください。&lt;/p&gt;

&lt;h2 id=&#34;インストール&#34;&gt;インストール&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ pip3 install online-judge-tools
$ npm install -g atcoder-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;詳細なインストール手順は、&lt;a href=&#34;2018/12/07/atcoder-cli-installation-guide/&#34;&gt;atcoder-cli インストールガイド&lt;/a&gt; を参照してください。&lt;/p&gt;

&lt;h2 id=&#34;atcoder-cliのインストール確認&#34;&gt;atcoder-cliのインストール確認&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;※行頭の「&lt;code&gt;$&lt;/code&gt;」は入力しないでください&lt;/p&gt;

&lt;p&gt;&lt;code&gt;acc&lt;/code&gt;コマンドが使用できれば、インストールは正しく行えています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kmyk/online-judge-tools&#34;&gt;online-judge-tools&lt;/a&gt;がインストールされている場合、atcoder-cliは自動的にそれを検知します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc check-oj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を入力して、availableと表示されれば連携機能が有効になっています。&lt;/p&gt;

&lt;h2 id=&#34;atcoderへのログイン&#34;&gt;AtCoderへのログイン&lt;/h2&gt;

&lt;p&gt;atcoder-cliを使用するためには、初回使用時にAtCoderへのログインが必要になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc login
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンドでAtCoderにログインしてください。
ユーザー名とパスワードの入力を求められますが、パスワードは安全のため入力しても画面には表示されないので注意してください。&lt;/p&gt;

&lt;p&gt;ユーザー名・パスワードはatcoder-cliによって保存されることはありません。
そのかわりにログインセッションの情報が設定ファイルとして保存されますが、共用のPCなどで他の人が使用する可能性がある場合は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc logout
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で現在のログイン状態を破棄することができます。&lt;/p&gt;

&lt;p&gt;ログインしている状態かどうか知るためには、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc session
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を使用してください。&lt;/p&gt;

&lt;p&gt;online-judge-toolsを使用している場合は、&lt;code&gt;oj&lt;/code&gt;コマンドを使用してそちらでもログインしておく必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ oj login https://beta.atcoder.jp/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でログインを行ってください。&lt;/p&gt;

&lt;h2 id=&#34;atcoder-cliでコンテスト用ディレクトリを作成する&#34;&gt;atcoder-cliでコンテスト用ディレクトリを作成する&lt;/h2&gt;

&lt;p&gt;以後、online-judge-toolsを使用している前提とします。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://beta.atcoder.jp/contests/abc101&#34;&gt;ABC101&lt;/a&gt;のコンテストの問題を解くことを想定してみましょう。&lt;/p&gt;

&lt;p&gt;ABC101のURLは &lt;a href=&#34;https://beta.atcoder.jp/contests/abc101&#34;&gt;https://beta.atcoder.jp/contests/abc101&lt;/a&gt; ですが、この末尾の&lt;code&gt;abc101&lt;/code&gt;がこのコンテストのIDとなります。
&lt;code&gt;acc n&lt;/code&gt;コマンドにこのIDを指定することで、ABC101用のディレクトリを作らせてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc new abc101
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンドを実行すると、問題の一覧が表示されます。
上下キーでカーソルを移動し、スペースキーで選択することで、サンプルケースをダウンロードしてくる問題を選ぶことができます。
この問題は後から追加することもできます。
一番上のA問題は予め選択されているはずなので、今回はそのままエンターキーを押しましょう。&lt;/p&gt;

&lt;p&gt;コマンドの実行が完了すると、&lt;code&gt;abc101&lt;/code&gt;という名前のディレクトリが作られていると思います。
このディレクトリの中に移動してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd abc101
$ ls # ディレクトリの中身を表示
a  contest.acc.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;a/&lt;/code&gt;という名前のディレクトリと、&lt;code&gt;contest.acc.json&lt;/code&gt;というファイルが一つ存在していると思います。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;contest.acc.json&lt;/code&gt;は、atcoder-cliがコンテストや問題の情報を取得したり、問題ディレクトリの情報を管理するためのファイルです。
通常の使用中は、このファイルに触る機会はありません。&lt;/p&gt;

&lt;p&gt;ディレクトリ&lt;code&gt;a/&lt;/code&gt;に移動してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd a/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このディレクトリの中には、&lt;code&gt;tests/&lt;/code&gt;という名前のディレクトリが既に存在しています。
&lt;code&gt;online-judge-tools&lt;/code&gt;との連携機能により、自動的に問題のサンプルケースがダウンロードされたものです。&lt;/p&gt;

&lt;p&gt;この&lt;code&gt;a/&lt;/code&gt;ディレクトリの中で、問題を解いていきます。
たとえば、&lt;code&gt;main.cpp&lt;/code&gt;という名前のファイルを作り、&lt;a href=&#34;https://beta.atcoder.jp/contests/abc101/tasks/abc101_a&#34;&gt;A問題&lt;/a&gt;を解くプログラムを書いてみましょう。&lt;/p&gt;

&lt;h2 id=&#34;問題を提出する&#34;&gt;問題を提出する&lt;/h2&gt;

&lt;p&gt;書き終わったら、正しくプログラムが書けているか確認します。&lt;/p&gt;

&lt;p&gt;online-judge-toolsは入出力ケースの自動テスト機能を備えているため、自動ダウンロードされたサンプルケースを用いてテストができます。
現在atcoder-cliはテストに関する機能の連携が未実装のため、詳しくは&lt;a href=&#34;https://kimiyuki.net/blog/2017/01/19/pr-online-judge-tools/&#34;&gt;online-judge-toolsの解説記事&lt;/a&gt;を参照してください。&lt;/p&gt;

&lt;p&gt;問題文で与えられた入力例について正しい答えが得られていることを確認したら、プログラムの提出をしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc submit main.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;atcoder-cliでは、提出するファイルを指定するだけで提出先を自動的に判別します。
たとえば、&lt;code&gt;abc101/a/&lt;/code&gt;ディレクトリの中にあるプログラムはABC101のA問題のプログラムとして提出が行われます。&lt;/p&gt;

&lt;p&gt;提出が完了してA問題を解き終わったら、一つ上のディレクトリに戻りましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;問題用ディレクトリを追加する&#34;&gt;問題用ディレクトリを追加する&lt;/h2&gt;

&lt;p&gt;次はB問題を解いていくので、B問題用の新しいディレクトリを作る必要があります。
コンテストディレクトリの中で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc add
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンドを入力すると、再び問題を選択する画面になります。
先程既にディレクトリを作ったA問題は選択できなくなっています。&lt;/p&gt;

&lt;p&gt;このようにして問題用のディレクトリを作って問題を解いていくのが、atcoder-cliでコンテストに取り組む流れになります。&lt;/p&gt;

&lt;h2 id=&#34;デフォルト動作の設定&#34;&gt;デフォルト動作の設定&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;acc new&lt;/code&gt;コマンドや&lt;code&gt;acc add&lt;/code&gt;コマンドで問題ディレクトリを作成する際、毎回問題を選択してエンターキーを押さないといけないのが煩雑に感じるかもしれません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンドによって、現在のグローバル設定を確認することができます。
この中に、&lt;code&gt;default-task-choice: inquire&lt;/code&gt; と書かれた行があるのではないかと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc config default-task-choice next
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとすることで、問題の選択方法を変更することができます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;next&lt;/code&gt;を指定することで、問題を選ぶ画面を出さずに次の一問だけを自動で選ぶようにしたり、&lt;code&gt;all&lt;/code&gt;を指定することで全ての問題ディレクトリを最初に作るようにできます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;default-task-choice&lt;/code&gt;に設定可能な選択肢については、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc add -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で確認することができます。&lt;/p&gt;

&lt;p&gt;また、グローバル設定で設定可能な項目の一覧は、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc cnfig -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で確認できます。&lt;/p&gt;

&lt;h2 id=&#34;テンプレート設定&#34;&gt;テンプレート設定&lt;/h2&gt;

&lt;p&gt;予めマクロの定義や入力を受け付ける部分などの雛形が書かれたプログラムファイルを用意しておくことで、問題ディレクトリを作成する際にそのファイルをコピーして配置することができます。&lt;/p&gt;

&lt;p&gt;たとえば、C++用のテンプレートを用意するには、まずatcoder-cliの設定ファイルが配置されたディレクトリに移動し、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd `acc config-dir`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここに&lt;code&gt;cpp&lt;/code&gt; という名前のディレクトリを作ります。
テンプレートの名前は、このディレクトリ名によって決定されます。&lt;/p&gt;

&lt;p&gt;その中に、コピーしたい雛形である&lt;code&gt;main.cpp&lt;/code&gt;ファイルと、&lt;code&gt;template.json&lt;/code&gt;ファイルを作成します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;template.json&lt;/code&gt;ファイルには以下のように記述します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;task&amp;quot;:{
    &amp;quot;program&amp;quot;: [&amp;quot;main.cpp&amp;quot;],
    &amp;quot;submit&amp;quot;: &amp;quot;main.cpp&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;template.json&lt;/code&gt;を配置したら、&lt;code&gt;acc templates&lt;/code&gt;コマンドを使ってテンプレートが正常に認識されているか確認します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc templates
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正しく読み込まれていれば、&lt;code&gt;cpp&lt;/code&gt;という名前の項目が表示されます。&lt;/p&gt;

&lt;p&gt;実際にこのテンプレートを利用するには、&lt;code&gt;acc new&lt;/code&gt;コマンドと&lt;code&gt;acc add&lt;/code&gt;コマンドを実行する際に、&lt;code&gt;--template&lt;/code&gt;オプションを使用して使用するテンプレートを指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc add --template cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このようにして問題ディレクトリを作成すると、その中に&lt;code&gt;main.cpp&lt;/code&gt;がコピーされます。
また&lt;code&gt;template.json&lt;/code&gt;の&lt;code&gt;&amp;quot;submit&amp;quot;&lt;/code&gt;プロパティに&lt;code&gt;main.cpp&lt;/code&gt;を設定しているため、問題ディレクトリの中にいる場合は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc submit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように、明示的にファイルを指定しなくても&lt;code&gt;main.cpp&lt;/code&gt;が提出対象のファイルであると判断されます。&lt;/p&gt;

&lt;p&gt;頻繁に使用するテンプレートは、常に&lt;code&gt;--template&lt;/code&gt;オプションをつけるかわりに、グローバル設定からデフォルトのテンプレートとして設定することが可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc config defaullt-template cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これにより、&lt;code&gt;acc new&lt;/code&gt;コマンドと&lt;code&gt;acc add&lt;/code&gt;コマンドの実行時に自動的に&lt;code&gt;cpp&lt;/code&gt;テンプレートが使用されるようになります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;template.json&lt;/code&gt;についてのより詳細な情報は、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc template -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と入力すると知ることができます。&lt;/p&gt;

&lt;h2 id=&#34;その他&#34;&gt;その他&lt;/h2&gt;

&lt;p&gt;使用可能なコマンドの一覧は、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で表示することができます。&lt;/p&gt;

&lt;p&gt;また、コマンドごとの詳細な解説、利用可能なオプションを知るためには、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc &amp;lt;コマンド名&amp;gt; -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を使用してください。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がatcoder-cliの基本的な使い方になります。
このツールによってAtCoderで問題を解く作業の効率化ができることを願っています。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>atcoder-cli インストールガイド</title>
      <link>http://tatamo.81.la/blog/2018/12/07/atcoder-cli-installation-guide/</link>
      <pubDate>Fri, 07 Dec 2018 23:21:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/12/07/atcoder-cli-installation-guide/</guid>
      <description>
        &lt;p&gt;&lt;a href=&#34;https://www.npmjs.com/package/atcoder-cli&#34;&gt;atcoder-cli&lt;/a&gt;のインストール方法を解説していきます。&lt;/p&gt;

&lt;h2 id=&#34;わかる人向け&#34;&gt;わかる人向け&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ pip3 install online-judge-tools
$ npm install -g atcoder-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上です。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;インストールガイド&#34;&gt;インストールガイド&lt;/h2&gt;

&lt;p&gt;atcoder-cliをインストールするためには、Node.js環境が必要です。
また、Python3で動作する&lt;a href=&#34;https://github.com/kmyk/online-judge-tools&#34;&gt;online-judge-tools&lt;/a&gt;を併用することを強く推奨しているため、こちらも同時にインストールします。&lt;/p&gt;

&lt;p&gt;※ 以後、コマンド例の行頭の「&lt;code&gt;$&lt;/code&gt;」はターミナルのプロンプト記号を表しているため、実際に入力する必要はありません。
&lt;code&gt;$&lt;/code&gt;より後の部分を入力して実行してください。&lt;/p&gt;

&lt;h3 id=&#34;事前準備-windowsでwslを使う場合&#34;&gt;事前準備：WindowsでWSLを使う場合&lt;/h3&gt;

&lt;p&gt;Windowsの場合、直接言語環境をインストールする方法と、&lt;abbr title=&#34;Windows Subsystem for Linux&#34;&gt;WSL&lt;/abbr&gt;を使う方法があります。
どちらを使用するかはお好みですが、Linuxの使い方がわかるという方はWSLを選択するとよいでしょう。
WSLを使う場合は設定より有効化し、ストアからUbuntuなどのLinuxディストリビューションをインストールします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参考: &lt;a href=&#34;https://qiita.com/yoshikingt/items/ab86411e6031459db805&#34;&gt;https://qiita.com/yoshikingt/items/ab86411e6031459db805&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;WSLのインストール後は、Linuxの場合のインストール方法を参照してください。&lt;/p&gt;

&lt;h3 id=&#34;事前準備-macの場合&#34;&gt;事前準備：Macの場合&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://brew.sh/index_ja&#34;&gt;Homebrew&lt;/a&gt;の使用を想定します。
&lt;code&gt;brew&lt;/code&gt;コマンドが存在しない場合、以下のコマンドをターミナルで実行することでインストールしてください。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ /usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行が完了したら、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ brew -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンドをターミナルで実行して、エラーなどが起きずにHomebrewのバージョン名が表示されていることを確認してください。&lt;/p&gt;

&lt;h3 id=&#34;必要な環境のインストール&#34;&gt;必要な環境のインストール&lt;/h3&gt;

&lt;p&gt;Python3とNode.jsの両方をインストールしてください。
OSごとにインストール方法が違うため、お使いのOSの欄を参照してください。&lt;/p&gt;

&lt;p&gt;環境によってはもう少し良いやり方がある場合もありますが、この記事では少ない手順でインストールが完了することを目的として方法を選んでいます。&lt;/p&gt;

&lt;h4 id=&#34;windows&#34;&gt;Windows&lt;/h4&gt;

&lt;h5 id=&#34;python3&#34;&gt;Python3&lt;/h5&gt;

&lt;p&gt;公式インストーラーより&lt;a href=&#34;https://www.python.org/downloads/windows/&#34;&gt;Python&lt;/a&gt;をインストールします。
最新バージョンの&amp;rdquo;Download Windows x86-64 web-based installer&amp;rdquo;からインストーラーをダウンロードし、実行してください。
インストール時に、&amp;rdquo;Add Python 3.x to PATH&amp;rdquo;のチェックを忘れずに入れるようにしましょう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参考: &lt;a href=&#34;https://azriton.github.io/2017/07/25/Python-3.6-64bit%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/&#34;&gt;https://azriton.github.io/2017/07/25/Python-3.6-64bit%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;node-js&#34;&gt;Node.js&lt;/h5&gt;

&lt;p&gt;公式インストーラーより&lt;a href=&#34;https://nodejs.org/ja/download/&#34;&gt;Node.js&lt;/a&gt;をインストールします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参考: &lt;a href=&#34;https://qiita.com/taiponrock/items/9001ae194571feb63a5e&#34;&gt;https://qiita.com/taiponrock/items/9001ae194571feb63a5e&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;mac-linux&#34;&gt;Mac/Linux&lt;/h4&gt;

&lt;p&gt;端末コンソールを開いて作業をしてください。&lt;/p&gt;

&lt;h5 id=&#34;python3-1&#34;&gt;Python3&lt;/h5&gt;

&lt;p&gt;Linuxの場合は、&lt;code&gt;brew&lt;/code&gt;のかわりにディストリビューションごとのパッケージマネージャを使用してください。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ # Macの場合はこちらを実行してください
$ brew install python3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ # UbuntuまたはDebianを使用している場合はこちらを実行してください
$ # 他のLinuxディストリビューションを使っている人はこんな記事を読むまでもなくインストールを終わらせていると思われるため触れません
$ sudo apt-get install python3
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;node-js-1&#34;&gt;Node.js&lt;/h5&gt;

&lt;p&gt;パッケージマネージャによって古いバージョンのNodeしか手に入らないことがあるので、&lt;a href=&#34;https://github.com/creationix/nvm&#34;&gt;nvm&lt;/a&gt;を使ってインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコマンドの実行が完了したら、一度ターミナルを閉じてください。
新しいターミナルを開き、続きのコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ nvm install node
$ npm install -g npm
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;atcoder-cli-online-judge-toolsのインストール&#34;&gt;atcoder-cli, online-judge-toolsのインストール&lt;/h3&gt;

&lt;p&gt;言語環境のインストールが正しく行われていることを確認します。
Windowsの場合はコマンドプロンプトを、Mac/Linuxの場合は端末コンソールを開いてください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip3 -V
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と入力してエンターキーを押し、バージョン番号が表示されることを確認してください。&lt;/p&gt;

&lt;p&gt;同様にして、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行し、バージョン番号が表示されることを確認してください。&lt;/p&gt;

&lt;p&gt;「コマンドが見つかりません」や「command not found」、それに似たメッセージが表示される場合はPython3およびNode.jsのインストールに失敗している可能性があります。
その場合は再度手順を確認してインストールし直したり、「Python3 インストール (+OS名)」などで検索して調べてください。&lt;/p&gt;

&lt;p&gt;問題がなかった場合は、atcoder-cliおよびonline-judge-toolsのインストールを行います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g atcoder-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;pip3 install online-judge-tools
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とそれぞれ入力してエンターキーを押すことで、atcoder-cliとonline-judge-toolsがインストールされます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;acc -h
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;oj -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とそれぞれ入力し、ヘルプが表示されることを確認してください。&lt;/p&gt;

&lt;p&gt;ここまででインストール作業は完了です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;2018/12/07/atcoder-cli-tutorial/&#34;&gt;atcoder-cli チュートリアル&lt;/a&gt;に進み、atcoder-cliの基本的な使い方を確認しましょう。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>コマンドラインツールatcoder-cliを公開しました</title>
      <link>http://tatamo.81.la/blog/2018/12/07/atcoder-cli/</link>
      <pubDate>Fri, 07 Dec 2018 23:20:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/12/07/atcoder-cli/</guid>
      <description>
        &lt;p&gt;&lt;a href=&#34;https://beta.atcoder.jp/&#34;&gt;AtCoder&lt;/a&gt;のためのコマンドラインツール、&lt;a href=&#34;https://www.npmjs.com/package/atcoder-cli&#34;&gt;atcoder-cli&lt;/a&gt;をリリースしました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;2018/12/07/atcoder-cli-installation-guide/&#34;&gt;インストールガイド&lt;/a&gt;と&lt;a href=&#34;2018/12/07/atcoder-cli-tutorial/&#34;&gt;チュートリアル&lt;/a&gt;の記事も用意しています。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;モチベーション&#34;&gt;モチベーション&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://beta.atcoder.jp/&#34;&gt;AtCoder&lt;/a&gt;のコンテストで問題を解く際に、問題用のディレクトリを作る、プログラム用のファイルを用意する、問題を解き終わったらソースコードをコピーして提出するなど、プログラムを書く以外の部分で手間がかかることがあります。
そのため、問題を提出する、プログラムがサンプルケースで失敗しないかチェックする、問題を解くのに必要なファイルやディレクトリを構築する、といった処理をコマンドラインから実行できればコンテスト中の処理の自動化が可能になり、快適に問題を解くことができるようになります。&lt;/p&gt;

&lt;p&gt;コマンドラインからAtCoderに問題を提出したりするツールとしては、&lt;a href=&#34;https://github.com/kmyk/online-judge-tools&#34;&gt;online-judge-tools&lt;/a&gt;などが存在します。&lt;/p&gt;

&lt;p&gt;とはいえ、既存のツールでは複数のコンテストサイトを動作対象としていることなどから、「プログラムを提出するたびに提出先の問題IDやURLを指定しなければならない」といった問題点がありました。
提出ファイルのコピペなどの手間を省くためにコマンドラインツールを使っているはずなのに、その提出先を指定するためにURLをブラウザからコピーしてくる必要があるのでは本末転倒感があります。&lt;/p&gt;

&lt;p&gt;また、問題を一問解く度にプログラムのテンプレートを用意したり、既存ツールを用いてサンプルケースをダウンロードしてくるのも手間がかかります。&lt;/p&gt;

&lt;p&gt;そこで、数ある競技プログラミングのサイトの中からAtCoderに特化することで、コンテスト中にコンソールに打ち込むコマンドの数を極限まで減らせるようにするツールとして、&lt;a href=&#34;https://www.npmjs.com/package/atcoder-cli&#34;&gt;atcoder-cli&lt;/a&gt;を開発しました。&lt;/p&gt;

&lt;p&gt;atcoder-cliはディレクトリ構成から自動的に提出するコンテスト・問題を検出し、短いコマンドの入力だけで問題を提出できるようにするのみならず、テンプレートを自動的に展開する機能などを備えており、AtCoder用のプロジェクト管理ツールとしても機能するソフトウェアです。
また、online-judge-toolsとの連携によって、サンプルケースの自動ダウンロードなどの機能を余計なURL指定なしで快適に使用できるようになります。&lt;/p&gt;

&lt;h2 id=&#34;インストール方法&#34;&gt;インストール方法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ npm install -g atcoder-cli
$ acc -v # 正しくインストールされたかどうか確認する
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;atcoder-cliはnpmパッケージとして公開しているため、node.jsが必要です。
また、&lt;a href=&#34;https://github.com/kmyk/online-judge-tools&#34;&gt;online-judge-tools&lt;/a&gt;はインストールされていなくても問題なく動作しますが、連携機能のため同時にインストールしておくことを強く推奨します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;2018/12/07/atcoder-cli-installation-guide/&#34;&gt;atcoder-cli インストールガイド&lt;/a&gt;を公開していますので、詳しいインストール手順はそちらをお読みください。&lt;/p&gt;

&lt;h2 id=&#34;特徴&#34;&gt;特徴&lt;/h2&gt;

&lt;p&gt;詳細な機能については&lt;a href=&#34;https://github.com/Tatamo/atcoder-cli&#34;&gt;README&lt;/a&gt;や&lt;code&gt;acc [COMMAND] -h&lt;/code&gt;コマンドを参照してください。
日本語の解説記事として、&lt;a href=&#34;2018/12/07/atcoder-cli-tutorial/&#34;&gt;atcoder-cli チュートリアル&lt;/a&gt;があります。&lt;/p&gt;

&lt;h3 id=&#34;コンテスト情報取得&#34;&gt;コンテスト情報取得&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;$ acc contest abc100
AtCoder Beginner Contest 100  https://beta.atcoder.jp/contests/abc100
$ acc tasks abc100
A  Happy Birthday!           https://beta.atcoder.jp/contests/abc100/tasks/abc100_a
B  Ringo&#39;s Favorite Numbers  https://beta.atcoder.jp/contests/abc100/tasks/abc100_b
C  *3 or /2                  https://beta.atcoder.jp/contests/abc100/tasks/abc100_c
D  Patisserie ABC            https://beta.atcoder.jp/contests/abc100/tasks/abc100_d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CLIツールとして、問題のURLなどをコマンドラインから取得できます。他のシェルコマンドと組み合わせることで、AtCoderに関連する処理を自動化する際に役立てることができます。&lt;/p&gt;

&lt;h3 id=&#34;コンテスト用ディレクトリ作成&#34;&gt;コンテスト用ディレクトリ作成&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ acc new abc100 # abc100用のディレクトリを作成
$ cd abc100
$ cat contest.acc.json
{
  &amp;quot;contest&amp;quot;: {
    &amp;quot;id&amp;quot;: &amp;quot;abc100&amp;quot;,
    &amp;quot;title&amp;quot;: &amp;quot;AtCoder Beginner Contest 100&amp;quot;,
    &amp;quot;url&amp;quot;: &amp;quot;https://beta.atcoder.jp/contests/abc100&amp;quot;
  },
  &amp;quot;tasks&amp;quot;: [
    {
      &amp;quot;id&amp;quot;: &amp;quot;abc100_a&amp;quot;,
      &amp;quot;label&amp;quot;: &amp;quot;A&amp;quot;,
      &amp;quot;title&amp;quot;: &amp;quot;Happy Birthday!&amp;quot;,
      &amp;quot;url&amp;quot;: &amp;quot;https://beta.atcoder.jp/contests/abc100/tasks/abc100_a&amp;quot;,
      &amp;quot;directory&amp;quot;: {
        &amp;quot;path&amp;quot;: &amp;quot;a&amp;quot;,
        &amp;quot;testdir&amp;quot;: &amp;quot;tests&amp;quot;
      }
    },
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;atcoder-cliでは、コンテストごとにディレクトリを作成してプログラムを管理します。
デフォルトではコンテストディレクトリ内でさらに問題ごとにディレクトリを分け、その中で問題を解いていくことを想定していますが、コンテストディレクトリ直下でディレクトリを分けずに複数のプログラムファイルを配置することもサポートしています。&lt;/p&gt;

&lt;p&gt;この際に、以下のような処理を自動的に行うことができます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;サンプルケースの自動ダウンロード (online-judge-toolsが必要)&lt;/li&gt;
&lt;li&gt;テンプレートを予め用意しておくことで、プログラム等のファイルを問題ディレクトリにコピー&lt;/li&gt;
&lt;li&gt;任意のシェルコマンドを実行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらを組み合わせることで、コンテスト用ディレクトリを作成した時点であらゆる前準備を終えることができます。&lt;/p&gt;

&lt;h3 id=&#34;提出機能&#34;&gt;提出機能&lt;/h3&gt;

&lt;p&gt;atcoder-cli本体は今のところAtCoderにファイルを提出する機能を備えていませんが、内側でonline-judge-toolsを呼び出すことにより、もともとのonline-judge-toolsの機能よりもさらに簡単に問題を提出することができるようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ oj s https://beta.atcoder.jp/contests/abc100/tasks/abc100_a main.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;online-judge-toolsでは問題の提出のために上記のコマンドが必要でしたが、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ acc s main.cpp # s はsubmitの省略名
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;atcoder-cliはファイルが配置されたディレクトリから自動的に提出するべき問題を判別し、URLなどを明示する必要がなくなっています。&lt;/p&gt;

&lt;p&gt;さらに、問題テンプレート機能を使用すれば提出するプログラムのファイル名を予め指定しておくことができるため、以下のように一切の引数を与えることなく提出が可能になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ acc s # これだけで提出ができる！
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;高速な応答性&#34;&gt;高速な応答性&lt;/h3&gt;

&lt;p&gt;レスポンスの速さはCLIツールにとって重要な要素であるため、依存パッケージのロードを必要なタイミングまで遅延させることで、そのコマンドの実行時に使用されないパッケージの読み込みを防止して応答性を高めています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ time acc -h
...
real    0m0.093s
user    0m0.080s
sys     0m0.008s
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;類似ツール&#34;&gt;類似ツール&lt;/h2&gt;

&lt;h3 id=&#34;kmyk-online-judge-tools-https-github-com-kmyk-online-judge-tools&#34;&gt;&lt;a href=&#34;https://github.com/kmyk/online-judge-tools&#34;&gt;kmyk/online-judge-tools&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;AtCoderに限定せず様々なサイトに対応

&lt;ul&gt;
&lt;li&gt;それ故にややコマンドのタイプ数が増えやすい傾向にある&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;テストツールとしての機能も有する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;atcoder-cliは現状online-judge-toolsにどっぷり依存しているので頭が上がりません。
便利なツールを作って頂いてありがとうございます。&lt;/p&gt;

&lt;p&gt;とはいえatcoder-cliはnpm, ojはpipでインストールしないといけないため、atcoder-cli単体で同等の機能が提供できたほうがインストールの手間は減ると思うので好ましいのかもしれません(サンプルケースの取得はアドホックにやらざるを得ないし、提出ファイルの言語指定も割とつらさがあるので既にあるものをあまり再実装したくない)。&lt;/p&gt;

&lt;h3 id=&#34;nodchip-onlinejudgehelper-https-github-com-nodchip-onlinejudgehelper&#34;&gt;&lt;a href=&#34;https://github.com/nodchip/OnlineJudgeHelper&#34;&gt;nodchip/OnlineJudgeHelper&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;様々なサイトに対応、多機能&lt;/li&gt;
&lt;li&gt;outdated&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;URLをすべて入力しなくても、コンテストID+問題IDでの提出ができるため少しは楽です。
年単位でメンテナンスされていなかったり、アカウントのパスワードをローカルに置いておくことを求められたりするので、今使うには微妙かもしれません。&lt;/p&gt;

&lt;h3 id=&#34;xmlpro-atam-https-github-com-xmlpro-atam&#34;&gt;&lt;a href=&#34;https://github.com/XMLPro/atam&#34;&gt;XMLPro/atam&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;AtCoder用の問題提出ツール&lt;/li&gt;
&lt;li&gt;node.jsで動作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;AtCoder専用のツールで、現状では問題提出のみの機能を持っています。
npmからインストールすることができ、連携が比較的容易と思われるので、今後連携機能の実装を行うかもしれません。&lt;/p&gt;

&lt;h2 id=&#34;contribution&#34;&gt;Contribution&lt;/h2&gt;

&lt;p&gt;バグ報告、要望などは&lt;a href=&#34;https://github.com/Tatamo/atcoder-cli/issues&#34;&gt;https://github.com/Tatamo/atcoder-cli/issues&lt;/a&gt;で受け付けています。&lt;/p&gt;

&lt;h2 id=&#34;余談&#34;&gt;余談&lt;/h2&gt;

&lt;p&gt;このツールが良いと思っていただけましたら、ぜひ&lt;strong&gt;&lt;a href=&#34;https://github.com/Tatamo/atcoder-cli&#34;&gt;★Starをください&lt;/a&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;というのも、AtCoder勢で利用していない人はほとんどいないであろう&lt;a href=&#34;https://kenkoooo.com/atcoder/&#34;&gt;AtCoder Problems&lt;/a&gt;が、その圧倒的な知名度と比較して&lt;a href=&#34;https://github.com/kenkoooo/AtCoderProblems&#34;&gt;GitHubリポジトリ&lt;/a&gt;についている★の数があまりに少ないのではないか、という話があります。&lt;/p&gt;

&lt;p&gt;★とはTwitterの&lt;del&gt;ふぁぼ&lt;/del&gt;いいねのようなものです。
競プロ勢はGitHubの使い方もよくわからないのだ、という不名誉な評判がつきかねませんから、ぜひ良いと思ったリポジトリには★を投げてみましょう。&lt;/p&gt;

&lt;p&gt;ここに&lt;a href=&#34;https://github.com/Tatamo/atcoder-cli&#34;&gt;良い練習台 (Tatamo/atcoder-cli)&lt;/a&gt;がありますね。&lt;/p&gt;

&lt;p&gt;GitHubのアカウントを持っていない方は、有効なメールアドレスとユーザー名、パスワードだけあれば&lt;a href=&#34;https://github.com/join&#34;&gt;https://github.com/join&lt;/a&gt;から簡単にアカウントの作成を行うことができます。
(&lt;a href=&#34;https://www.google.co.jp/search?q=github+登録&#34;&gt;参考&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;ログインができたら&lt;a href=&#34;https://github.com/Tatamo/atcoder-cli&#34;&gt;適当なソフトウェア (Tatamo/atcoder-cli)&lt;/a&gt;のページに行き、ページの上の方にある「★Star」をクリック/タップするだけで★をつけることができます。&lt;/p&gt;

&lt;p&gt;(露骨な宣伝で申し訳ありません。
私のツールに★を投げる必要はありませんが、AtCoder Problemsは実際もっと★がついていてもよいのではと思っています。
皆さんどんどんGitHubで★を投げあいましょう)&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>JavaScript/TypeScriptで競技プログラミングをするには 後編</title>
      <link>http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-02/</link>
      <pubDate>Fri, 09 Feb 2018 19:30:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-02/</guid>
      <description>
        &lt;p&gt;主要コンテストサイトのJavaScript対応状況、および私がJavaScript/TypeScriptで競技プログラミングをする時に気をつけていることなどを書きます。
今回は後者についてです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-01/&#34;&gt;前回の記事&lt;/a&gt;ではコンテストサイトのJavaScript対応状況をメインに書きました。
この記事では、実際にJavaScript/TypeScriptで競技プログラミングをする際に気をつけている点について書いていきます。&lt;/p&gt;

&lt;h2 id=&#34;競技プログラミングにおけるjavascriptの致命的な問題点&#34;&gt;競技プログラミングにおけるJavaScriptの致命的な問題点&lt;/h2&gt;

&lt;p&gt;残念ながら、JavaScriptが競技プログラミングに向いていない理由となる仕様がいくつか存在します。&lt;/p&gt;

&lt;h3 id=&#34;末尾再帰最適化が実装されていない上にコールスタック上限が小さく-変更できない&#34;&gt;末尾再帰最適化が実装されていない上にコールスタック上限が小さく、変更できない&lt;/h3&gt;

&lt;p&gt;JavaScriptではPythonの&lt;code&gt;sys.setrecursionlimit()&lt;/code&gt;のように再帰呼び出し回数の最大値を変更することができません。
コールスタックの上限は処理系に依存しますが、たとえばnode.js v5.12.0 (x64)では15712です。
また、末尾再帰最適化はES2015の仕様に盛り込まれていた内容ですが、現在においてもこれを実装している処理系は非常に少ないのが現状です。&lt;/p&gt;

&lt;p&gt;これらの要因のため、要素数が数万程度の何かに対して手っ取り早く再帰でDFSを書こうとすると、ほぼ間違いなくMaximum call stack size exceededで落ちます。
自分で配列をスタックとして使ってBFSと同じような書き方で書くか、DFS専用のイテレータでも自作しましょう。&lt;/p&gt;

&lt;h3 id=&#34;64bit整数値を扱う手段が存在しない&#34;&gt;64bit整数値を扱う手段が存在しない&lt;/h3&gt;

&lt;p&gt;JavaScriptのすべての数値は、いわゆるdouble型で保持されています。
&lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt;で確認できますが、整数値としての精度が保証される最大値は2^53-1までです。
これはおよそ9.0*10^15程度なので、入力中に10^18ぐらいの数値が与えられるとその時点で詰みです。&lt;/p&gt;

&lt;p&gt;まあ&lt;a href=&#34;https://github.com/broofa/node-int64&#34;&gt;Int64&lt;/a&gt;とか&lt;a href=&#34;https://github.com/silentmatt/javascript-biginteger&#34;&gt;biginteger&lt;/a&gt;的なものを使う・作るしかないです。&lt;/p&gt;

&lt;p&gt;余談ですが、JavaScriptは歴史的経緯から複数のJavaScriptファイルをまとめて一つのソースコードとすることが頻繁に行われているため、browserifyやwebpackといったツールを使えばサードパーティのライブラリを使うことは割と平気で可能です(ソースコード上限を越えなければ)。
しかし競技プログラミング的にどうなのかよくわからないので、私は今のところ自作以外のライブラリを使ったことはないです。&lt;/p&gt;

&lt;p&gt;まあできないことを気にしても仕方がありませんので、以上のような問題点が存在することを把握しておく、ということが大切です。&lt;/p&gt;

&lt;h2 id=&#34;入出力テンプレート&#34;&gt;入出力テンプレート&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import * as fs from &amp;quot;fs&amp;quot;;

const input = (fs.readFileSync(&amp;quot;/dev/stdin&amp;quot;, &amp;quot;utf8&amp;quot;) as string).split(&amp;quot;\n&amp;quot;);
const n = +input[0];
// const [n] = input[0].split(&amp;quot; &amp;quot;).map((x: string): number =&amp;gt; +x);
const a = [];
for(let i=0;i&amp;lt;n;i++){
	a.push(input[i+1].split(&amp;quot; &amp;quot;).map((x:string):number=&amp;gt;+x));
}

console.log(input);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;入力部分は多少長くなってしまうので、テンプレートを用意しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;N M
A1 A2 ... A3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような入力に対しては、少し書き換えて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;const [n, m] = input[0].split(&amp;quot; &amp;quot;).map((x: string): number =&amp;gt; +x);
const a = input[1].split(&amp;quot; &amp;quot;).map((x: string): number =&amp;gt; +x);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすれば対応できます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fs.readFileSync(&amp;quot;/dev/stdin&amp;quot;, &amp;quot;utf8&amp;quot;)&lt;/code&gt;部分がWindowsでは動かない気がするので、適当にUNIX環境を用意しましょう。&lt;/p&gt;

&lt;p&gt;package.jsonやtsconfig.jsonについては、&lt;a href=&#34;https://github.com/Tatamo/comp/tree/master/template/ts&#34;&gt;このへん&lt;/a&gt;に上げています。&lt;/p&gt;

&lt;h2 id=&#34;typescript-複数のプログラムを同時にコンパイルする際の注意&#34;&gt;(TypeScript) 複数のプログラムを同時にコンパイルする際の注意&lt;/h2&gt;

&lt;p&gt;npm scripts等で自動コンパイルを行っている場合などに、&lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/modules.html&#34;&gt;モジュール&lt;/a&gt;でない複数のTypeScriptプログラムを同時にコンパイルすると、すべてのプログラムの変数が同一スコープ上で扱われるため、&lt;code&gt;input&lt;/code&gt;などの変数が衝突してエラーになります。&lt;/p&gt;

&lt;p&gt;これは、それぞれのプログラムがモジュールであると認識されれば解決されます。
そのためのワークアラウンドとして、1行目でfsを取得する際に&lt;code&gt;require()&lt;/code&gt;ではなく&lt;code&gt;import&lt;/code&gt;文を使うようにしています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import * as fs from &amp;quot;fs&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;export&lt;/code&gt;を行っていなくても、TypeScript的にはこれだけでモジュールとして扱われるようなので、複数のプログラムを同時にコンパイルすることができるようになります。&lt;/p&gt;

&lt;h2 id=&#34;array-prototype-shift-の計算量はo-n&#34;&gt;Array.prototype.shift()の計算量はO(n)&lt;/h2&gt;

&lt;p&gt;JavaScriptで計算量について触れられている資料は少ないので、下手をすると&lt;a href=&#34;http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.shift&#34;&gt;仕様書&lt;/a&gt;まで見に行かないと気付けないのですが、&lt;code&gt;shift()&lt;/code&gt;の計算量はO(n)です。
inputに10万行程度の入力を入れて、先頭から1行ずつ&lt;code&gt;shift()&lt;/code&gt;で取り出すと、それだけで2秒が過ぎます。
&lt;code&gt;push()&lt;/code&gt;および&lt;code&gt;pop()&lt;/code&gt;は高速でできるので、普通の配列はスタックとしてのみ使用し、キューは自前で実装する必要があります。&lt;/p&gt;

&lt;p&gt;参考までに、私は次のようなコードを使用しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;export default class Queue&amp;lt;T&amp;gt; {
	private _in: Array&amp;lt;T&amp;gt;;
	private _out: Array&amp;lt;T&amp;gt;;

	get length(): number {
		return this._in.length + this._out.length;
	}

	constructor(iterable?: Iterable&amp;lt;T&amp;gt;) {
		this._in = iterable === undefined ? new Array&amp;lt;T&amp;gt;() : [...iterable];
		this._out = new Array&amp;lt;T&amp;gt;();
	}

	private _fix() {
		this._out = this._in.reverse().concat(this._out);
		this._in = new Array&amp;lt;T&amp;gt;();
	}

	push(...values: Array&amp;lt;T&amp;gt;): void {
		this._in.push(...values);
	}

	shift(): T | undefined {
		if (this._out.length === 0) this._fix();
		return this._out.pop();
	}

	toArray(): Array&amp;lt;T&amp;gt; {
		this._fix();
		return this._out.slice().reverse();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;array-prototype-fill-は同一オブジェクトで埋められる&#34;&gt;Array.prototype.fill()は同一オブジェクトで埋められる&lt;/h2&gt;

&lt;p&gt;まあこれは気付かなかった私がよくないという例ですが、一応。&lt;/p&gt;

&lt;p&gt;0埋めされた3×3の二次元配列を用意しようとして、次のようなコードを書いたとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const a = new Array(3).fill(new Array(3).fill(0));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあ確かに0埋めされた3×3の二次元配列は得られますが、a[0]とa[1]とa[2]は同じ一次元配列を参照しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;a[0][0] = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすると、aの中身は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[[1,0,0]
 [1,0,0]
 [1,0,0]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となってしまいます。
そのため、多次元配列を初期化するときは横着せずにforで回すようにするか、適当な要素を入れてからmapで埋めます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const a = new Array(3);
for(let i=0; i&amp;lt;3; i++){
	a[i].push(new Array(3).fill(0));
}

const a = new Array(3).fill([]).map(()=&amp;gt;new Array(3).fill());
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;以上が、私がJavaScript/TypeScriptで競技プログラミングをする際に気をつけている点です。&lt;/p&gt;

&lt;p&gt;こうして書き出してみると、数値が大きくなると詰むとか再帰がろくに使えないだとかでろくな言語じゃないなという感じですね。
競技プログラミングの問題自体がC/C++で解くことを想定されている節があるので、仕方のないことではあります。&lt;/p&gt;

&lt;p&gt;とはいえ、以上のことさえ気に留めていれば、JavaScript/TypeScriptを使っていることが原因で詰むことはほとんどないと思います。
JavaScriptそのものは非常に書きやすい言語なので、ハマりどころを把握した上で選択肢にしていただける方が増えればいいなと思っています。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>JavaScript/TypeScriptで競技プログラミングをするには 前編</title>
      <link>http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-01/</link>
      <pubDate>Fri, 09 Feb 2018 17:25:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-01/</guid>
      <description>
        &lt;p&gt;主要コンテストサイトのJavaScript対応状況、および私がJavaScript/TypeScriptで競技プログラミングをする時に気をつけていることなどを書きます。
今回は前者についてです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;追記：&lt;a href=&#34;http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-02/&#34;&gt;後編&lt;/a&gt;書きました。&lt;/p&gt;

&lt;p&gt;競技プログラミングをやるのにC++を選択しない時点で物好きという気はしますが、私は普段からTypeScriptをメインに使って問題を解いています。
この前AtCoder Problemsに&lt;a href=&#34;http://kenkoooo.com/atcoder/?kind=lang&#34;&gt;Language Owners Ranking&lt;/a&gt;ができていたので見てみたらTypeScriptで1位を取っていました(2018年2月時点)。
ちなみにJavaScriptランカーのAC数と比較すると3位にも入れていません。&lt;/p&gt;

&lt;p&gt;AtCoderレーティングは水色、コンテスト参加回数もぎりぎり二桁に達する程度で、あまり真面目にやっているほうではないので参考になるかどうかはわかりませんが、JavaScriptまたはTypeScriptで競技プログラミングをするときに気をつけるべき点などを書いていきます。&lt;/p&gt;

&lt;h2 id=&#34;javascriptで競技プログラミングをすることについて&#34;&gt;JavaScriptで競技プログラミングをすることについて&lt;/h2&gt;

&lt;p&gt;こんな記事を書いていて言うのもどうかと思いますが、他の言語ではなくJavaScriptを競技プログラミングに使用することに、何かメリットはあるのか？と聞かれれば、おそらく目立った利点を挙げることはできないと思います。&lt;/p&gt;

&lt;p&gt;とはいえ、&lt;code&gt;function&lt;/code&gt;だらけの黒魔術のようなコードとスクリプト言語特有の遅さは、ここ数年のJavaScriptの目覚ましい進化によって克服されてきています。
現在のJavaScript処理系はJITコンパイルが主流のため、C++やJavaのような言語には敵わないとはいえ、PythonやRubyのようなスクリプト言語よりも圧倒的に高速です。
またECMAScript2015の登場により、もはや&lt;code&gt;function&lt;/code&gt;と書く必要はなくなりました。&lt;/p&gt;

&lt;p&gt;もっとも、JavaScriptが競技プログラミングに不向きな理由もいくつか存在することは事実です(次の記事で紹介します)。
ですが、近年のJavaScriptが以前とは見違えるほどに書きやすい言語になったことから、決して選択肢に入らない言語ではないと私は考えています。&lt;/p&gt;

&lt;p&gt;JavaScriptを使用する最大のモチベーションは、それが書きやすい・手慣れた言語であるからという点に尽きると思いますが、これは重要なことです。&lt;/p&gt;

&lt;h2 id=&#34;コンテストサイトのモダンjavascriptやtypescript対応状況&#34;&gt;コンテストサイトのモダンJavaScriptやTypeScript対応状況&lt;/h2&gt;

&lt;p&gt;JavaScript/TypeScriptで競技プログラミングをするためには、コンテストサイトのオンラインジャッジシステムが少なくともJavaScriptに対応している必要があります。
特にJavaScriptという言語は、ECMAScript2015の策定によって言語仕様が大きく拡張され、その後もECMAScript2016, ECMAScript2017と機能追加が進んでおり、ここ数年間での移り変わりが非常に激しい言語であるため、言語環境が整備されていることの重要性は大きいです。&lt;/p&gt;

&lt;p&gt;ACM-ICPCではC/C++, Java, Python2/3しか使えないのは周知の事実ですが、比較的多くの言語に対応しているコンテストサイトであってもJavaScriptの対応が行き届いていないのが現状です。&lt;/p&gt;

&lt;p&gt;まずは、日本である程度知名度がある(と思われる)コンテストサイトについて、2018年2月現在でのJavaScriptの対応状況を見ていきたいと思います。
なおTopCoderはJavaScript非対応のため除外しています。&lt;/p&gt;

&lt;h3 id=&#34;atcoder-http-atcoder-jp&#34;&gt;&lt;a href=&#34;http://atcoder.jp/&#34;&gt;AtCoder&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript node v5.12.0&lt;/li&gt;
&lt;li&gt;TypeScript 2.1.6&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TypeScriptについてはnode.jsのバージョンが記載されていなかったのですが、おそらく5.12.0であると思われます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://node.green&#34;&gt;node.green&lt;/a&gt;によると、5.12.0ではES2015の対応率は59%程度となっており、次の項目の6.4.0で対応率が95%まで上昇していることを見ると残念な感じです。
しかしAtCoderで注目するべきは、オンラインジャッジ系のサイトでは非常に珍しく、TypeScriptに対応していることです。
たとえば、分割代入構文はnode.js v5.12.0では未対応のため、以下のコードはシンタックスエラーとなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const [a, b, ...c] = [1, 2, 3, 4, 5];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかしこれをTypeScript2.1.6に食わせると、勝手にES5(= Bad Old DaysのJavaScript)仕様にpolyfillしてトランスパイルしてくれるため、以下のJavaScriptコードが生成されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var _a = [1, 2, 3, 4, 5], a = _a[0], b = _a[1], c = _a.slice(2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;つまり言語欄でTypeScriptを選択することで、ES2015の仕様をもう少し多く使うことができるようになります。&lt;/p&gt;

&lt;p&gt;もっともProxyなんかは全く使うことができないのですが、とはいえSet・Map、class、アロー関数および分割代入が使えるので、競技プログラミングで用いる範囲内なら十分にモダンなJavaScriptを書くことができます。
コンパイラオプションなしでTypeScript2.1.6にSetやMapを食わせると&lt;code&gt;Cannot find name &#39;Map&#39;.&lt;/code&gt;等のエラーが出たような気もするのですが、AtCoder上だと特にエラーメッセージは表示されずに無理矢理動かしてくれます。&lt;/p&gt;

&lt;p&gt;TypeScriptはJavaScriptの完全なスーパーセットであるため、すべてのJavaScriptコードはTypeScriptコードとみなすことができます。
TypeScriptの仕様を全く使っていないJavaScriptを書いたとしても、AtCoderではTypeScriptとして提出することをおすすめします。&lt;/p&gt;

&lt;p&gt;なんともいえない感じですが、これでもモダンJavaScriptの対応状況としてはよっぽどマシなほうです。&lt;/p&gt;

&lt;h3 id=&#34;yukicoder-https-yukicoder-me&#34;&gt;&lt;a href=&#34;https://yukicoder.me/&#34;&gt;yukicoder&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;(正直ここがどれくらいの知名度があるのかあまり把握していませんが)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript node v9.2.1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;調べた中で最も最新バージョンに近く、ES2017までのほぼすべての機能が使用可能なJavaScript環境が用意されています。
モダンなJavaScriptを書きながら競技プログラミングを楽しみたいなら、このサイトはおすすめといえます。
TypeScriptには対応していませんが、まあトランスパイルされた.jsファイルを提出すれば済む話でしょう。&lt;/p&gt;

&lt;h3 id=&#34;aizu-online-judge-http-judge-u-aizu-ac-jp-onlinejudge&#34;&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/&#34;&gt;AIZU ONLINE JUDGE&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript node 0.10.36&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/AOJ_tutorial.pdf&#34;&gt;http://judge.u-aizu.ac.jp/onlinejudge/AOJ_tutorial.pdf&lt;/a&gt; に書いてありました。&lt;/p&gt;

&lt;p&gt;ほぼ完全なES5時代の遺物です。
どうしてもJavaScriptが書きたいなら、babel-polyfillあたりをかませてJavaScriptからさらに古い時代のJavaScriptにトランスパイルして提出するのがいいでしょう。&lt;/p&gt;

&lt;h3 id=&#34;codeforces-http-codeforces-com&#34;&gt;&lt;a href=&#34;http://codeforces.com/&#34;&gt;Codeforces&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript V8 4.8.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;node.jsを使っていただきたいところです。
V8 4.8.0はnode.jsでは5.12と6.0.0の間ぐらいなので、ES2015の対応状況ではAtCoderのやや上といったところです。古いことにかわりはありませんが。&lt;/p&gt;

&lt;p&gt;最大の問題点は、標準入出力の方法がnode.jsとは全く異なるという点です。
node.jsでは&lt;code&gt;console.log()&lt;/code&gt;で出力しますが、V8の場合は&lt;code&gt;print()&lt;/code&gt;か&lt;code&gt;write()&lt;/code&gt;になります。&lt;/p&gt;

&lt;p&gt;JavaScriptの処理系としてnode.jsを使わずにわざわざV8を生で叩いている人間ってどれくらいいるんでしょうか？
ちょっと怖いのであまり触れたくない感じです。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;ここまで書いていて思った以上に分量が膨らんでしまいました。
&lt;a href=&#34;http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-02/&#34;&gt;後編&lt;/a&gt;では、実際にJavaScript/TypeScriptで問題を解く上で気をつけている点を書いていきます。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>ACM-ICPC2017アジアつくば大会に参加しました</title>
      <link>http://tatamo.81.la/blog/2017/12/18/icpc-2017-asia/</link>
      <pubDate>Mon, 18 Dec 2017 01:30:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/12/18/icpc-2017-asia/</guid>
      <description>
        &lt;p&gt;この記事は&lt;a href=&#34;https://adventar.org/calendars/2491&#34;&gt;Kobe University Advent Calendar 2017&lt;/a&gt;の18日の記事です。
なお私は当該大学の学部3年(2017年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://icpc.iisf.or.jp/2017-tsukuba/results/&#34;&gt;ICPC国内予選39位&lt;/a&gt;で神戸大学の第2チームとしてぎりぎり予選通過できたので、&lt;a href=&#34;https://icpc.iisf.or.jp/2017-tsukuba/&#34;&gt;アジア大会&lt;/a&gt;に参加しました。&lt;/p&gt;

&lt;p&gt;結果としては3問通して&lt;a href=&#34;http://icpc2017.yamagula.ic.i.u-tokyo.ac.jp/standings/&#34;&gt;39位&lt;/a&gt;でした。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;実績「座っているだけのお仕事」&lt;br&gt;解除条件：ICPCで一度たりとも競技用マシンに触れない&lt;br&gt;を達成しました💺💤&lt;/p&gt;&amp;mdash; Tatamo@Super-Srups (@&lt;strong&gt;tatamo&lt;/strong&gt;) &lt;a href=&#34;https://twitter.com/__tatamo__/status/942290374382383104?ref_src=twsrc%5Etfw&#34;&gt;2017年12月17日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
なにもしないをしました&lt;/p&gt;

&lt;h2 id=&#34;チーム構成-方針&#34;&gt;チーム構成・方針&lt;/h2&gt;

&lt;p&gt;私の所属するチームであるSuper-Srupsのメンバー構成は以下の通りです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/mmxsrup&#34;&gt;@mmxsrup&lt;/a&gt;氏

&lt;ul&gt;
&lt;li&gt;学部2年&lt;/li&gt;
&lt;li&gt;リーダー&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/kurenai3110&#34;&gt;@kurenai3110&lt;/a&gt;氏

&lt;ul&gt;
&lt;li&gt;学部2年&lt;/li&gt;
&lt;li&gt;実装担当&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/__tatamo__&#34;&gt;@__tatamo__&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;わたし 学部3年&lt;/li&gt;
&lt;li&gt;座っている担当&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;私は3人の中で最も実力が低く、かつここ数ヶ月のあいだ全くC++を書いていないという状態です。
つまり論理的結論として、私は一行もコードを書くべきではありません。
そのため私は英語で与えられる問題文の読解、他メンバーの補助および考察少しを担当しました。
他の2人はUSキーボードのEnterキーが空振りするとかgeditがつらいとかubuntuの使い方がわからないとか大変そうでした。&lt;/p&gt;

&lt;h2 id=&#34;解いた問題&#34;&gt;解いた問題&lt;/h2&gt;

&lt;p&gt;問題の内容については&lt;a href=&#34;https://storage.googleapis.com/icpcsec/icpc2017-regional/problems.pdf&#34;&gt;問題文&lt;/a&gt;を参照してください。&lt;/p&gt;

&lt;h3 id=&#34;a&#34;&gt;A&lt;/h3&gt;

&lt;p&gt;やるだけ問です。
問題文を読んで&lt;a href=&#34;https://twitter.com/kurenai3110&#34;&gt;@kurenai3110&lt;/a&gt;氏に投げたらよろしくやってくれました。&lt;/p&gt;

&lt;h3 id=&#34;c&#34;&gt;C&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/mmxsrup&#34;&gt;@mmxsrup&lt;/a&gt;氏と考察を担当し、実装は&lt;a href=&#34;https://twitter.com/kurenai3110&#34;&gt;@kurenai3110&lt;/a&gt;氏にやってもらいました。
値が負になるときの特殊ケースや変数の更新タイミングのミス等のちょっとした考察漏れ・実装ミスを3つほど同時に仕込んでしまって数十分ほど無駄に消費してしまったので反省点が多いです。&lt;/p&gt;

&lt;h3 id=&#34;i&#34;&gt;I&lt;/h3&gt;

&lt;p&gt;B問題・C問題で無限に時間を費やしているうちに他チームは問題をたくさん解いていたので、風船の浮かんでいる状況を見てI,F,G問題に解く対象を絞りました。
なお今年の問題の並び順は、A,B,C問題までが易しい順に並んでおりそれ以降の問題はランダムになっています。&lt;/p&gt;

&lt;p&gt;I問題は問題文を読んで&lt;a href=&#34;https://twitter.com/kurenai3110&#34;&gt;@kurenai3110&lt;/a&gt;氏に丸投げしたら見事に解いてくれました。&lt;/p&gt;

&lt;h2 id=&#34;解けなかった問題&#34;&gt;解けなかった問題&lt;/h2&gt;

&lt;h3 id=&#34;b&#34;&gt;B&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/mmxsrup&#34;&gt;@mmxsrup&lt;/a&gt;氏がメインで担当しました。
制限実行時間10秒の問題ですが、最初にすべての可能な傾きの同じ線分の集合を持ったりしていたらハマってしまって通せませんでした。
普通に全探索すれば解けるなどということを終了後に聞きましたが、全然通らなかったのでいっそ早めに放り投げるべきだったのかもしれません。&lt;/p&gt;

&lt;h3 id=&#34;f&#34;&gt;F&lt;/h3&gt;

&lt;p&gt;私はグラフは最短経路の超典型問ぐらいしか解けないので、問題を訳すだけして他の２人に投げました。
実装の最後の方まで行っていたようなのですが間に合いませんでした。&lt;/p&gt;

&lt;h3 id=&#34;g&#34;&gt;G&lt;/h3&gt;

&lt;p&gt;考察を担当しました。
座標変換で簡単になるというのは気付きませんでしたが、極座標→XY座標への変換をしてからdX=正三角形の辺の長さの半分, dY=正三角形の高さ で区切って場合分け2回ほどで数学的に求めて終わりです。&lt;/p&gt;

&lt;h2 id=&#34;結果&#34;&gt;結果&lt;/h2&gt;

&lt;p&gt;A問題解いた直後に沼にはまって時間を無為に費やし、終盤になってB,F,Gの解法が出揃ったが実装時間が圧倒的に足りないという状況に陥り、結局4問目を通せず3完でした。
予選と全く同じ順位の39位です。&lt;/p&gt;

&lt;p&gt;ICPCはやはりマシン1台のチーム戦ということで、特有の難しさがあるので事前の慣らしはもっとしておいたほうがよかったような気がします。
あとUSキーボードは思った以上に慣れない(らしい)のでこちらも事前準備が必要そうです。&lt;/p&gt;

&lt;p&gt;とはいえ、そもそも私は自力で問題を解けないので、問題文の和訳と考察補助とただ座っているぐらいしか仕事がない感じです。
こういう場にカジュアル勢が紛れ込んでしまって肩身が狭いというか申し訳無さです。&lt;/p&gt;

&lt;h2 id=&#34;雑事&#34;&gt;雑事&lt;/h2&gt;

&lt;p&gt;1日目は昼過ぎに集合で、参加受付+開会式+練習+懇親会だけで、解放される時間がなぜか20時です。
思うところがないでもありません。&lt;/p&gt;

&lt;p&gt;2日目についても、終了後の懇親会で2時間拘束されます。
こちらでは企業ブースがいくつかあり、物をもらったり話を聞いたりすることができました。&lt;a href=&#34;2017/09/17/indeed-austin-tour/&#34;&gt;ツアー&lt;/a&gt;で一緒だった某r(i)社の方々とまた会ったりしました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://proc-cpuinfo.fixstars.com/2017/12/in-house-procon-06-announcement/&#34;&gt;量子リバーシ&lt;/a&gt;なるクイズが出題されており、こういうのは&lt;a href=&#34;http://shogitter.com/rule/108&#34;&gt;量子将棋&lt;/a&gt;とか&lt;a href=&#34;http://uhyo.hatenablog.com/entry/2016/04/22/161011&#34;&gt;量子人狼&lt;/a&gt;とか&lt;a href=&#34;https://uhyohyo.net/quantum2048/&#34;&gt;量子2048&lt;/a&gt;とか作ってる人たちが周りにいるから見慣れてるんだよなあなどと思いつつ、順に確定させてから普通のオセロをシミュレートするだけのやるだけ問を3分ぐらいで解いたら驚かれました。&lt;/p&gt;

&lt;p&gt;また他のブースではよくわからないクイズを解くだけでANKERの10000mAhモバイルバッテリー(自分が持っている物の一つ下のモデル)をもらうことができました。&lt;/p&gt;

&lt;h2 id=&#34;つくば&#34;&gt;つくば&lt;/h2&gt;

&lt;p&gt;交通費補助が新幹線代程度出るものの、宿泊施設の提供なしで宿泊補助費は5000円しか出ないので新幹線で行くと大赤字です。
そこでLCCで飛んでいくことで交通費を浮かせて2泊するための宿泊費に充てました(これって書いていいんでしょうか)。&lt;/p&gt;

&lt;p&gt;宿泊施設が用意されなくなったのは今年からとのことですが、ICPC協賛の某企業の方に聞いた話によると、どうもスポンサー費用は例年上がっていく一方らしいです。
よくわかりません。&lt;/p&gt;

&lt;p&gt;そこそこ移動がつらく、朝6時頃には家を出て空港まで行ったかと思えば移動の間に2時間ぐらい待機する必要があったりしました。
また宿はできるだけ安いところを取りましたが、1日目は浴場の給湯器が故障していて使えず、2日目は浴場に入ることはできたものの、あまりにお湯がぬるいので仕方なくサウナで温まるなどすることになりました。&lt;/p&gt;

&lt;p&gt;1日目は部屋に備え付けの浴室を使いましたが、湯を張るために蛇口を開くと汚れの混じった赤っぽい水が出てきたので、無心でシャワーを浴びてそのまま何も考えずに寝ました。&lt;/p&gt;

&lt;h2 id=&#34;3日目&#34;&gt;3日目&lt;/h2&gt;

&lt;p&gt;エクスカーションや企業見学に参加する人に合わせて飛行機を取ったので、3日目は夜まで暇です。
ほとんどの人は企業見学に行ったので、残りの3人で東京観光に行きました。
大洗は非常に遠かったのでやめておいて、VRの体験や靖国神社に行ったりして所々で先輩におごってもらいました。
大荷物を持って長距離を移動した上に懇親会等で立ちっぱなしで疲労が蓄積していたので、夕方はカフェで休憩しながら時間を潰していました。&lt;/p&gt;
      </description>
    </item>
    
  </channel>
</rss>