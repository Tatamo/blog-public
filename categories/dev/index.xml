<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dev on わたしろぐ</title>
    <link>http://tatamo.81.la/blog/categories/dev/</link>
    <description>Recent content in Dev on わたしろぐ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Fri, 07 Dec 2018 23:22:00 +0900</lastBuildDate>
    <atom:link href="/categories/dev/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>atcoder-cli チュートリアル</title>
      <link>http://tatamo.81.la/blog/2018/12/07/atcoder-cli-tutorial/</link>
      <pubDate>Fri, 07 Dec 2018 23:22:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/12/07/atcoder-cli-tutorial/</guid>
      <description>
        &lt;p&gt;&lt;a href=&#34;https://www.npmjs.com/package/atcoder-cli&#34;&gt;atcoder-cli&lt;/a&gt;の使用方法を解説していきます。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;atcoder-cliは、&lt;a href=&#34;https://beta.atcoder.jp/&#34;&gt;AtCoder&lt;/a&gt;用のコマンドラインツールです。
このツールの特徴については、&lt;a href=&#34;http://tatamo.81.la/blog/2018/12/07/atcoder-cli/&#34;&gt;紹介記事&lt;/a&gt;をご覧ください。&lt;/p&gt;

&lt;h2 id=&#34;インストール&#34;&gt;インストール&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ pip3 install online-judge-tools
$ npm install -g atcoder-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;詳細なインストール手順は、&lt;a href=&#34;2018/12/07/atcoder-cli-installation-guide/&#34;&gt;atcoder-cli インストールガイド&lt;/a&gt; を参照してください。&lt;/p&gt;

&lt;h2 id=&#34;atcoder-cliのインストール確認&#34;&gt;atcoder-cliのインストール確認&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;※行頭の「&lt;code&gt;$&lt;/code&gt;」は入力しないでください&lt;/p&gt;

&lt;p&gt;&lt;code&gt;acc&lt;/code&gt;コマンドが使用できれば、インストールは正しく行えています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kmyk/online-judge-tools&#34;&gt;online-judge-tools&lt;/a&gt;がインストールされている場合、atcoder-cliは自動的にそれを検知します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc check-oj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を入力して、availableと表示されれば連携機能が有効になっています。&lt;/p&gt;

&lt;h2 id=&#34;atcoderへのログイン&#34;&gt;AtCoderへのログイン&lt;/h2&gt;

&lt;p&gt;atcoder-cliを使用するためには、初回使用時にAtCoderへのログインが必要になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc login
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンドでAtCoderにログインしてください。
ユーザー名とパスワードの入力を求められますが、パスワードは安全のため入力しても画面には表示されないので注意してください。&lt;/p&gt;

&lt;p&gt;ユーザー名・パスワードはatcoder-cliによって保存されることはありません。
そのかわりにログインセッションの情報が設定ファイルとして保存されますが、共用のPCなどで他の人が使用する可能性がある場合は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc logout
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で現在のログイン状態を破棄することができます。&lt;/p&gt;

&lt;p&gt;ログインしている状態かどうか知るためには、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc session
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を使用してください。&lt;/p&gt;

&lt;p&gt;online-judge-toolsを使用している場合は、&lt;code&gt;oj&lt;/code&gt;コマンドを使用してそちらでもログインしておく必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ oj login https://beta.atcoder.jp/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でログインを行ってください。&lt;/p&gt;

&lt;h2 id=&#34;atcoder-cliでコンテスト用ディレクトリを作成する&#34;&gt;atcoder-cliでコンテスト用ディレクトリを作成する&lt;/h2&gt;

&lt;p&gt;以後、online-judge-toolsを使用している前提とします。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://beta.atcoder.jp/contests/abc101&#34;&gt;ABC101&lt;/a&gt;のコンテストの問題を解くことを想定してみましょう。&lt;/p&gt;

&lt;p&gt;ABC101のURLは &lt;a href=&#34;https://beta.atcoder.jp/contests/abc101&#34;&gt;https://beta.atcoder.jp/contests/abc101&lt;/a&gt; ですが、この末尾の&lt;code&gt;abc101&lt;/code&gt;がこのコンテストのIDとなります。
&lt;code&gt;acc n&lt;/code&gt;コマンドにこのIDを指定することで、ABC101用のディレクトリを作らせてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc new abc101
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンドを実行すると、問題の一覧が表示されます。
上下キーでカーソルを移動し、スペースキーで選択することで、サンプルケースをダウンロードしてくる問題を選ぶことができます。
この問題は後から追加することもできます。
一番上のA問題は予め選択されているはずなので、今回はそのままエンターキーを押しましょう。&lt;/p&gt;

&lt;p&gt;コマンドの実行が完了すると、&lt;code&gt;abc101&lt;/code&gt;という名前のディレクトリが作られていると思います。
このディレクトリの中に移動してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd abc101
$ ls # ディレクトリの中身を表示
a  contest.acc.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;a/&lt;/code&gt;という名前のディレクトリと、&lt;code&gt;contest.acc.json&lt;/code&gt;というファイルが一つ存在していると思います。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;contest.acc.json&lt;/code&gt;は、atcoder-cliがコンテストや問題の情報を取得したり、問題ディレクトリの情報を管理するためのファイルです。
通常の使用中は、このファイルに触る機会はありません。&lt;/p&gt;

&lt;p&gt;ディレクトリ&lt;code&gt;a/&lt;/code&gt;に移動してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd a/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このディレクトリの中には、&lt;code&gt;tests/&lt;/code&gt;という名前のディレクトリが既に存在しています。
&lt;code&gt;online-judge-tools&lt;/code&gt;との連携機能により、自動的に問題のサンプルケースがダウンロードされたものです。&lt;/p&gt;

&lt;p&gt;この&lt;code&gt;a/&lt;/code&gt;ディレクトリの中で、問題を解いていきます。
たとえば、&lt;code&gt;main.cpp&lt;/code&gt;という名前のファイルを作り、&lt;a href=&#34;https://beta.atcoder.jp/contests/abc101/tasks/abc101_a&#34;&gt;A問題&lt;/a&gt;を解くプログラムを書いてみましょう。&lt;/p&gt;

&lt;h2 id=&#34;問題を提出する&#34;&gt;問題を提出する&lt;/h2&gt;

&lt;p&gt;書き終わったら、正しくプログラムが書けているか確認します。&lt;/p&gt;

&lt;p&gt;online-judge-toolsは入出力ケースの自動テスト機能を備えているため、自動ダウンロードされたサンプルケースを用いてテストができます。
現在atcoder-cliはテストに関する機能の連携が未実装のため、詳しくは&lt;a href=&#34;https://kimiyuki.net/blog/2017/01/19/pr-online-judge-tools/&#34;&gt;online-judge-toolsの解説記事&lt;/a&gt;を参照してください。&lt;/p&gt;

&lt;p&gt;問題文で与えられた入力例について正しい答えが得られていることを確認したら、プログラムの提出をしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc submit main.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;atcoder-cliでは、提出するファイルを指定するだけで提出先を自動的に判別します。
たとえば、&lt;code&gt;abc101/a/&lt;/code&gt;ディレクトリの中にあるプログラムはABC101のA問題のプログラムとして提出が行われます。&lt;/p&gt;

&lt;p&gt;提出が完了してA問題を解き終わったら、一つ上のディレクトリに戻りましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;問題用ディレクトリを追加する&#34;&gt;問題用ディレクトリを追加する&lt;/h2&gt;

&lt;p&gt;次はB問題を解いていくので、B問題用の新しいディレクトリを作る必要があります。
コンテストディレクトリの中で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc add
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンドを入力すると、再び問題を選択する画面になります。
先程既にディレクトリを作ったA問題は選択できなくなっています。&lt;/p&gt;

&lt;p&gt;このようにして問題用のディレクトリを作って問題を解いていくのが、atcoder-cliでコンテストに取り組む流れになります。&lt;/p&gt;

&lt;h2 id=&#34;デフォルト動作の設定&#34;&gt;デフォルト動作の設定&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;acc new&lt;/code&gt;コマンドや&lt;code&gt;acc add&lt;/code&gt;コマンドで問題ディレクトリを作成する際、毎回問題を選択してエンターキーを押さないといけないのが煩雑に感じるかもしれません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンドによって、現在のグローバル設定を確認することができます。
この中に、&lt;code&gt;default-task-choice: inquire&lt;/code&gt; と書かれた行があるのではないかと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc config default-task-choice next
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとすることで、問題の選択方法を変更することができます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;next&lt;/code&gt;を指定することで、問題を選ぶ画面を出さずに次の一問だけを自動で選ぶようにしたり、&lt;code&gt;all&lt;/code&gt;を指定することで全ての問題ディレクトリを最初に作るようにできます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;default-task-choice&lt;/code&gt;に設定可能な選択肢については、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc add -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で確認することができます。&lt;/p&gt;

&lt;p&gt;また、グローバル設定で設定可能な項目の一覧は、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc cnfig -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で確認できます。&lt;/p&gt;

&lt;h2 id=&#34;テンプレート設定&#34;&gt;テンプレート設定&lt;/h2&gt;

&lt;p&gt;予めマクロの定義や入力を受け付ける部分などの雛形が書かれたプログラムファイルを用意しておくことで、問題ディレクトリを作成する際にそのファイルをコピーして配置することができます。&lt;/p&gt;

&lt;p&gt;たとえば、C++用のテンプレートを用意するには、まずatcoder-cliの設定ファイルが配置されたディレクトリに移動し、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd `acc config-dir`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここに&lt;code&gt;cpp&lt;/code&gt; という名前のディレクトリを作ります。
テンプレートの名前は、このディレクトリ名によって決定されます。&lt;/p&gt;

&lt;p&gt;その中に、コピーしたい雛形である&lt;code&gt;main.cpp&lt;/code&gt;ファイルと、&lt;code&gt;template.json&lt;/code&gt;ファイルを作成します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;template.json&lt;/code&gt;ファイルには以下のように記述します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;task&amp;quot;:{
    &amp;quot;program&amp;quot;: [&amp;quot;main.cpp&amp;quot;],
    &amp;quot;submit&amp;quot;: &amp;quot;main.cpp&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;template.json&lt;/code&gt;を配置したら、&lt;code&gt;acc templates&lt;/code&gt;コマンドを使ってテンプレートが正常に認識されているか確認します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc templates
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正しく読み込まれていれば、&lt;code&gt;cpp&lt;/code&gt;という名前の項目が表示されます。&lt;/p&gt;

&lt;p&gt;実際にこのテンプレートを利用するには、&lt;code&gt;acc new&lt;/code&gt;コマンドと&lt;code&gt;acc add&lt;/code&gt;コマンドを実行する際に、&lt;code&gt;--template&lt;/code&gt;オプションを使用して使用するテンプレートを指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc add --template cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このようにして問題ディレクトリを作成すると、その中に&lt;code&gt;main.cpp&lt;/code&gt;がコピーされます。
また&lt;code&gt;template.json&lt;/code&gt;の&lt;code&gt;&amp;quot;submit&amp;quot;&lt;/code&gt;プロパティに&lt;code&gt;main.cpp&lt;/code&gt;を設定しているため、問題ディレクトリの中にいる場合は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc submit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように、明示的にファイルを指定しなくても&lt;code&gt;main.cpp&lt;/code&gt;が提出対象のファイルであると判断されます。&lt;/p&gt;

&lt;p&gt;頻繁に使用するテンプレートは、常に&lt;code&gt;--template&lt;/code&gt;オプションをつけるかわりに、グローバル設定からデフォルトのテンプレートとして設定することが可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc config defaullt-template cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これにより、&lt;code&gt;acc new&lt;/code&gt;コマンドと&lt;code&gt;acc add&lt;/code&gt;コマンドの実行時に自動的に&lt;code&gt;cpp&lt;/code&gt;テンプレートが使用されるようになります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;template.json&lt;/code&gt;についてのより詳細な情報は、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc template -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と入力すると知ることができます。&lt;/p&gt;

&lt;h2 id=&#34;その他&#34;&gt;その他&lt;/h2&gt;

&lt;p&gt;使用可能なコマンドの一覧は、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で表示することができます。&lt;/p&gt;

&lt;p&gt;また、コマンドごとの詳細な解説、利用可能なオプションを知るためには、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc &amp;lt;コマンド名&amp;gt; -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を使用してください。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がatcoder-cliの基本的な使い方になります。
このツールによってAtCoderで問題を解く作業の効率化ができることを願っています。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>atcoder-cli インストールガイド</title>
      <link>http://tatamo.81.la/blog/2018/12/07/atcoder-cli-installation-guide/</link>
      <pubDate>Fri, 07 Dec 2018 23:21:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/12/07/atcoder-cli-installation-guide/</guid>
      <description>
        &lt;p&gt;&lt;a href=&#34;https://www.npmjs.com/package/atcoder-cli&#34;&gt;atcoder-cli&lt;/a&gt;のインストール方法を解説していきます。&lt;/p&gt;

&lt;h2 id=&#34;わかる人向け&#34;&gt;わかる人向け&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ pip3 install online-judge-tools
$ npm install -g atcoder-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上です。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;インストールガイド&#34;&gt;インストールガイド&lt;/h2&gt;

&lt;p&gt;atcoder-cliをインストールするためには、Node.js環境が必要です。
また、Python3で動作する&lt;a href=&#34;https://github.com/kmyk/online-judge-tools&#34;&gt;online-judge-tools&lt;/a&gt;を併用することを強く推奨しているため、こちらも同時にインストールします。&lt;/p&gt;

&lt;p&gt;※ 以後、コマンド例の行頭の「&lt;code&gt;$&lt;/code&gt;」はターミナルのプロンプト記号を表しているため、実際に入力する必要はありません。
&lt;code&gt;$&lt;/code&gt;より後の部分を入力して実行してください。&lt;/p&gt;

&lt;h3 id=&#34;事前準備-windowsでwslを使う場合&#34;&gt;事前準備：WindowsでWSLを使う場合&lt;/h3&gt;

&lt;p&gt;Windowsの場合、直接言語環境をインストールする方法と、&lt;abbr title=&#34;Windows Subsystem for Linux&#34;&gt;WSL&lt;/abbr&gt;を使う方法があります。
どちらを使用するかはお好みですが、Linuxの使い方がわかるという方はWSLを選択するとよいでしょう。
WSLを使う場合は設定より有効化し、ストアからUbuntuなどのLinuxディストリビューションをインストールします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参考: &lt;a href=&#34;https://qiita.com/yoshikingt/items/ab86411e6031459db805&#34;&gt;https://qiita.com/yoshikingt/items/ab86411e6031459db805&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;WSLのインストール後は、Linuxの場合のインストール方法を参照してください。&lt;/p&gt;

&lt;h3 id=&#34;事前準備-macの場合&#34;&gt;事前準備：Macの場合&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://brew.sh/index_ja&#34;&gt;Homebrew&lt;/a&gt;の使用を想定します。
&lt;code&gt;brew&lt;/code&gt;コマンドが存在しない場合、以下のコマンドをターミナルで実行することでインストールしてください。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ /usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行が完了したら、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ brew -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンドをターミナルで実行して、エラーなどが起きずにHomebrewのバージョン名が表示されていることを確認してください。&lt;/p&gt;

&lt;h3 id=&#34;必要な環境のインストール&#34;&gt;必要な環境のインストール&lt;/h3&gt;

&lt;p&gt;Python3とNode.jsの両方をインストールしてください。
OSごとにインストール方法が違うため、お使いのOSの欄を参照してください。&lt;/p&gt;

&lt;p&gt;環境によってはもう少し良いやり方がある場合もありますが、この記事では少ない手順でインストールが完了することを目的として方法を選んでいます。&lt;/p&gt;

&lt;h4 id=&#34;windows&#34;&gt;Windows&lt;/h4&gt;

&lt;h5 id=&#34;python3&#34;&gt;Python3&lt;/h5&gt;

&lt;p&gt;公式インストーラーより&lt;a href=&#34;https://www.python.org/downloads/windows/&#34;&gt;Python&lt;/a&gt;をインストールします。
最新バージョンの&amp;rdquo;Download Windows x86-64 web-based installer&amp;rdquo;からインストーラーをダウンロードし、実行してください。
インストール時に、&amp;rdquo;Add Python 3.x to PATH&amp;rdquo;のチェックを忘れずに入れるようにしましょう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参考: &lt;a href=&#34;https://azriton.github.io/2017/07/25/Python-3.6-64bit%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/&#34;&gt;https://azriton.github.io/2017/07/25/Python-3.6-64bit%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;node-js&#34;&gt;Node.js&lt;/h5&gt;

&lt;p&gt;公式インストーラーより&lt;a href=&#34;https://nodejs.org/ja/download/&#34;&gt;Node.js&lt;/a&gt;をインストールします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参考: &lt;a href=&#34;https://qiita.com/taiponrock/items/9001ae194571feb63a5e&#34;&gt;https://qiita.com/taiponrock/items/9001ae194571feb63a5e&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;mac-linux&#34;&gt;Mac/Linux&lt;/h4&gt;

&lt;p&gt;端末コンソールを開いて作業をしてください。&lt;/p&gt;

&lt;h5 id=&#34;python3-1&#34;&gt;Python3&lt;/h5&gt;

&lt;p&gt;Linuxの場合は、&lt;code&gt;brew&lt;/code&gt;のかわりにディストリビューションごとのパッケージマネージャを使用してください。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ # Macの場合はこちらを実行してください
$ brew install python3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ # UbuntuまたはDebianを使用している場合はこちらを実行してください
$ # 他のLinuxディストリビューションを使っている人はこんな記事を読むまでもなくインストールを終わらせていると思われるため触れません
$ sudo apt-get install python3
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;node-js-1&#34;&gt;Node.js&lt;/h5&gt;

&lt;p&gt;パッケージマネージャによって古いバージョンのNodeしか手に入らないことがあるので、&lt;a href=&#34;https://github.com/creationix/nvm&#34;&gt;nvm&lt;/a&gt;を使ってインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコマンドの実行が完了したら、一度ターミナルを閉じてください。
新しいターミナルを開き、続きのコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ nvm install node
$ npm install -g npm
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;atcoder-cli-online-judge-toolsのインストール&#34;&gt;atcoder-cli, online-judge-toolsのインストール&lt;/h3&gt;

&lt;p&gt;言語環境のインストールが正しく行われていることを確認します。
Windowsの場合はコマンドプロンプトを、Mac/Linuxの場合は端末コンソールを開いてください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip3 -V
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と入力してエンターキーを押し、バージョン番号が表示されることを確認してください。&lt;/p&gt;

&lt;p&gt;同様にして、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行し、バージョン番号が表示されることを確認してください。&lt;/p&gt;

&lt;p&gt;「コマンドが見つかりません」や「command not found」、それに似たメッセージが表示される場合はPython3およびNode.jsのインストールに失敗している可能性があります。
その場合は再度手順を確認してインストールし直したり、「Python3 インストール (+OS名)」などで検索して調べてください。&lt;/p&gt;

&lt;p&gt;問題がなかった場合は、atcoder-cliおよびonline-judge-toolsのインストールを行います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g atcoder-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;pip3 install online-judge-tools
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とそれぞれ入力してエンターキーを押すことで、atcoder-cliとonline-judge-toolsがインストールされます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;acc -h
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;oj -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とそれぞれ入力し、ヘルプが表示されることを確認してください。&lt;/p&gt;

&lt;p&gt;ここまででインストール作業は完了です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;2018/12/07/atcoder-cli-tutorial/&#34;&gt;atcoder-cli チュートリアル&lt;/a&gt;に進み、atcoder-cliの基本的な使い方を確認しましょう。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>コマンドラインツールatcoder-cliを公開しました</title>
      <link>http://tatamo.81.la/blog/2018/12/07/atcoder-cli/</link>
      <pubDate>Fri, 07 Dec 2018 23:20:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/12/07/atcoder-cli/</guid>
      <description>
        &lt;p&gt;&lt;a href=&#34;https://beta.atcoder.jp/&#34;&gt;AtCoder&lt;/a&gt;のためのコマンドラインツール、&lt;a href=&#34;https://www.npmjs.com/package/atcoder-cli&#34;&gt;atcoder-cli&lt;/a&gt;をリリースしました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;2018/12/07/atcoder-cli-installation-guide/&#34;&gt;インストールガイド&lt;/a&gt;と&lt;a href=&#34;2018/12/07/atcoder-cli-tutorial/&#34;&gt;チュートリアル&lt;/a&gt;の記事も用意しています。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;モチベーション&#34;&gt;モチベーション&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://beta.atcoder.jp/&#34;&gt;AtCoder&lt;/a&gt;のコンテストで問題を解く際に、問題用のディレクトリを作る、プログラム用のファイルを用意する、問題を解き終わったらソースコードをコピーして提出するなど、プログラムを書く以外の部分で手間がかかることがあります。
そのため、問題を提出する、プログラムがサンプルケースで失敗しないかチェックする、問題を解くのに必要なファイルやディレクトリを構築する、といった処理をコマンドラインから実行できればコンテスト中の処理の自動化が可能になり、快適に問題を解くことができるようになります。&lt;/p&gt;

&lt;p&gt;コマンドラインからAtCoderに問題を提出したりするツールとしては、&lt;a href=&#34;https://github.com/kmyk/online-judge-tools&#34;&gt;online-judge-tools&lt;/a&gt;などが存在します。&lt;/p&gt;

&lt;p&gt;とはいえ、既存のツールでは複数のコンテストサイトを動作対象としていることなどから、「プログラムを提出するたびに提出先の問題IDやURLを指定しなければならない」といった問題点がありました。
提出ファイルのコピペなどの手間を省くためにコマンドラインツールを使っているはずなのに、その提出先を指定するためにURLをブラウザからコピーしてくる必要があるのでは本末転倒感があります。&lt;/p&gt;

&lt;p&gt;また、問題を一問解く度にプログラムのテンプレートを用意したり、既存ツールを用いてサンプルケースをダウンロードしてくるのも手間がかかります。&lt;/p&gt;

&lt;p&gt;そこで、数ある競技プログラミングのサイトの中からAtCoderに特化することで、コンテスト中にコンソールに打ち込むコマンドの数を極限まで減らせるようにするツールとして、&lt;a href=&#34;https://www.npmjs.com/package/atcoder-cli&#34;&gt;atcoder-cli&lt;/a&gt;を開発しました。&lt;/p&gt;

&lt;p&gt;atcoder-cliはディレクトリ構成から自動的に提出するコンテスト・問題を検出し、短いコマンドの入力だけで問題を提出できるようにするのみならず、テンプレートを自動的に展開する機能などを備えており、AtCoder用のプロジェクト管理ツールとしても機能するソフトウェアです。
また、online-judge-toolsとの連携によって、サンプルケースの自動ダウンロードなどの機能を余計なURL指定なしで快適に使用できるようになります。&lt;/p&gt;

&lt;h2 id=&#34;インストール方法&#34;&gt;インストール方法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ npm install -g atcoder-cli
$ acc -v # 正しくインストールされたかどうか確認する
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;atcoder-cliはnpmパッケージとして公開しているため、node.jsが必要です。
また、&lt;a href=&#34;https://github.com/kmyk/online-judge-tools&#34;&gt;online-judge-tools&lt;/a&gt;はインストールされていなくても問題なく動作しますが、連携機能のため同時にインストールしておくことを強く推奨します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;2018/12/07/atcoder-cli-installation-guide/&#34;&gt;atcoder-cli インストールガイド&lt;/a&gt;を公開していますので、詳しいインストール手順はそちらをお読みください。&lt;/p&gt;

&lt;h2 id=&#34;特徴&#34;&gt;特徴&lt;/h2&gt;

&lt;p&gt;詳細な機能については&lt;a href=&#34;https://github.com/Tatamo/atcoder-cli&#34;&gt;README&lt;/a&gt;や&lt;code&gt;acc [COMMAND] -h&lt;/code&gt;コマンドを参照してください。
日本語の解説記事として、&lt;a href=&#34;2018/12/07/atcoder-cli-tutorial/&#34;&gt;atcoder-cli チュートリアル&lt;/a&gt;があります。&lt;/p&gt;

&lt;h3 id=&#34;コンテスト情報取得&#34;&gt;コンテスト情報取得&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;$ acc contest abc100
AtCoder Beginner Contest 100  https://beta.atcoder.jp/contests/abc100
$ acc tasks abc100
A  Happy Birthday!           https://beta.atcoder.jp/contests/abc100/tasks/abc100_a
B  Ringo&#39;s Favorite Numbers  https://beta.atcoder.jp/contests/abc100/tasks/abc100_b
C  *3 or /2                  https://beta.atcoder.jp/contests/abc100/tasks/abc100_c
D  Patisserie ABC            https://beta.atcoder.jp/contests/abc100/tasks/abc100_d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CLIツールとして、問題のURLなどをコマンドラインから取得できます。他のシェルコマンドと組み合わせることで、AtCoderに関連する処理を自動化する際に役立てることができます。&lt;/p&gt;

&lt;h3 id=&#34;コンテスト用ディレクトリ作成&#34;&gt;コンテスト用ディレクトリ作成&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ acc new abc100 # abc100用のディレクトリを作成
$ cd abc100
$ cat contest.acc.json
{
  &amp;quot;contest&amp;quot;: {
    &amp;quot;id&amp;quot;: &amp;quot;abc100&amp;quot;,
    &amp;quot;title&amp;quot;: &amp;quot;AtCoder Beginner Contest 100&amp;quot;,
    &amp;quot;url&amp;quot;: &amp;quot;https://beta.atcoder.jp/contests/abc100&amp;quot;
  },
  &amp;quot;tasks&amp;quot;: [
    {
      &amp;quot;id&amp;quot;: &amp;quot;abc100_a&amp;quot;,
      &amp;quot;label&amp;quot;: &amp;quot;A&amp;quot;,
      &amp;quot;title&amp;quot;: &amp;quot;Happy Birthday!&amp;quot;,
      &amp;quot;url&amp;quot;: &amp;quot;https://beta.atcoder.jp/contests/abc100/tasks/abc100_a&amp;quot;,
      &amp;quot;directory&amp;quot;: {
        &amp;quot;path&amp;quot;: &amp;quot;a&amp;quot;,
        &amp;quot;testdir&amp;quot;: &amp;quot;tests&amp;quot;
      }
    },
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;atcoder-cliでは、コンテストごとにディレクトリを作成してプログラムを管理します。
デフォルトではコンテストディレクトリ内でさらに問題ごとにディレクトリを分け、その中で問題を解いていくことを想定していますが、コンテストディレクトリ直下でディレクトリを分けずに複数のプログラムファイルを配置することもサポートしています。&lt;/p&gt;

&lt;p&gt;この際に、以下のような処理を自動的に行うことができます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;サンプルケースの自動ダウンロード (online-judge-toolsが必要)&lt;/li&gt;
&lt;li&gt;テンプレートを予め用意しておくことで、プログラム等のファイルを問題ディレクトリにコピー&lt;/li&gt;
&lt;li&gt;任意のシェルコマンドを実行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらを組み合わせることで、コンテスト用ディレクトリを作成した時点であらゆる前準備を終えることができます。&lt;/p&gt;

&lt;h3 id=&#34;提出機能&#34;&gt;提出機能&lt;/h3&gt;

&lt;p&gt;atcoder-cli本体は今のところAtCoderにファイルを提出する機能を備えていませんが、内側でonline-judge-toolsを呼び出すことにより、もともとのonline-judge-toolsの機能よりもさらに簡単に問題を提出することができるようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ oj s https://beta.atcoder.jp/contests/abc100/tasks/abc100_a main.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;online-judge-toolsでは問題の提出のために上記のコマンドが必要でしたが、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ acc s main.cpp # s はsubmitの省略名
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;atcoder-cliはファイルが配置されたディレクトリから自動的に提出するべき問題を判別し、URLなどを明示する必要がなくなっています。&lt;/p&gt;

&lt;p&gt;さらに、問題テンプレート機能を使用すれば提出するプログラムのファイル名を予め指定しておくことができるため、以下のように一切の引数を与えることなく提出が可能になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ acc s # これだけで提出ができる！
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;高速な応答性&#34;&gt;高速な応答性&lt;/h3&gt;

&lt;p&gt;レスポンスの速さはCLIツールにとって重要な要素であるため、依存パッケージのロードを必要なタイミングまで遅延させることで、そのコマンドの実行時に使用されないパッケージの読み込みを防止して応答性を高めています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ time acc -h
...
real    0m0.093s
user    0m0.080s
sys     0m0.008s
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;類似ツール&#34;&gt;類似ツール&lt;/h2&gt;

&lt;h3 id=&#34;kmyk-online-judge-tools-https-github-com-kmyk-online-judge-tools&#34;&gt;&lt;a href=&#34;https://github.com/kmyk/online-judge-tools&#34;&gt;kmyk/online-judge-tools&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;AtCoderに限定せず様々なサイトに対応

&lt;ul&gt;
&lt;li&gt;それ故にややコマンドのタイプ数が増えやすい傾向にある&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;テストツールとしての機能も有する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;atcoder-cliは現状online-judge-toolsにどっぷり依存しているので頭が上がりません。
便利なツールを作って頂いてありがとうございます。&lt;/p&gt;

&lt;p&gt;とはいえatcoder-cliはnpm, ojはpipでインストールしないといけないため、atcoder-cli単体で同等の機能が提供できたほうがインストールの手間は減ると思うので好ましいのかもしれません(サンプルケースの取得はアドホックにやらざるを得ないし、提出ファイルの言語指定も割とつらさがあるので既にあるものをあまり再実装したくない)。&lt;/p&gt;

&lt;h3 id=&#34;nodchip-onlinejudgehelper-https-github-com-nodchip-onlinejudgehelper&#34;&gt;&lt;a href=&#34;https://github.com/nodchip/OnlineJudgeHelper&#34;&gt;nodchip/OnlineJudgeHelper&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;様々なサイトに対応、多機能&lt;/li&gt;
&lt;li&gt;outdated&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;URLをすべて入力しなくても、コンテストID+問題IDでの提出ができるため少しは楽です。
年単位でメンテナンスされていなかったり、アカウントのパスワードをローカルに置いておくことを求められたりするので、今使うには微妙かもしれません。&lt;/p&gt;

&lt;h3 id=&#34;xmlpro-atam-https-github-com-xmlpro-atam&#34;&gt;&lt;a href=&#34;https://github.com/XMLPro/atam&#34;&gt;XMLPro/atam&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;AtCoder用の問題提出ツール&lt;/li&gt;
&lt;li&gt;node.jsで動作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;AtCoder専用のツールで、現状では問題提出のみの機能を持っています。
npmからインストールすることができ、連携が比較的容易と思われるので、今後連携機能の実装を行うかもしれません。&lt;/p&gt;

&lt;h2 id=&#34;contribution&#34;&gt;Contribution&lt;/h2&gt;

&lt;p&gt;バグ報告、要望などは&lt;a href=&#34;https://github.com/Tatamo/atcoder-cli/issues&#34;&gt;https://github.com/Tatamo/atcoder-cli/issues&lt;/a&gt;で受け付けています。&lt;/p&gt;

&lt;h2 id=&#34;余談&#34;&gt;余談&lt;/h2&gt;

&lt;p&gt;このツールが良いと思っていただけましたら、ぜひ&lt;strong&gt;&lt;a href=&#34;https://github.com/Tatamo/atcoder-cli&#34;&gt;★Starをください&lt;/a&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;というのも、AtCoder勢で利用していない人はほとんどいないであろう&lt;a href=&#34;https://kenkoooo.com/atcoder/&#34;&gt;AtCoder Problems&lt;/a&gt;が、その圧倒的な知名度と比較して&lt;a href=&#34;https://github.com/kenkoooo/AtCoderProblems&#34;&gt;GitHubリポジトリ&lt;/a&gt;についている★の数があまりに少ないのではないか、という話があります。&lt;/p&gt;

&lt;p&gt;★とはTwitterの&lt;del&gt;ふぁぼ&lt;/del&gt;いいねのようなものです。
競プロ勢はGitHubの使い方もよくわからないのだ、という不名誉な評判がつきかねませんから、ぜひ良いと思ったリポジトリには★を投げてみましょう。&lt;/p&gt;

&lt;p&gt;ここに&lt;a href=&#34;https://github.com/Tatamo/atcoder-cli&#34;&gt;良い練習台 (Tatamo/atcoder-cli)&lt;/a&gt;がありますね。&lt;/p&gt;

&lt;p&gt;GitHubのアカウントを持っていない方は、有効なメールアドレスとユーザー名、パスワードだけあれば&lt;a href=&#34;https://github.com/join&#34;&gt;https://github.com/join&lt;/a&gt;から簡単にアカウントの作成を行うことができます。
(&lt;a href=&#34;https://www.google.co.jp/search?q=github+登録&#34;&gt;参考&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;ログインができたら&lt;a href=&#34;https://github.com/Tatamo/atcoder-cli&#34;&gt;適当なソフトウェア (Tatamo/atcoder-cli)&lt;/a&gt;のページに行き、ページの上の方にある「★Star」をクリック/タップするだけで★をつけることができます。&lt;/p&gt;

&lt;p&gt;(露骨な宣伝で申し訳ありません。
私のツールに★を投げる必要はありませんが、AtCoder Problemsは実際もっと★がついていてもよいのではと思っています。
皆さんどんどんGitHubで★を投げあいましょう)&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>JavaScript/TypeScriptで競技プログラミングをするには 後編</title>
      <link>http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-02/</link>
      <pubDate>Fri, 09 Feb 2018 19:30:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-02/</guid>
      <description>
        &lt;p&gt;主要コンテストサイトのJavaScript対応状況、および私がJavaScript/TypeScriptで競技プログラミングをする時に気をつけていることなどを書きます。
今回は後者についてです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-01/&#34;&gt;前回の記事&lt;/a&gt;ではコンテストサイトのJavaScript対応状況をメインに書きました。
この記事では、実際にJavaScript/TypeScriptで競技プログラミングをする際に気をつけている点について書いていきます。&lt;/p&gt;

&lt;h2 id=&#34;競技プログラミングにおけるjavascriptの致命的な問題点&#34;&gt;競技プログラミングにおけるJavaScriptの致命的な問題点&lt;/h2&gt;

&lt;p&gt;残念ながら、JavaScriptが競技プログラミングに向いていない理由となる仕様がいくつか存在します。&lt;/p&gt;

&lt;h3 id=&#34;末尾再帰最適化が実装されていない上にコールスタック上限が小さく-変更できない&#34;&gt;末尾再帰最適化が実装されていない上にコールスタック上限が小さく、変更できない&lt;/h3&gt;

&lt;p&gt;JavaScriptではPythonの&lt;code&gt;sys.setrecursionlimit()&lt;/code&gt;のように再帰呼び出し回数の最大値を変更することができません。
コールスタックの上限は処理系に依存しますが、たとえばnode.js v5.12.0 (x64)では15712です。
また、末尾再帰最適化はES2015の仕様に盛り込まれていた内容ですが、現在においてもこれを実装している処理系は非常に少ないのが現状です。&lt;/p&gt;

&lt;p&gt;これらの要因のため、要素数が数万程度の何かに対して手っ取り早く再帰でDFSを書こうとすると、ほぼ間違いなくMaximum call stack size exceededで落ちます。
自分で配列をスタックとして使ってBFSと同じような書き方で書くか、DFS専用のイテレータでも自作しましょう。&lt;/p&gt;

&lt;h3 id=&#34;64bit整数値を扱う手段が存在しない&#34;&gt;64bit整数値を扱う手段が存在しない&lt;/h3&gt;

&lt;p&gt;JavaScriptのすべての数値は、いわゆるdouble型で保持されています。
&lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt;で確認できますが、整数値としての精度が保証される最大値は2^53-1までです。
これはおよそ9.0*10^15程度なので、入力中に10^18ぐらいの数値が与えられるとその時点で詰みです。&lt;/p&gt;

&lt;p&gt;まあ&lt;a href=&#34;https://github.com/broofa/node-int64&#34;&gt;Int64&lt;/a&gt;とか&lt;a href=&#34;https://github.com/silentmatt/javascript-biginteger&#34;&gt;biginteger&lt;/a&gt;的なものを使う・作るしかないです。&lt;/p&gt;

&lt;p&gt;余談ですが、JavaScriptは歴史的経緯から複数のJavaScriptファイルをまとめて一つのソースコードとすることが頻繁に行われているため、browserifyやwebpackといったツールを使えばサードパーティのライブラリを使うことは割と平気で可能です(ソースコード上限を越えなければ)。
しかし競技プログラミング的にどうなのかよくわからないので、私は今のところ自作以外のライブラリを使ったことはないです。&lt;/p&gt;

&lt;p&gt;まあできないことを気にしても仕方がありませんので、以上のような問題点が存在することを把握しておく、ということが大切です。&lt;/p&gt;

&lt;h2 id=&#34;入出力テンプレート&#34;&gt;入出力テンプレート&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import * as fs from &amp;quot;fs&amp;quot;;

const input = (fs.readFileSync(&amp;quot;/dev/stdin&amp;quot;, &amp;quot;utf8&amp;quot;) as string).split(&amp;quot;\n&amp;quot;);
const n = +input[0];
// const [n] = input[0].split(&amp;quot; &amp;quot;).map((x: string): number =&amp;gt; +x);
const a = [];
for(let i=0;i&amp;lt;n;i++){
	a.push(input[i+1].split(&amp;quot; &amp;quot;).map((x:string):number=&amp;gt;+x));
}

console.log(input);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;入力部分は多少長くなってしまうので、テンプレートを用意しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;N M
A1 A2 ... A3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような入力に対しては、少し書き換えて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;const [n, m] = input[0].split(&amp;quot; &amp;quot;).map((x: string): number =&amp;gt; +x);
const a = input[1].split(&amp;quot; &amp;quot;).map((x: string): number =&amp;gt; +x);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすれば対応できます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fs.readFileSync(&amp;quot;/dev/stdin&amp;quot;, &amp;quot;utf8&amp;quot;)&lt;/code&gt;部分がWindowsでは動かない気がするので、適当にUNIX環境を用意しましょう。&lt;/p&gt;

&lt;p&gt;package.jsonやtsconfig.jsonについては、&lt;a href=&#34;https://github.com/Tatamo/comp/tree/master/template/ts&#34;&gt;このへん&lt;/a&gt;に上げています。&lt;/p&gt;

&lt;h2 id=&#34;typescript-複数のプログラムを同時にコンパイルする際の注意&#34;&gt;(TypeScript) 複数のプログラムを同時にコンパイルする際の注意&lt;/h2&gt;

&lt;p&gt;npm scripts等で自動コンパイルを行っている場合などに、&lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/modules.html&#34;&gt;モジュール&lt;/a&gt;でない複数のTypeScriptプログラムを同時にコンパイルすると、すべてのプログラムの変数が同一スコープ上で扱われるため、&lt;code&gt;input&lt;/code&gt;などの変数が衝突してエラーになります。&lt;/p&gt;

&lt;p&gt;これは、それぞれのプログラムがモジュールであると認識されれば解決されます。
そのためのワークアラウンドとして、1行目でfsを取得する際に&lt;code&gt;require()&lt;/code&gt;ではなく&lt;code&gt;import&lt;/code&gt;文を使うようにしています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import * as fs from &amp;quot;fs&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;export&lt;/code&gt;を行っていなくても、TypeScript的にはこれだけでモジュールとして扱われるようなので、複数のプログラムを同時にコンパイルすることができるようになります。&lt;/p&gt;

&lt;h2 id=&#34;array-prototype-shift-の計算量はo-n&#34;&gt;Array.prototype.shift()の計算量はO(n)&lt;/h2&gt;

&lt;p&gt;JavaScriptで計算量について触れられている資料は少ないので、下手をすると&lt;a href=&#34;http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.shift&#34;&gt;仕様書&lt;/a&gt;まで見に行かないと気付けないのですが、&lt;code&gt;shift()&lt;/code&gt;の計算量はO(n)です。
inputに10万行程度の入力を入れて、先頭から1行ずつ&lt;code&gt;shift()&lt;/code&gt;で取り出すと、それだけで2秒が過ぎます。
&lt;code&gt;push()&lt;/code&gt;および&lt;code&gt;pop()&lt;/code&gt;は高速でできるので、普通の配列はスタックとしてのみ使用し、キューは自前で実装する必要があります。&lt;/p&gt;

&lt;p&gt;参考までに、私は次のようなコードを使用しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;export default class Queue&amp;lt;T&amp;gt; {
	private _in: Array&amp;lt;T&amp;gt;;
	private _out: Array&amp;lt;T&amp;gt;;

	get length(): number {
		return this._in.length + this._out.length;
	}

	constructor(iterable?: Iterable&amp;lt;T&amp;gt;) {
		this._in = iterable === undefined ? new Array&amp;lt;T&amp;gt;() : [...iterable];
		this._out = new Array&amp;lt;T&amp;gt;();
	}

	private _fix() {
		this._out = this._in.reverse().concat(this._out);
		this._in = new Array&amp;lt;T&amp;gt;();
	}

	push(...values: Array&amp;lt;T&amp;gt;): void {
		this._in.push(...values);
	}

	shift(): T | undefined {
		if (this._out.length === 0) this._fix();
		return this._out.pop();
	}

	toArray(): Array&amp;lt;T&amp;gt; {
		this._fix();
		return this._out.slice().reverse();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;array-prototype-fill-は同一オブジェクトで埋められる&#34;&gt;Array.prototype.fill()は同一オブジェクトで埋められる&lt;/h2&gt;

&lt;p&gt;まあこれは気付かなかった私がよくないという例ですが、一応。&lt;/p&gt;

&lt;p&gt;0埋めされた3×3の二次元配列を用意しようとして、次のようなコードを書いたとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const a = new Array(3).fill(new Array(3).fill(0));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあ確かに0埋めされた3×3の二次元配列は得られますが、a[0]とa[1]とa[2]は同じ一次元配列を参照しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;a[0][0] = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすると、aの中身は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[[1,0,0]
 [1,0,0]
 [1,0,0]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となってしまいます。
そのため、多次元配列を初期化するときは横着せずにforで回すようにするか、適当な要素を入れてからmapで埋めます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const a = new Array(3);
for(let i=0; i&amp;lt;3; i++){
	a[i].push(new Array(3).fill(0));
}

const a = new Array(3).fill([]).map(()=&amp;gt;new Array(3).fill());
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;以上が、私がJavaScript/TypeScriptで競技プログラミングをする際に気をつけている点です。&lt;/p&gt;

&lt;p&gt;こうして書き出してみると、数値が大きくなると詰むとか再帰がろくに使えないだとかでろくな言語じゃないなという感じですね。
競技プログラミングの問題自体がC/C++で解くことを想定されている節があるので、仕方のないことではあります。&lt;/p&gt;

&lt;p&gt;とはいえ、以上のことさえ気に留めていれば、JavaScript/TypeScriptを使っていることが原因で詰むことはほとんどないと思います。
JavaScriptそのものは非常に書きやすい言語なので、ハマりどころを把握した上で選択肢にしていただける方が増えればいいなと思っています。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>JavaScript/TypeScriptで競技プログラミングをするには 前編</title>
      <link>http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-01/</link>
      <pubDate>Fri, 09 Feb 2018 17:25:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-01/</guid>
      <description>
        &lt;p&gt;主要コンテストサイトのJavaScript対応状況、および私がJavaScript/TypeScriptで競技プログラミングをする時に気をつけていることなどを書きます。
今回は前者についてです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;追記：&lt;a href=&#34;http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-02/&#34;&gt;後編&lt;/a&gt;書きました。&lt;/p&gt;

&lt;p&gt;競技プログラミングをやるのにC++を選択しない時点で物好きという気はしますが、私は普段からTypeScriptをメインに使って問題を解いています。
この前AtCoder Problemsに&lt;a href=&#34;http://kenkoooo.com/atcoder/?kind=lang&#34;&gt;Language Owners Ranking&lt;/a&gt;ができていたので見てみたらTypeScriptで1位を取っていました(2018年2月時点)。
ちなみにJavaScriptランカーのAC数と比較すると3位にも入れていません。&lt;/p&gt;

&lt;p&gt;AtCoderレーティングは水色、コンテスト参加回数もぎりぎり二桁に達する程度で、あまり真面目にやっているほうではないので参考になるかどうかはわかりませんが、JavaScriptまたはTypeScriptで競技プログラミングをするときに気をつけるべき点などを書いていきます。&lt;/p&gt;

&lt;h2 id=&#34;javascriptで競技プログラミングをすることについて&#34;&gt;JavaScriptで競技プログラミングをすることについて&lt;/h2&gt;

&lt;p&gt;こんな記事を書いていて言うのもどうかと思いますが、他の言語ではなくJavaScriptを競技プログラミングに使用することに、何かメリットはあるのか？と聞かれれば、おそらく目立った利点を挙げることはできないと思います。&lt;/p&gt;

&lt;p&gt;とはいえ、&lt;code&gt;function&lt;/code&gt;だらけの黒魔術のようなコードとスクリプト言語特有の遅さは、ここ数年のJavaScriptの目覚ましい進化によって克服されてきています。
現在のJavaScript処理系はJITコンパイルが主流のため、C++やJavaのような言語には敵わないとはいえ、PythonやRubyのようなスクリプト言語よりも圧倒的に高速です。
またECMAScript2015の登場により、もはや&lt;code&gt;function&lt;/code&gt;と書く必要はなくなりました。&lt;/p&gt;

&lt;p&gt;もっとも、JavaScriptが競技プログラミングに不向きな理由もいくつか存在することは事実です(次の記事で紹介します)。
ですが、近年のJavaScriptが以前とは見違えるほどに書きやすい言語になったことから、決して選択肢に入らない言語ではないと私は考えています。&lt;/p&gt;

&lt;p&gt;JavaScriptを使用する最大のモチベーションは、それが書きやすい・手慣れた言語であるからという点に尽きると思いますが、これは重要なことです。&lt;/p&gt;

&lt;h2 id=&#34;コンテストサイトのモダンjavascriptやtypescript対応状況&#34;&gt;コンテストサイトのモダンJavaScriptやTypeScript対応状況&lt;/h2&gt;

&lt;p&gt;JavaScript/TypeScriptで競技プログラミングをするためには、コンテストサイトのオンラインジャッジシステムが少なくともJavaScriptに対応している必要があります。
特にJavaScriptという言語は、ECMAScript2015の策定によって言語仕様が大きく拡張され、その後もECMAScript2016, ECMAScript2017と機能追加が進んでおり、ここ数年間での移り変わりが非常に激しい言語であるため、言語環境が整備されていることの重要性は大きいです。&lt;/p&gt;

&lt;p&gt;ACM-ICPCではC/C++, Java, Python2/3しか使えないのは周知の事実ですが、比較的多くの言語に対応しているコンテストサイトであってもJavaScriptの対応が行き届いていないのが現状です。&lt;/p&gt;

&lt;p&gt;まずは、日本である程度知名度がある(と思われる)コンテストサイトについて、2018年2月現在でのJavaScriptの対応状況を見ていきたいと思います。
なおTopCoderはJavaScript非対応のため除外しています。&lt;/p&gt;

&lt;h3 id=&#34;atcoder-http-atcoder-jp&#34;&gt;&lt;a href=&#34;http://atcoder.jp/&#34;&gt;AtCoder&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript node v5.12.0&lt;/li&gt;
&lt;li&gt;TypeScript 2.1.6&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TypeScriptについてはnode.jsのバージョンが記載されていなかったのですが、おそらく5.12.0であると思われます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://node.green&#34;&gt;node.green&lt;/a&gt;によると、5.12.0ではES2015の対応率は59%程度となっており、次の項目の6.4.0で対応率が95%まで上昇していることを見ると残念な感じです。
しかしAtCoderで注目するべきは、オンラインジャッジ系のサイトでは非常に珍しく、TypeScriptに対応していることです。
たとえば、分割代入構文はnode.js v5.12.0では未対応のため、以下のコードはシンタックスエラーとなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const [a, b, ...c] = [1, 2, 3, 4, 5];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかしこれをTypeScript2.1.6に食わせると、勝手にES5(= Bad Old DaysのJavaScript)仕様にpolyfillしてトランスパイルしてくれるため、以下のJavaScriptコードが生成されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var _a = [1, 2, 3, 4, 5], a = _a[0], b = _a[1], c = _a.slice(2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;つまり言語欄でTypeScriptを選択することで、ES2015の仕様をもう少し多く使うことができるようになります。&lt;/p&gt;

&lt;p&gt;もっともProxyなんかは全く使うことができないのですが、とはいえSet・Map、class、アロー関数および分割代入が使えるので、競技プログラミングで用いる範囲内なら十分にモダンなJavaScriptを書くことができます。
コンパイラオプションなしでTypeScript2.1.6にSetやMapを食わせると&lt;code&gt;Cannot find name &#39;Map&#39;.&lt;/code&gt;等のエラーが出たような気もするのですが、AtCoder上だと特にエラーメッセージは表示されずに無理矢理動かしてくれます。&lt;/p&gt;

&lt;p&gt;TypeScriptはJavaScriptの完全なスーパーセットであるため、すべてのJavaScriptコードはTypeScriptコードとみなすことができます。
TypeScriptの仕様を全く使っていないJavaScriptを書いたとしても、AtCoderではTypeScriptとして提出することをおすすめします。&lt;/p&gt;

&lt;p&gt;なんともいえない感じですが、これでもモダンJavaScriptの対応状況としてはよっぽどマシなほうです。&lt;/p&gt;

&lt;h3 id=&#34;yukicoder-https-yukicoder-me&#34;&gt;&lt;a href=&#34;https://yukicoder.me/&#34;&gt;yukicoder&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;(正直ここがどれくらいの知名度があるのかあまり把握していませんが)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript node v9.2.1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;調べた中で最も最新バージョンに近く、ES2017までのほぼすべての機能が使用可能なJavaScript環境が用意されています。
モダンなJavaScriptを書きながら競技プログラミングを楽しみたいなら、このサイトはおすすめといえます。
TypeScriptには対応していませんが、まあトランスパイルされた.jsファイルを提出すれば済む話でしょう。&lt;/p&gt;

&lt;h3 id=&#34;aizu-online-judge-http-judge-u-aizu-ac-jp-onlinejudge&#34;&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/&#34;&gt;AIZU ONLINE JUDGE&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript node 0.10.36&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/AOJ_tutorial.pdf&#34;&gt;http://judge.u-aizu.ac.jp/onlinejudge/AOJ_tutorial.pdf&lt;/a&gt; に書いてありました。&lt;/p&gt;

&lt;p&gt;ほぼ完全なES5時代の遺物です。
どうしてもJavaScriptが書きたいなら、babel-polyfillあたりをかませてJavaScriptからさらに古い時代のJavaScriptにトランスパイルして提出するのがいいでしょう。&lt;/p&gt;

&lt;h3 id=&#34;codeforces-http-codeforces-com&#34;&gt;&lt;a href=&#34;http://codeforces.com/&#34;&gt;Codeforces&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript V8 4.8.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;node.jsを使っていただきたいところです。
V8 4.8.0はnode.jsでは5.12と6.0.0の間ぐらいなので、ES2015の対応状況ではAtCoderのやや上といったところです。古いことにかわりはありませんが。&lt;/p&gt;

&lt;p&gt;最大の問題点は、標準入出力の方法がnode.jsとは全く異なるという点です。
node.jsでは&lt;code&gt;console.log()&lt;/code&gt;で出力しますが、V8の場合は&lt;code&gt;print()&lt;/code&gt;か&lt;code&gt;write()&lt;/code&gt;になります。&lt;/p&gt;

&lt;p&gt;JavaScriptの処理系としてnode.jsを使わずにわざわざV8を生で叩いている人間ってどれくらいいるんでしょうか？
ちょっと怖いのであまり触れたくない感じです。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;ここまで書いていて思った以上に分量が膨らんでしまいました。
&lt;a href=&#34;http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-02/&#34;&gt;後編&lt;/a&gt;では、実際にJavaScript/TypeScriptで問題を解く上で気をつけている点を書いていきます。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>Web技術ではじめるレポート・論文制作</title>
      <link>http://tatamo.81.la/blog/2017/12/06/web-dtp/</link>
      <pubDate>Wed, 06 Dec 2017 18:30:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/12/06/web-dtp/</guid>
      <description>
        &lt;p&gt;この記事は&lt;a href=&#34;https://adventar.org/calendars/2491&#34;&gt;Kobe University Advent Calendar 2017&lt;/a&gt;の6日の記事です。
なお私は当該大学の学部3年(2017年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;http://vivliostyle.com/ja/products/&#34;&gt;Vivliostyle&lt;/a&gt;やその他のWeb技術を用いて、HTMLとCSSで課題のレポートを書くための環境を作る話です。
あと「&lt;a href=&#34;https://pentapod.github.io/c92/&#34;&gt;CSSではじめる同人誌制作&lt;/a&gt;」を勝手に販促する記事でもあります。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;html-cssによる組版&#34;&gt;HTML+CSSによる組版&lt;/h2&gt;

&lt;p&gt;個人的にはWordもTeXもあまり得意ではない、というか、HTML+CSSで似たようなことができそうなのにわざわざWordやTeXを使うのが大変だと感じています(InDesignはよく知りません)。
文書構造の明確化という観点においては、構造と見た目が明確に分離しているHTML+CSSに勝るものはありません(筆者個人の主観です)。&lt;/p&gt;

&lt;p&gt;そこでWeb技術を用いてレポートや論文を書きたいなあと思っていたのですが、ちょうど&lt;a href=&#34;http://tatamo.81.la/blog/2017/08/27/seccamp-2017/&#34;&gt;セキュキャンの事前準備で行けなかった&lt;/a&gt;ときのコミケで、pentapodさんより「&lt;a href=&#34;https://pentapod.github.io/c92/&#34;&gt;CSSではじめる同人誌制作&lt;/a&gt;」が頒布されていたので、友人に頼んで確保しておいてもらいました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote&gt;内容については同人誌制作だけをターゲットに絞らず， できるだけ色々な場面で使えるような説明を心がけています．&lt;/blockquote&gt;
というあとがきの記述通り、CSS組版全般、また単にCSSの解説本としても読めるようになっており、本書を参考にしてレポートを書くための環境を整えることができました。
同人誌でもレポートでも論文でも、やりたいことは結局同じ組版であるため、整えるべき環境は変わりません。&lt;/p&gt;

&lt;h2 id=&#34;この記事で書くこと&#34;&gt;この記事で書くこと&lt;/h2&gt;

&lt;p&gt;CSSを用いた組版については、「&lt;a href=&#34;https://pentapod.github.io/c92/&#34;&gt;CSSではじめる同人誌制作&lt;/a&gt;」を直接読んでいただくのが一番早いため、今回はあまり詳しくは書きません。
&lt;a href=&#34;https://pentapod.booth.pm/items/601017&#34;&gt;300円というお手頃価格で電子版も出ている&lt;/a&gt;ので買ってください。
これは販促です。&lt;/p&gt;

&lt;p&gt;そこでこの記事では、本書を参考にしながら行った環境構築を中心に書いていきます。
構築した環境は &lt;a href=&#34;https://github.com/Tatamo/htmldtp&#34;&gt;https://github.com/Tatamo/htmldtp&lt;/a&gt; に上げていますが、「そもそもボイラープレートという単語を数日前にはじめて知った」レベルのためディレクトリ構成ひとつとっても正直褒められたものではないと感じています。
なのでまたちゃんと体裁を整えたいと思います。&lt;/p&gt;

&lt;h2 id=&#34;vivliostyle&#34;&gt;Vivliostyle&lt;/h2&gt;

&lt;p&gt;とはいえ、&lt;a href=&#34;http://vivliostyle.com/ja/products/&#34;&gt;Vivliostyle&lt;/a&gt;については触れておかないと話が始まりません。
これはWeb技術による組版を目的としたプロジェクトで、CSSの将来的な仕様を先取りすることで、より多彩なレイアウトを実現できるようにしているものです。
&lt;a href=&#34;http://vivliostyle.com/ja/samples/&#34;&gt;サンプル&lt;/a&gt;が充実しており、実際にCSSによってデザインされた本と、その生のHTMLを閲覧することができます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://vivliostyle.github.io/vivliostyle.js/samples/css-secrets-long/viewer/vivliostyle-viewer.html#x=../doc/&#34;&gt;こういうレベルのこと&lt;/a&gt;がCSSで既に可能となっているのです。&lt;/p&gt;

&lt;p&gt;Vivliostyleを用いた印刷を行う方法は何種類かありますが、&lt;a href=&#34;https://chrome.google.com/webstore/detail/vivliostyle/ffeiildjegeigkbobbakjjmfeacadbne&#34;&gt;Chrome拡張&lt;/a&gt;を用いるのが最も簡単だと思われます。
目的のHTMLファイルを表示した状態で拡張機能を有効化するとレイアウトが紙面向けのものに変換されるので、これをChromeの印刷機能を用いて紙面やPDFに印刷します。&lt;/p&gt;

&lt;p&gt;そのため、Vivliostyleに対応したCSSファイルと、それを適用するための原稿となるHTMLファイルを用意することが目的となります。
HTMLとCSSの状態からPDFを生成する作業を自動化する方法についても「&lt;a href=&#34;https://pentapod.github.io/c92/&#34;&gt;CSSではじめる同人誌制作&lt;/a&gt;」では解説されていますが、今回は省略するので本書を購入してください。&lt;/p&gt;

&lt;p&gt;恥ずかしい話ですが、最近のCSS3の仕様をしっかり追いかけているわけではないため、どこからどこまでがVivliostyleによって実現されている機能で、どこまでがブラウザの標準機能で既にサポートされている部分なのかがよくわかっていません。
このあたりは書けば書くほどボロが出るに違いないので適当にごまかします。&lt;/p&gt;

&lt;h2 id=&#34;フレームワーク選定&#34;&gt;フレームワーク選定&lt;/h2&gt;

&lt;p&gt;書籍ではPug+marked+Stylus+Prism.js+MathJax+Browsersync+Gulpの構成が紹介されていましたが、このあたりは好みだと思うので適当に選んでいきました。&lt;/p&gt;

&lt;p&gt;結論としては、Nunjucks+nunjucks-markdown+PostCSS(cssnext+stylelint)+highlight.js+MathJax+Browsersync+Gulpという構成になりました。&lt;/p&gt;

&lt;h3 id=&#34;nunjucks&#34;&gt;Nunjucks&lt;/h3&gt;

&lt;p&gt;まずはHTMLテンプレートエンジンを選びます。
変数を用いた操作や別のHTMLの継承などの機能を取り入れることで、HTMLをより書きやすくして開発の高速化・再利用の促進を図ります。&lt;/p&gt;

&lt;p&gt;今回は&lt;a href=&#34;https://mozilla.github.io/nunjucks/&#34;&gt;Nunjucks&lt;/a&gt;を使うことにしました。
昔Djangoを触ったことがあるので見慣れたテンプレートであるという点などが採用理由です。
他には以前使ったことのあるEJS、紹介されていたPug(Jade)なども候補に上がりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- template/_base.njk --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;ja&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;{{ title }}&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
{% block content %}
    &amp;lt;section&amp;gt;
        &amp;lt;p&amp;gt;default content&amp;lt;/p&amp;gt;
    &amp;lt;/section&amp;gt;
{% endblock %}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- index.njk --&amp;gt;
{% extends &amp;quot;template/_base.njk&amp;quot; %}
{% set title = &amp;quot;awesome-report&amp;quot; %}
{% block content %}
&amp;lt;section&amp;gt;
    &amp;lt;!-- awesome-report-content --&amp;gt;
&amp;lt;/section&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のような感じでHTMLにいろいろなものをくっつけていきながら書けるようになります。
Nunjucksで記述したHTMLは、.htmlのほかに.njkなどの拡張子を使ったりするらしいです。&lt;/p&gt;

&lt;h3 id=&#34;nunjucks-markdown&#34;&gt;nunjucks-markdown&lt;/h3&gt;

&lt;p&gt;ひたすら文章を書くのにいちいち&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;タグを書いたりしていられないので、Markdownを使えるようにすることが必要です。
Nunjucksを使うことにしたので、markedのNunjucks向けプラグインである&lt;a href=&#34;https://www.npmjs.com/package/nunjucks-markdown&#34;&gt;nunjucks-markdown&lt;/a&gt;を使うことにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% block content %}
&amp;lt;section&amp;gt;
    {% markdown %}
    ## PPAP
    I have a pen.
    I have an apple.
    ```js
    console.log(&amp;quot;Apple pen!&amp;quot;);
    ```
    {% endmarkdown %}
&amp;lt;/section&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように、&lt;code&gt;{% markdown %}&lt;/code&gt;で囲った部分をMarkdownとして書くことができようになります。&lt;/p&gt;

&lt;h3 id=&#34;postcss-cssnext-stylelint&#34;&gt;PostCSS(cssnext+stylelint)&lt;/h3&gt;

&lt;p&gt;HTMLだけでなくCSSも次世代仕様を使用できるようにしておくと便利です。
SassやStylusという選択肢もありますが、この次世代CSS過渡期において独自記法マシマシのcoffeeとあくまでES2015をもとにしたtsならどちらを使うかという話です。
一通り必要な機能が入ったプラグイン集である&lt;a href=&#34;http://cssnext.io/&#34;&gt;cssnext&lt;/a&gt;と、lintをしてくれる&lt;a href=&#34;https://stylelint.io/&#34;&gt;stylelint&lt;/a&gt;を入れていますが、この構成だとSassのように&lt;code&gt;@import&lt;/code&gt;できない点で不便さがあるので、CSSをモジュール化できるようにするためにpostcss-importも入れたほうが良いかもしれません。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;gulp-postcssを使っている際にstylelintでインデント幅をlintするよう指定している状態でAutoprefixerなどで右寄せしたprefixが追加された場合、なぜかsrc側のCSSのインデントが崩れているとしてstylelintに怒られてしまうので、plugin設定にはstylelintを一番先に置くべきという知見を得ました &lt;a href=&#34;https://t.co/IMnmqibetC&#34;&gt;pic.twitter.com/IMnmqibetC&lt;/a&gt;&lt;/p&gt;&amp;mdash; たたもさん@がんばらない (@&lt;strong&gt;tatamo&lt;/strong&gt;) &lt;a href=&#34;https://twitter.com/__tatamo__/status/928286264914145280?ref_src=twsrc%5Etfw&#34;&gt;2017年11月8日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
これは余談です。&lt;/p&gt;

&lt;h3 id=&#34;highlight-js&#34;&gt;highlight.js&lt;/h3&gt;

&lt;p&gt;プログラムリストを貼り付けることが求められることもあるので、シンタックスハイライターを用意します。
他の候補としてはPrism.jsなどがあります。
今回はこのブログで使ったりして使い慣れている&lt;a href=&#34;https://highlightjs.org/&#34;&gt;highlight.js&lt;/a&gt;を用いました。&lt;/p&gt;

&lt;h3 id=&#34;mathjax&#34;&gt;MathJax&lt;/h3&gt;

&lt;p&gt;TeX形式で書いた数式を表示するために必須です。
&lt;a href=&#34;https://www.mathjax.org/&#34;&gt;MathJax&lt;/a&gt;以外の選択肢は特にないと言っていいでしょう。
適当なスニペットを&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;タグ内に追加し、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;p&amp;gt;MathJax test: $E = mc^2$&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などと書くだけで数式部分が整形されて表示されます。&lt;/p&gt;

&lt;p&gt;どうでもいい余談ですが、個人的にはMicrosoft Officeの数式エディタは見た目もきれいですし非常に使いやすいと思っています。
これについてはあまり同意されたことがない気がします。&lt;/p&gt;

&lt;h3 id=&#34;browsersync&#34;&gt;Browsersync&lt;/h3&gt;

&lt;p&gt;ソースコードが更新され(、そしてそれを検知してビルドが走って&lt;code&gt;dist/&lt;/code&gt;ディレクトリが更新され)たことを検知し、&lt;a href=&#34;https://www.browsersync.io/&#34;&gt;Browsersync&lt;/a&gt;が自動でブラウザを再読み込みしてくれるようにします。
わざわざF5を押さなくても変更が反映され、ビルド結果がすぐにブラウザ上で見れて便利…… なのですが、今回はブラウザを更新したあとVivliostyleのChrome拡張を有効化しなければならず、結局F5相当の動作を手で行わなければならないという難点があります。&lt;/p&gt;

&lt;h3 id=&#34;gulp&#34;&gt;Gulp&lt;/h3&gt;

&lt;p&gt;ビルドを自動化してくれるようにするためのタスクランナーです。
&lt;a href=&#34;https://gulpjs.com/&#34;&gt;Gulp&lt;/a&gt;は使っていますがGruntは使ったことがないです。
タスクランナーとは、&lt;code&gt;hoge&lt;/code&gt;というパッケージと一緒に&lt;code&gt;gulp-hoge&lt;/code&gt;を入れなければならなくなってpackage.jsonの依存パッケージ数が2倍近くに膨れ上がるという、とても素敵なものです。&lt;/p&gt;

&lt;p&gt;最近は何でもかんでもnpm-scriptsでやろうという話があって、確かに一理あるなあという感じなのでGulpじゃなくてもよかったかもしれません。&lt;/p&gt;

&lt;h2 id=&#34;全部突っ込む&#34;&gt;全部突っ込む&lt;/h2&gt;

&lt;p&gt;JavaScriptから利用するためのパッケージを一つも入れていない、というかJavaScriptを書くつもりがない(gulpfile除く)のに依存パッケージ数が10を越えるのはどういうことなんだ、という感じですが、とりあえず上記のツールを全部組み合わせます。
highlight.jsとMathJaxに関しては、&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;タグで読み込むだけでいいので&lt;code&gt;npm install&lt;/code&gt;は不要です。
Nunjucksのテンプレート継承機能を用いて、これらの読み込み用のスニペットをモジュール化しておくのがいいでしょう。&lt;/p&gt;

&lt;p&gt;Nunjucks(+nunjucks-markdown)とPostCSSを用いて、それぞれHTMLファイルとCSSファイルを生成する処理が行われるので、これをGulpのタスクとしてまとめてしまいます。
あとはソースコードの更新を検知して自動的にこのビルド処理が走るようにしたり、ビルド完了のタイミングでBrowsersyncに更新を伝えたりする処理を&lt;a href=&#34;https://github.com/Tatamo/htmldtp/blob/master/gulpfile.js&#34;&gt;gulpfile.js&lt;/a&gt;に書いて終わりです。&lt;/p&gt;

&lt;h2 id=&#34;使ってみた&#34;&gt;使ってみた&lt;/h2&gt;

&lt;p&gt;大学でパーセプトロンの出力を求めるだけのレポート課題が出たので、構築した環境を用いてレポートを書いてみました。&lt;/p&gt;

&lt;p&gt;以下に、Vivliostyleを用いて出力されたPDF(のスクリーンショットにモザイクかけたただの画像)を示します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2017/12/06/output_report.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2017/12/06/output_report.png&#34; alt=&#34;PDFに出力されたレポート&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;図はLibreOffice Drawで用意しましたがそのあたりは適当です。&lt;/p&gt;

&lt;p&gt;これに用いたCSSは、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;@page {
  size: A4;
  margin: 20mm;
  @bottom-center {
    content: counter(page);
  }
}

figcaption {
  counter-increment: fig;
}

figcaption::before {
  content: &amp;quot;図&amp;quot; counter(fig) &amp;quot;. &amp;quot;;
}

/* うまく動かない(後述) */
a.figref::after {
  content: &amp;quot;図&amp;quot; target-counter(attr(href), fig);
}

img {
  max-width: 100%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;だけであり、非常に簡潔なCSSで十分に見た目の整ったレポートを書くことができます。&lt;/p&gt;

&lt;p&gt;そういえば指定するのを忘れていましたが、当然&lt;code&gt;font-size&lt;/code&gt;でフォントサイズをポイント指定することも可能です。&lt;/p&gt;

&lt;h3 id=&#34;相互参照と問題点&#34;&gt;相互参照と問題点&lt;/h3&gt;

&lt;p&gt;図を示している部分のHTMLを抜粋すると、以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;section&amp;gt;
    {% markdown %}
    ## パーセプトロンの提示
    まず、パーセプトロンの修正後の重みを&amp;lt;a class=&amp;quot;figref&amp;quot; href=&amp;quot;#fig-nn&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;に示す。
    &amp;lt;figure&amp;gt;
        &amp;lt;img src=&amp;quot;perceptron.png&amp;quot;&amp;gt;
        &amp;lt;figcaption id=&amp;quot;fig-nn&amp;quot;&amp;gt;パーセプトロン&amp;lt;/figcaption&amp;gt;
    &amp;lt;/figure&amp;gt;
    簡単のため、パーセプトロンのそれぞれのノードに番号を付与した。
    {% endmarkdown %}
&amp;lt;/section&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;figcaption::before&lt;/code&gt;の&lt;code&gt;content&lt;/code&gt;に&lt;code&gt;counter(fig)&lt;/code&gt;を用いることで、自動的に図表番号を振ることができます。&lt;/p&gt;

&lt;p&gt;それに加えて、&lt;code&gt;figcaption&lt;/code&gt;の持つidに対するリンクのcontentに&lt;code&gt;target-counter(attr(href), fig)&lt;/code&gt;を指定しています。
これは&lt;code&gt;attr(href)&lt;/code&gt;&amp;mdash;つまりhrefの属性値、&lt;code&gt;&amp;quot;#fig-nn&amp;quot;&lt;/code&gt;&amp;mdash;の地点での&lt;code&gt;counter(fig)&lt;/code&gt;のカウンタの値を取得しており、つまりその図表に割り当てられた番号が得られます。&lt;/p&gt;

&lt;p&gt;これによって相互参照が実現できます。&lt;/p&gt;

&lt;p&gt;と言ってドヤ顔したいところなのですが、ここで致命的な問題が発生します。
なぜかChrome拡張のVivliostyleでは、この&lt;code&gt;target-counter()&lt;/code&gt;がうまく動かず、図表番号が&lt;code&gt;??&lt;/code&gt;で表示されます。&lt;/p&gt;

&lt;p&gt;他の手段であるVivliostyle FormatterやVivliostyle Viewerを使えば動かせはするのですが、その場合highlight.jsによるシンタックスハイライトが効かなかったり、MathJaxは対応しているもののMathML以外の記法を使えない、などの別の問題が生じてきます。&lt;/p&gt;

&lt;p&gt;なので現状、&lt;code&gt;a.figref::after&lt;/code&gt;に対するスタイル指定を削除し、&lt;code&gt;&amp;lt;a class=&amp;quot;figref&amp;quot; href=&amp;quot;#fig-nn&amp;quot;&amp;gt;図1&amp;lt;/a&amp;gt;&lt;/code&gt;などと直接書くしかないという本末転倒感があります。&lt;/p&gt;

&lt;p&gt;これについては今のところ解決策を見つけられていないので、もう少し調べてみて必要ならissueを飛ばすなりしようと思っています。&lt;/p&gt;

&lt;h2 id=&#34;おわり&#34;&gt;おわり&lt;/h2&gt;

&lt;p&gt;レポート・論文程度ならそこまで凝ったデザインである必要がないので、非常に短いCSSでそれなりの印刷が可能になります。
HTML+CSSを用いてレポートを書くというのは十分に実用の範囲内だと思ったので、これからも試していこうと思っています。&lt;/p&gt;

&lt;p&gt;しかしながら、やはり現状で相互参照が実現できないというのはレポート・論文執筆には致命的なところがあります。
&lt;code&gt;target-counter()&lt;/code&gt;は策定中の次期CSS仕様であることから、解決は時間の問題だとは思っているのですが、なんとかしたいところです。&lt;/p&gt;

&lt;p&gt;今の時代のCSSは、もはやWebページだけでなく紙面上のレイアウトも自在に操れるようになってきています。「&lt;a href=&#34;https://pentapod.github.io/c92/&#34;&gt;CSSではじめる同人誌制作&lt;/a&gt;」はCSSを使ったさまざまな紙面レイアウトについて書かれており、とてもおすすめなのでぜひ購入してみてください。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>ゲーム「じゃぱりうぉっち」を作りました</title>
      <link>http://tatamo.81.la/blog/2017/12/01/japari-watch/</link>
      <pubDate>Fri, 01 Dec 2017 17:35:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/12/01/japari-watch/</guid>
      <description>
        &lt;p&gt;この記事は&lt;a href=&#34;https://adventar.org/calendars/2491&#34;&gt;Kobe University Advent Calendar 2017&lt;/a&gt;の1日の記事です。
なお私は当該大学の学部3年(2017年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;ブラウザ上で動作するゲーム「&lt;a href=&#34;https://tatamo.github.io/japari-watch/&#34;&gt;じゃぱりうぉっち&lt;/a&gt;」を作ったので、開発記を書きます。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;じゃぱりうぉっち&#34;&gt;じゃぱりうぉっち&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://tatamo.github.io/japari-watch/&#34;&gt;https://tatamo.github.io/japari-watch/&lt;/a&gt; で公開しており、PCとモバイル端末のどちらでも遊ぶことができます。&lt;/p&gt;

&lt;h3 id=&#34;発端&#34;&gt;発端&lt;/h3&gt;

&lt;p&gt;期末試験前に現実逃避のためにTLを眺めていたところ、以下のツイートが流れてきました。
&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;フェネック「アライさんに似合いそうな帽子を見つけてきたよー」&lt;br&gt;アライグマ「ありがとうなのだ！」&lt;a href=&#34;https://twitter.com/hashtag/%E3%81%91%E3%82%82%E3%81%AE%E3%83%95%E3%83%AC%E3%83%B3%E3%82%BA?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#けものフレンズ&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/%E3%83%89%E3%83%83%E3%83%88%E7%B5%B5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#ドット絵&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/pixelart?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#pixelart&lt;/a&gt; &lt;a href=&#34;https://t.co/1VueMavObQ&#34;&gt;pic.twitter.com/1VueMavObQ&lt;/a&gt;&lt;/p&gt;&amp;mdash; 鬼雷 昇炎 (@kirai_s) &lt;a href=&#34;https://twitter.com/kirai_s/status/934412479597199361?ref_src=twsrc%5Etfw&#34;&gt;2017年11月25日&lt;/a&gt;&lt;/blockquote&gt;&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Version Upgrade Nanoda!! &lt;a href=&#34;https://t.co/IXSjV6A1PN&#34;&gt;pic.twitter.com/IXSjV6A1PN&lt;/a&gt;&lt;/p&gt;&amp;mdash; 鬼雷 昇炎 (@kirai_s) &lt;a href=&#34;https://twitter.com/kirai_s/status/934695920414765056?ref_src=twsrc%5Etfw&#34;&gt;2017年11月26日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;作品としての完成度が高く、実際にゲームとして遊べそうに見えたので、これをゲーム化してみました。&lt;/p&gt;

&lt;h3 id=&#34;素材&#34;&gt;素材&lt;/h3&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;原寸(128*128px)なのだ &lt;a href=&#34;https://twitter.com/hashtag/%E3%81%91%E3%82%82%E3%81%AE%E3%83%95%E3%83%AC%E3%83%B3%E3%82%BA?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#けものフレンズ&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/%E3%83%89%E3%83%83%E3%83%88%E7%B5%B5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#ドット絵&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/pixelart?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#pixelart&lt;/a&gt; &lt;a href=&#34;https://t.co/BJ0Mc27vR5&#34;&gt;pic.twitter.com/BJ0Mc27vR5&lt;/a&gt;&lt;/p&gt;&amp;mdash; 鬼雷 昇炎 (@kirai_s) &lt;a href=&#34;https://twitter.com/kirai_s/status/934699058542678016?ref_src=twsrc%5Etfw&#34;&gt;2017年11月26日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;元画像が上がっていたので使わせていただきました。&lt;/p&gt;

&lt;p&gt;背景に相当する部分の画像がなかったので自分で加工したり、そのまま矩形状にスプライトを切り出すと被ってしまう部分があったのでいくつかのパーツに分けたりしました。&lt;/p&gt;

&lt;h2 id=&#34;製作期間&#34;&gt;製作期間&lt;/h2&gt;

&lt;p&gt;ゲーム本体の作成(アセットの用意・環境構築含む)： 一晩&lt;br /&gt;
公開のためのWebページデザインやTwitterカード、faviconの用意：半日&lt;br /&gt;
公開後の難易度調整+自動モード機能の追加：半日&lt;/p&gt;

&lt;h2 id=&#34;フレームワーク選定&#34;&gt;フレームワーク選定&lt;/h2&gt;

&lt;p&gt;ブラウザで動作するゲームを作ろうと思ったため、基本的にはNode環境で開発を進めていくことになります。
高速に開発するためにTypeScriptで記述することとしたうえで、使用するツールを選定していきました。&lt;/p&gt;

&lt;h3 id=&#34;pixi-js&#34;&gt;PIXI.js&lt;/h3&gt;

&lt;p&gt;PC・モバイル両方のブラウザで動作するゲームという方針のため、HTML5 Canvas系のライブラリを使うことにしました。
npm上で型定義が用意されているものを使いたかったので、今回は&lt;a href=&#34;http://www.pixijs.com/&#34;&gt;PIXI.js&lt;/a&gt;を選択しました。&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;shell&#34;&gt;$ npm install --save-dev @types/pixi.js&lt;/code&gt;で型定義ファイルをインストールし、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import * as PIXI from &amp;quot;pixi.js&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でPIXI.jsの型情報を使用可能になります。&lt;/p&gt;

&lt;h4 id=&#34;ビルドシステム&#34;&gt;ビルドシステム&lt;/h4&gt;

&lt;p&gt;また、今回はブラウザを動作対象とするため、jsファイルのバンドルとBabel化のためにwebpackを使用しました。
実際のところwebpackもBabelもこれまで使ったことがなかったのですが、なんとかts-loaderとbabel-loaderでTypeScriptのソースコードをBabel化してバンドルするところまでやりました。&lt;/p&gt;

&lt;p&gt;期末試験直前であまり学習コストをかけられず、これ以上webpackであれこれするのは怖くなったので、jsファイル以外の静的ファイルのコピーなどはrimrafやcpxを使い、npm scriptsでビルドすることにしました。
また開発中の自動コンパイルのために、chokidarとbrowser-syncを使いました。&lt;/p&gt;

&lt;h2 id=&#34;設計&#34;&gt;設計&lt;/h2&gt;

&lt;p&gt;一定時間ごとにゲームループをまわし、大元のゲームオブジェクトから各マネージャのupdateメソッドを呼び出して処理を行い、最後にレンダリングを行うという基本的な設計としています。&lt;/p&gt;

&lt;p&gt;今回は、エンティティを管理するエンティティマネージャ、スコアを管理するスコアマネージャ、エンティティとスコア以外のゲーム内表示を管理するエフェクトマネージャ、ユーザーからの入力を受け取るインプットマネージャを用意しました。
また、スコアマネージャはインスタンスを2つ生成してそれぞれ取得スコアとミス回数を管理するようにしています。&lt;/p&gt;

&lt;p&gt;ステートマシンを用いてゲーム状態の遷移を管理する方法もありますが、今回はタイトルとゲーム中とゲームオーバーの三状態しかなく、また各エンティティも決まった動きしかしないため不要と判断しました。&lt;/p&gt;

&lt;p&gt;エンティティごとにスプライトのテクスチャを用意しておく必要があり、これはstaticメンバとして各エンティティのクラスに紐付けることにしました。
このテクスチャの生成はアセットのローディングが終わった後に行う必要があるため、エンティティマネージャの初期化時に各staticメソッドを呼び出すことで初期化するようにしました。&lt;/p&gt;

&lt;h3 id=&#34;eventemitterによるメッセージング&#34;&gt;EventEmitterによるメッセージング&lt;/h3&gt;

&lt;p&gt;PIXI.jsで用意されているクラスは&lt;a href=&#34;https://github.com/primus/eventemitter3&#34;&gt;EventEmitter&lt;/a&gt;を継承しており、イベント駆動でのオブジェクト間のメッセージングが可能です。
たとえば&lt;code&gt;アライさん&lt;/code&gt;オブジェクトは&lt;code&gt;Hat&lt;/code&gt;コレクションに対する参照を持ちませんが、イベントの発火にフックしてエンティティマネージャがメソッド引数にコレクションの参照を流し込むことで、&lt;code&gt;アライさん&lt;/code&gt;オブジェクトは外部の参照を持つことなく&lt;code&gt;Hat&lt;/code&gt;コレクションにアクセスし、当たり判定の処理を行うことができます。
これにより、ゲーム内エンティティを表すオブジェクト同士を疎結合に保つことができます。
&lt;code&gt;Hat&lt;/code&gt;のように複数のインスタンスが生成される場合、そのたびにイベントの登録を行う必要があるので、このようなクラスはファクトリを通して実体化するようにします。&lt;/p&gt;

&lt;p&gt;その他にも、インプットマネージャがキーボード入力を受け取ったり、ゲーム画面上に配置されている透明のスプライトに対するクリック・タッチ入力を受け取った場合に、入力された動作に応じたイベントを発火することで、入力の種類を隠蔽したうえでそれにフックする処理を定義可能になります。&lt;/p&gt;

&lt;h2 id=&#34;はまりどころ&#34;&gt;はまりどころ&lt;/h2&gt;

&lt;p&gt;ちょっとしたミスなどですが、詰まった点について。&lt;/p&gt;

&lt;h3 id=&#34;エンティティの消去&#34;&gt;エンティティの消去&lt;/h3&gt;

&lt;p&gt;ループ中にループ対象の配列を変更するな、というのは基本ですが、ゲームの場合当たり判定がヒットしたエンティティを消去したいという場面は多いです。
&lt;code&gt;Hat&lt;/code&gt;コレクションに対してループを回して&lt;code&gt;update()&lt;/code&gt;を呼び出し、その処理の中で&lt;code&gt;Hat&lt;/code&gt;オブジェクトを消去してしまい、それ以降のオブジェクトの処理がおかしくなるというバグが発生しました。&lt;/p&gt;

&lt;p&gt;対処として、まずエンティティに&lt;code&gt;alive&lt;/code&gt;フラグを持たせておき、エンティティを消去したいときには以下のような処理を呼び出すだけにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;die() {
    this.alive = false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、全エンティティのupdate処理終了後に再度ループを回し、ここでaliveフラグがfalseとなっているエンティティをコレクションから取り除きます。
ただし、死んだはずのオブジェクトの当たり判定が残ったりすることを防ぐため、一度aliveフラグがfalseになったエンティティは処理から除外するようにしておく必要があります。
また、結局ループ中の配列を弄ることになるので、このループの中でおかしなことが起きるかもしれないので注意が必要です(とはいえ削除処理を別のループに分けていることで、最悪でもエンティティの削除が次回以降のフレームに引き延ばされてしまう程度の影響しか起きません)。&lt;/p&gt;

&lt;p&gt;ループ中に配列から安全に要素を取り除く方法としては、要素の削除時にイテレータをうまく調整したり、ループインデックスをずらして対処するなどといった方法がありますが、イテレータの仕様を正しく理解している必要があったり、削除処理のタイミングで自分の外側のループのことを考えないといけなかったりするため、処理がやや煩雑になりがちです。
そこで技巧的な方法として、ループのインデックスを配列の末尾から順に0に向けてデクリメントしていけば、途中で要素が取り除かれてもループに影響が出ない、といったものがあります。
ただし処理順は逆になってしまうので、それが気になるなら先述したエンティティ削除用のループでのみ行うなどする必要があります(エンティティの削除処理程度なら順序が変わっても影響が出ないため)。
最も単純なのはループ前にコレクションをコピーしてループを回すことですが、ゲームプログラムで毎フレームごとに配列のコピーを生成するのはパフォーマンス的に避けたいところでもあります。
なお今回は、&lt;code&gt;Hat&lt;/code&gt;オブジェクトは同時に10個も存在することはないため、毎回配列をコピーして削除用のループを回すことにしました。&lt;/p&gt;

&lt;h3 id=&#34;faviconの配信&#34;&gt;faviconの配信&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;favicon.ico&lt;/code&gt;を配信しようと思ったのですが、&lt;a href=&#34;https://tatamo.github.io/japari-watch/&#34;&gt;https://tatamo.github.io/japari-watch/&lt;/a&gt; というURLのルートパスは&lt;a href=&#34;https://tatamo.github.io/&#34;&gt;https://tatamo.github.io/&lt;/a&gt; であるため、&lt;a href=&#34;https://tatamo.github.io/japari-watch/&#34;&gt;https://tatamo.github.io/japari-watch/&lt;/a&gt; 直下にfaviconを配置しても正しく読み込ませることができません。
そのため、&lt;code&gt;&amp;lt;link rel=&amp;quot;shortcut icon href=&amp;quot;favicon.ico&amp;quot; type=&amp;quot;image/x-icon&amp;quot;&amp;quot;&amp;gt;&lt;/code&gt;などとして明示的にfavicon.icoの位置を示す必要がありました。&lt;/p&gt;

&lt;p&gt;また、&lt;code&gt;manifest.json&lt;/code&gt;を&lt;a href=&#34;https://tatamo.github.io/japari-watch/favicons/manifest.json&#34;&gt;https://tatamo.github.io/japari-watch/favicons/manifest.json&lt;/a&gt; に、同様にandroid用のアイコン画像を&lt;code&gt;favicons/&lt;/code&gt;ディレクトリに配置していました。
&lt;code&gt;manifest.json&lt;/code&gt;中の相対パスは基準となるディレクトリが&lt;code&gt;manifest.json&lt;/code&gt;自身となることを知らなかったので、srcパスを&lt;code&gt;&amp;quot;favicons\/android-icon-***.png&amp;quot;&lt;/code&gt;としたところ、&lt;code&gt;favicons/favicons/&lt;/code&gt;が読まれてしまって正しくアイコンを配信できなかったりしました。&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.pixijs.com/&#34;&gt;PIXI.js&lt;/a&gt;はチュートリアルだけは読んだことがあるという状態で、一度実際に使ってみたいと思っていたので使用することができて良かったです。
ドキュメントをろくに読み込まずに使いたい機能だけ調べて使うといった感じでしたが、かなり高速にゲーム開発ができたので非常に便利でした。
またwebpackやBabel、npm scriptsをメインに用いたビルドなどもはじめてだったのですがいい感じにできました。&lt;/p&gt;

&lt;p&gt;使用した画像については作者である&lt;a href=&#34;https://twitter.com/kirai_s&#34;&gt;@kirai_s&lt;/a&gt;さんに確認を得ないまま加工して作り始めてしまったのですが、使用を快く承諾していただけました。
この場を借りてお礼申し上げます。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>ブログのシンタックスハイライトを改善しました</title>
      <link>http://tatamo.81.la/blog/2017/11/08/syntax-highlight-improvement/</link>
      <pubDate>Wed, 08 Nov 2017 18:00:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/11/08/syntax-highlight-improvement/</guid>
      <description>
        &lt;p&gt;このブログのシンタックスハイライトには&lt;a href=&#34;https://highlightjs.org/&#34;&gt;highlight.js&lt;/a&gt;を使用していますが、使い勝手を上げるために調整を行いました。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;コードの強調は不要だがhighlight-jsのテーマは使いたい&#34;&gt;コードの強調は不要だがhighlight.jsのテーマは使いたい&lt;/h2&gt;

&lt;p&gt;プログラムの実行結果など、プログラムそのもの以外を&lt;code class=&#34;html&#34;&gt;&amp;lt;code&amp;gt;&lt;/code&gt;タグで囲いたくなる場合が何度かありました。
class要素に&lt;code&gt;nohighlight&lt;/code&gt;を指定すればハイライトは行われなくなりますが、highlight.jsのCSSテーマも適用されなくなります。&lt;/p&gt;

&lt;h2 id=&#34;インライン要素のハイライトをデフォルトで無効化したい&#34;&gt;インライン要素のハイライトをデフォルトで無効化したい&lt;/h2&gt;

&lt;p&gt;さらに、インライン要素のハイライトを行う場合、対象となるコードが短いために言語の自動検出がうまく働かないことが多いです。
ブロック要素ではMarkdownでcode部分を囲う際に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;```javascript
/* code */
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすることで言語注釈をつけることができますが、インラインの場合はこれができないため言語を明示的に指定する場合には直接codeタグを書く必要があります。&lt;/p&gt;

&lt;h2 id=&#34;解決策&#34;&gt;解決策&lt;/h2&gt;

&lt;p&gt;今のところ&lt;code class=&#34;html&#34;&gt;&amp;lt;code&amp;gt;&lt;/code&gt;で囲った部分はすべてhighlight.jsのテーマを適用してしまって問題はないので、&lt;code&gt;nohighlight&lt;/code&gt;を指定した場合でもCSSテーマが適用されるようにします。
また、インライン要素の場合はデフォルトで&lt;code&gt;nohighlight&lt;/code&gt;にしてしまって、必要がある場合のみHTMLタグを記述して明示的に言語を指定することとしました。
&lt;a href=&#34;http://tatamo.81.la/blog/2015/12/12/apply-highlightjs-to-inline/&#34;&gt;highlight.jsをインライン要素にも適用できるようにした&lt;/a&gt; で書いたコードを、さらに手直しします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// hljs.initHighlightingOnLoad();
window.addEventListener(&amp;quot;DOMContentLoaded&amp;quot;, () =&amp;gt; {
	const elements = document.getElementsByTagName(&amp;quot;code&amp;quot;);
	for (const el of elements) {
		if (el.parentNode.tagName != &amp;quot;PRE&amp;quot;) {
			// インライン要素
			el.style.display = &amp;quot;inline&amp;quot;;
			el.style.margin = &amp;quot;0 2px&amp;quot;;
			el.style.padding = &amp;quot;1px 3px&amp;quot;;
			if (el.classList.length == 0) {
				// classが指定されていない場合はnohighlightとする
				el.classList.add(&amp;quot;nohighlight&amp;quot;);
			}
		}
		hljs.highlightBlock(el);
		// nohighlightでもテーマは適用する
		if (el.classList.contains(&amp;quot;nohighlight&amp;quot;) ||
			el.classList.contains(&amp;quot;lang-nohighlight&amp;quot;) ||
			el.classList.contains(&amp;quot;language-nohighlight&amp;quot;)) {
			el.classList.add(&amp;quot;hljs&amp;quot;);
		}
	}
}, false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、&lt;code class=&#34;html&#34;&gt;&amp;lt;code&amp;gt;&lt;/code&gt;タグでclassの指定が明示的に行われていない場合は自動的に&lt;code&gt;nohighlight&lt;/code&gt;クラスを追加しています。
この処理はhighlight.jsでのハイライト化の処理を行う前に持ってきました。
スタイルの適用も同じように前に持ってきましたが、特に問題はないようです。
次に、&lt;code&gt;nohighlight&lt;/code&gt;が指定されていてハイライトが行われていない要素に対して、classにhighlight.jsで使用されているクラスである&lt;code&gt;hljs&lt;/code&gt;を指定することでテーマの適用を行っています。&lt;/p&gt;

&lt;p&gt;あとは既存の記事をこの変更に合わせて修正しました。
ところどころ不自然なハイライトが行われていた箇所がありましたが、これで改善されました。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第6回:パーサの実装と構文解析の実行</title>
      <link>http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-06/</link>
      <pubDate>Tue, 04 Apr 2017 23:41:09 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-06/</guid>
      <description>
        &lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-05/&#34;&gt;前回&lt;/a&gt;ではLR(1)法による構文解析表の実装を済ませました。
今回はいよいよ、構文解析表をもとに実際に構文解析を行うことのできる構文解析器を実装し、実際に構文解析を行ってみます。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;概略は&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;第4回&lt;/a&gt;で示した通りであり、ステートマシンの仕様に沿って構文解析表を解析できるようにします。
第4回でアルゴリズム面まで踏み込んで解説してしまったため、あまり書くことがなくてやや後悔しています。&lt;/p&gt;

&lt;h2 id=&#34;astの定義&#34;&gt;ASTの定義&lt;/h2&gt;

&lt;p&gt;パーサを実装する前に、パーサの出力結果となる抽象構文木の定義を行います。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/ast.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/ast.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// ast.ts
export interface ASTNode{
	type: Token;
	value: string|null;
	children: Array&amp;lt;ASTNode&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;構文木は再帰的な木構造によって表されます。
それぞれのノードにはそれが何の記号かを示すトークン、およびそのトークンに紐つけられている実際の入力文字列(そのトークンが非終端記号である場合はnull)、自身の子となるノードの配列を持ちます。&lt;/p&gt;

&lt;p&gt;たとえば、&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;第3回&lt;/a&gt;で定義した構文規則によって&lt;code&gt;1+1&lt;/code&gt;を解析した場合、結果として得られる抽象構文木は以下のようになるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
    {&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
        {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
            {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
                {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;, &amp;quot;value&amp;quot;:&amp;quot;1&amp;quot;, &amp;quot;children&amp;quot;:[]}
            ]}
        ]}
    ]}, 
    {&amp;quot;type&amp;quot;:&amp;quot;PLUS&amp;quot;, &amp;quot;value&amp;quot;:&amp;quot;+&amp;quot;, &amp;quot;children&amp;quot;:[]}, 
    {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
        {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
            {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;, &amp;quot;value&amp;quot;:&amp;quot;1&amp;quot;, &amp;quot;children&amp;quot;:[]}
        ]}
    ]}
]}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;簡単ですね。&lt;/p&gt;

&lt;h2 id=&#34;パーサの実装&#34;&gt;パーサの実装&lt;/h2&gt;

&lt;p&gt;ではParserクラスを作っていきます。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/parser.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/parser.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// parser.ts
export interface TerminalCallbackArg {
        token: string;
        value: string;
        terminal: true;
}
export interface NonterminalCallbackArg {
        token: string;
        children: Array&amp;lt;any&amp;gt;;
        pattern: Array&amp;lt;string&amp;gt;;
        terminal: false;
}
export declare type ParserCallbackArg = TerminalCallbackArg | NonterminalCallbackArg;
export declare type ParserCallback = (arg: ParserCallbackArg) =&amp;gt; any;
export declare class Parser {
        private lexer;
        private syntax;
        private parsingtable;
        private default_callback;
        constructor(lexer: ILexer, syntax: SyntaxDefinitions, parsingtable: ParsingTable, default_callback?: ParserCallback | null);
        setDefaultCallback(default_callback?: ParserCallback | null): void;
        parse(input: string, cb?: ParserCallback): any;
        private _parse(inputs, cb?);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;できました。&lt;/p&gt;

&lt;p&gt;構文解析処理を行う処理は、110行程度に及ぶ&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/parser.ts#L40&#34;&gt;Parser#_parse()メソッド&lt;/a&gt;の内部で完結しています。
これは、&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;第4回&lt;/a&gt;に示したオートマトンの動作を仕様通りに実装しています。
入力を前から順に読み込み、現在スタックに積まれている状態番号を取得し、構文解析表の該当する位置に書かれている命令を実行していくだけです。&lt;/p&gt;

&lt;p&gt;ここでは、構文解析の実行中に衝突した命令が存在した場合、その時点で解析失敗としてエラーを返すようにしています。
コンフリクトが発生した際の対処についても&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;第4回&lt;/a&gt;で触れていますが、一般に使用されているパーサジェネレータでは、構文規則を定義するファイルの中に演算子の優先度や右結合/左結合の指定を行うことができたり、指定のない場合はshift/reduceのいずれかを優先するようになっていたりします。&lt;/p&gt;

&lt;p&gt;このあたりのコンフリクト回避処理や、エラーが発生した際の詳細なエラー情報の検知・回避などの機能面には大きく改善の余地があります。&lt;/p&gt;

&lt;p&gt;あとは、このParserをParserGeneratorから利用できるようにするため、適当にファクトリクラスを作ります。
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/factory.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/factory.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// factory.ts
export class ParserFactory{
	public static create(grammar: GrammarDefinition, parsing_table: ParsingTable, default_fallback?: ParserCallback):Parser{
		let lexer = new Lexer(grammar.lex);
		return new Parser(lexer, grammar.syntax, parsing_table, default_fallback);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/parsergenerator.ts#L32&#34;&gt;ParserGenerator#getParser()メソッド&lt;/a&gt;には、以下のような記述を行います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// parsergenerator.ts
public getParser(default_callback?: ParserCallback):Parser{
	return ParserFactory.create(this.grammar, this.parsing_table, default_callback);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで完成です。&lt;/p&gt;

&lt;h2 id=&#34;構文解析を実行する&#34;&gt;構文解析を実行する&lt;/h2&gt;

&lt;h3 id=&#34;構文木を生成する&#34;&gt;構文木を生成する&lt;/h3&gt;

&lt;p&gt;では、実際に構文解析を実行してみましょう。
与える構文は、以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const syntax:SyntaxDefinitions = [
	{
		ltoken: &amp;quot;EXP&amp;quot;,
		pattern: [&amp;quot;EXP&amp;quot;, &amp;quot;PLUS&amp;quot;, &amp;quot;TERM&amp;quot;]
	},
	{
		ltoken: &amp;quot;EXP&amp;quot;,
		pattern: [&amp;quot;TERM&amp;quot;]
	},
	{
		ltoken: &amp;quot;TERM&amp;quot;,
		pattern: [&amp;quot;TERM&amp;quot;, &amp;quot;ASTERISK&amp;quot;, &amp;quot;ATOM&amp;quot;]
	},
	{
		ltoken: &amp;quot;TERM&amp;quot;,
		pattern: [&amp;quot;ATOM&amp;quot;]
	},
	{
		ltoken: &amp;quot;ATOM&amp;quot;,
		pattern:[&amp;quot;DIGITS&amp;quot;]
	},
	{
		ltoken: &amp;quot;ATOM&amp;quot;,
		pattern:[&amp;quot;LPAREN&amp;quot;, &amp;quot;EXP&amp;quot;, &amp;quot;RPAREN&amp;quot;]
	}
];
const lex:LexDefinitions = [
	{token:&amp;quot;DIGITS&amp;quot;, pattern:/[1-9][0-9]*/},
	{token:&amp;quot;PLUS&amp;quot;, pattern:&amp;quot;+&amp;quot;},
	{token:&amp;quot;ASTERISK&amp;quot;, pattern:&amp;quot;*&amp;quot;},
	{token:&amp;quot;LPAREN&amp;quot;, pattern:&amp;quot;(&amp;quot;},
	{token:&amp;quot;RPAREN&amp;quot;, pattern:&amp;quot;)&amp;quot;},
	{token:null, pattern:/(\r\n|\r|\n)+/},
	{token:null, pattern:/[ \f\t\v\u00a0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]+/},
	{token:&amp;quot;INVALID&amp;quot;, pattern:/./},
];

const grammar:GrammarDefinition = {
	lex: lex,
	syntax: syntax,
	start_symbol: &amp;quot;EXP&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt;という式を解析するためには、以下のように実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;new ParserGenerator(grammar).getParser().parse(&amp;quot;9 + 11 * (2 + 1)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すると、結果として以下のようなオブジェクトが得られます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
    {&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
    {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
        {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;9&amp;quot;,&amp;quot;children&amp;quot;:[]}
            ]}
        ]}
    ]},
    {&amp;quot;type&amp;quot;:&amp;quot;PLUS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;+&amp;quot;,&amp;quot;children&amp;quot;:[]},
    {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
        {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
            {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;11&amp;quot;,&amp;quot;children&amp;quot;:[]}
            ]}
        ]},
        {&amp;quot;type&amp;quot;:&amp;quot;ASTERISK&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;*&amp;quot;,&amp;quot;children&amp;quot;:[]},
        {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
            {&amp;quot;type&amp;quot;:&amp;quot;LPAREN&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;(&amp;quot;,&amp;quot;children&amp;quot;:[]},
            {&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                {&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                    {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                        {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                            {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;2&amp;quot;,&amp;quot;children&amp;quot;:[]}
                        ]}
                    ]}
                ]},
                {&amp;quot;type&amp;quot;:&amp;quot;PLUS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;+&amp;quot;,&amp;quot;children&amp;quot;:[]},
                {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                    {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                        {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;children&amp;quot;:[]}
                    ]}
                ]}
            ]},
            {&amp;quot;type&amp;quot;:&amp;quot;RPAREN&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;)&amp;quot;,&amp;quot;children&amp;quot;:[]}
        ]}
    ]}
]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どこからどう見ても成功ですね。
おめでとうございます。&lt;/p&gt;

&lt;h3 id=&#34;コールバックを利用して構文木のさらなる解析を行う&#34;&gt;コールバックを利用して構文木のさらなる解析を行う&lt;/h3&gt;

&lt;p&gt;ついに、本記事の目標である構文木の取得を達成しました。
あとはこれに適当な再帰的処理を挟めば、良い感じに数式処理ができるでしょう。&lt;/p&gt;

&lt;p&gt;確かに一度構文木を生成してからそれを解析してもよいのですが、パーサに適当なコールバックを渡し、構文木を生成する代わりに数式処理を行ってしまうという手もあります。&lt;/p&gt;

&lt;p&gt;先ほどのparsergenerator.tsに、以下のような定義が含まれていました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export interface TerminalCallbackArg {
        token: string;
        value: string;
        terminal: true;
}
export interface NonterminalCallbackArg {
        token: string;
        children: Array&amp;lt;any&amp;gt;;
        pattern: Array&amp;lt;string&amp;gt;;
        terminal: false;
}
export declare type ParserCallbackArg = TerminalCallbackArg | NonterminalCallbackArg;
export declare type ParserCallback = (arg: ParserCallbackArg) =&amp;gt; any;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Parserのコンストラクタ引数、ParserGeneratorのgetParserメソッドの引数、またはParserのparseメソッドの引数としてコールバックを与えると、reduce処理が行われた際にそれを呼び出すことができます。
処理するべきトークンが終端器号であった場合はそのトークンの種類と実際の入力が、非終端記号であった場合は対応する規則の情報、およびその子ノードの情報が引数として与えられます。&lt;/p&gt;

&lt;p&gt;実際に、数式の処理を行うための関数を書いてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;let solve_terminal = (arg:TerminalCallbackArg)=&amp;gt;{
	switch(arg.token){
		case &amp;quot;DIGITS&amp;quot;:
			return +arg.value;
		default:
			return null;
	}
}
let solve_nonterminal = (arg:NonterminalCallbackArg)=&amp;gt;{
	switch(arg.token){
		case &amp;quot;EXP&amp;quot;:
			if(arg.children.length == 1) return arg.children[0];
			else return arg.children[0] + arg.children[2];
		case &amp;quot;TERM&amp;quot;:
			if(arg.children.length == 1) return arg.children[0];
			else return arg.children[0] * arg.children[2];
		case &amp;quot;ATOM&amp;quot;:
			if(arg.children.length == 1) return arg.children[0];
			else return arg.children[1];
	}
}
let solve = (arg:ParserCallbackArg)=&amp;gt;{
	if(arg.terminal) return solve_terminal(arg);
	else return solve_nonterminal(arg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをもとに、以下のように実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;new ParserGenerator(grammar).getParser(solve).parse(&amp;quot;9 + 11 * (2 + 1)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果は、以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これにて、パーサジェネレータの実装および構文解析が完了しました。
ここまでお付き合いいただき、ありがとうございました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回:かんたん構文解析入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-05/&#34;&gt;前回:LR(1)パーサジェネレータの実装&lt;/a&gt;&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第5回:LR(1)パーサジェネレータの実装</title>
      <link>http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-05/</link>
      <pubDate>Tue, 04 Apr 2017 21:54:01 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-05/</guid>
      <description>
        &lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;前回&lt;/a&gt;の記事ではLR(1)法の解説を行いました。
今回は前回解説した部分の実装を行います。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;今回はひたすらパーサジェネレータの実装をしていきます。
概略やアルゴリズムは既に紹介しているため、基本的に省略します。
適宜&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;前回&lt;/a&gt;の記事を参照してください。&lt;/p&gt;

&lt;p&gt;今回取り上げる部分は特にパフォーマンスに与える影響が大きいため、処理速度を重視した設計を行っています。
そのため、天下り的な解説となる箇所が増えるかもしれませんがご了承ください。&lt;/p&gt;

&lt;h2 id=&#34;syntaxdbクラスの作成&#34;&gt;SyntaxDBクラスの作成&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;第3回&lt;/a&gt;で終端記号と非終端記号の区別を行ったり、First集合を求めたりしたように、与えられた構文から様々な情報を得る必要があります。&lt;/p&gt;

&lt;p&gt;そこで、それらの情報取得を担うクラスとしてSyntaxDBクラスを作成します。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/syntaxdb.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/syntaxdb.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// syntaxdb.d.ts
export declare class SyntaxDB {
    private syntax;
    private _start_symbol;
    private _first;
    private _symbols;
    private tokenmap;
    private tokenid_counter;
    private defmap;
    constructor(grammar: GrammarDefinition);
    private initDefMap();
    readonly start_symbol: Token;
    readonly first: FirstSet;
    readonly symbols: SymbolDiscriminator;
    findDef(x: Token): Array&amp;lt;{
        id: number;
        def: SyntaxDefinitionSection;
    }&amp;gt;;
    getTokenId(token: Token): number;
    get(id: number): SyntaxDefinitionSection;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SyntaxDBクラスの読み取り専用メンバとして第3回で作成したFirstSetとSymbolDiscriminatorを持たせており、このクラスから終端記号の区別、First集合の取得が可能です。
また、開始記号の取得も行えるようにします。
さらに、構文id(上から何番目かを表す番号)を与えるとそれに対応する規則を返す&lt;code&gt;get&lt;/code&gt;メソッド、記号を与えるとそれが左辺に現れる規則すべてを、構文idとともに返す&lt;code&gt;findDef&lt;/code&gt;メソッド、そして記号を与えるとそれに対応した一意なトークンidを返す&lt;code&gt;getTokenId&lt;/code&gt;メソッドを持ちます。&lt;/p&gt;

&lt;p&gt;findDefメソッドは愚直に実装した場合、複数回呼ばれるとそのたびに&lt;code&gt;O(n)&lt;/code&gt;程度の計算量がかかります。
そのため、SyntaxDBインスタンスの初期化時に非終端記号と規則群を対応付けたMapを生成する(計算量は&lt;code&gt;O(n)&lt;/code&gt;程度)ことで、findDefの呼び出し時にはMapの中身をそのまま返すだけで済むようにします。&lt;/p&gt;

&lt;p&gt;getTokenIdメソッドは後述するアイテム集合部分で使用する必要がありますが、特に厳密なシリアライズや復元可能性を求めているわけではなく、単にハッシュ代わりに使用されます。
そのため、同一のSyntaxDBインスタンスのgetTokenIdメソッドにトークンを与えると、同一のトークンならば必ず同じ番号が返ってくるようになっていればそれで構いません。
よって、以下のような単純な実装で事足ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// Tokenを与えると一意なidを返す
public getTokenId(token: Token): number{
	if(!this.tokenmap.has(token)) this.tokenmap.set(token, this.tokenid_counter++);
	return this.tokenmap.get(token)!; /// ※ !はTypeScriptのnon-nullable注釈
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このSyntaxDBクラスは、パーサジェネレータ全体を通して一つのインスタンスのみを使いまわすようにします。&lt;/p&gt;

&lt;h2 id=&#34;アイテム集合とクロージャー展開&#34;&gt;アイテム集合とクロージャー展開&lt;/h2&gt;

&lt;p&gt;まずは、LRアイテムおよびその集合を表現するクラスを作っていきます。
アイテム集合クラスには、自身をクロージャー展開する機能を持たせることとします。&lt;/p&gt;

&lt;p&gt;また、DFAの構築において、「既存のアイテム集合の中に、新しく生成されたアイテム集合と一致するものが存在するかどうか判定する」処理が必要とされます。
愚直に実装すると、この処理を1回行うだけで&lt;code&gt;O(n^3)&lt;/code&gt;程度の計算量が必要となり、パーサジェネレータの処理全体の中で最大のボトルネックとなりえます。
そのため、2つのアイテム集合の高速な一致判定を行えるようにする必要があります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/closure.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/closure.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// closure.d.ts
export declare class ClosureItem {
    private syntax;
    private _syntax_id;
    private _dot_index;
    private _lookaheads;
    private _lr0_hash;
    private _lr1_hash;
    constructor(syntax: SyntaxDB, _syntax_id: number, _dot_index: number, _lookaheads: Array&amp;lt;Token&amp;gt;);
    readonly syntax_id: number;
    readonly dot_index: number;
    readonly lookaheads: Array&amp;lt;Token&amp;gt;;
    private sortLA();
    private updateHash();
    getLR0Hash(): string;
    getLR1Hash(): string;
    isSameLR0(c: ClosureItem): boolean;
    isSameLR1(c: ClosureItem): boolean;
    merge(c: ClosureItem): ClosureItem | null;
}
export declare class ClosureSet {
    private syntax;
    private closureset;
    private _lr0_hash;
    private _lr1_hash;
    constructor(syntax: SyntaxDB, closureset: Array&amp;lt;ClosureItem&amp;gt;);
    private sort();
    readonly size: number;
    getArray(): ClosureItem[];
    includes(item: ClosureItem): boolean;
    isSameLR0(c: ClosureSet): boolean;
    isSameLR1(c: ClosureSet): boolean;
    private updateHash();
    getLR0Hash(): string;
    getLR1Hash(): string;
    mergeLA(cs: ClosureSet): ClosureSet | null;
    private expandClosure();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ClosureItemクラスはLRアイテム1つに対応し、構文id、&lt;code&gt;.&lt;/code&gt;の位置、および先読み記号の情報を持ちます。
ClosureSetクラスは複数のClosureItemをまとめた集合を表し、自身をクロージャー展開することが出来ます。
さらに、後述するハッシュに関連した機能、および先読み部分のマージ機能などを持ちます。&lt;/p&gt;

&lt;h3 id=&#34;クロージャー展開&#34;&gt;クロージャー展開&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// クロージャー展開を行う
// TODO: リファクタリング
private expandClosure(){
	// 展開処理中はClosureItemのlookaheadsの要素数を常に1に保つこととする
	// 初期化
	let set:Array&amp;lt;ClosureItem&amp;gt; = [];
	// ClosureItemをlookaheadsごとに分解する
	for(let ci of this.closureset){
		for(let la of ci.lookaheads){
			set.push(new ClosureItem(this.syntax, ci.syntax_id, ci.dot_index, [la]));
		}
	}
	this.closureset = set;
	this.sort();

	// 変更がなくなるまで繰り返す
	let i=0;
	while(i&amp;lt;this.closureset.length){
		let ci = this.closureset[i++];
		let {ltoken, pattern} = this.syntax.get(ci.syntax_id);

		if(ci.dot_index == pattern.length) continue; // .が末尾にある場合はスキップ
		let follow = pattern[ci.dot_index];
		if(!this.syntax.symbols.isNonterminalSymbol(follow)) continue; // .の次の記号が非終端記号でないならばスキップ

		// クロージャー展開を行う

		// 先読み記号を導出
		// ci.lookaheadsは要素数1のため、0番目のインデックスのみを参照すればよい
		let lookaheads = [...this.syntax.first.get(pattern.slice(ci.dot_index+1).concat(ci.lookaheads[0])).values()];
		lookaheads.sort((t1:Token, t2:Token)=&amp;gt;{
			return this.syntax.getTokenId(t1) - this.syntax.getTokenId(t2);
		});

		// symbolを左辺にもつ全ての規則を、先読み記号を付与して追加
		let definitions = this.syntax.findDef(follow);
		for(let {id, def} of definitions){
			for(let la of lookaheads){
				let new_ci = new ClosureItem(this.syntax, id, 0, [la]);
				// 重複がなければ新しいアイテムを追加する
				let flg_duplicated = false;
				for(let existing_item of this.closureset){
					if(new_ci.isSameLR1(existing_item)){
						flg_duplicated = true;
						break;
					}
				}
				if(!flg_duplicated){
					this.closureset.push(new_ci);
				}
			}
		}
	}
	this.sort();

	// ClosureItemの先読み部分をマージする
	let tmp = this.closureset;
	this.closureset = [];
	let lookaheads = [];
	for(let i=0; i&amp;lt;tmp.length; i++){
		lookaheads.push(tmp[i].lookaheads[0]);
		if(i == tmp.length-1 || !tmp[i].isSameLR0(tmp[i+1])){
			this.closureset.push(new ClosureItem(this.syntax, tmp[i].syntax_id, tmp[i].dot_index, lookaheads));
			lookaheads = [];
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まだリファクタリングしていません。
すみません。&lt;/p&gt;

&lt;p&gt;ClosureItemは本来複数の先読み記号を保持することができるのですが、クロージャー展開の初期化段階では、まずそれを分解し、一つのClosureItemが必ず一つの先読み記号のみを持つようにします。&lt;/p&gt;

&lt;p&gt;この制約がなければ、たとえば&lt;code&gt;[x,y]&lt;/code&gt;という先読み記号を持ったAというClosureItemの展開処理が済んだあと、BというClosureItemを展開したところ、&lt;code&gt;[y,z]&lt;/code&gt;という先読み記号を持ち、先読み部分以外はAと全く同じClosureItemが生成される、といった自体が発生する可能性があります。
この場合、先読み記号&lt;code&gt;y&lt;/code&gt;については2度展開されてしまったり、それを防ぐために処理済みのClosureItemの走査を行うことで余計な計算が必要になってしまうなど、様々な弊害が発生します。
クロージャー展開の処理中だけはClosureItemの先読み記号は常に一つであるという制約を設けていることで、展開処理が非常に簡潔になります。&lt;/p&gt;

&lt;p&gt;処理が終わった段階で、ClosureItemの先読み部分をマージすることによってクロージャー展開後のClosureSetが完成します。&lt;/p&gt;

&lt;h3 id=&#34;ハッシュ&#34;&gt;ハッシュ&lt;/h3&gt;

&lt;p&gt;先述したように、2つのClosureSetの高速な比較を可能とする必要があります。
そこで、ClosureItemおよびClosureSetにハッシュ文字列の生成機能を追加し、構文番号、&lt;code&gt;.&lt;/code&gt;の位置、先読み記号という要素が一致していれば同じ文字列を生成するようにすれば、同一性の比較を文字列比較に落としこむことができ、非常に高速になります。
ハッシュといっても、SHA-1やMD5のようなビット列を出力する必要はなく、要素が同じなら同じ結果が得られ、かつ衝突が発生しなければそれでよいので、単純に要素を文字列化してしまえば事足ります。&lt;/p&gt;

&lt;p&gt;たとえば、構文番号1、&lt;code&gt;.&lt;/code&gt;の位置が左から2番目、先読み記号が&lt;code&gt;[$,x]&lt;/code&gt;のClosureItemなら、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;quot;1,2,[$,x]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような文字列を出力すれば目的は果たせます。
ClosureItemの集合であるClosureSetの場合は、まず自身の持っているClosureItemを、このハッシュ文字列を使ってソートした上で、以下のような文字列を生成します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;quot;1,2,[$,x]|2,3,[$]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ClosureItemが常にソートされていると仮定したならば、こちらも同一性の判定に用いることができます。&lt;/p&gt;

&lt;p&gt;ただしこの場合、ひとつだけ問題が生じます。
もし上記の&lt;code&gt;x&lt;/code&gt;のかわりに、&lt;code&gt;x]|2,2,[y&lt;/code&gt;という名前の終端記号があったとすると、さきほどのClosureSetのハッシュ文字列は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;quot;1,2,[$,x]|2,2,[y]|2,3,[$]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となってしまい、&lt;code&gt;2,2,[y]&lt;/code&gt;というClosureItemが存在した時に衝突が発生してしまう可能性があります。
これを防ぐため、先ほどのSyntaxDBを用いて、それぞれの終端記号を個別の数値に直してしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;quot;1,2,[0,1]&amp;quot;
&amp;quot;1,2,[0,1]|2,3,[1]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにすることで、危険性は回避できます。&lt;/p&gt;

&lt;p&gt;また、LALR(1)法のDFAマージの際に、先読み記号を除いた部分が一致しているかどうか調べる必要もあるため、ハッシュ文字列は先読み部分を除いたLR(0)ハッシュと、先読み部分も含めたLR(1)ハッシュの2種類を用意しておきます。&lt;/p&gt;

&lt;h4 id=&#34;closureitemおよびclosuresetのconst性&#34;&gt;ClosureItemおよびClosureSetのconst性&lt;/h4&gt;

&lt;p&gt;ハッシュの再生成や、それに伴うClosureSetのソート処理を回避するため、ClosureItemおよびClosureSetは、初期化終了後は自身の状態を変化させることがないようにします。&lt;/p&gt;

&lt;p&gt;たとえば、クロージャー展開を行うとClosureSetの中身は変化しますが、この処理はコンストラクタ呼び出し時に行うようにすることで、オブジェクトの初期化が終了した時点でクロージャー展開は終わっており、それ以降ClosureSetの状態が変化することはありません。
また、ClosureSetおよびClosureItemは、LR(0)部分(先読み部分を除いた部分)が同じなら先読み記号をマージするmergeメソッドを持っていますが、このメソッドもそのオブジェクト自身の状態を変更するのではなく、新しいオブジェクトを生成してそれを返すようにしています。&lt;/p&gt;

&lt;h2 id=&#34;dfaの構築&#34;&gt;DFAの構築&lt;/h2&gt;

&lt;p&gt;アイテム集合を扱えるようになったため、次はDFAの構築です。
DFAGeneratorクラスを作っていきます。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/dfagenerator.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/dfagenerator.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// dfagenerator.d.ts
export declare type DFAEdge = Map&amp;lt;Token, number&amp;gt;;
export declare type DFANode = {
    closure: ClosureSet;
    edge: DFAEdge;
};
export declare type DFA = Array&amp;lt;DFANode&amp;gt;;
export declare class DFAGenerator {
    private syntax;
    private lr_dfa;
    private lalr_dfa;
    constructor(syntax: SyntaxDB);
    getLR1DFA(): DFA;
    getLALR1DFA(): DFA;
    private generateNewClosureSets(closureset);
    private indexOfDuplicatedNode(dfa, new_node);
    private generateDFA();
    private mergeLA(dfa);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とはいえ、やるべきことはDFAの構築処理、およびLALR(1)法のDFAを生成するためのマージ処理のみです。&lt;/p&gt;

&lt;p&gt;DFAは、DFANodeの配列として表現します。
DFANodeは、一つのClosureSetとDFAEdgeを持ちます。
DFAEdgeはトークンをキーとしてDFANodeのインデックスを持つMapであり、これはトークンをラベルとして他のDFANodeに向けて張られた辺の情報を意味します。&lt;/p&gt;

&lt;p&gt;前回紹介したアルゴリズムをそのままコードにするだけなので、DFAの構築処理は特に解説する点はありません。&lt;/p&gt;

&lt;h2 id=&#34;構文解析表の構築&#34;&gt;構文解析表の構築&lt;/h2&gt;

&lt;p&gt;構文解析表と、それに必要な四種類の命令群を定義しておきます。
また、コンフリクトが発生したことを表す命令も定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// parsingtable.ts
export type ShiftOperation = {type: &amp;quot;shift&amp;quot;, to: number};
export type ReduceOperation = {type: &amp;quot;reduce&amp;quot;, syntax: number};
export type ConflictedOperation = {type: &amp;quot;conflict&amp;quot;, shift_to:Array&amp;lt;number&amp;gt;, reduce_syntax:Array&amp;lt;number&amp;gt;};
export type AcceptOperation = {type: &amp;quot;accept&amp;quot;};
export type GotoOperation = {type : &amp;quot;goto&amp;quot;, to: number};
export type ParsingOperation = ShiftOperation|ReduceOperation|ConflictedOperation|AcceptOperation|GotoOperation;
export type ParsingTable = Array&amp;lt;Map&amp;lt;Token, ParsingOperation&amp;gt;&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;構文解析表の構築処理は、ParserGeneratorクラスのメソッドとして実装します。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/parsergenerator.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/parsergenerator.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// parsergenerator.d.ts
export declare class ParserGenerator {
    private grammar;
    private parsing_table;
    private syntax;
    private dfa_generator;
    constructor(grammar: GrammarDefinition);
    init(): void;
    getParser(default_callback?: ParserCallback): Parser;
    getParsingTable(): ParsingTable;
    private generateParsingTable(dfa);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これも前回紹介したアルゴリズムの通り、DFAを読み取って適切な命令を配置していくだけです。
ParserGeneratorクラスは、初期化時にSyntaxDBおよびDFAGeneratorのインスタンスを生成し、DFAGeneratorから得られたDFAをもとに構文解析表の生成を行います。&lt;/p&gt;

&lt;p&gt;ここまでで構文解析表の構築まで終了したので、パーサジェネレータはほぼ完成となります。
あとは、この構文解析表を読み取ることのできるパーサの実装が必要です。
次回はパーサの実装を行いますが、そのパーサの動作等についても前回の記事である程度解説しているため、やはり実装中心となります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回:かんたん構文解析入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;前回:かんたんLR(1)法入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-06/&#34;&gt;次回:パーサの実装と構文解析の実行&lt;/a&gt;&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第4回:かんたんLR(1)法入門</title>
      <link>http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/</link>
      <pubDate>Wed, 22 Mar 2017 15:58:04 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/</guid>
      <description>
        &lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;前回&lt;/a&gt;で構文解析器を生成する際に必要となる準備を済ませたため、LR(1)法ベースのパーサジェネレータを作る用意が整いました。
ですが相変わらず本題のパーサジェネレータ作成には入らず、まずはLR(1)法のおおまかな理論的概略の紹介を行います。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回&lt;/a&gt;では構文解析全体の流れを解説しましたが、実際にどのような過程でパーサを、またパーサジェネレータを作成するかについては触れませんでした。
今回は、LR法による構文解析の流れを解説するとともに、これからどのような流れでパーサジェネレータを作成していくのかを紹介します。
今回は解説のみのためソースコードが載りません。&lt;/p&gt;

&lt;h2 id=&#34;lr-1-構文解析の流れ&#34;&gt;LR(1)構文解析の流れ&lt;/h2&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;字句規則を用意して字句解析器にかけてトークン列を取得したあと構文規則をもとにFIRST関数とFOLLOW関数を求め、それをもとにgotoグラフを導出することによってLR表を作成して、構築したLRパーサでトークン列を解析して得た抽象構文木を処理すれば構文解析ができると知ったわたし &lt;a href=&#34;https://t.co/aIbxqSf5qj&#34;&gt;pic.twitter.com/aIbxqSf5qj&lt;/a&gt;&lt;/p&gt;&amp;mdash; たたも (@&lt;strong&gt;tatamo&lt;/strong&gt;) &lt;a href=&#34;https://twitter.com/__tatamo__/status/798837425313189888&#34;&gt;2016年11月16日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;FOLLOW関数はSLR法などで使用する概念のため、LR(1)法を用いる今回の記事では用いません。忘れてください。&lt;/p&gt;

&lt;p&gt;LR構文解析の流れは、以下の通りとなります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;First関数を求める&lt;/li&gt;
&lt;li&gt;アイテム集合およびDFA(gotoグラフ)を作成する&lt;/li&gt;
&lt;li&gt;(LALR法のみ)DFAの先読み部分をマージし、より状態数が少なく軽量なDFAにする&lt;/li&gt;
&lt;li&gt;DFAをもとに構文解析表(LR表)を構築する&lt;/li&gt;
&lt;li&gt;構文解析表を実行できるパーサを作成する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1.のFirst関数については、&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;前回&lt;/a&gt;の記事で紹介を済ませているため割愛します。&lt;br /&gt;
LALR法のLR(1)法との相違点は3.のみで、他はLR(1)法と全く同じ処理を行います。&lt;/p&gt;

&lt;p&gt;パーサジェネレータを作成して解析する構文を自由に決定できるようにする場合、4.の構文解析表までを与えられた構文に合わせて自動的に生成できるようにします。&lt;/p&gt;

&lt;h2 id=&#34;アイテム集合とdfa&#34;&gt;アイテム集合とDFA&lt;/h2&gt;

&lt;p&gt;LR法による構文解析のためには、DFA(決定性有限オートマトン)の作成を行う必要があります。&lt;/p&gt;

&lt;p&gt;LR法によって作られるDFAは、それぞれの状態(ノード)に、アイテム集合と呼ばれる情報と、他の状態への遷移ルールを示すトークンをラベルとした辺情報とを持ちます。
このLRアイテム集合は、構文解析表やDFA自身の構築のために必要な情報として使用されます。&lt;/p&gt;

&lt;p&gt;アイテム集合は、文字通りアイテム(便宜的にLRアイテムと呼称します)からなる集合です。&lt;/p&gt;

&lt;h3 id=&#34;lrアイテム&#34;&gt;LRアイテム&lt;/h3&gt;

&lt;p&gt;個別のLRアイテムは、以下のようなものです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;X -&amp;gt; A . B C [x,y,$]
Xは非終端記号
A,B,Cは終端記号または非終端記号
x,yは終端記号
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一見すると&lt;code&gt;X -&amp;gt; A B C&lt;/code&gt;のような構文規則のルールのように見えますが、相違点があります。&lt;/p&gt;

&lt;p&gt;まず、規則の右辺に&lt;code&gt;.&lt;/code&gt;という記号が存在します。
これは終端記号でも非終端記号でもなく、「現在この部分まで解析した」ということを示すマーカーです。
上記の場合、&lt;code&gt;X&lt;/code&gt;という記号の解析の途中で既に&lt;code&gt;A&lt;/code&gt;を読み終え、次は&lt;code&gt;B C&lt;/code&gt;が与えられることが期待されているということを意味します。&lt;/p&gt;

&lt;p&gt;次に、規則の右辺のさらに右に、&lt;code&gt;[x,y,$]&lt;/code&gt;という表記が存在します。
これはLR(1)法の(1)先読みのために用いる先読み記号の集合を表しています。
解析が進んで&lt;code&gt;X&lt;/code&gt;の解析が終わった場合、つまり&lt;code&gt;.&lt;/code&gt;の位置が右端まで移動した場合、その次には&lt;code&gt;x&lt;/code&gt;,&lt;code&gt;y&lt;/code&gt;,&lt;code&gt;$&lt;/code&gt;のいずれかの記号が来ることを意味します。
先読み記号は常に終端記号であることに注意してください。
また、&lt;code&gt;$&lt;/code&gt;は「入力の終わり」を表す記号で、これは便宜的に終端記号として扱います(&lt;a href=&#34;http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/&#34;&gt;第2回&lt;/a&gt;で内部的に追加したSymbol(EOF)トークンのことです)。&lt;/p&gt;

&lt;h3 id=&#34;dfaの構築&#34;&gt;DFAの構築&lt;/h3&gt;

&lt;p&gt;まず、DFAを最初の状態で初期化します。
このとき、DFAのノード数は一つのみであり、そのノードは、以下のようなLRアイテム一つのみを要素とするアイテム集合を持ちます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S&#39; -&amp;gt; . S [$]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただし、&lt;code&gt;S&lt;/code&gt;は開始記号であり、&lt;code&gt;S&#39;&lt;/code&gt;は便宜的に追加した新しい非終端記号です。
便宜的には、&lt;code&gt;S&#39;&lt;/code&gt;について以下の規則が成り立つこととみなします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S&#39; -&amp;gt; S $
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを自己展開させることによって、構文解析のためのDFAを構築していきます。&lt;/p&gt;

&lt;h4 id=&#34;クロージャー展開&#34;&gt;クロージャー展開&lt;/h4&gt;

&lt;p&gt;まず、初期化時点で存在するこのDFAノードは、まだ完全な状態にはなっていません。
一定のルールに従い、アイテム集合を「クロージャー展開」する必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;X -&amp;gt; α . Y β [x]
X,Yは非終端記号(X=Yであってもよい)
xは終端記号
α,βは任意の長さの終端記号または非終端記号の列
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というLRアイテムが存在する場合、&lt;code&gt;Y&lt;/code&gt;を左辺として&lt;code&gt;.&lt;/code&gt;が右辺の左端にあるような新しいLRアイテムを、アイテムセットに追加します。
ただし、先読み記号はFirst(βx)で得られる記号全てとします。
つまり、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;Y -&amp;gt; γ
γは任意の長さの終端記号または非終端記号の列
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような規則があった場合、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;Y -&amp;gt; . γ [First(βx)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というLRアイテムを新しく追加します。&lt;/p&gt;

&lt;p&gt;これを、新しいアイテムが追加されなくなるまで繰り返します。&lt;/p&gt;

&lt;p&gt;具体的に見て行きましょう。
以下の規則を仮定します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S -&amp;gt; 0
S -&amp;gt; X 1
X -&amp;gt; 0
Sは開始記号
S,Xは非終端記号
0,1は終端記号
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、開始記号は&lt;code&gt;S&lt;/code&gt;なので、最初のLRアイテムは以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S&#39; -&amp;gt; . S [$]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.&lt;/code&gt;の次にある&lt;code&gt;S&lt;/code&gt;を展開します。
先読み記号は&lt;code&gt;First($)=[$]&lt;/code&gt;です。
以下のアイテムを追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S -&amp;gt; . 0 [$]
S -&amp;gt; . X 1 [$]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに、新しく追加されたアイテムにも同様の処理を行うと、&lt;code&gt;.&lt;/code&gt;の次に&lt;code&gt;X&lt;/code&gt;があるため、これを展開します。
&lt;code&gt;0&lt;/code&gt;は終端記号のため、展開は行いません。
先読み記号は、&lt;code&gt;First(1$)=[1]&lt;/code&gt;です(First関数は終端記号の列の左端の記号を得るので、ここでは&lt;code&gt;1&lt;/code&gt;のみとなります)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;X -&amp;gt; . 0 [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上の規則では&lt;code&gt;0&lt;/code&gt;は終端記号のため、ここで展開は終了します。&lt;/p&gt;

&lt;p&gt;結果として、最初のDFAノードの持つアイテム集合は以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S&#39; -&amp;gt; . S [$]
S -&amp;gt; . 0 [$]
S -&amp;gt; . X 1 [$]
X -&amp;gt; . 0 [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上がクロージャー展開の処理です。
こうして展開したアイテム集合をもとに、新しいDFAノードを生成していきます。&lt;/p&gt;

&lt;h4 id=&#34;新しいdfaノードの生成&#34;&gt;新しいDFAノードの生成&lt;/h4&gt;

&lt;p&gt;クロージャー展開が完了したアイテム集合から、一定のルールのもとで新しいDFAノードを生成します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;X -&amp;gt; α . A β [x]
Xは非終端記号
Aは終端記号または非終端記号(X=Aであってもよい)
xは終端記号
α,βは任意の長さの終端記号または非終端記号の列
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というLRアイテムが存在する場合、以下の新しいLRアイテムを生成します(そのDFAノードのアイテムセットには追加しません)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;X -&amp;gt; α A . β [x]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そのDFAノードの持つ全てのLRアイテムについてこの処理が終わったら、&lt;code&gt;.&lt;/code&gt;の左隣の記号、つまり&lt;code&gt;A&lt;/code&gt;の位置の記号ごとに新しいアイテム集合を作り、それを情報としてもつ新しいDFAノードを生成します。
そして既存のDFAノードから、&lt;code&gt;A&lt;/code&gt;をラベルとして新しいノードに対して辺を張ります。&lt;/p&gt;

&lt;p&gt;具体的には、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S&#39; -&amp;gt; . S [$]
S -&amp;gt; . 0 [$]
S -&amp;gt; . X 1 [$]
X -&amp;gt; . 0 [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というアイテム集合を持つDFAからは、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S&#39; -&amp;gt; S . [$]
S -&amp;gt; 0 . [$]
S -&amp;gt; X . 1 [$]
X -&amp;gt; 0 . [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という4つのLRアイテムが生成され、これは以下の3つに分けられます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;1. ラベル: S
S&#39; -&amp;gt; S . [$]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;2. ラベル: 0
S -&amp;gt; 0 . [$]
X -&amp;gt; 0 . [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;3. ラベル: X
S -&amp;gt; X . 1 [$]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このようにして新しく3つのDFAノードを生成し、もとのノードからそれぞれの記号をラベルとした辺を張ります。
あとは、新しいノード全てについて、同様にクロージャー展開を行い、さらに新しいDFAノードを生成していきます。
ただし、その過程で既存のノードと全く同じアイテム集合を持つDFAノードが作られた場合は、新しいノードとしてそこに辺を張るのではなく、かわりに重複する既存のノードに対して辺を張るものとします。&lt;/p&gt;

&lt;p&gt;この処理を繰り返し、DFAノードが新しく生成されなくなればDFAの構築は終了です。&lt;/p&gt;

&lt;h4 id=&#34;lalr法のみ-先読み部分のマージ&#34;&gt;(LALR法のみ)先読み部分のマージ&lt;/h4&gt;

&lt;p&gt;LALR法では、この時点でDFAのサイズ縮小を行います。
そのアルゴリズムは、以下の通りです。&lt;/p&gt;

&lt;p&gt;まず、DFAの持つアイテム集合から、それぞれのLRアイテムの先読み部分のみを除いた場合に、全く同じアイテム集合を持つようなDFAノードの組を見つけます。
そして、そのようなDFAノードの組において、LRアイテムの先読み部分をそれぞれの和集合とするような新しいDFAノードを作り、それらのノードに対して辺を張っていたノードがあれば、その辺を新しいノードに対して張り直します。&lt;/p&gt;

&lt;p&gt;具体的に、以下のようなアイテム集合を持つ2つのDFAノードを考えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;DFAノードA:
X -&amp;gt; .Y Z [x]
Y -&amp;gt; .V W [x,y]

DFAノードB:
X -&amp;gt; .Y Z [z]
Y -&amp;gt; .V W [y,z]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この2つのDFAノードは、先読み部分を除けば一致しているため、マージして次のDFAノードCを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;DFAノードC:
X -&amp;gt; .Y Z [x,z]
Y -&amp;gt; .V W [x,y,z]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、DFAノードAまたはBに対して辺を張っているDFAノードが存在するならば、それらの辺をDFAノードCに向けたものに書き換えます。&lt;/p&gt;

&lt;h2 id=&#34;構文解析表と構文解析器&#34;&gt;構文解析表と構文解析器&lt;/h2&gt;

&lt;p&gt;DFAが完成したら、それをもとにして構文解析表を生成していきます。
構文解析表はそれ自体がステートマシンの動作仕様を表すものであり、構文解析表が完成してしまえば、それに沿ってステートマシンを動作させることで構文解析が可能となります。&lt;/p&gt;

&lt;h3 id=&#34;構文解析を行うステートマシン&#34;&gt;構文解析を行うステートマシン&lt;/h3&gt;

&lt;p&gt;構文解析表には、ステートマシンの現在の状態、および次の入力に応じて、4種類の命令のいずれかが記述されます。
構文解析を行うステートマシンは、現在の状態を示すスタックと、構文解析の結果を保持するスタックの2つのスタックを持ちます。
また、入力を一文字だけ確認するか、入力を消費して一文字先に進めることができます。
(この仕様自体は変更の余地があります。)&lt;/p&gt;

&lt;p&gt;ステートマシンは、構文解析表から(状態スタックの一番上にある状態, 現在見ている入力)の命令を実行します。
最初は(初期状態, 一文字目の入力)となります。&lt;/p&gt;

&lt;p&gt;以下に、4つのそれぞれの命令の説明を記します。
とはいえ、ステートマシンの仕様なんざ読んでいて動きが分かるわけもなく楽しくも何ともないため、参考資料の&lt;a href=&#34;http://www.slideshare.net/ichikaz3/lr-parsing&#34;&gt;LR parsing&lt;/a&gt;のスライドを確認していただくことをおすすめします。
ステートマシンの動きを視覚的に追いかけることができて非常にわかりやすいです。&lt;/p&gt;

&lt;h4 id=&#34;shift命令&#34;&gt;shift命令&lt;/h4&gt;

&lt;p&gt;shift命令を受けると、ステートマシンは入力を一つ消費します。
shift命令には状態番号が付与されているので、ステートマシンは状態スタックにその数値を追加します。&lt;/p&gt;

&lt;h4 id=&#34;reduce命令&#34;&gt;reduce命令&lt;/h4&gt;

&lt;p&gt;reduce命令は文法idが付与されています。
ステートマシンがreduce命令を受けると、示された文法規則を確認し、その右辺の記号の数だけ状態スタックからポップして取り除きます。
さらに、結果スタックからも右辺の記号の数だけ取り除き、取り除いた結果すべてを現在見ている規則の左辺の記号を親とする木構造の子にして、そうしてできた木を結果スタックに追加します(または、取り除いた結果および文法idを引数として何らかのプログラムを実行し、その結果をスタックに追加する場合もあります)。&lt;/p&gt;

&lt;p&gt;そしてその処理の終了後、構文解析表の(状態スタックの一番上にある状態、規則の左辺の記号)の位置にあるgoto命令を実行させます。&lt;/p&gt;

&lt;h4 id=&#34;goto命令&#34;&gt;goto命令&lt;/h4&gt;

&lt;p&gt;goto命令は、reduce命令の直後に実行されることが期待されます。
goto命令には状態番号が付与されているので、ステートマシンは状態スタックにその数値を追加します。
shift命令と異なり、入力の消費は行いません。&lt;/p&gt;

&lt;h4 id=&#34;accept命令&#34;&gt;accept命令&lt;/h4&gt;

&lt;p&gt;ステートマシンがaccept命令を受けると、それは構文解析が終了したことを意味します。
理想的な入力が与えられた場合、入力は全て消費され、結果スタックには最終的な構文解析結果のみが入っていることが期待されます。&lt;/p&gt;

&lt;h3 id=&#34;構文解析器&#34;&gt;構文解析器&lt;/h3&gt;

&lt;p&gt;構文解析器は、上記の仕様をなぞって構文解析表を読み取ることのできるステートマシンそのものです。
よって、構文解析表さえ個々の構文にあわせて生成することができれば、それを構文解析器に与えることによってさまざまな構文の解析が可能になります。&lt;/p&gt;

&lt;h3 id=&#34;構文解析表の構築&#34;&gt;構文解析表の構築&lt;/h3&gt;

&lt;p&gt;完成したDFAをもとにして、構文解析表を生成することができます。&lt;/p&gt;

&lt;h4 id=&#34;shiftおよびgotoオペレーションの登録&#34;&gt;shiftおよびgotoオペレーションの登録&lt;/h4&gt;

&lt;p&gt;それぞれのDFAノードは、ステートマシンの状態と対応しています。
簡単のため、個々のDFAノードには一意なid(ステートマシンの状態番号)が割り振られているものとします。
すべてのDFAノードについて、そのノードから張られている辺を参照します。&lt;/p&gt;

&lt;p&gt;その辺のラベルの記号が終端記号であるならば、構文解析表の(そのDFAノードのid, ラベルの記号)の部分にshift命令を書き込み、その辺の向かう対象となるDFAノードのidを付与します。&lt;/p&gt;

&lt;p&gt;その辺のラベルの記号が非終端記号であるならば、同様にしてgoto命令を書き込みます。&lt;/p&gt;

&lt;h4 id=&#34;acceptおよびreduceオペレーションの登録&#34;&gt;acceptおよびreduceオペレーションの登録&lt;/h4&gt;

&lt;p&gt;すべてのDFAノードについて、そのアイテム集合の持つLRアイテム一つ一つを確認していきます。
もしも&lt;code&gt;.&lt;/code&gt;の位置が右辺の末尾にある場合、そのLRアイテムの持つ先読み記号それぞれについて、以下の処理を行います。&lt;/p&gt;

&lt;p&gt;構文解析表の(そのDFAノードのid, 先読み記号)の部分にreduce命令を書き込み、そのLRアイテムのもととなっている規則のidを付与。&lt;/p&gt;

&lt;p&gt;ただし、その規則が&lt;code&gt;S&#39;&lt;/code&gt;に対応するものであった場合、かわりにaccept命令を書き込みます。&lt;/p&gt;

&lt;h4 id=&#34;shift-reduceコンフリクト&#34;&gt;shift/reduceコンフリクト&lt;/h4&gt;

&lt;p&gt;shiftオペレーションおよびreduceオペレーションは、表の同じ位置に競合して書き込まれてしまうことがあります。
このような状況を、shift/reduceコンフリクトと呼びます。
なお、shift/reduceコンフリクトだけでなく、reduce/reduceコンフリクト、複数回競合しあった3つ以上の命令のコンフリクト等も発生する可能性があります(shift/shiftコンフリクトも発生する可能性があると聞きましたが、上記のアルゴリズムでshiftを登録している場合はDFAが壊れていない限り発生し得ない気がします)。&lt;/p&gt;

&lt;p&gt;コンフリクトが発生してしまった場合の対処法は、大きく分けて二種類存在します。&lt;/p&gt;

&lt;p&gt;まずひとつは、諦めることです。
コンフリクトが発生した時点でそれはLR(1)文法を逸脱しているため、もともと解析可能な構文ではありません。
構文規則を等価になるようにいろいろ書き換えるとうまくコンフリクトが消せる(かもしれない)ので、与える構文の見直しをします。&lt;/p&gt;

&lt;p&gt;もうひとつは、規則ごとにオペレーションの優先度を設定し、コンフリクトが発生した場合は強制的にどちらかの命令を実行すると決めてしまうことです。
これは一般的に行われている方法であり、かなり乱暴ですが大抵の場合はまあなんとかなります。&lt;/p&gt;

&lt;h2 id=&#34;参考資料&#34;&gt;参考資料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回&lt;/a&gt;で紹介したものを今回もそのまま参考資料としているため、基本的にはそちらをご覧ください。
今回紹介した内容の理解を深めるのに特に役立つと思われるおすすめの資料を抜粋しておきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.cornell.edu/courses/cs412/2003sp/lectures/lec09.pdf&#34;&gt;Cornell CIS Introduction to Compilers Lecture 9: LR(1) Parsing&lt;/a&gt;&lt;br /&gt;
LR(1) DFA、クロージャー展開、構文解析表等について詳細な定義や図解等が記載されています。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/ichikaz3/lr-parsing&#34;&gt;LR parsing&lt;/a&gt;&lt;br /&gt;
クロージャー展開やDFAの構築、実際のステートマシンの動きに至るまで実際の動作過程を見ることができます。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;今回でおおまかなLR(1)構文解析器作りの解説を済ませたので、次回からは実装をしていくだけです。
誰も他人のソースコードの解説なんて読む気は起きないでしょうし、これ以上続ける意味があるのか大いに疑問ではあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回:かんたん構文解析入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;前回:儀式の下準備&lt;/a&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-05/&#34;&gt;次回:LR(1)パーサジェネレータの実装&lt;/a&gt;&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第3回:儀式の下準備</title>
      <link>http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/</link>
      <pubDate>Tue, 21 Mar 2017 00:29:18 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/</guid>
      <description>
        &lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/&#34;&gt;前回&lt;/a&gt;は字句解析器の作成を行ったので、次にLR(1)法による構文解析のためのパーサジェネレータの作成に入っていきます。
今回は、LR(1)構文解析器の構築のために必要な、終端記号と非終端記号の区別、Nulls集合、First集合の導出等を行えるようにしていきます。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;いよいよ構文解析部分の実装にとりかかるため、今後はLR(1)法に焦点を絞って解説していきます。&lt;/p&gt;

&lt;p&gt;今回はその準備段階として必要になる部分を作っていくため、どんどん実装を進めていきます。&lt;/p&gt;

&lt;h2 id=&#34;構文規則を定義する&#34;&gt;構文規則を定義する&lt;/h2&gt;

&lt;p&gt;まずは、前回字句規則を定義したように、構文規則を定義していく必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export interface LexDefinitionSection{
	token: Token|null;
	pattern: string|RegExp;
}
export type LexDefinitions = Array&amp;lt;LexDefinitionSection&amp;gt;;

export interface SyntaxDefinitionSection{
	ltoken: Token;
	pattern: Array&amp;lt;Token&amp;gt;;
}
export type SyntaxDefinitions = Array&amp;lt;SyntaxDefinitionSection&amp;gt;;

export interface GrammarDefinition{
	lex: LexDefinitions;
	syntax: SyntaxDefinitions;
	start_symbol: Token;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字句規則と構文規則を合わせて、上記のように定義しておきましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回&lt;/a&gt;で定義した構文規則をこのデータ形式に直すと、以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const syntax:SyntaxDefinitions = [
	{
		ltoken: &amp;quot;EXP&amp;quot;,
		pattern: [&amp;quot;EXP&amp;quot;, &amp;quot;PLUS&amp;quot;, &amp;quot;TERM&amp;quot;]
	},
	{
		ltoken: &amp;quot;EXP&amp;quot;,
		pattern: [&amp;quot;TERM&amp;quot;]
	},
	{
		ltoken: &amp;quot;TERM&amp;quot;,
		pattern: [&amp;quot;TERM&amp;quot;, &amp;quot;ASTERISK&amp;quot;, &amp;quot;ATOM&amp;quot;]
	},
	{
		ltoken: &amp;quot;TERM&amp;quot;,
		pattern: [&amp;quot;ATOM&amp;quot;]
	},
	{
		ltoken: &amp;quot;ATOM&amp;quot;,
		pattern:[&amp;quot;DIGITS&amp;quot;]
	},
	{
		ltoken: &amp;quot;ATOM&amp;quot;,
		pattern:[&amp;quot;LPAREN&amp;quot;, &amp;quot;EXP&amp;quot;, &amp;quot;RPAREN&amp;quot;]
	}
];
const lex:LexDefinitions = [
	{token:&amp;quot;DIGITS&amp;quot;, pattern:/[1-9][0-9]*/},
	{token:&amp;quot;PLUS&amp;quot;, pattern:&amp;quot;+&amp;quot;},
	{token:&amp;quot;ASTERISK&amp;quot;, pattern:&amp;quot;*&amp;quot;},
	{token:&amp;quot;LPAREN&amp;quot;, pattern:&amp;quot;(&amp;quot;},
	{token:&amp;quot;RPAREN&amp;quot;, pattern:&amp;quot;)&amp;quot;},
	{token:null, pattern:/\s/},
	{token:&amp;quot;INVALID&amp;quot;, pattern:/./},
];
const grammar:GrammarDefinition = {
	lex: lex,
	syntax: syntax,
	start_symbol: &amp;quot;EXP&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ルール一行ごとに一つのオブジェクトを割り当てています。
また、&lt;code&gt;start_symbol&lt;/code&gt;の定義を加えていることに注意してください。
これは文字通り開始記号のことであり、最初にどの記号から構文解析を開始するか表すために必要です。
最終的に構文解析を行った結果として構文木を得た場合、この開始記号が構文木の根となります。&lt;/p&gt;

&lt;h2 id=&#34;終端記号と非終端記号を区別する&#34;&gt;終端記号と非終端記号を区別する&lt;/h2&gt;

&lt;p&gt;構文解析器を作るためには、与えられた構文から終端記号と非終端記号を区別できるようにする必要があります。
定義を再確認しておくと、規則の左辺に現れることのない記号が終端記号、現れる記号が非終端記号です。&lt;/p&gt;

&lt;p&gt;実装上難しい点は特にないので、簡単に済ませてしまいましょう。&lt;/p&gt;

&lt;p&gt;ひとまず、SymbolDiscriminatorというクラスを作って終端記号と非終端記号の問い合わせをできるようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// symboldiscriminator.d.ts
export declare class SymbolDiscriminator {
    private terminal_symbols;
    private nonterminal_symbols;
    constructor(syntaxdef: SyntaxDefinitions);
    getTerminalSymbols(): Set&amp;lt;Token&amp;gt;;
    getNonterminalSymbols(): Set&amp;lt;Token&amp;gt;;
    isTerminalSymbol(symbol: Token): boolean;
    isNonterminalSymbol(symbol: Token): boolean;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際のコードは以下を参照してください。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/symboldiscriminator.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/symboldiscriminator.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// コンストラクタの実装のみ抜粋
constructor(syntaxdef:SyntaxDefinitions){
	this.terminal_symbols = new Set&amp;lt;Token&amp;gt;();
	this.nonterminal_symbols = new Set&amp;lt;Token&amp;gt;();

	// 左辺値の登録
	for(let sect of syntaxdef){
		let symbol = sect.ltoken;
		// 構文規則の左辺に現れる記号は非終端記号
		this.nonterminal_symbols.add(symbol);
	}
	// 右辺値の登録
	for(let sect of syntaxdef){
		for(let symbol of sect.pattern){
			if(!this.nonterminal_symbols.has(symbol)){
				// 非終端記号でない(=左辺値に現れない)場合、終端記号である
				this.terminal_symbols.add(symbol);
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2つのSetを用意し、コンストラクタの呼び出し時に左辺に現れる記号とそうでない記号で分けています。
これで、トークンを与えるとそれが終端記号かどうか、非終端記号かどうかを判別できるようになりました。&lt;/p&gt;

&lt;p&gt;なおこの記事において、「トークン」と「記号」は概念上は同様の意味を持ちますが、前者はプログラム内で記号を表すための構造として扱い、理論的な概念について触れる際は後者を使うものとします。&lt;/p&gt;

&lt;h2 id=&#34;nulls集合とfirst集合&#34;&gt;Nulls集合とFirst集合&lt;/h2&gt;

&lt;p&gt;構文解析器の作成のためには、First集合というものを求める必要があります。
そしてFisrt集合を求めるためには、Nulls集合が必要です。&lt;/p&gt;

&lt;p&gt;First集合はFirst関数などとも呼ばれます。
まあ名前なんてどうでもいいのですが、とにかくFirstとNullsを導出しなければなりません。
順を追って見て行きましょう。
例に漏れず、&lt;a href=&#34;https://twitter.com/ki6o4&#34;&gt;うさぎさん(@ki6o4)&lt;/a&gt;の&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kimiyuki.net/blog/2016/08/03/context-free-grammar/&#34;&gt;文脈自由文法とその構文解析法 &amp;middot; うさぎ小屋&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が詳しいので厳密な定義等はそちらを参照してください(First,NullableはLL(1)の項で紹介されています)。&lt;/p&gt;

&lt;h3 id=&#34;nulls集合を求める&#34;&gt;Nulls集合を求める&lt;/h3&gt;

&lt;h4 id=&#34;nulls集合とは&#34;&gt;Nulls集合とは&lt;/h4&gt;

&lt;p&gt;ある終端記号または非終端記号について、それが「Nullableである」かどうかを判別する必要があります。
「Nullableな記号」を集めた集合をNulls集合ということにします。
記号がNullableであるとは、その記号から空列が導かれうることを意味します。&lt;/p&gt;

&lt;p&gt;今回題材としている数式の構文規則には、「右辺が存在しない」ルールはありません。
しかし、解析したい構文によっては、右辺が存在しない、つまり左辺から空列が導かれるルールが存在することがあります。
空列とはスペース(空白)等を意味するのではなく、長さ0の入力を意味します。
具体的には、次のようなルールを見てみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;X -&amp;gt; Y &amp;quot;0&amp;quot;
Y -&amp;gt; &amp;quot;1&amp;quot;
Y -&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;構文規則の三行目の右辺には何も書かれていません。
このような場合、&lt;code&gt;Y&lt;/code&gt;は&lt;code&gt;1&lt;/code&gt;もしくは空列となり得ます。
よって&lt;code&gt;X&lt;/code&gt;は、&lt;code&gt;10&lt;/code&gt;と&lt;code&gt;0&lt;/code&gt;の2通りが許容されるのです。
ここで、&lt;code&gt;Y&lt;/code&gt;は空列となり得るため、Nulls集合に含まれます。
さらに、次のような例を見てください。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;Z -&amp;gt; Y
Y -&amp;gt; &amp;quot;1&amp;quot;
Y -&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、&lt;code&gt;Z&lt;/code&gt;は&lt;code&gt;1&lt;/code&gt;と空列の2通りとなる可能性があります。
よって、&lt;code&gt;Z&lt;/code&gt;もNullableであるといえます。
このように、その記号自体が空列となるルールを指定していなくても、右辺の記号次第では空列となることがあります。
ひとつでも空列となるパターンが存在する場合、Nulls集合に含まなければなりません。
また当然ですが、左辺に現れることのない終端記号はNullableではありません。&lt;/p&gt;

&lt;h4 id=&#34;nulls集合を実装する&#34;&gt;Nulls集合を実装する&lt;/h4&gt;

&lt;p&gt;なにやら面倒そうですが、実装はそう複雑ではありません。
NullableSetクラスを作ってみましょう。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/nullableset.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/nullableset.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// nullableset.ts
export class NullableSet{
	private nulls:Set&amp;lt;Token&amp;gt;;
	constructor(private syntax: SyntaxDefinitions){
		this.generateNulls();
	}
	// nulls初期化
	private generateNulls(){
		// 制約条件を導出するために、
		// 空列になりうる記号の集合nullsを導出
		this.nulls = new Set&amp;lt;Token&amp;gt;();
		for(let rule of this.syntax){
			// 右辺の記号の数が0の規則を持つ記号は空列になりうる
			if(rule.pattern.length == 0){
				this.nulls.add(rule.ltoken);
			}
		}

		// 変更が起きなくなるまでループする
		let flg_changed:boolean = true;
		while(flg_changed){
			flg_changed = false;
			for(let rule of this.syntax){
				// 既にnullsに含まれていればスキップ
				if(this.isNullable(rule.ltoken)) continue;

				let flg_nulls = true;
				// 右辺に含まれる記号がすべてnullableの場合はその左辺はnullable
				for(let token of rule.pattern){
					if(!this.isNullable(token)){
						// 一つでもnullableでない記号があるならnon-nullable
						flg_nulls = false;
						break;
					}
				}
				if(flg_nulls){
					flg_changed = true;
					this.nulls.add(rule.ltoken);
				}
			}
		}
	}
	public isNullable(x:Token){
		return this.nulls.has(x);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アルゴリズムは以下の通りです。&lt;br /&gt;
まず、右辺の記号の数が0になるような規則を持っている記号は明らかにNullableです。
そのため、初期化段階として、そのような規則を探してNulls集合に追加します。&lt;br /&gt;
次に、それ以外の記号がNullableであるためには、規則の右辺がすべてNullableな記号である必要があります。
そこで、すべての規則を調べ、その右辺の記号がすべて既存のNull集合に含まれているならば、その記号もNulls集合に追加します。&lt;br /&gt;
この処理を、一巡しても新しいNullableな規則が追加されなくなるまで繰り返せば終了です。&lt;/p&gt;

&lt;h3 id=&#34;first集合を求める&#34;&gt;First集合を求める&lt;/h3&gt;

&lt;h4 id=&#34;first集合とは&#34;&gt;First集合とは&lt;/h4&gt;

&lt;p&gt;たとえば先ほど挙げた&lt;code&gt;X&lt;/code&gt;が&lt;code&gt;10&lt;/code&gt;や&lt;code&gt;0&lt;/code&gt;となるように、非終端記号は規則をたどっていくと終端記号のみの列に変換することができます。
構文解析を行うためには、ある非終端記号から得られるそのような終端記号の列のうち、最も左側にどのような終端記号が来るのかを知る必要があります。
今解析している記号の次に非終端記号が来るときに、実際にどのような終端記号が来るのかを調べることによって、(1)先読み(&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回&lt;/a&gt;参照)が可能となるわけです。&lt;/p&gt;

&lt;p&gt;このように、ある非終端記号と、そこから得られる可能性のある終端記号の列の先頭に来る記号の集合を対応付けたものを、First集合またはFirst関数と呼びます。
たとえば、先ほどの&lt;code&gt;X&lt;/code&gt;を例にすると、&lt;code&gt;First(X)&lt;/code&gt;は、&lt;code&gt;10&lt;/code&gt;と&lt;code&gt;0&lt;/code&gt;のそれぞれ左端の記号をとって&lt;code&gt;{1, 0}&lt;/code&gt;となります。&lt;/p&gt;

&lt;p&gt;Aが終端記号であるなら、&lt;code&gt;First(A)&lt;/code&gt;は&lt;code&gt;{A}&lt;/code&gt;(A自身のみを要素とする集合)です。
また、Firstに与える引数は記号だけでなく記号列である可能性もあります。
&lt;code&gt;First(YA)&lt;/code&gt;なら、&lt;code&gt;Y&lt;/code&gt;がNullableであるため、&lt;code&gt;YA&lt;/code&gt;から得られうる文字列の左端になりうるのは&lt;code&gt;1&lt;/code&gt;と&lt;code&gt;A&lt;/code&gt;なので、&lt;code&gt;{1, A}&lt;/code&gt;のようになるでしょう。&lt;/p&gt;

&lt;h4 id=&#34;first集合の実装&#34;&gt;First集合の実装&lt;/h4&gt;

&lt;p&gt;話がごちゃごちゃしてきましたが、実装に移りましょう。
基本的なアルゴリズムは、以下のようになります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ある記号&lt;code&gt;A&lt;/code&gt;が終端記号なら、&lt;code&gt;First(A)&lt;/code&gt;は&lt;code&gt;{A}&lt;/code&gt;である。全ての終端記号についてそのように初期化する。&lt;/li&gt;
&lt;li&gt;非終端記号に対応するFirst集合は、まず空集合で初期化する。&lt;/li&gt;
&lt;li&gt;ルール &lt;code&gt;X -&amp;gt; Y1 Y2 ... Yi&lt;/code&gt; について、以下の制約を生成する。

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;First(X) ⊇ First(Y1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Y1&lt;/code&gt;がNullableなら &lt;code&gt;First(X) ⊇ First(Y2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Y1&lt;/code&gt;および&lt;code&gt;Y2&lt;/code&gt;がともにNullableなら &lt;code&gt;First(X) ⊇ First(Y3)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Y1&lt;/code&gt;および&lt;code&gt;Y2&lt;/code&gt;および&lt;code&gt;Y3&lt;/code&gt;がともにNullableなら &lt;code&gt;First(X) ⊇ First(Y4)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;以下繰り返し&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;生成した制約に従い、スーパーセット側にサブセット側の集合の持つ記号を追加していく(制約の解消)。&lt;/li&gt;
&lt;li&gt;制約の解消を全ての集合に変化がなくなるまで繰り返す。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;わかりにくいですね。
ちなみにこのアルゴリズムは、言葉で定義するよりもプログラムを書いたほうがわかりやすい類のものです。&lt;/p&gt;

&lt;p&gt;とはいえちょっとコードが長いので、URLから参照をお願いします。
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/firstset.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/firstset.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// firstset.d.ts
export declare class FirstSet {
    private syntax;
    private symbols;
    private first_map;
    private nulls;
    constructor(syntax: SyntaxDefinitions, symbols: SymbolDiscriminator);
    private generateFirst();
    get(arg: Token): Set&amp;lt;Token&amp;gt;;
    get(arg: Array&amp;lt;Token&amp;gt;): Set&amp;lt;Token&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実のところNulls集合はFirst集合を求める時にしか使わないので、First関数のprivateメンバとしてNullableSetインスタンスを生成して使用します。
SymbolDiscriminatorは他でも使いまわす必要があるので、コンストラクタ引数による依存性の注入を行います。&lt;/p&gt;

&lt;p&gt;また、First関数の引数には単一の記号だけでなく、記号列も与えられるようにする必要があります。
getメソッドではトークンを引数にとるだけでなく、トークンの配列も引数として与えることができるようにします。
トークンの配列が与えられた場合は、左から順に個別のトークンのFirst関数を呼び、そのトークンがNullableである限り、その右隣のFirst関数も呼び出し、その結果として得られた記号全てを要素とする集合を返すものとします。&lt;/p&gt;

&lt;p&gt;説明が適当かつわかりにくくて申し訳ありませんが、どうせ準備段階なので軽く飛ばして先に進めていきましょう(&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回&lt;/a&gt;に参考資料をまとめてあるため、詳細かつ厳密に知りたい方はそちらを参照してください)。&lt;/p&gt;

&lt;p&gt;これでひとまずFirst集合の導出まで終わったので、次回からは構文解析表の作成にとりかかります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回:かんたん構文解析入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/&#34;&gt;前回:字句解析器の実装&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;次回:かんたんLR(1)法入門&lt;/a&gt;&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第2回:字句解析器の実装</title>
      <link>http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/</link>
      <pubDate>Sat, 11 Feb 2017 18:13:48 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/</guid>
      <description>
        &lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;前回&lt;/a&gt;は構文解析の概略を紹介したので、今回から実装に移っていきたいと思います。
まずは字句解析器を用意する必要があるため、今回は字句解析器の作成について紹介します。&lt;/p&gt;

&lt;p&gt;なお今回から実際のプログラムを記述していきますが、使用言語はTypeScriptとします。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;パーサジェネレータを作るのに比べれば字句解析器を作るのは非常に単純です。
早速はじめていきましょう。&lt;/p&gt;

&lt;h2 id=&#34;字句解析器の仕様を確認する&#34;&gt;字句解析器の仕様を確認する&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;前回&lt;/a&gt;の記事でも紹介しましたが、字句解析器の行う処理は以下のような流れになります。&lt;/p&gt;

&lt;p&gt;まず、解析するべき入力を文字列として受け取ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;9 + 11 * (2 + 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに加えて、字句規則を用意します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;数字: /[1-9][0-9]*/
プラス: &amp;quot;+&amp;quot;
アステリスク: &amp;quot;*&amp;quot;
左括弧: &amp;quot;(&amp;quot;
右括弧: &amp;quot;)&amp;quot;
(読み捨て): /\s/
(不正): /./
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字句解析器は受け取った入力を先頭から順に字句規則にあてはめ、マッチするものがあればそのトークンを割り当てます。
結果として得られる出力は、以下のようなリストになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;数字: 9
プラス: +
数字: 11
アステリスク: *
左括弧: (
数字: 2
プラス: +
数字: 1
右括弧: )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得られたトークンのリストを構文解析器の入力として渡すことで、構文解析器は文法の解析のみに注力することができます。&lt;/p&gt;

&lt;h2 id=&#34;字句規則を定義する&#34;&gt;字句規則を定義する&lt;/h2&gt;

&lt;p&gt;実際に解析を行うタイミングでは文字列のみを入力として受け取りますが、字句解析器の生成時には字句規則が必要です。
そのため、予め字句規則を別の設定ファイルなどに書いておくなどして用意しておかなければなりません。
ただし、&lt;strong&gt;字句規則の解析には構文解析器が必要&lt;/strong&gt;となるため、現時点ではプログラム内にハードコーディングしておくなどする必要があります。
今回は、字句規則を内部的に以下のようなデータ構造で扱うこととして、しばらくは字句規則をその内部データの形式で直接書くことにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// 定義
export type Token = string|symbol;
export interface LexDefinitionSection{
	token: Token|null;
	pattern: string|RegExp;
}
export type LexDefinitions = Array&amp;lt;LexDefinitionSection&amp;gt;;

// 実際の字句規則
const lex: LexDefinitions = [
	{token:&amp;quot;DIGITS&amp;quot;, pattern:/[1-9][0-9]*/},
	{token:&amp;quot;PLUS&amp;quot;, pattern:&amp;quot;+&amp;quot;},
	{token:&amp;quot;ASTERISK&amp;quot;, pattern:&amp;quot;*&amp;quot;},
	{token:&amp;quot;LPAREN&amp;quot;, pattern:&amp;quot;(&amp;quot;},
	{token:&amp;quot;RPAREN&amp;quot;, pattern:&amp;quot;)&amp;quot;},
	{token:null, pattern:/\s/},
	{token:&amp;quot;INVALID&amp;quot;, pattern:/./},
];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この字句規則の定義について、実用上の理由で追加したいくつかの仕様に注意する必要があります。&lt;/p&gt;

&lt;p&gt;Tokenの型定義にsymbolを含めている点についてはここで説明せずに後述することとします。&lt;/p&gt;

&lt;h3 id=&#34;入力の読み捨て&#34;&gt;入力の読み捨て&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;{token:null, pattern:/\s/}
// (読み捨て): /\s/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この部分は、何らかの空白文字が入力に存在していればマッチングされます。
&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; を解析する際、ここに含まれている空白は文法上何の意味も持たず、&lt;code&gt;9+11*(2+1)&lt;/code&gt; のように入力が与えられたとしても解析結果は変化しません。
このような場合、構文解析器に空白の情報を与えることすらせずに、字句解析器上で空白を検知した段階でその情報を捨ててしまったほうが、構文解析器に余計な処理をさせずに済みます。&lt;/p&gt;

&lt;p&gt;今回は、トークンのラベル部分にnullを指定することで、読み取った結果をトークンとして保持することなく読み捨てることを表すようにしています。&lt;/p&gt;

&lt;h3 id=&#34;正規表現パターンと文字列パターンの使い分け&#34;&gt;正規表現パターンと文字列パターンの使い分け&lt;/h3&gt;

&lt;p&gt;(ごちゃごちゃ書いている割に小手先のテクニックという感じが強いため、よくわからなければ読み飛ばしてください)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{token:&amp;quot;PLUS&amp;quot;, pattern:&amp;quot;+&amp;quot;}&lt;/code&gt; のように、パターン部分に正規表現ではなく文字列を用いて記述している箇所があります。
すべて正規表現を使って記述するのではなく文字列も許容している理由として、まず&lt;code&gt;/\+/&lt;/code&gt;のように特殊記号をエスケープせずに済む点が挙げられます。
そして、「文字列でパターンを記述した場合は、アルファベットの途中でトークンを区切らないようにする」というルールを用いることで、一部のパターンを簡潔に書くことが可能になります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vwxyz&lt;/code&gt; という入力を考えてみましょう。
ここでもし、&lt;code&gt;&amp;quot;vwx&amp;quot;&lt;/code&gt; にマッチする規則と、&lt;code&gt;&amp;quot;vwxyz&amp;quot;&lt;/code&gt; にマッチする規則の2つが存在した場合、&lt;code&gt;&amp;quot;vwxyz&amp;quot;&lt;/code&gt; の規則を先に書かない限り、入力&lt;code&gt;vwxyz&lt;/code&gt; は&lt;code&gt;&amp;quot;vwx&amp;quot; + yz&lt;/code&gt; とみなされ、&lt;code&gt;&amp;quot;yz&amp;quot;&lt;/code&gt; に対応する規則が存在しなければエラーとなります。
これを回避するためには、よりマッチするパターンが長い規則を常に短い規則よりも先に書くようにする必要がありますが、面倒です。
そこで、正規表現ではなく文字列で&lt;code&gt;&amp;quot;vwx&amp;quot;&lt;/code&gt; などのパターンが定義され、かつその末尾の文字が&lt;code&gt;\w&lt;/code&gt; にマッチする場合、マッチした部分の一文字先の文字が&lt;code&gt;\w&lt;/code&gt; 以外でなければマッチしないようにします。
これは、正規表現で&lt;code&gt;/vwx(?!\w)/&lt;/code&gt; 、&lt;code&gt;/vwxyz(?!\w)/&lt;/code&gt; というような否定的前方先読みをパターンの最後に追加することに相当します。
このルールを追加することで、正規表現を用いる場合よりも簡潔に記述可能となります。&lt;/p&gt;

&lt;h2 id=&#34;字句解析器を実装する&#34;&gt;字句解析器を実装する&lt;/h2&gt;

&lt;p&gt;ではLexerクラスを作っていきましょう。
とはいえ字句規則さえ定義してしまえば、やることはほとんどありません。
コンストラクタ引数として字句規則データを受け取って保持しておくようにして、解析実行時に上から順に字句規則のマッチングを試みるだけです。&lt;/p&gt;

&lt;p&gt;今回はコード量が少ないので、 &lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/lexer.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/lexer.ts&lt;/a&gt; 全体をそのまま貼り付けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// token.ts
export type Token = string|symbol;
export const SYMBOL_EOF:Token = Symbol(&amp;quot;EOF&amp;quot;);
export const SYMBOL_SYNTAX:Token = Symbol(&amp;quot;S&#39;&amp;quot;);
export const SYMBOL_DOT:Token = Symbol(&amp;quot;.&amp;quot;);

export type TokenList = Array&amp;lt;{token:Token, value:string}&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// lexer.ts
/// LexDefinitionsの定義は先述のものと同一
import {Token, SYMBOL_EOF, TokenList} from &amp;quot;./token&amp;quot;;
import {LexDefinitions} from &amp;quot;./grammar&amp;quot;;

export interface ILexer{
	exec(str: string):TokenList;
}

export class Lexer implements ILexer{
	constructor(public def: LexDefinitions){
		// 正しいトークン定義が与えられているかチェック
		for(var i=0; i&amp;lt;this.def.length; i++){
			var token_pattern = this.def[i].pattern;
			if(typeof token_pattern == &amp;quot;string&amp;quot;){
				continue;
			}
			else if(token_pattern instanceof RegExp){
				// フラグを整形する
				let flags:string = &amp;quot;&amp;quot;;
				// gフラグは邪魔なので取り除く
				// i,m,uフラグがあれば維持する
				if(token_pattern.ignoreCase){
					flags += &amp;quot;i&amp;quot;;
				}
				if(token_pattern.multiline){
					flags += &amp;quot;m&amp;quot;;
				}
				if(token_pattern.unicode){
					flags += &amp;quot;u&amp;quot;;
				}
				// yフラグは必ずつける
				flags += &amp;quot;y&amp;quot;;
				// フラグをつけなおして新しい正規表現オブジェクトにする
				this.def[i].pattern = new RegExp(token_pattern, flags);
				continue;
			}
			throw new Error(&amp;quot;invalid token definition: neither string nor RegExp object&amp;quot;);
		}
	}
	exec(str: string):TokenList{
		var result:TokenList = [];
		let lastindex = 0;
		while(lastindex &amp;lt; str.length){
			for(var i=0; i&amp;lt;this.def.length; i++){
				var token:Token|null = this.def[i].token;
				var token_pattern = this.def[i].pattern;
				var match:string;
				if(typeof token_pattern == &amp;quot;string&amp;quot;){
					let last_tmp = lastindex+token_pattern.length;
					if(str.substring(lastindex,last_tmp) != token_pattern) continue;
					if(last_tmp &amp;lt; str.length &amp;amp;&amp;amp; /\w/.test(token_pattern.slice(-1)) &amp;amp;&amp;amp; /\w/.test(str[last_tmp])) continue; // ヒットした文字の末尾が\wで、そのすぐ後ろが\wの場合はスキップ
					match = token_pattern;
					lastindex += token_pattern.length;
				}
				else{
					// token_pattern: RegExp
					token_pattern.lastIndex = lastindex;
					let m = token_pattern.exec(str);
					if(m === null) continue; // マッチ失敗
					match = m[0];
					lastindex = token_pattern.lastIndex; // lastindexを進める
				}
				// tokenがnullなら処理を飛ばします
				if(token != null){
					result.push({token:token, value:match});
				}
				break;
			}
		}
		// 最後にEOFトークンを付与
		result.push({token:SYMBOL_EOF, value:&amp;quot;&amp;quot;});
		return result;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まずコンストラクタでは、与えられた字句規則に簡単な型チェックと正規表現の整形を行っています。
グローバルマッチは今回は邪魔なだけなので、与えられた正規表現にgフラグがついていれば取り除きます。
ES2015でRegExpに追加されたstickyフラグ(&lt;strong&gt;ほぼ&lt;/strong&gt;全ての主要モダンブラウザ上で実装済み)を使うと楽なので、ここでyフラグの追加も行います。&lt;/p&gt;

&lt;p&gt;execメソッドでは入力を読み終えるまでマッチングを繰り返し、&lt;code&gt;{token:Token, value:string}&lt;/code&gt; というオブジェクトを結果の配列に追加していきます。
先述のようにパターンが文字列であれば&lt;code&gt;\w&lt;/code&gt;が連続した場所では区切らないようにして、マッチングが成功するたびにインデックス位置を先に進めていきます。&lt;/p&gt;

&lt;p&gt;また、すべての入力を読み終えた後、最後にSymbol(EOF)を名前としたトークンを結果に追加します。
これは入力の末尾を意味するトークンで、構文解析の際に内部的に使用されます。&lt;/p&gt;

&lt;p&gt;(Symbolは、それ自身と比較しない限り&lt;code&gt;==&lt;/code&gt;や&lt;code&gt;===&lt;/code&gt;の評価結果が常にfalseになるプリミティブ型で、ES2015で追加されたものです。
字句規則で定義されたトークンとの衝突が発生しないようにここでSymbolを使用していますが、Symbolそのものはオブジェクトのプロパティとして使用することで後方互換性を維持することを目的としてJavaScriptに追加された型であるため、この用途で用いるのに適しているのかどうかは議論の余地があります。
とはいえプログラミング言語個別の問題はこの記事の主題とは関係がないため、詳しくは言及しません。)&lt;/p&gt;

&lt;p&gt;この字句解析器に先ほどの字句規則を与え、&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; を入力すると、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
	{token:&amp;quot;DIGITS&amp;quot;, value:&amp;quot;9&amp;quot;},
	{token:&amp;quot;PLUS&amp;quot;, value:&amp;quot;+&amp;quot;},
	{token:&amp;quot;DIGITS&amp;quot;, value:&amp;quot;11&amp;quot;},
	{token:&amp;quot;ASTERISK&amp;quot;, value:&amp;quot;*&amp;quot;},
	{token:&amp;quot;LPAREN&amp;quot;, value:&amp;quot;(&amp;quot;},
	{token:&amp;quot;DIGITS&amp;quot;, value:&amp;quot;2&amp;quot;},
	{token:&amp;quot;PLUS&amp;quot;, value:&amp;quot;+&amp;quot;},
	{token:&amp;quot;DIGITS&amp;quot;, value:&amp;quot;1&amp;quot;},
	{token:&amp;quot;RPAREN&amp;quot;, value:&amp;quot;)&amp;quot;},
	{token:Symbol(EOF), value:&amp;quot;&amp;quot;}
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という結果が得られます。
これでトークンの並びを得ることに成功したので、次回以降はいよいよパーサジェネレータの作成に移っていくことになります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;前回:かんたん構文解析入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;次回:儀式の下準備&lt;/a&gt;&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第1回:かんたん構文解析入門</title>
      <link>http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/</link>
      <pubDate>Thu, 22 Dec 2016 03:03:09 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/</guid>
      <description>
        &lt;p&gt;この記事は&lt;a href=&#34;http://www.adventar.org/calendars/1881&#34;&gt;Kobe University Advent Calendar 2016&lt;/a&gt;の21日の記事です。また遅刻か。
なお私は当該大学の学部2年(2016年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;構文解析ができるプログラマはちょっとかっこいいですよね。
「構文解析？ああ、できますよ」とか言って自分のスキルを自慢できそうな印象があります。&lt;/p&gt;

&lt;p&gt;(ほぼ)フルスクラッチでTypeScriptによるLR(1)パーサジェネレータを実装した(ついでにLALR(1)パーサも作れる)ので、これを完成させるまでの流れを紹介していこうと思います。&lt;/p&gt;

&lt;p&gt;今回は構文解析自体の入門編となります。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;自作したパーサジェネレータは &lt;a href=&#34;https://github.com/Tatamo/parsergenerator&#34;&gt;https://github.com/Tatamo/parsergenerator&lt;/a&gt; にあります。&lt;br /&gt;
今のところパーサジェネレータ部分は完成、基本的な構文解析なら問題なくこなせるので構文規則や字句規則を外部から読み取って構文解析してパーサジェネレータに渡すような処理や、全体の見通しを良くするための設計の見直しやリファクタリング等を行っている段階です。
ドキュメント作ってなくてすみません。&lt;/p&gt;

&lt;h2 id=&#34;構文解析をしたい&#34;&gt;構文解析をしたい&lt;/h2&gt;

&lt;p&gt;構文解析、時々見かけるフレーズです。
プログラマなら覚えておいて損はない技術……かどうかはわかりませんが、そういう類のスキルに(傍からは)見えます。&lt;br /&gt;
ぜひやりましょう。&lt;/p&gt;

&lt;p&gt;ひとまず、何をやりたいのかを明確にする必要があります。&lt;br /&gt;
この記事では、「入力として与えられるLR(1)文法に属する文法に従ったトークン列をパース(構文解析)することで、その構造を構文木として出力する」ことを目標とします。
何を言っているのかさっぱりわかりませんね、わからなくていいです。&lt;/p&gt;

&lt;p&gt;順を追って説明する必要がありますが、詳細は適宜省略します。
そのため、まずは今回主に参照した資料を列挙しておきます。&lt;/p&gt;

&lt;h2 id=&#34;参考資料一覧&#34;&gt;参考資料一覧&lt;/h2&gt;

&lt;p&gt;より詳しく知りたい方は、下記に挙げる資料やそこで紹介されている参考文献などを参照されるのが良いと思われます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.cornell.edu/courses/cs412/2003sp/lectures/lec09.pdf&#34;&gt;Cornell CIS Introduction to Compilers Lecture 9: LR(1) Parsing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jaist.ac.jp/~kshirai/lec/i223/04a.pdf&#34;&gt;JAIST 自然言語処理論Ｉ 4.文法2(構文解析) その1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jaist.ac.jp/~kshirai/lec/i223/04b.pdf&#34;&gt;JAIST 自然言語処理論Ｉ 4.文法2(構文解析) その2&lt;/a&gt;
(注：「LR法による構文解析」として紹介されているアルゴリズムはSLR法)&lt;br /&gt;
上記3つはネット上にアップロードされている特定の大学の講義資料ですが、公開の規定等を確認していないためリンクを張ることに不都合があるようなら知らせていただけると助かります。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Canonical_LR_parser&#34;&gt;Canonical LR parser - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/ichikaz3/lr-parsing&#34;&gt;LR parsing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kimiyuki.net/blog/2016/08/03/context-free-grammar/&#34;&gt;文脈自由文法とその構文解析法 &amp;middot; うさぎ小屋&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/uhyo_&#34;&gt;うひょ(@uhyo_)さん&lt;/a&gt; 生き字引。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;構文解析とは-ざっくり&#34;&gt;構文解析とは？(ざっくり)&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; という数式を考えてみます。
構文解析をすることによる最終的な目的は、この数式を(たとえば)文字列として与えると、結果としてこの数式の答えが&lt;code&gt;42&lt;/code&gt;であることを導く、といったことです。&lt;/p&gt;

&lt;p&gt;そのためには、以下のものが必要になります：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数式を表現する構文規則&lt;/li&gt;
&lt;li&gt;上記構文規則を解析するように作られた構文解析器(Parser)&lt;/li&gt;
&lt;li&gt;解析された構文を処理するプログラム&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さらに、これらの構文解析に入る前の下準備のために以下が必要です：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;文字列をトークンとして分割して表現するための字句規則&lt;/li&gt;
&lt;li&gt;上記字句規則をもとに、文字列を読み取ってトークンを返す字句解析器(Lexical Analyzer、略してLexer)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ちなみに、今回の記事の目標は、それらに加えて以下のものを実装することです：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;構文規則および字句規則を入力として与えることで、構文解析器そのものを自動生成するパーサジェネレータ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;実際の構文解析を行う手順とはずれてしまいますが、紹介した順番に沿って構文解析器→字句解析器の順に解説していきます。&lt;/p&gt;

&lt;h3 id=&#34;構文解析器-パーサ&#34;&gt;構文解析器(パーサ)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; という数式を解析するためには、まずこの数式がどのようなルールで記述されているのかを(再)定義する必要があります。
そのルールをを表すのが構文規則です。
構文規則を書き表すルールは、たとえば&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%90%E3%83%83%E3%82%AB%E3%82%B9%E3%83%BB%E3%83%8A%E3%82%A6%E3%82%A2%E8%A8%98%E6%B3%95&#34;&gt;BNF&lt;/a&gt;など様々な種類がありますが、基本的な発想としては&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S -&amp;gt; X Y Z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように左辺の記号を右辺の記号の並びによって定義することで行います。&lt;/p&gt;

&lt;p&gt;具体的に見てみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;式 -&amp;gt; 式 &amp;quot;+&amp;quot; 項
式 -&amp;gt; 項
項 -&amp;gt; 項 &amp;quot;*&amp;quot; 因子
項 -&amp;gt; 因子
因子 -&amp;gt; 数
因子 -&amp;gt; &amp;quot;(&amp;quot; 式 &amp;quot;)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;妥当ですね。
&lt;code&gt;式 -&amp;gt; 式 + 項&lt;/code&gt; と &lt;code&gt;式 -&amp;gt; 項&lt;/code&gt;の２つの規則が、再帰的な繰り返しを表現していることに注意してください。
たとえば、&lt;code&gt;項&lt;/code&gt;は当然&lt;code&gt;式&lt;/code&gt;ですし、&lt;code&gt;項 + 項&lt;/code&gt;も&lt;code&gt;式(-&amp;gt;項) + 項&lt;/code&gt; より&lt;code&gt;式&lt;/code&gt;となります。
さらに、&lt;code&gt;項 + 項 + 項&lt;/code&gt;は最初の&lt;code&gt;項 + 項&lt;/code&gt;が&lt;code&gt;式&lt;/code&gt;なので、&lt;code&gt;式(-&amp;gt;項 + 項) + 項&lt;/code&gt; より&lt;code&gt;式&lt;/code&gt;です。
よって、&lt;code&gt;式&lt;/code&gt;は&lt;code&gt;項&lt;/code&gt;を&lt;code&gt;&amp;quot;+&amp;quot;&lt;/code&gt;によって任意の回数だけ繋げたものであり、同様に&lt;code&gt;項&lt;/code&gt;は&lt;code&gt;因子&lt;/code&gt;を&lt;code&gt;&amp;quot;*&amp;quot;&lt;/code&gt;で繋げたものとなります。
最後に、&lt;code&gt;因子&lt;/code&gt;は単なる&lt;code&gt;数&lt;/code&gt;かもしれませんし、または&lt;code&gt;&amp;quot;(&amp;quot;&lt;/code&gt;と&lt;code&gt;&amp;quot;)&amp;quot;&lt;/code&gt;で囲まれた&lt;code&gt;式&lt;/code&gt;かもしれません。
これは括弧で囲まれた部分の式が他の部分よりも高い優先順位となることを表現しています。&lt;/p&gt;

&lt;p&gt;たとえば&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt;は、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;式{ [9] [+] [11 * (2 + 1)] }
式{ 項{ [9] } &amp;quot;+&amp;quot; 項{ [11] [*] [(2 + 1)] } }
式{ 項{ 因子{9} } &amp;quot;+&amp;quot; 項{ 因子{11} &amp;quot;*&amp;quot; 因子{ [(] [2 + 1] [)] } } }
式{ 項{ 因子{9} } &amp;quot;+&amp;quot; 項{ 因子{11} &amp;quot;*&amp;quot; 因子{ &amp;quot;(&amp;quot; 式{ [2] [+] [1] } &amp;quot;)&amp;quot; } } }
式{ 項{ 因子{9} } &amp;quot;+&amp;quot; 項{ 因子{11} &amp;quot;*&amp;quot; 因子{ &amp;quot;(&amp;quot; 式{ 項{ [2] } &amp;quot;+&amp;quot; 項{ [1] } } &amp;quot;)&amp;quot; } } }
式{ 項{ 因子{9} } &amp;quot;+&amp;quot; 項{ 因子{11} &amp;quot;*&amp;quot; 因子{ &amp;quot;(&amp;quot; 式{ 項{ 因子{2} } &amp;quot;+&amp;quot; 項{ 因子{1} } } &amp;quot;)&amp;quot; } } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように展開されます(こうして得られた構造をどう解析するかについては省略します)。この、解析対象→構文木の変換を自動で行うのがパーサです。&lt;/p&gt;

&lt;p&gt;ちなみにですが、この構文規則は解析したい対象ごとにあなたが一から書き上げる必要があります。&lt;/p&gt;

&lt;h3 id=&#34;字句解析器-レキシカルアナライザ&#34;&gt;字句解析器(レキシカルアナライザ)&lt;/h3&gt;

&lt;p&gt;上記構文規則では、&lt;code&gt;+&lt;/code&gt;や&lt;code&gt;*&lt;/code&gt;のような演算子、&lt;code&gt;数&lt;/code&gt;についての規定はありません。
これらの「左辺に現れない記号」を、「終端記号」と呼びます。左辺に現れる記号は非終端記号と呼ばれます。&lt;/p&gt;

&lt;p&gt;通常、&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; のような入力は文字列で与えられますが、記号と記号の間には複数もしくは0個の空白が挿入されている可能性もあります。
しかし以下のような構文規則を定義するのは本質的ではありません：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;空白 -&amp;gt; &amp;quot; &amp;quot;
空白 -&amp;gt; &amp;quot; &amp;quot; 空白
数字 -&amp;gt; &amp;quot;0&amp;quot; | &amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | ... | &amp;quot;9&amp;quot;
数字 -&amp;gt; (&amp;quot;0&amp;quot; | &amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | ... | &amp;quot;9&amp;quot;) 数字
数 -&amp;gt; (&amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | &amp;quot;3&amp;quot; ... | &amp;quot;9&amp;quot;) 数字
ただし、|は「または」を表す
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そこで、通常は「入力として与えられた文字列」を「終端記号として分類されたトークンの列」に変換する処理をはさみ、これによって得られたトークンを構文解析器に与えます。
トークンとは終端記号と、必要ならばそれに紐付いた元々の情報を保持しておいたものです。たとえば、&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt;は、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;数字: 9
プラス: +
数字: 11
アステリスク: *
左括弧: (
数字: 2
プラス: +
数字: 1
右括弧: )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような9つのトークンの列に分けることができます。
構文解析器はそのトークンがどのような終端記号に対応しているかは見ますが、たとえば個々の数字が何であるかを判断することはしません。
これによって、構文解析器は本質的な文法の解析のみに注力することができます。&lt;/p&gt;

&lt;p&gt;この処理をするのが字句解析器で、どのような文字や文字列が与えられた場合に何という終端記号かを判別するための規則が字句規則です。&lt;/p&gt;

&lt;p&gt;字句規則は、例えば以下のような書き方になるでしょう：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;数字: /[1-9][0-9]*/
プラス: &amp;quot;+&amp;quot;
アステリスク: &amp;quot;*&amp;quot;
左括弧: &amp;quot;(&amp;quot;
右括弧: &amp;quot;)&amp;quot;
(読み捨て): /\s/
(不正): /./
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでは字句規則の表現のために、文字列および正規表現を使用しています。
通常(?)字句規則は上から順に文字列の先頭部分を当てはめていき、マッチするものがあればその終端記号に対応付けます。
そのため、&lt;code&gt;(不正)&lt;/code&gt;の部分は入力された文字全てにマッチする正規表現&lt;code&gt;/./&lt;/code&gt;が使用されていますが、これは上の規則のいずれにも当てはまらなかった場合にのみマッチします。&lt;/p&gt;

&lt;p&gt;与えられた文字列を前から順番に見ていくだけなので、字句解析器の実装はパーサやパーサジェネレータの実装と比べると単純です。&lt;/p&gt;

&lt;h3 id=&#34;パーサジェネレータ&#34;&gt;パーサジェネレータ&lt;/h3&gt;

&lt;p&gt;ここまで構文解析器(パーサ)と字句解析器(レキシカルアナライザ)について見てきました。
基本的にはこの2つによって構文解析を行うことができ、基本的な流れとしては&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;入力となるような解析したい言語を用意する&lt;/li&gt;
&lt;li&gt;字句規則を用意して、それをもとにしたレキシカルアナライザを用意する&lt;/li&gt;
&lt;li&gt;レキシカルアナライザに入力を与え、トークンの列を取得する&lt;/li&gt;
&lt;li&gt;構文規則を用意して、それをもとにしたパーサを用意する&lt;/li&gt;
&lt;li&gt;パーサにトークンの列を与え、解析結果を得る&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となります。
パーサジェネレータとは何かというと、この 4. の部分を自動化するものです。
(LR法の)構文解析器は、内部的には入力を受け取ってスタックに積みながら状態遷移を繰り返すオートマトンにすぎません。
そのため、どの入力が与えられればどのような状態に遷移するかを示す「構文解析表」を得ることができれば、その構文を解析するパーサを作成することができます。
パーサジェネレータは、構文規則を読み取ることでこの構文解析表をつくり上げるという処理を主に行います。&lt;/p&gt;

&lt;p&gt;字句解析器程度ならわざわざジェネレータを作らなくても、字句規則そのものを字句解析器に渡せば良い感じに字句解析してくれるようにできますが、パーサジェネレータも「構文解析表の構築後、それをもとにして構文解析を行う」ような機能がついていればそれはパーサであるとも言えます。
わざわざパーサとパーサジェネレータが分けられているのは、一つには計算資源の乏しかった昔はパーサジェネレータがオンメモリで展開した構文解析表をもとにそのままパーサとして振る舞うというようなことが少なく、構文解析表を与えることで「パーサのソースコード」を出力するようなものが一般的だったからではないかと思われます(適当な思いつきを言っています)。
もっとも、パーサジェネレータがパーサを生成する際の処理にかかる時間を省略したい場合、予めパーサをコンパイルしておけるようにするのは妥当といえるでしょう。
字句解析器のための「字句解析器ジェネレータ」も実際に存在していますが、ここでは簡単のために字句解析器はコンストラクタに字句規則を与えれば勝手に良い感じの字句解析を行ってくれるようになるものと思ってもらえればよいです。&lt;/p&gt;

&lt;h3 id=&#34;文脈自由言語について&#34;&gt;文脈自由言語について&lt;/h3&gt;

&lt;p&gt;構文解析器が解析対象とする「言語」がどのようなものであるかについてはいろいろな定義がなされています。&lt;/p&gt;

&lt;p&gt;これについては、参考資料でも紹介した&lt;a href=&#34;https://twitter.com/ki6o4&#34;&gt;うさぎさん(@ki6o4)&lt;/a&gt;の&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kimiyuki.net/blog/2016/08/03/context-free-grammar/&#34;&gt;文脈自由文法とその構文解析法 &amp;middot; うさぎ小屋&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が詳しいため、こちらを参照していただくことをおすすめします。
ここでは、厳密な話はあまりせずにごくごく簡単に触れていこうと思います。&lt;/p&gt;

&lt;p&gt;構文解析の対象とするのは、基本的に文脈自由言語となります。
構文解析の手法にも様々なものがありますが、それらの手法の中には文脈自由言語すべてを解析できるわけではないものも多く、たとえばLR(1)法ならLR(1)文法やLR(1)言語というように、ある手法で解析できる文法や、解析できる言語全体をその手法の名前で表される言語として表現することがあります。&lt;/p&gt;

&lt;h3 id=&#34;解析手法と言語のクラス&#34;&gt;解析手法と言語のクラス&lt;/h3&gt;

&lt;p&gt;いくつかの手法を主観を交えて乱暴に紹介していきます。&lt;/p&gt;

&lt;h4 id=&#34;先読み&#34;&gt;先読み&lt;/h4&gt;

&lt;p&gt;**この項は下のLR法などの項を「先読み」してから戻ってきて読むことをおすすめします**&lt;/p&gt;

&lt;p&gt;たとえばLR(1)法のように、数字を括弧でくくって(k)と表現している手法がいくつかあります。このkは何文字先読みするかを示していて、たとえば(1)ならば1文字先読みするという意味です。
先読み数については、たとえばLR法については以下のようなことが言われています。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;LR(k)で表せる文法のクラス ⊆ LR(k+1)先読みで表せるクラス である&lt;/li&gt;
&lt;li&gt;LR(k)文法によって受理可能な言語のクラスは、LR(1)のそれと等しい&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.より、基本的には(1)について考えることが多いようです。&lt;/p&gt;

&lt;h4 id=&#34;ll-1-法&#34;&gt;LL(1)法&lt;/h4&gt;

&lt;p&gt;「再帰を使って構文解析する」という発想としては単純なもの。
LL(1)文法のクラスはLR(1)よりも大幅に小さいものの、それでもLALR(1)文法を外れた文法を解析できたりします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S -&amp;gt; S + E
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような、右辺の一番左の場所に左辺の記号が登場するような「左再帰則」を読むことができません。ナンセンス。&lt;/p&gt;

&lt;h4 id=&#34;lr-0-法&#34;&gt;LR(0)法&lt;/h4&gt;

&lt;p&gt;先読み数が0なのでよわい。&lt;/p&gt;

&lt;h4 id=&#34;slr法&#34;&gt;SLR法&lt;/h4&gt;

&lt;p&gt;SLRのSはSimpleの意味です。LR(0)から単純な先読みを加えることでLR(0)よりも解析可能な文法が増えますが、それでもLALR(1)には及びません。&lt;/p&gt;

&lt;h4 id=&#34;lr-1-法&#34;&gt;LR(1)法&lt;/h4&gt;

&lt;p&gt;LR(0)に対し、1文字だけ先読みして次にどのような入力が期待されるかを判断。
LR(1)文法がそれなりに広いという点で優秀な一方、LR(0)に比べて構文解析表の大きさが爆発しやすいという欠点がある、と言われています。
しかし今の時代はそんなものは大した欠点になり得ない気がします。&lt;/p&gt;

&lt;h4 id=&#34;lalr-1-法&#34;&gt;LALR(1)法&lt;/h4&gt;

&lt;p&gt;プログラミング言語を解析するコンパイラなどによく使われている手法です。
基本的に先読み数1で行うので、(1)を略してLALR法と呼ばれることも多くあります。
LALR(1)のLAはLook-Aheadの略で、LR(1)法の構文解析表のうち、文法部分が同じで先読み記号だけが違うような状態をマージした構文解析表を使うという特徴があります。
表を併合してしまうためにLR(1)法よりも解析可能な文法のクラスが小さくなるものの、実用上はほとんど問題にならず、LR(1)法の構文解析表が大きくなりすぎるという欠点を補える手法です。&lt;/p&gt;

&lt;p&gt;状態数が多くなるLR(1)法の構文解析表を一度作らずとも、直接LALR構文解析表を作ることのできるアルゴリズムも存在しています。&lt;/p&gt;

&lt;p&gt;また、LALR法のLAはLook-Aheadの略だと言いましたが、注意しなければならないのは&lt;strong&gt;Look-Ahead(先読み)を行うのはLALR法固有の手法ではない&lt;/strong&gt;ということです。  先読み自体はLR(1)法でもやりますし、LALR(1)はあくまでLR(1)の先読み部分をマージしたものにすぎません。
私はLALR法の名前の付け方はあまり良くないと思っていて、MLR法(Merged Look-Ahead LR法)とかなんとか、そういう感じの名前に変えたほうが良いと思います。&lt;/p&gt;

&lt;h4 id=&#34;glr法&#34;&gt;GLR法&lt;/h4&gt;

&lt;p&gt;「あいまいな」解釈が可能な文法があった場合、考えられうるすべての可能性を探索してしまうことによって解決する手法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;「お魚くわえた猫を追いかけるサザエさん」&lt;/code&gt;で魚をくわえているのが猫とサザエさんの両方に解釈できるように、一つの入力に対して複数の結果が得られることがあります。
どちらかというと自然言語処理向きかもしれません。&lt;/p&gt;

&lt;h4 id=&#34;cyk法&#34;&gt;CYK法&lt;/h4&gt;

&lt;p&gt;強力なアルゴリズムにより、文脈自由言語すべてを比較的高速に解析可能。
ただし、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S -&amp;gt; NP VP
VP -&amp;gt; v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように、チョムスキー標準形といわれるような、「右辺が非終端記号ちょうど2つか終端記号1つでなければならない」、つまり結果として得られる構造が二分木になっていなければならないというナンセンスにも程がある制約を課されます(アルゴリズムの改良や規則の変換、得られた木構造の後処理などによって回避は可能ですが)。&lt;/p&gt;

&lt;p&gt;このCYK法の計算量オーダーは&lt;code&gt;O(n^3)&lt;/code&gt;程度で、曖昧性のない文法であれば&lt;code&gt;O(n^2)&lt;/code&gt;で解析できると言われています。
これは文脈自由言語全てを解析可能なアルゴリズムの中では高速ですが、この記事で紹介されている他のアルゴリズムよりは低速となります。
たとえばLR(1)法は文脈自由言語全体を解析出来ないかわりに&lt;code&gt;O(n)&lt;/code&gt;で解析が可能です。&lt;/p&gt;

&lt;p&gt;プログラミング言語の解析では、言語の開発者が文法自体をある程度自由に定義することができるため、文脈自由言語の一部だけでなく全体を解析したいという需要はあまり発生しません。&lt;/p&gt;

&lt;h2 id=&#34;lr-1-パーサジェネレータをつくろう&#34;&gt;LR(1)パーサジェネレータをつくろう&lt;/h2&gt;

&lt;p&gt;構文解析の大まかな流れはわかりました。
とりあえず字句規則と構文規則を用意して、あとはどうにかしてこの構文を読んでくれるようなパーサを用意すれば構文解析ができそうです(字句解析器なんてのは適当にやってもすぐ用意できます)。&lt;/p&gt;

&lt;p&gt;先ほど紹介したような手法によって構文ごとに一からパーサをプログラミングするようなことはやりたくないので、パーサジェネレータを用いてパーサを自動的に生成してもらえば事は済みそうですね。&lt;/p&gt;

&lt;p&gt;ここに&lt;a href=&#34;https://www.gnu.org/software/bison/&#34;&gt;Bison&lt;/a&gt;という有名なパーサジェネレータがあります。
今の時代にわざわざCやC++で構文解析なんてしたくないのでしたら、Pythonで&lt;a href=&#34;http://www.dabeaz.com/ply/&#34;&gt;PLY&lt;/a&gt;とか、JavaScriptの&lt;a href=&#34;https://github.com/zaach/jison&#34;&gt;jison&lt;/a&gt;というものなど、いくらでも選択肢があります。
これらのうち一つを選んで、チュートリアルを読んでパーサを作っていくのがいいでしょう。&lt;/p&gt;

&lt;p&gt;というわけで、前段を書いていると結構分量が膨らんでしまったため、今回はここで区切ります。&lt;/p&gt;

&lt;p&gt;では次回からは、構文解析を行えるようになるため、LR(1)法を用いたパーサジェネレータを実際に作っていく流れを紹介していきたいと思います。&lt;/p&gt;

&lt;p&gt;えっちょっとまって、今パーサジェネレータは既存のものを使えばいいって言ったよね、ねえ&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/&#34;&gt;次回:字句解析器の実装&lt;/a&gt;&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>Javaのリフレクションを悪用してクラス設計してみる</title>
      <link>http://tatamo.81.la/blog/2016/12/15/java-generics-and-reflection/</link>
      <pubDate>Thu, 15 Dec 2016 01:11:23 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/12/15/java-generics-and-reflection/</guid>
      <description>
        &lt;p&gt;この記事は&lt;a href=&#34;http://www.adventar.org/calendars/1881&#34;&gt;Kobe University Advent Calendar 2016&lt;/a&gt;の14日の記事です。遅刻です。
なお私は当該大学の学部2年(2016年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最近、大学の授業などで少しだけJavaに触れる機会があったので、ちょっとした黒魔術っぽいことでもやってみようと思います。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;と思ったのですが、記事を書こうとして調べていたら普通に書きたかったことをわかりやすく書いている記事がありました。&lt;br /&gt;
* &lt;a href=&#34;http://d.hatena.ne.jp/Nagise/20131121/1385046248&#34;&gt;new T()したいケースへの対処法 - プログラマーの脳みそ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;もう帰っていいですかね。&lt;/p&gt;

&lt;h2 id=&#34;総称型tに対してt-classやnew-t-したい&#34;&gt;総称型Tに対してT.classやnew T()したい&lt;/h2&gt;

&lt;h3 id=&#34;ジェネリクスとは&#34;&gt;ジェネリクスとは&lt;/h3&gt;

&lt;p&gt;わざわざ書くまでもないとは思いますが、ジェネリクスについておさらいをしておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ArrayList&amp;lt;String&amp;gt; strlist = new ArrayList&amp;lt;String&amp;gt;();
ArrayList&amp;lt;Integer&amp;gt; intlist = new ArrayList&amp;lt;Integer&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ArrayList&lt;T&gt;に対し、ジェネリクスとしてStringやIntegerなど、リストの要素として入れたい型をTの部分に具体的に書くことで、一つのクラスであるArrayListに利用者側が好きな要素を入れることができるようになります。&lt;/p&gt;

&lt;p&gt;ジェネリクスを用いて自分でメソッドを定義する場合は、以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;T&amp;gt; void doSomething(T arg){
	// doSomething
}

// TをSomeClassのサブクラスに限定する
public &amp;lt;T extends SomeClass&amp;gt; void notDoAnything(T arg){
	return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらのメソッドを呼び出すときは、&lt;code&gt;hoge.&amp;lt;SomeClass&amp;gt;doSomething();&lt;/code&gt;のようになります。&lt;br /&gt;
どうして&lt;code&gt;hoge.doSomething&amp;lt;SomeClass&amp;gt;();&lt;/code&gt;じゃないんだろう。&lt;/p&gt;

&lt;h3 id=&#34;ジェネリクスはt-classやnew-t-をさせてくれない&#34;&gt;ジェネリクスはT.classやnew T()をさせてくれない&lt;/h3&gt;

&lt;p&gt;Javaのジェネリクスでは、以下のコードはコンパイルエラーとなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;T extends SomeClass&amp;gt; List&amp;lt;T&amp;gt; getSubClassList(List&amp;lt;SomeClass&amp;gt; list){
	return list
		.stream()
		.filter(value -&amp;gt; value instanceof T) // ここでlistの要素valueがTのインスタンスかどうか判別したい -&amp;gt; error
		.collect(Collectors.toList());
}

public &amp;lt;T extends SomeClass&amp;gt; List&amp;lt;T&amp;gt; getSubClassList2(List&amp;lt;SomeClass&amp;gt; list){
	return list
		.stream()
		.filter(value -&amp;gt; value.getClass() == T.class) // instanceofがだめならclassを取得して判別したい -&amp;gt; error
		.collect(Collectors.toList());
}

public &amp;lt;T&amp;gt; void doSomething(String arg){
	T foo = new T(arg); // T型の新しいインスタンスfooを作りたい -&amp;gt; error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ジェネリクス型に対して、hoge instanceof T、T.class、new T()といった操作を行うことはできません。
残念でしたね。&lt;/p&gt;

&lt;h2 id=&#34;なぜしたいのか&#34;&gt;なぜしたいのか&lt;/h2&gt;

&lt;h3 id=&#34;もしかして-設計が間違っている&#34;&gt;もしかして： 設計が間違っている&lt;/h3&gt;

&lt;p&gt;先ほどのgetSubClassListメソッドを見てみましょう。
正しく動くかどうかはさておき、やりたいことは以下の通りです：&lt;br /&gt;
* SomeClassとそのサブクラスを含んだリストlistの要素のうち、SomeClassのサブクラスTのインスタンスだけを要素とする新しいリストを取得したい。&lt;/p&gt;

&lt;p&gt;そもそも、抽象化された集合から具体的なクラスのインスタンスを取り出そうとすること自体がオブジェクト指向やポリモーフィズムの考え方に対する反逆である可能性があります。&lt;/p&gt;

&lt;p&gt;SomeClassのリストであるlistをイテレートして、それぞれの要素のdoSomething()メソッドを呼べば、あとはそれがSomeClassのインスタンスであろうと、もしくはSomeClassを継承した別のクラスのインスタンスであろうと、外部からはただdoSomething()メソッドを呼ぶだけで操作が完結していなければなりません。
それがサブクラス固有のふるまいをするとしても、その実装はそのクラス自身に隠蔽されるべきなのです。&lt;/p&gt;

&lt;p&gt;よって、サブクラスだけを取り出そうとする試み自体がナンセンスなものである可能性が非常に高く、まずそのような試みが必要になる設計そのものを見直す必要があります。&lt;/p&gt;

&lt;p&gt;終わり。&lt;/p&gt;

&lt;h3 id=&#34;そうも言っていられない&#34;&gt;そうも言っていられない&lt;/h3&gt;

&lt;p&gt;実際その通りなのですが、それではこの記事が続きません。&lt;/p&gt;

&lt;p&gt;ここからは、少し具体的なプログラムの設計を例にとって考えてみたいと思います。&lt;br /&gt;
あなたはちょっとしたゲームを作るためのフレームワークを作っています。
その一部分が以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 抽象的なゲーム内エンティティクラス
public abstract class Entity {
	private int x;
	private int y;
	public Entity(int x, int y){
		this.setX(x);
		this.setY(y);
	}
	public int getX() { return x; }
	public void setX(int x) { this.x = x; }
	public int getY() { return y; }
	public void setY(int y) { this.y = y; }

	public abstract void update(EntityManager manager);
}

// なんでもかんでも××Managerという名前を付けるのはやめましょう
public class EntityManager {
	private ArrayList&amp;lt;Entity&amp;gt; all_entities;
	public EntityManager(){
		this.all_entities = new ArrayList&amp;lt;Entity&amp;gt;();
	}
	public void add(Entity e){
		this.all_entities.add(e);
	}
	public ArrayList&amp;lt;Entity&amp;gt; getAll() {
		return new ArrayList&amp;lt;Entity&amp;gt;(this.all_entities);
	}
	public void updateAll(){
		this.all_entities.forEach(e-&amp;gt;e.update(this));
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なんのことはありませんね。
ゲーム内に登場するエンティティを表す抽象クラスEntityを作り、それをEntityManagerで管理します(なんでもかんでも××Managerという名前を付けるのはManagerクラスの肥大化を招きかねないため避けるべきであるなどという話もありますが、今回は置いておきます)。
たとえば毎フレームごとにメインループ内で&lt;code&gt;EntityManager#updateAll()&lt;/code&gt;を呼び出すことで、全てのエンティティの更新を行ったりすることが想定されます。
オーソドックスなループ駆動型のゲームプログラム設計です。&lt;br /&gt;
Entityインスタンスを作成するためのFactory Methodパターンを使うべきとか、そういう話もあっちでやってください。&lt;/p&gt;

&lt;p&gt;あとは、このフレームワークの利用者にはEntityクラスを継承したクラスを作らせ、それをもとにゲームを作ってもらえればいいだけです。
以下のクラスを追加してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// あなたです
public class Player extends Entity{
	private int hp; // プレイヤーはヒットポイントを持ちます
	public Player(int x, int y, int hp){
		super(x, y);
		this.setHp(hp);
	}
	public int getHp() { return hp; }
	public void setHp(int hp) { this.hp = hp; }
	@Override
	public void update(EntityManager manager){
		// プレイヤーが動きます
	}
}

// 敵です
public class Enemy extends Entity {
	private int damage; // 敵がプレイヤーに与えることのできるダメージ値です
	public Enemy(int x, int y, int damage){
		super(x, y);
		this.setDamage(damage);
	}
	public int getDamage() { return damage; }
	public void setDamage(int damage) { this.damage = damage; }
	@Override
	public void update() {
		// 敵が動きます
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プレイヤーと敵を登場させました。
常命の者であるプレイヤーにはヒットポイントが定められており、敵はこれを脅かすダメージ値を持っています。&lt;/p&gt;

&lt;p&gt;注意しておく必要があるのは、これらのクラスはあくまでフレームワークの利用者が作るものだということです。
よって、EntityクラスやEntityManagerクラスからはこのようなEntityサブクラスの存在を知ることはできません。&lt;br /&gt;
知る必要もないというのがオブジェクト指向の考え方だったはずです。
そうですよね？&lt;/p&gt;

&lt;p&gt;ここで、「敵のダメージ値を参照して、プレイヤーのヒットポイントを減らす」処理をしたいという需要が当然生まれます。
実装の方法はいろいろあると思いますが、ひとまずこの処理を、Enemyのメソッドとして書いてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 敵です
public class Enemy extends Entity {
	private int damage; // 敵がプレイヤーに与えることのできるダメージ値です
	public Enemy(int x, int y, int damage){
		super(x, y);
		this.setDamage(damage);
	}
	public int getDamage() { return damage; }
	public void setDamage(int damage) { this.damage = damage; }
	@Override
	public void update(EntityManager manager) {
		// 敵が動きます
		// プレイヤーがいたらダメージを与えます
		manager.getAll().forEach((entity)-&amp;gt;{ // 全てのエンティティを調べる
			if(entity instanceof Player){ //  エンティティがプレイヤーなら
				if(this.getX() == entity.getX() &amp;amp;&amp;amp; this.getY() == entity.getY()){ // プレイヤーと敵の座標が同じなら
					this.doDamage((Player) entity); // ダメージを与える
				}
			}
		});
	}
	public void doDamage(Player p){
		p.setHp(p.getHp() - this.getDamage()); // プレイヤーのヒットポイントをダメージ値分だけ減らします
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここであなたは気を利かせます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;manager.getAll().forEach((entity)-&amp;gt;{
	if(entity instanceof Player){
		if(...){
			...
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この部分です、どう見ても冗長ですし、いちいち全エンティティのリストをforEachで回しているので高速化も望めませんし、同様のコードクローンが至る所に発生するのは目に見えています。&lt;/p&gt;

&lt;p&gt;できるならたとえばこう書きたい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;manager.&amp;lt;Player&amp;gt;getAllOfSubClass().forEach((player)-&amp;gt;{
	if(...){
		...
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでPlayerクラスだけが得られるなら、呼び出し側のコード量は減りますし、もしあなたがO(n^2)の処理をO(nlogn)に落とすような作業に慣れているなら、Managerクラスの内側でより高速になるような最適化を行い、その実装も内部に隠蔽することができます。&lt;/p&gt;

&lt;p&gt;また、ゲームのセーブとロードをするときのことも考えてみます。
たとえばデータのセーブを行うときはとりあえずオブジェクトを文字列化するとして、&lt;br /&gt;
&lt;code&gt;public String Entity#serialize()&lt;/code&gt;などといったメソッドを作ってセーブし、ロード時には文字列配列を引数として受け取るようオーバーロードされたコンストラクタを使用してオブジェクトを再生成するといったことが考えられます。
そういうことはFactory Methodあたりに委譲するべきな気もしますし、うまくやらないとフレームワークの利用者側の負担が増える気もしますが、今は置いておきます。&lt;/p&gt;

&lt;p&gt;結局、セーブデータのロード時にこのようなコードを書くことになるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public &amp;lt;E extends Entity&amp;gt; E createEntity(List&amp;lt;String&amp;gt; args){ // 可変長引数としてもよい
		return new E(args); // ジェネリクス型はnewできない -&amp;gt; error
	}
	public loadSaveData(SaveData savedata){
		// セーブデータから1行ずつ読み込んでオブジェクトを再生成する
		... {
			entityManager.add(this.createEntity(agrs));
		}
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかしジェネリクス型はnewできないため、コンパイルエラーとなります。&lt;/p&gt;

&lt;h2 id=&#34;解決策&#34;&gt;解決策&lt;/h2&gt;

&lt;p&gt;さて、だいぶん勿体つけたが、解決編に入ろう。&lt;/p&gt;

&lt;p&gt;……というか、例として取り上げた題材が無理やりすぎた気がしてやる気が尽きかけてきました。&lt;/p&gt;

&lt;h3 id=&#34;リフレクションを使用する&#34;&gt;リフレクションを使用する&lt;/h3&gt;

&lt;p&gt;Javaにはリフレクションという機能があり、プログラムの実行中にクラス名やメソッド名を動的に取り扱うことができます。
これのClass&lt;T&gt;型を、ジェネリクスと併用しましょう。
&lt;code&gt;EntityManager#getAllOfSubClass&lt;/code&gt;メソッドを考えてみます。
実装は以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	@SuppressWarnings(&amp;quot;unchecked&amp;quot;)
	public &amp;lt;E extends Entity&amp;gt; List&amp;lt;E&amp;gt; getAllOfSubClass(Class&amp;lt;E&amp;gt; cls){
		return (List&amp;lt;E&amp;gt;) all_entities.stream()
			.filter(entity -&amp;gt; entity.getClass() == cls)
			.collect(Collectors.toList());
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを呼び出す際は、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;entityManager.getAllOfSubClass(Player.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにして、Class型の&lt;code&gt;クラス名.class&lt;/code&gt;を引数として与えます。
ここで型推論が働くので、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;entityManager.&amp;lt;Player&amp;gt;getAllOfSubClass(Player.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにPlayerクラス名を2度も書く必要はありません。&lt;/p&gt;

&lt;p&gt;また、Playerクラスだけでなく、Playerクラスを継承したクラスも含めて判別したいときは、以下のようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	@SuppressWarnings(&amp;quot;unchecked&amp;quot;)
	public &amp;lt;E extends Entity&amp;gt; List&amp;lt;E&amp;gt; getAllOfSubClass(Class&amp;lt;E&amp;gt; cls){
		return (List&amp;lt;E&amp;gt;) all_entities.stream()
			.filter(entity -&amp;gt; cls.isAssignableFrom(entity.getClass()))
			.collect(Collectors.toList());
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;createEntity&lt;/code&gt;メソッドも、以下のようにすれば書くことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public &amp;lt;E extends Entity&amp;gt; E createEntity(Class&amp;lt;E&amp;gt; cls, List&amp;lt;String&amp;gt; args){
		// cls型のString[]を引数にとるコンストラクタを呼び出す
		return cls.getConstructor(new Class&amp;lt;?&amp;gt;[] { String[].class }).newInstance(args);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やや黒魔術じみてきました。
実際にはE型がString[]を引数にとるコンストラクタを持つということが担保されていないためこれだけでは動かず、例外回避のためにいろいろやる必要があります。&lt;/p&gt;

&lt;p&gt;最初の例に戻ってみましょう。&lt;code&gt;getSubClassList&lt;/code&gt;は、以下のように書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;T extends SomeClass&amp;gt; List&amp;lt;T&amp;gt; getSubClassList(List&amp;lt;SomeClass&amp;gt; list, Class&amp;lt;T&amp;gt; cls){
	return list
		.stream()
		.filter(value -&amp;gt; value.getClass() == cls)
		.collect(Collectors.toList());
}

// 呼び出し側
getSubClassList(list, SubClassOfSomeClass.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;めでたしめでたし。&lt;/p&gt;

&lt;h3 id=&#34;おまけ&#34;&gt;おまけ&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;T&amp;gt; int getStaticValue(Class&amp;lt;T&amp;gt; cls) throws Exception{ // なにがthrows Exceptionだやる気あんのか
	return (int) cls.getMethod(&amp;quot;getStaticValue&amp;quot;).invoke(null);
}

// 呼び出し
getStaticValue(SomeClass.class); // SomeClass.getStaticValue() を呼んでいるのと同じになる
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;staticメソッドも呼び出し可能なうえ、「そのクラスに与えられた名前のstaticメソッドが存在しない場合、その親クラスの同名のstaticメソッドを呼び出す」というようなふるまいを疑似的に再現することも可能です。&lt;/p&gt;

&lt;h2 id=&#34;おわり&#34;&gt;おわり&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Class&amp;lt;T&amp;gt; cls&lt;/code&gt;を引数にとり、&lt;code&gt;value.getClass() == cls&lt;/code&gt;で比較を行うのは、実質的にはinstanceofの迂回といえます。&lt;br /&gt;
この程度なら型安全性は一応担保されますが、コンストラクタやメソッドの取得と呼び出しまで始めた場合、throw宣言やcatch節が山のように膨らんだり、メソッドの存在確認や型の確認などに多大なコストを支払う必要がありそうです。
実際に使用するには相当の覚悟を必要とするでしょう。&lt;strong&gt;やめましょう。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;自分でプログラムを組んでいる際にこのような需要が発生することが時々あったので、Javaではリフレクションを使うことで強引に解決できると知って記事を書いてみましたが、自分の中ではむしろ「設計が悪い」の一言に実感が沸くという結果となった気がします。&lt;br /&gt;
今回例に挙げたゲームプログラムの設計はまさしく昔私が作ったものそのものなのですが、記事を書く上で「リフレクションを使いたい理由付け」を明確にしようとすればするほど、その理由が無理やりなものにしかならないのではないかという気持ちに陥りました。
途中まで書いた記事がグダグダになりそうな予感がしてくると結構精神的につらい。&lt;br /&gt;
……うーん。Abstract Factoryパターンとか、もととなるクラスが増えるとそれに合わせてFactoryクラスも増やさないといけないのがあまり好きじゃないので、そのあたりも動的になんとかできないかなどと思っていたのですが、なかなか難しいようです。&lt;/p&gt;

&lt;p&gt;私感としては、instanceof Tの代用としてClass型を使用する程度は許容できますが、普通のプログラムを書くならそれ以上は安易に手を出すべきではないという印象です。&lt;/p&gt;

&lt;p&gt;プログラミングをするときはまともな設計をするようにしましょう。&lt;/p&gt;
      </description>
    </item>
    
  </channel>
</rss>