<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dev on わたしろぐ</title>
    <link>http://tatamo.81.la/blog/categories/dev/</link>
    <description>Recent content in Dev on わたしろぐ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Fri, 01 Dec 2017 17:35:00 +0900</lastBuildDate>
    <atom:link href="http://tatamo.81.la/blog/categories/dev/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ゲーム「じゃぱりうぉっち」を作りました</title>
      <link>http://tatamo.81.la/blog/2017/12/01/japari-watch/</link>
      <pubDate>Fri, 01 Dec 2017 17:35:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/12/01/japari-watch/</guid>
      <description>
        

&lt;p&gt;この記事は&lt;a href=&#34;https://adventar.org/calendars/2491&#34;&gt;Kobe University Advent Calendar 2017&lt;/a&gt;の1日の記事です。
なお私は当該大学の学部3年(2017年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;ブラウザ上で動作するゲーム「&lt;a href=&#34;https://tatamo.github.io/japari-watch/&#34;&gt;じゃぱりうぉっち&lt;/a&gt;」を作ったので、開発記を書きます。&lt;/p&gt;

&lt;h2 id=&#34;じゃぱりうぉっち:715a67537c3fb0cd66e102735cb99acd&#34;&gt;じゃぱりうぉっち&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://tatamo.github.io/japari-watch/&#34;&gt;https://tatamo.github.io/japari-watch/&lt;/a&gt; で公開しており、PCとモバイル端末のどちらでも遊ぶことができます。&lt;/p&gt;

&lt;h3 id=&#34;発端:715a67537c3fb0cd66e102735cb99acd&#34;&gt;発端&lt;/h3&gt;

&lt;p&gt;期末試験前に現実逃避のためにTLを眺めていたところ、以下のツイートが流れてきました。
&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;フェネック「アライさんに似合いそうな帽子を見つけてきたよー」&lt;br&gt;アライグマ「ありがとうなのだ！」&lt;a href=&#34;https://twitter.com/hashtag/%E3%81%91%E3%82%82%E3%81%AE%E3%83%95%E3%83%AC%E3%83%B3%E3%82%BA?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#けものフレンズ&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/%E3%83%89%E3%83%83%E3%83%88%E7%B5%B5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#ドット絵&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/pixelart?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#pixelart&lt;/a&gt; &lt;a href=&#34;https://t.co/1VueMavObQ&#34;&gt;pic.twitter.com/1VueMavObQ&lt;/a&gt;&lt;/p&gt;&amp;mdash; 鬼雷 昇炎 (@kirai_s) &lt;a href=&#34;https://twitter.com/kirai_s/status/934412479597199361?ref_src=twsrc%5Etfw&#34;&gt;2017年11月25日&lt;/a&gt;&lt;/blockquote&gt;&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Version Upgrade Nanoda!! &lt;a href=&#34;https://t.co/IXSjV6A1PN&#34;&gt;pic.twitter.com/IXSjV6A1PN&lt;/a&gt;&lt;/p&gt;&amp;mdash; 鬼雷 昇炎 (@kirai_s) &lt;a href=&#34;https://twitter.com/kirai_s/status/934695920414765056?ref_src=twsrc%5Etfw&#34;&gt;2017年11月26日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;作品としての完成度が高く、実際にゲームとして遊べそうに見えたので、これをゲーム化してみました。&lt;/p&gt;

&lt;h3 id=&#34;素材:715a67537c3fb0cd66e102735cb99acd&#34;&gt;素材&lt;/h3&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;原寸(128*128px)なのだ &lt;a href=&#34;https://twitter.com/hashtag/%E3%81%91%E3%82%82%E3%81%AE%E3%83%95%E3%83%AC%E3%83%B3%E3%82%BA?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#けものフレンズ&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/%E3%83%89%E3%83%83%E3%83%88%E7%B5%B5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#ドット絵&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/pixelart?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#pixelart&lt;/a&gt; &lt;a href=&#34;https://t.co/BJ0Mc27vR5&#34;&gt;pic.twitter.com/BJ0Mc27vR5&lt;/a&gt;&lt;/p&gt;&amp;mdash; 鬼雷 昇炎 (@kirai_s) &lt;a href=&#34;https://twitter.com/kirai_s/status/934699058542678016?ref_src=twsrc%5Etfw&#34;&gt;2017年11月26日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;元画像が上がっていたので使わせていただきました。&lt;/p&gt;

&lt;p&gt;背景に相当する部分の画像がなかったので自分で加工したり、そのまま矩形状にスプライトを切り出すと被ってしまう部分があったのでいくつかのパーツに分けたりしました。&lt;/p&gt;

&lt;h2 id=&#34;製作期間:715a67537c3fb0cd66e102735cb99acd&#34;&gt;製作期間&lt;/h2&gt;

&lt;p&gt;ゲーム本体の作成(アセットの用意・環境構築含む)： 一晩&lt;br /&gt;
公開のためのWebページデザインやTwitterカード、faviconの用意：半日&lt;br /&gt;
公開後の難易度調整+自動モード機能の追加：半日&lt;/p&gt;

&lt;h2 id=&#34;フレームワーク選定:715a67537c3fb0cd66e102735cb99acd&#34;&gt;フレームワーク選定&lt;/h2&gt;

&lt;p&gt;ブラウザで動作するゲームを作ろうと思ったため、基本的にはNode環境で開発を進めていくことになります。
高速に開発するためにTypeScriptで記述することとしたうえで、使用するツールを選定していきました。&lt;/p&gt;

&lt;h3 id=&#34;pixi-js:715a67537c3fb0cd66e102735cb99acd&#34;&gt;PIXI.js&lt;/h3&gt;

&lt;p&gt;PC・モバイル両方のブラウザで動作するゲームという方針のため、HTML5 Canvas系のライブラリを使うことにしました。
npm上で型定義が用意されているものを使いたかったので、今回は&lt;a href=&#34;http://www.pixijs.com/&#34;&gt;PIXI.js&lt;/a&gt;を選択しました。&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;shell&#34;&gt;$ npm install --save-dev @types/pixi.js&lt;/code&gt;で型定義ファイルをインストールし、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import * as PIXI from &amp;quot;pixi.js&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でPIXI.jsの型情報を使用可能になります。&lt;/p&gt;

&lt;h4 id=&#34;ビルドシステム:715a67537c3fb0cd66e102735cb99acd&#34;&gt;ビルドシステム&lt;/h4&gt;

&lt;p&gt;また、今回はブラウザを動作対象とするため、jsファイルのバンドルとBabel化のためにwebpackを使用しました。
実際のところwebpackもBabelもこれまで使ったことがなかったのですが、なんとかts-loaderとbabel-loaderでTypeScriptのソースコードをBabel化してバンドルするところまでやりました。&lt;/p&gt;

&lt;p&gt;期末試験直前であまり学習コストをかけられず、これ以上webpackであれこれするのは怖くなったので、jsファイル以外の静的ファイルのコピーなどはrimrafやcpxを使い、npm scriptsでビルドすることにしました。
また開発中の自動コンパイルのために、chokidarとbrowser-syncを使いました。&lt;/p&gt;

&lt;h2 id=&#34;設計:715a67537c3fb0cd66e102735cb99acd&#34;&gt;設計&lt;/h2&gt;

&lt;p&gt;一定時間ごとにゲームループをまわし、大元のゲームオブジェクトから各マネージャのupdateメソッドを呼び出して処理を行い、最後にレンダリングを行うという基本的な設計としています。&lt;/p&gt;

&lt;p&gt;今回は、エンティティを管理するエンティティマネージャ、スコアを管理するスコアマネージャ、エンティティとスコア以外のゲーム内表示を管理するエフェクトマネージャ、ユーザーからの入力を受け取るインプットマネージャを用意しました。
また、スコアマネージャはインスタンスを2つ生成してそれぞれ取得スコアとミス回数を管理するようにしています。&lt;/p&gt;

&lt;p&gt;ステートマシンを用いてゲーム状態の遷移を管理する方法もありますが、今回はタイトルとゲーム中とゲームオーバーの三状態しかなく、また各エンティティも決まった動きしかしないため不要と判断しました。&lt;/p&gt;

&lt;p&gt;エンティティごとにスプライトのテクスチャを用意しておく必要があり、これはstaticメンバとして各エンティティのクラスに紐付けることにしました。
このテクスチャの生成はアセットのローディングが終わった後に行う必要があるため、エンティティマネージャの初期化時に各staticメソッドを呼び出すことで初期化するようにしました。&lt;/p&gt;

&lt;h3 id=&#34;eventemitterによるメッセージング:715a67537c3fb0cd66e102735cb99acd&#34;&gt;EventEmitterによるメッセージング&lt;/h3&gt;

&lt;p&gt;PIXI.jsで用意されているクラスは&lt;a href=&#34;https://github.com/primus/eventemitter3&#34;&gt;EventEmitter&lt;/a&gt;を継承しており、イベント駆動でのオブジェクト間のメッセージングが可能です。
たとえば&lt;code&gt;アライさん&lt;/code&gt;オブジェクトは&lt;code&gt;Hat&lt;/code&gt;コレクションに対する参照を持ちませんが、イベントの発火にフックしてエンティティマネージャがメソッド引数にコレクションの参照を流し込むことで、&lt;code&gt;アライさん&lt;/code&gt;オブジェクトは外部の参照を持つことなく&lt;code&gt;Hat&lt;/code&gt;コレクションにアクセスし、当たり判定の処理を行うことができます。
これにより、ゲーム内エンティティを表すオブジェクト同士を疎結合に保つことができます。
&lt;code&gt;Hat&lt;/code&gt;のように複数のインスタンスが生成される場合、そのたびにイベントの登録を行う必要があるので、このようなクラスはファクトリを通して実体化するようにします。&lt;/p&gt;

&lt;p&gt;その他にも、インプットマネージャがキーボード入力を受け取ったり、ゲーム画面上に配置されている透明のスプライトに対するクリック・タッチ入力を受け取った場合に、入力された動作に応じたイベントを発火することで、入力の種類を隠蔽したうえでそれにフックする処理を定義可能になります。&lt;/p&gt;

&lt;h2 id=&#34;はまりどころ:715a67537c3fb0cd66e102735cb99acd&#34;&gt;はまりどころ&lt;/h2&gt;

&lt;p&gt;ちょっとしたミスなどですが、詰まった点について。&lt;/p&gt;

&lt;h3 id=&#34;エンティティの消去:715a67537c3fb0cd66e102735cb99acd&#34;&gt;エンティティの消去&lt;/h3&gt;

&lt;p&gt;ループ中にループ対象の配列を変更するな、というのは基本ですが、ゲームの場合当たり判定がヒットしたエンティティを消去したいという場面は多いです。
&lt;code&gt;Hat&lt;/code&gt;コレクションに対してループを回して&lt;code&gt;update()&lt;/code&gt;を呼び出し、その処理の中で&lt;code&gt;Hat&lt;/code&gt;オブジェクトを消去してしまい、それ以降のオブジェクトの処理がおかしくなるというバグが発生しました。&lt;/p&gt;

&lt;p&gt;対処として、まずエンティティに&lt;code&gt;alive&lt;/code&gt;フラグを持たせておき、エンティティを消去したいときには以下のような処理を呼び出すだけにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;die() {
    this.alive = false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、全エンティティのupdate処理終了後に再度ループを回し、ここでaliveフラグがfalseとなっているエンティティをコレクションから取り除きます。
ただし、死んだはずのオブジェクトの当たり判定が残ったりすることを防ぐため、一度aliveフラグがfalseになったエンティティは処理から除外するようにしておく必要があります。
また、結局ループ中の配列を弄ることになるので、このループの中でおかしなことが起きるかもしれないので注意が必要です(とはいえ削除処理を別のループに分けていることで、最悪でもエンティティの削除が次回以降のフレームに引き延ばされてしまう程度の影響しか起きません)。&lt;/p&gt;

&lt;p&gt;ループ中に配列から安全に要素を取り除く方法としては、要素の削除時にイテレータをうまく調整したり、ループインデックスをずらして対処するなどといった方法がありますが、イテレータの仕様を正しく理解している必要があったり、削除処理のタイミングで自分の外側のループのことを考えないといけなかったりするため、処理がやや煩雑になりがちです。
そこで技巧的な方法として、ループのインデックスを配列の末尾から順に0に向けてデクリメントしていけば、途中で要素が取り除かれてもループに影響が出ない、といったものがあります。
ただし処理順は逆になってしまうので、それが気になるなら先述したエンティティ削除用のループでのみ行うなどする必要があります(エンティティの削除処理程度なら順序が変わっても影響が出ないため)。
最も単純なのはループ前にコレクションをコピーしてループを回すことですが、ゲームプログラムで毎フレームごとに配列のコピーを生成するのはパフォーマンス的に避けたいところでもあります。
なお今回は、&lt;code&gt;Hat&lt;/code&gt;オブジェクトは同時に10個も存在することはないため、毎回配列をコピーして削除用のループを回すことにしました。&lt;/p&gt;

&lt;h3 id=&#34;faviconの配信:715a67537c3fb0cd66e102735cb99acd&#34;&gt;faviconの配信&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;favicon.ico&lt;/code&gt;を配信しようと思ったのですが、&lt;a href=&#34;https://tatamo.github.io/japari-watch/&#34;&gt;https://tatamo.github.io/japari-watch/&lt;/a&gt; というURLのルートパスは&lt;a href=&#34;https://tatamo.github.io/&#34;&gt;https://tatamo.github.io/&lt;/a&gt; であるため、&lt;a href=&#34;https://tatamo.github.io/japari-watch/&#34;&gt;https://tatamo.github.io/japari-watch/&lt;/a&gt; 直下にfaviconを配置しても正しく読み込ませることができません。
そのため、&lt;code&gt;&amp;lt;link rel=&amp;quot;shortcut icon href=&amp;quot;favicon.ico&amp;quot; type=&amp;quot;image/x-icon&amp;quot;&amp;quot;&amp;gt;&lt;/code&gt;などとして明示的にfavicon.icoの位置を示す必要がありました。&lt;/p&gt;

&lt;p&gt;また、&lt;code&gt;manifest.json&lt;/code&gt;を&lt;a href=&#34;https://tatamo.github.io/japari-watch/favicons/manifest.json&#34;&gt;https://tatamo.github.io/japari-watch/favicons/manifest.json&lt;/a&gt; に、同様にandroid用のアイコン画像を&lt;code&gt;favicons/&lt;/code&gt;ディレクトリに配置していました。
&lt;code&gt;manifest.json&lt;/code&gt;中の相対パスは基準となるディレクトリが&lt;code&gt;manifest.json&lt;/code&gt;自身となることを知らなかったので、srcパスを&lt;code&gt;&amp;quot;favicons\/android-icon-***.png&amp;quot;&lt;/code&gt;としたところ、&lt;code&gt;favicons/favicons/&lt;/code&gt;が読まれてしまって正しくアイコンを配信できなかったりしました。&lt;/p&gt;

&lt;h2 id=&#34;おわりに:715a67537c3fb0cd66e102735cb99acd&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.pixijs.com/&#34;&gt;PIXI.js&lt;/a&gt;はチュートリアルだけは読んだことがあるという状態で、一度実際に使ってみたいと思っていたので使用することができて良かったです。
ドキュメントをろくに読み込まずに使いたい機能だけ調べて使うといった感じでしたが、かなり高速にゲーム開発ができたので非常に便利でした。
またwebpackやBabel、npm scriptsをメインに用いたビルドなどもはじめてだったのですがいい感じにできました。&lt;/p&gt;

&lt;p&gt;使用した画像については作者である&lt;a href=&#34;https://twitter.com/kirai_s&#34;&gt;@kirai_s&lt;/a&gt;さんに確認を得ないまま加工して作り始めてしまったのですが、使用を快く承諾していただけました。
この場を借りてお礼申し上げます。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>ブログのシンタックスハイライトを改善しました</title>
      <link>http://tatamo.81.la/blog/2017/11/08/syntax-highlight-improvement/</link>
      <pubDate>Wed, 08 Nov 2017 18:00:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/11/08/syntax-highlight-improvement/</guid>
      <description>
        

&lt;p&gt;このブログのシンタックスハイライトには&lt;a href=&#34;https://highlightjs.org/&#34;&gt;highlight.js&lt;/a&gt;を使用していますが、使い勝手を上げるために調整を行いました。&lt;/p&gt;

&lt;h2 id=&#34;コードの強調は不要だがhighlight-jsのテーマは使いたい:0daaccc7bb8856c5021376961a2bf330&#34;&gt;コードの強調は不要だがhighlight.jsのテーマは使いたい&lt;/h2&gt;

&lt;p&gt;プログラムの実行結果など、プログラムそのもの以外を&lt;code class=&#34;html&#34;&gt;&amp;lt;code&amp;gt;&lt;/code&gt;タグで囲いたくなる場合が何度かありました。
class要素に&lt;code&gt;nohighlight&lt;/code&gt;を指定すればハイライトは行われなくなりますが、highlight.jsのCSSテーマも適用されなくなります。&lt;/p&gt;

&lt;h2 id=&#34;インライン要素のハイライトをデフォルトで無効化したい:0daaccc7bb8856c5021376961a2bf330&#34;&gt;インライン要素のハイライトをデフォルトで無効化したい&lt;/h2&gt;

&lt;p&gt;さらに、インライン要素のハイライトを行う場合、対象となるコードが短いために言語の自動検出がうまく働かないことが多いです。
ブロック要素ではMarkdownでcode部分を囲う際に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;```javascript
/* code */
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすることで言語注釈をつけることができますが、インラインの場合はこれができないため言語を明示的に指定する場合には直接codeタグを書く必要があります。&lt;/p&gt;

&lt;h2 id=&#34;解決策:0daaccc7bb8856c5021376961a2bf330&#34;&gt;解決策&lt;/h2&gt;

&lt;p&gt;今のところ&lt;code class=&#34;html&#34;&gt;&amp;lt;code&amp;gt;&lt;/code&gt;で囲った部分はすべてhighlight.jsのテーマを適用してしまって問題はないので、&lt;code&gt;nohighlight&lt;/code&gt;を指定した場合でもCSSテーマが適用されるようにします。
また、インライン要素の場合はデフォルトで&lt;code&gt;nohighlight&lt;/code&gt;にしてしまって、必要がある場合のみHTMLタグを記述して明示的に言語を指定することとしました。
&lt;a href=&#34;http://tatamo.81.la/blog/2015/12/12/apply-highlightjs-to-inline/&#34;&gt;highlight.jsをインライン要素にも適用できるようにした&lt;/a&gt; で書いたコードを、さらに手直しします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// hljs.initHighlightingOnLoad();
window.addEventListener(&amp;quot;DOMContentLoaded&amp;quot;, () =&amp;gt; {
	const elements = document.getElementsByTagName(&amp;quot;code&amp;quot;);
	for (const el of elements) {
		if (el.parentNode.tagName != &amp;quot;PRE&amp;quot;) {
			// インライン要素
			el.style.display = &amp;quot;inline&amp;quot;;
			el.style.margin = &amp;quot;0 2px&amp;quot;;
			el.style.padding = &amp;quot;1px 3px&amp;quot;;
			if (el.classList.length == 0) {
				// classが指定されていない場合はnohighlightとする
				el.classList.add(&amp;quot;nohighlight&amp;quot;);
			}
		}
		hljs.highlightBlock(el);
		// nohighlightでもテーマは適用する
		if (el.classList.contains(&amp;quot;nohighlight&amp;quot;) ||
			el.classList.contains(&amp;quot;lang-nohighlight&amp;quot;) ||
			el.classList.contains(&amp;quot;language-nohighlight&amp;quot;)) {
			el.classList.add(&amp;quot;hljs&amp;quot;);
		}
	}
}, false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、&lt;code class=&#34;html&#34;&gt;&amp;lt;code&amp;gt;&lt;/code&gt;タグでclassの指定が明示的に行われていない場合は自動的に&lt;code&gt;nohighlight&lt;/code&gt;クラスを追加しています。
この処理はhighlight.jsでのハイライト化の処理を行う前に持ってきました。
スタイルの適用も同じように前に持ってきましたが、特に問題はないようです。
次に、&lt;code&gt;nohighlight&lt;/code&gt;が指定されていてハイライトが行われていない要素に対して、classにhighlight.jsで使用されているクラスである&lt;code&gt;hljs&lt;/code&gt;を指定することでテーマの適用を行っています。&lt;/p&gt;

&lt;p&gt;あとは既存の記事をこの変更に合わせて修正しました。
ところどころ不自然なハイライトが行われていた箇所がありましたが、これで改善されました。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第6回:パーサの実装と構文解析の実行</title>
      <link>http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-06/</link>
      <pubDate>Tue, 04 Apr 2017 23:41:09 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-06/</guid>
      <description>
        

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-05/&#34;&gt;前回&lt;/a&gt;ではLR(1)法による構文解析表の実装を済ませました。
今回はいよいよ、構文解析表をもとに実際に構文解析を行うことのできる構文解析器を実装し、実際に構文解析を行ってみます。&lt;/p&gt;

&lt;p&gt;概略は&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;第4回&lt;/a&gt;で示した通りであり、ステートマシンの仕様に沿って構文解析表を解析できるようにします。
第4回でアルゴリズム面まで踏み込んで解説してしまったため、あまり書くことがなくてやや後悔しています。&lt;/p&gt;

&lt;h2 id=&#34;astの定義:bed37c78c27b269093985160c6797817&#34;&gt;ASTの定義&lt;/h2&gt;

&lt;p&gt;パーサを実装する前に、パーサの出力結果となる抽象構文木の定義を行います。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/ast.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/ast.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// ast.ts
export interface ASTNode{
	type: Token;
	value: string|null;
	children: Array&amp;lt;ASTNode&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;構文木は再帰的な木構造によって表されます。
それぞれのノードにはそれが何の記号かを示すトークン、およびそのトークンに紐つけられている実際の入力文字列(そのトークンが非終端記号である場合はnull)、自身の子となるノードの配列を持ちます。&lt;/p&gt;

&lt;p&gt;たとえば、&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;第3回&lt;/a&gt;で定義した構文規則によって&lt;code&gt;1+1&lt;/code&gt;を解析した場合、結果として得られる抽象構文木は以下のようになるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
    {&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
        {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
            {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
                {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;, &amp;quot;value&amp;quot;:&amp;quot;1&amp;quot;, &amp;quot;children&amp;quot;:[]}
            ]}
        ]}
    ]}, 
    {&amp;quot;type&amp;quot;:&amp;quot;PLUS&amp;quot;, &amp;quot;value&amp;quot;:&amp;quot;+&amp;quot;, &amp;quot;children&amp;quot;:[]}, 
    {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
        {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;, &amp;quot;value&amp;quot;:null, &amp;quot;children&amp;quot;:[
            {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;, &amp;quot;value&amp;quot;:&amp;quot;1&amp;quot;, &amp;quot;children&amp;quot;:[]}
        ]}
    ]}
]}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;簡単ですね。&lt;/p&gt;

&lt;h2 id=&#34;パーサの実装:bed37c78c27b269093985160c6797817&#34;&gt;パーサの実装&lt;/h2&gt;

&lt;p&gt;ではParserクラスを作っていきます。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/parser.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/parser.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// parser.ts
export interface TerminalCallbackArg {
        token: string;
        value: string;
        terminal: true;
}
export interface NonterminalCallbackArg {
        token: string;
        children: Array&amp;lt;any&amp;gt;;
        pattern: Array&amp;lt;string&amp;gt;;
        terminal: false;
}
export declare type ParserCallbackArg = TerminalCallbackArg | NonterminalCallbackArg;
export declare type ParserCallback = (arg: ParserCallbackArg) =&amp;gt; any;
export declare class Parser {
        private lexer;
        private syntax;
        private parsingtable;
        private default_callback;
        constructor(lexer: ILexer, syntax: SyntaxDefinitions, parsingtable: ParsingTable, default_callback?: ParserCallback | null);
        setDefaultCallback(default_callback?: ParserCallback | null): void;
        parse(input: string, cb?: ParserCallback): any;
        private _parse(inputs, cb?);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;できました。&lt;/p&gt;

&lt;p&gt;構文解析処理を行う処理は、110行程度に及ぶ&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/parser.ts#L40&#34;&gt;Parser#_parse()メソッド&lt;/a&gt;の内部で完結しています。
これは、&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;第4回&lt;/a&gt;に示したオートマトンの動作を仕様通りに実装しています。
入力を前から順に読み込み、現在スタックに積まれている状態番号を取得し、構文解析表の該当する位置に書かれている命令を実行していくだけです。&lt;/p&gt;

&lt;p&gt;ここでは、構文解析の実行中に衝突した命令が存在した場合、その時点で解析失敗としてエラーを返すようにしています。
コンフリクトが発生した際の対処についても&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;第4回&lt;/a&gt;で触れていますが、一般に使用されているパーサジェネレータでは、構文規則を定義するファイルの中に演算子の優先度や右結合/左結合の指定を行うことができたり、指定のない場合はshift/reduceのいずれかを優先するようになっていたりします。&lt;/p&gt;

&lt;p&gt;このあたりのコンフリクト回避処理や、エラーが発生した際の詳細なエラー情報の検知・回避などの機能面には大きく改善の余地があります。&lt;/p&gt;

&lt;p&gt;あとは、このParserをParserGeneratorから利用できるようにするため、適当にファクトリクラスを作ります。
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/factory.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parser/factory.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// factory.ts
export class ParserFactory{
	public static create(grammar: GrammarDefinition, parsing_table: ParsingTable, default_fallback?: ParserCallback):Parser{
		let lexer = new Lexer(grammar.lex);
		return new Parser(lexer, grammar.syntax, parsing_table, default_fallback);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/parsergenerator.ts#L32&#34;&gt;ParserGenerator#getParser()メソッド&lt;/a&gt;には、以下のような記述を行います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// parsergenerator.ts
public getParser(default_callback?: ParserCallback):Parser{
	return ParserFactory.create(this.grammar, this.parsing_table, default_callback);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで完成です。&lt;/p&gt;

&lt;h2 id=&#34;構文解析を実行する:bed37c78c27b269093985160c6797817&#34;&gt;構文解析を実行する&lt;/h2&gt;

&lt;h3 id=&#34;構文木を生成する:bed37c78c27b269093985160c6797817&#34;&gt;構文木を生成する&lt;/h3&gt;

&lt;p&gt;では、実際に構文解析を実行してみましょう。
与える構文は、以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const syntax:SyntaxDefinitions = [
	{
		ltoken: &amp;quot;EXP&amp;quot;,
		pattern: [&amp;quot;EXP&amp;quot;, &amp;quot;PLUS&amp;quot;, &amp;quot;TERM&amp;quot;]
	},
	{
		ltoken: &amp;quot;EXP&amp;quot;,
		pattern: [&amp;quot;TERM&amp;quot;]
	},
	{
		ltoken: &amp;quot;TERM&amp;quot;,
		pattern: [&amp;quot;TERM&amp;quot;, &amp;quot;ASTERISK&amp;quot;, &amp;quot;ATOM&amp;quot;]
	},
	{
		ltoken: &amp;quot;TERM&amp;quot;,
		pattern: [&amp;quot;ATOM&amp;quot;]
	},
	{
		ltoken: &amp;quot;ATOM&amp;quot;,
		pattern:[&amp;quot;DIGITS&amp;quot;]
	},
	{
		ltoken: &amp;quot;ATOM&amp;quot;,
		pattern:[&amp;quot;LPAREN&amp;quot;, &amp;quot;EXP&amp;quot;, &amp;quot;RPAREN&amp;quot;]
	}
];
const lex:LexDefinitions = [
	{token:&amp;quot;DIGITS&amp;quot;, pattern:/[1-9][0-9]*/},
	{token:&amp;quot;PLUS&amp;quot;, pattern:&amp;quot;+&amp;quot;},
	{token:&amp;quot;ASTERISK&amp;quot;, pattern:&amp;quot;*&amp;quot;},
	{token:&amp;quot;LPAREN&amp;quot;, pattern:&amp;quot;(&amp;quot;},
	{token:&amp;quot;RPAREN&amp;quot;, pattern:&amp;quot;)&amp;quot;},
	{token:null, pattern:/(\r\n|\r|\n)+/},
	{token:null, pattern:/[ \f\t\v\u00a0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]+/},
	{token:&amp;quot;INVALID&amp;quot;, pattern:/./},
];

const grammar:GrammarDefinition = {
	lex: lex,
	syntax: syntax,
	start_symbol: &amp;quot;EXP&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt;という式を解析するためには、以下のように実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;new ParserGenerator(grammar).getParser().parse(&amp;quot;9 + 11 * (2 + 1)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すると、結果として以下のようなオブジェクトが得られます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
    {&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
    {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
        {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;9&amp;quot;,&amp;quot;children&amp;quot;:[]}
            ]}
        ]}
    ]},
    {&amp;quot;type&amp;quot;:&amp;quot;PLUS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;+&amp;quot;,&amp;quot;children&amp;quot;:[]},
    {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
        {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
            {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;11&amp;quot;,&amp;quot;children&amp;quot;:[]}
            ]}
        ]},
        {&amp;quot;type&amp;quot;:&amp;quot;ASTERISK&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;*&amp;quot;,&amp;quot;children&amp;quot;:[]},
        {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
            {&amp;quot;type&amp;quot;:&amp;quot;LPAREN&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;(&amp;quot;,&amp;quot;children&amp;quot;:[]},
            {&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                {&amp;quot;type&amp;quot;:&amp;quot;EXP&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                    {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                        {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                            {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;2&amp;quot;,&amp;quot;children&amp;quot;:[]}
                        ]}
                    ]}
                ]},
                {&amp;quot;type&amp;quot;:&amp;quot;PLUS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;+&amp;quot;,&amp;quot;children&amp;quot;:[]},
                {&amp;quot;type&amp;quot;:&amp;quot;TERM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                    {&amp;quot;type&amp;quot;:&amp;quot;ATOM&amp;quot;,&amp;quot;value&amp;quot;:null,&amp;quot;children&amp;quot;:[
                        {&amp;quot;type&amp;quot;:&amp;quot;DIGITS&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;children&amp;quot;:[]}
                    ]}
                ]}
            ]},
            {&amp;quot;type&amp;quot;:&amp;quot;RPAREN&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;)&amp;quot;,&amp;quot;children&amp;quot;:[]}
        ]}
    ]}
]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どこからどう見ても成功ですね。
おめでとうございます。&lt;/p&gt;

&lt;h3 id=&#34;コールバックを利用して構文木のさらなる解析を行う:bed37c78c27b269093985160c6797817&#34;&gt;コールバックを利用して構文木のさらなる解析を行う&lt;/h3&gt;

&lt;p&gt;ついに、本記事の目標である構文木の取得を達成しました。
あとはこれに適当な再帰的処理を挟めば、良い感じに数式処理ができるでしょう。&lt;/p&gt;

&lt;p&gt;確かに一度構文木を生成してからそれを解析してもよいのですが、パーサに適当なコールバックを渡し、構文木を生成する代わりに数式処理を行ってしまうという手もあります。&lt;/p&gt;

&lt;p&gt;先ほどのparsergenerator.tsに、以下のような定義が含まれていました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export interface TerminalCallbackArg {
        token: string;
        value: string;
        terminal: true;
}
export interface NonterminalCallbackArg {
        token: string;
        children: Array&amp;lt;any&amp;gt;;
        pattern: Array&amp;lt;string&amp;gt;;
        terminal: false;
}
export declare type ParserCallbackArg = TerminalCallbackArg | NonterminalCallbackArg;
export declare type ParserCallback = (arg: ParserCallbackArg) =&amp;gt; any;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Parserのコンストラクタ引数、ParserGeneratorのgetParserメソッドの引数、またはParserのparseメソッドの引数としてコールバックを与えると、reduce処理が行われた際にそれを呼び出すことができます。
処理するべきトークンが終端器号であった場合はそのトークンの種類と実際の入力が、非終端記号であった場合は対応する規則の情報、およびその子ノードの情報が引数として与えられます。&lt;/p&gt;

&lt;p&gt;実際に、数式の処理を行うための関数を書いてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;let solve_terminal = (arg:TerminalCallbackArg)=&amp;gt;{
	switch(arg.token){
		case &amp;quot;DIGITS&amp;quot;:
			return +arg.value;
		default:
			return null;
	}
}
let solve_nonterminal = (arg:NonterminalCallbackArg)=&amp;gt;{
	switch(arg.token){
		case &amp;quot;EXP&amp;quot;:
			if(arg.children.length == 1) return arg.children[0];
			else return arg.children[0] + arg.children[2];
		case &amp;quot;TERM&amp;quot;:
			if(arg.children.length == 1) return arg.children[0];
			else return arg.children[0] * arg.children[2];
		case &amp;quot;ATOM&amp;quot;:
			if(arg.children.length == 1) return arg.children[0];
			else return arg.children[1];
	}
}
let solve = (arg:ParserCallbackArg)=&amp;gt;{
	if(arg.terminal) return solve_terminal(arg);
	else return solve_nonterminal(arg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをもとに、以下のように実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;new ParserGenerator(grammar).getParser(solve).parse(&amp;quot;9 + 11 * (2 + 1)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行結果は、以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これにて、パーサジェネレータの実装および構文解析が完了しました。
ここまでお付き合いいただき、ありがとうございました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回:かんたん構文解析入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-05/&#34;&gt;前回:LR(1)パーサジェネレータの実装&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第5回:LR(1)パーサジェネレータの実装</title>
      <link>http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-05/</link>
      <pubDate>Tue, 04 Apr 2017 21:54:01 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-05/</guid>
      <description>
        

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;前回&lt;/a&gt;の記事ではLR(1)法の解説を行いました。
今回は前回解説した部分の実装を行います。&lt;/p&gt;

&lt;p&gt;今回はひたすらパーサジェネレータの実装をしていきます。
概略やアルゴリズムは既に紹介しているため、基本的に省略します。
適宜&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;前回&lt;/a&gt;の記事を参照してください。&lt;/p&gt;

&lt;p&gt;今回取り上げる部分は特にパフォーマンスに与える影響が大きいため、処理速度を重視した設計を行っています。
そのため、天下り的な解説となる箇所が増えるかもしれませんがご了承ください。&lt;/p&gt;

&lt;h2 id=&#34;syntaxdbクラスの作成:3aec03ed6d530aa5eea872bb2e906074&#34;&gt;SyntaxDBクラスの作成&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;第3回&lt;/a&gt;で終端記号と非終端記号の区別を行ったり、First集合を求めたりしたように、与えられた構文から様々な情報を得る必要があります。&lt;/p&gt;

&lt;p&gt;そこで、それらの情報取得を担うクラスとしてSyntaxDBクラスを作成します。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/syntaxdb.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/syntaxdb.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// syntaxdb.d.ts
export declare class SyntaxDB {
    private syntax;
    private _start_symbol;
    private _first;
    private _symbols;
    private tokenmap;
    private tokenid_counter;
    private defmap;
    constructor(grammar: GrammarDefinition);
    private initDefMap();
    readonly start_symbol: Token;
    readonly first: FirstSet;
    readonly symbols: SymbolDiscriminator;
    findDef(x: Token): Array&amp;lt;{
        id: number;
        def: SyntaxDefinitionSection;
    }&amp;gt;;
    getTokenId(token: Token): number;
    get(id: number): SyntaxDefinitionSection;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SyntaxDBクラスの読み取り専用メンバとして第3回で作成したFirstSetとSymbolDiscriminatorを持たせており、このクラスから終端記号の区別、First集合の取得が可能です。
また、開始記号の取得も行えるようにします。
さらに、構文id(上から何番目かを表す番号)を与えるとそれに対応する規則を返す&lt;code&gt;get&lt;/code&gt;メソッド、記号を与えるとそれが左辺に現れる規則すべてを、構文idとともに返す&lt;code&gt;findDef&lt;/code&gt;メソッド、そして記号を与えるとそれに対応した一意なトークンidを返す&lt;code&gt;getTokenId&lt;/code&gt;メソッドを持ちます。&lt;/p&gt;

&lt;p&gt;findDefメソッドは愚直に実装した場合、複数回呼ばれるとそのたびに&lt;code&gt;O(n)&lt;/code&gt;程度の計算量がかかります。
そのため、SyntaxDBインスタンスの初期化時に非終端記号と規則群を対応付けたMapを生成する(計算量は&lt;code&gt;O(n)&lt;/code&gt;程度)ことで、findDefの呼び出し時にはMapの中身をそのまま返すだけで済むようにします。&lt;/p&gt;

&lt;p&gt;getTokenIdメソッドは後述するアイテム集合部分で使用する必要がありますが、特に厳密なシリアライズや復元可能性を求めているわけではなく、単にハッシュ代わりに使用されます。
そのため、同一のSyntaxDBインスタンスのgetTokenIdメソッドにトークンを与えると、同一のトークンならば必ず同じ番号が返ってくるようになっていればそれで構いません。
よって、以下のような単純な実装で事足ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// Tokenを与えると一意なidを返す
public getTokenId(token: Token): number{
	if(!this.tokenmap.has(token)) this.tokenmap.set(token, this.tokenid_counter++);
	return this.tokenmap.get(token)!; /// ※ !はTypeScriptのnon-nullable注釈
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このSyntaxDBクラスは、パーサジェネレータ全体を通して一つのインスタンスのみを使いまわすようにします。&lt;/p&gt;

&lt;h2 id=&#34;アイテム集合とクロージャー展開:3aec03ed6d530aa5eea872bb2e906074&#34;&gt;アイテム集合とクロージャー展開&lt;/h2&gt;

&lt;p&gt;まずは、LRアイテムおよびその集合を表現するクラスを作っていきます。
アイテム集合クラスには、自身をクロージャー展開する機能を持たせることとします。&lt;/p&gt;

&lt;p&gt;また、DFAの構築において、「既存のアイテム集合の中に、新しく生成されたアイテム集合と一致するものが存在するかどうか判定する」処理が必要とされます。
愚直に実装すると、この処理を1回行うだけで&lt;code&gt;O(n^3)&lt;/code&gt;程度の計算量が必要となり、パーサジェネレータの処理全体の中で最大のボトルネックとなりえます。
そのため、2つのアイテム集合の高速な一致判定を行えるようにする必要があります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/closure.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/closure.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// closure.d.ts
export declare class ClosureItem {
    private syntax;
    private _syntax_id;
    private _dot_index;
    private _lookaheads;
    private _lr0_hash;
    private _lr1_hash;
    constructor(syntax: SyntaxDB, _syntax_id: number, _dot_index: number, _lookaheads: Array&amp;lt;Token&amp;gt;);
    readonly syntax_id: number;
    readonly dot_index: number;
    readonly lookaheads: Array&amp;lt;Token&amp;gt;;
    private sortLA();
    private updateHash();
    getLR0Hash(): string;
    getLR1Hash(): string;
    isSameLR0(c: ClosureItem): boolean;
    isSameLR1(c: ClosureItem): boolean;
    merge(c: ClosureItem): ClosureItem | null;
}
export declare class ClosureSet {
    private syntax;
    private closureset;
    private _lr0_hash;
    private _lr1_hash;
    constructor(syntax: SyntaxDB, closureset: Array&amp;lt;ClosureItem&amp;gt;);
    private sort();
    readonly size: number;
    getArray(): ClosureItem[];
    includes(item: ClosureItem): boolean;
    isSameLR0(c: ClosureSet): boolean;
    isSameLR1(c: ClosureSet): boolean;
    private updateHash();
    getLR0Hash(): string;
    getLR1Hash(): string;
    mergeLA(cs: ClosureSet): ClosureSet | null;
    private expandClosure();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ClosureItemクラスはLRアイテム1つに対応し、構文id、&lt;code&gt;.&lt;/code&gt;の位置、および先読み記号の情報を持ちます。
ClosureSetクラスは複数のClosureItemをまとめた集合を表し、自身をクロージャー展開することが出来ます。
さらに、後述するハッシュに関連した機能、および先読み部分のマージ機能などを持ちます。&lt;/p&gt;

&lt;h3 id=&#34;クロージャー展開:3aec03ed6d530aa5eea872bb2e906074&#34;&gt;クロージャー展開&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// クロージャー展開を行う
// TODO: リファクタリング
private expandClosure(){
	// 展開処理中はClosureItemのlookaheadsの要素数を常に1に保つこととする
	// 初期化
	let set:Array&amp;lt;ClosureItem&amp;gt; = [];
	// ClosureItemをlookaheadsごとに分解する
	for(let ci of this.closureset){
		for(let la of ci.lookaheads){
			set.push(new ClosureItem(this.syntax, ci.syntax_id, ci.dot_index, [la]));
		}
	}
	this.closureset = set;
	this.sort();

	// 変更がなくなるまで繰り返す
	let i=0;
	while(i&amp;lt;this.closureset.length){
		let ci = this.closureset[i++];
		let {ltoken, pattern} = this.syntax.get(ci.syntax_id);

		if(ci.dot_index == pattern.length) continue; // .が末尾にある場合はスキップ
		let follow = pattern[ci.dot_index];
		if(!this.syntax.symbols.isNonterminalSymbol(follow)) continue; // .の次の記号が非終端記号でないならばスキップ

		// クロージャー展開を行う

		// 先読み記号を導出
		// ci.lookaheadsは要素数1のため、0番目のインデックスのみを参照すればよい
		let lookaheads = [...this.syntax.first.get(pattern.slice(ci.dot_index+1).concat(ci.lookaheads[0])).values()];
		lookaheads.sort((t1:Token, t2:Token)=&amp;gt;{
			return this.syntax.getTokenId(t1) - this.syntax.getTokenId(t2);
		});

		// symbolを左辺にもつ全ての規則を、先読み記号を付与して追加
		let definitions = this.syntax.findDef(follow);
		for(let {id, def} of definitions){
			for(let la of lookaheads){
				let new_ci = new ClosureItem(this.syntax, id, 0, [la]);
				// 重複がなければ新しいアイテムを追加する
				let flg_duplicated = false;
				for(let existing_item of this.closureset){
					if(new_ci.isSameLR1(existing_item)){
						flg_duplicated = true;
						break;
					}
				}
				if(!flg_duplicated){
					this.closureset.push(new_ci);
				}
			}
		}
	}
	this.sort();

	// ClosureItemの先読み部分をマージする
	let tmp = this.closureset;
	this.closureset = [];
	let lookaheads = [];
	for(let i=0; i&amp;lt;tmp.length; i++){
		lookaheads.push(tmp[i].lookaheads[0]);
		if(i == tmp.length-1 || !tmp[i].isSameLR0(tmp[i+1])){
			this.closureset.push(new ClosureItem(this.syntax, tmp[i].syntax_id, tmp[i].dot_index, lookaheads));
			lookaheads = [];
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まだリファクタリングしていません。
すみません。&lt;/p&gt;

&lt;p&gt;ClosureItemは本来複数の先読み記号を保持することができるのですが、クロージャー展開の初期化段階では、まずそれを分解し、一つのClosureItemが必ず一つの先読み記号のみを持つようにします。&lt;/p&gt;

&lt;p&gt;この制約がなければ、たとえば&lt;code&gt;[x,y]&lt;/code&gt;という先読み記号を持ったAというClosureItemの展開処理が済んだあと、BというClosureItemを展開したところ、&lt;code&gt;[y,z]&lt;/code&gt;という先読み記号を持ち、先読み部分以外はAと全く同じClosureItemが生成される、といった自体が発生する可能性があります。
この場合、先読み記号&lt;code&gt;y&lt;/code&gt;については2度展開されてしまったり、それを防ぐために処理済みのClosureItemの走査を行うことで余計な計算が必要になってしまうなど、様々な弊害が発生します。
クロージャー展開の処理中だけはClosureItemの先読み記号は常に一つであるという制約を設けてることで、展開処理が非常に簡潔になります。&lt;/p&gt;

&lt;p&gt;処理が終わった段階で、ClosureItemの先読み部分をマージすることによってクロージャー展開後のClosureSetが完成します。&lt;/p&gt;

&lt;h3 id=&#34;ハッシュ:3aec03ed6d530aa5eea872bb2e906074&#34;&gt;ハッシュ&lt;/h3&gt;

&lt;p&gt;先述したように、2つのClosureSetの高速な比較を可能とする必要があります。
そこで、ClosureItemおよびClosureSetにハッシュ文字列の生成機能を追加し、構文番号、&lt;code&gt;.&lt;/code&gt;の位置、先読み記号という要素が一致していれば同じ文字列を生成するようにすれば、同一性の比較を文字列比較に落としこむことができ、非常に高速になります。
ハッシュといっても、SHA-1やMD5のようなビット列を出力する必要はなく、要素が同じなら同じ結果が得られ、かつ衝突が発生しなければそれでよいので、単純に要素を文字列化してしまえば事足ります。&lt;/p&gt;

&lt;p&gt;たとえば、構文番号1、&lt;code&gt;.&lt;/code&gt;の位置が左から2番目、先読み記号が&lt;code&gt;[$,x]&lt;/code&gt;のClosureItemなら、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;quot;1,2,[$,x]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような文字列を出力すれば目的は果たせます。
ClosureItemの集合であるClosureSetの場合は、まず自身の持っているClosureItemを、このハッシュ文字列を使ってソートした上で、以下のような文字列を生成します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;quot;1,2,[$,x]|2,3,[$]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ClosureItemが常にソートされていると仮定したならば、こちらも同一性の判定に用いることができます。&lt;/p&gt;

&lt;p&gt;ただしこの場合、ひとつだけ問題が生じます。
もし上記の&lt;code&gt;x&lt;/code&gt;のかわりに、&lt;code&gt;x]|2,2,[y&lt;/code&gt;という名前の終端記号があったとすると、さきほどのClosureSetのハッシュ文字列は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;quot;1,2,[$,x]|2,2,[y]|2,3,[$]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となってしまい、&lt;code&gt;2,2,[y]&lt;/code&gt;というClosureItemが存在した時に衝突が発生してしまう可能性があります。
これを防ぐため、先ほどのSyntaxDBを用いて、それぞれの終端記号を個別の数値に直してしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;quot;1,2,[0,1]&amp;quot;
&amp;quot;1,2,[0,1]|2,3,[1]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにすることで、危険性は回避できます。&lt;/p&gt;

&lt;p&gt;また、LALR(1)法のDFAマージの際に、先読み記号を除いた部分が一致しているかどうか調べる必要もあるため、ハッシュ文字列は先読み部分を除いたLR(0)ハッシュと、先読み部分も含めたLR(1)ハッシュの2種類を用意しておきます。&lt;/p&gt;

&lt;h4 id=&#34;closureitemおよびclosuresetのconst性:3aec03ed6d530aa5eea872bb2e906074&#34;&gt;ClosureItemおよびClosureSetのconst性&lt;/h4&gt;

&lt;p&gt;ハッシュの再生成や、それに伴うClosureSetのソート処理を回避するため、ClosureItemおよびClosureSetは、初期化終了後は自身の状態を変化させることがないようにします。&lt;/p&gt;

&lt;p&gt;たとえば、クロージャー展開を行うとClosureSetの中身は変化しますが、この処理はコンストラクタ呼び出し時に行うようにすることで、オブジェクトの初期化が終了した時点でクロージャー展開は終わっており、それ以降ClosureSetの状態が変化することはありません。
また、ClosureSetおよびClosureItemは、LR(0)部分(先読み部分を除いた部分)が同じなら先読み記号をマージするmergeメソッドを持っていますが、このメソッドもそのオブジェクト自身の状態を変更するのではなく、新しいオブジェクトを生成してそれを返すようにしています。&lt;/p&gt;

&lt;h2 id=&#34;dfaの構築:3aec03ed6d530aa5eea872bb2e906074&#34;&gt;DFAの構築&lt;/h2&gt;

&lt;p&gt;アイテム集合を扱えるようになったため、次はDFAの構築です。
DFAGeneratorクラスを作っていきます。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/dfagenerator.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/dfagenerator.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// dfagenerator.d.ts
export declare type DFAEdge = Map&amp;lt;Token, number&amp;gt;;
export declare type DFANode = {
    closure: ClosureSet;
    edge: DFAEdge;
};
export declare type DFA = Array&amp;lt;DFANode&amp;gt;;
export declare class DFAGenerator {
    private syntax;
    private lr_dfa;
    private lalr_dfa;
    constructor(syntax: SyntaxDB);
    getLR1DFA(): DFA;
    getLALR1DFA(): DFA;
    private generateNewClosureSets(closureset);
    private indexOfDuplicatedNode(dfa, new_node);
    private generateDFA();
    private mergeLA(dfa);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とはいえ、やるべきことはDFAの構築処理、およびLALR(1)法のDFAを生成するためのマージ処理のみです。&lt;/p&gt;

&lt;p&gt;DFAは、DFANodeの配列として表現します。
DFANodeは、一つのClosureSetとDFAEdgeを持ちます。
DFAEdgeはトークンをキーとしてDFANodeのインデックスを持つMapであり、これはトークンをラベルとして他のDFANodeに向けて張られた辺の情報を意味します。&lt;/p&gt;

&lt;p&gt;前回紹介したアルゴリズムをそのままコードにするだけなので、DFAの構築処理は特に解説する点はありません。&lt;/p&gt;

&lt;h2 id=&#34;構文解析表の構築:3aec03ed6d530aa5eea872bb2e906074&#34;&gt;構文解析表の構築&lt;/h2&gt;

&lt;p&gt;構文解析表と、それに必要な四種類の命令群を定義しておきます。
また、コンフリクトが発生したことを表す命令も定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// parsingtable.ts
export type ShiftOperation = {type: &amp;quot;shift&amp;quot;, to: number};
export type ReduceOperation = {type: &amp;quot;reduce&amp;quot;, syntax: number};
export type ConflictedOperation = {type: &amp;quot;conflict&amp;quot;, shift_to:Array&amp;lt;number&amp;gt;, reduce_syntax:Array&amp;lt;number&amp;gt;};
export type AcceptOperation = {type: &amp;quot;accept&amp;quot;};
export type GotoOperation = {type : &amp;quot;goto&amp;quot;, to: number};
export type ParsingOperation = ShiftOperation|ReduceOperation|ConflictedOperation|AcceptOperation|GotoOperation;
export type ParsingTable = Array&amp;lt;Map&amp;lt;Token, ParsingOperation&amp;gt;&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;構文解析表の構築処理は、ParserGeneratorクラスのメソッドとして実装します。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/parsergenerator.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/parsergenerator.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// parsergenerator.d.ts
export declare class ParserGenerator {
    private grammar;
    private parsing_table;
    private syntax;
    private dfa_generator;
    constructor(grammar: GrammarDefinition);
    init(): void;
    getParser(default_callback?: ParserCallback): Parser;
    getParsingTable(): ParsingTable;
    private generateParsingTable(dfa);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これも前回紹介したアルゴリズムの通り、DFAを読み取って適切な命令を配置していくだけです。
ParserGeneratorクラスは、初期化時にSyntaxDBおよびDFAGeneratorのインスタンスを生成し、DFAGeneratorから得られたDFAをもとに構文解析表の生成を行います。&lt;/p&gt;

&lt;p&gt;ここまでで構文解析表の構築まで終了したので、パーサジェネレータはほぼ完成となります。
あとは、この構文解析表を読み取ることのできるパーサの実装が必要です。
次回はパーサの実装を行いますが、そのパーサの動作等についても前回の記事である程度解説しているため、やはり実装中心となります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回:かんたん構文解析入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;前回:かんたんLR(1)法入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-06/&#34;&gt;次回:パーサの実装と構文解析の実行&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第4回:かんたんLR(1)法入門</title>
      <link>http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/</link>
      <pubDate>Wed, 22 Mar 2017 15:58:04 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/</guid>
      <description>
        

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;前回&lt;/a&gt;で構文解析器を生成する際に必要となる準備を済ませたため、LR(1)法ベースのパーサジェネレータを作る用意が整いました。
ですが相変わらず本題のパーサジェネレータ作成には入らず、まずはLR(1)法のおおまかな理論的概略の紹介を行います。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回&lt;/a&gt;では構文解析全体の流れを解説しましたが、実際にどのような過程でパーサを、またパーサジェネレータを作成するかについては触れませんでした。
今回は、LR法による構文解析の流れを解説するとともに、これからどのような流れでパーサジェネレータを作成していくのかを紹介します。
今回は解説のみのためソースコードが載りません。&lt;/p&gt;

&lt;h2 id=&#34;lr-1-構文解析の流れ:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;LR(1)構文解析の流れ&lt;/h2&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;字句規則を用意して字句解析器にかけてトークン列を取得したあと構文規則をもとにFIRST関数とFOLLOW関数を求め、それをもとにgotoグラフを導出することによってLR表を作成して、構築したLRパーサでトークン列を解析して得た抽象構文木を処理すれば構文解析ができると知ったわたし &lt;a href=&#34;https://t.co/aIbxqSf5qj&#34;&gt;pic.twitter.com/aIbxqSf5qj&lt;/a&gt;&lt;/p&gt;&amp;mdash; たたも (@&lt;strong&gt;tatamo&lt;/strong&gt;) &lt;a href=&#34;https://twitter.com/__tatamo__/status/798837425313189888&#34;&gt;2016年11月16日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;FOLLOW関数はSLR法などで使用する概念のため、LR(1)法を用いる今回の記事では用いません。忘れてください。&lt;/p&gt;

&lt;p&gt;LR構文解析の流れは、以下の通りとなります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;First関数を求める&lt;/li&gt;
&lt;li&gt;アイテム集合およびDFA(gotoグラフ)を作成する&lt;/li&gt;
&lt;li&gt;(LALR法のみ)DFAの先読み部分をマージし、より状態数が少なく軽量なDFAにする&lt;/li&gt;
&lt;li&gt;DFAをもとに構文解析表(LR表)を構築する&lt;/li&gt;
&lt;li&gt;構文解析表を実行できるパーサを作成する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1.のFirst関数については、&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;前回&lt;/a&gt;の記事で紹介を済ませているため割愛します。&lt;br /&gt;
LALR法のLR(1)法との相違点は3.のみで、他はLR(1)法と全く同じ処理を行います。&lt;/p&gt;

&lt;p&gt;パーサジェネレータを作成して解析する構文を自由に決定できるようにする場合、3.の構文解析表までを与えられた構文に合わせて自動的に生成できるようにします。&lt;/p&gt;

&lt;h2 id=&#34;アイテム集合とdfa:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;アイテム集合とDFA&lt;/h2&gt;

&lt;p&gt;LR法による構文解析のためには、DFA(決定性有限オートマトン)の作成を行う必要があります。&lt;/p&gt;

&lt;p&gt;LR法によって作られるDFAは、それぞれの状態(ノード)に、アイテム集合と呼ばれる情報と、他の状態への遷移ルールを示すトークンをラベルとした辺情報とを持ちます。
このLRアイテム集合は、構文解析表やDFA自身の構築のために必要な情報として使用されます。&lt;/p&gt;

&lt;p&gt;アイテム集合は、文字通りアイテム(便宜的にLRアイテムと呼称します)からなる集合です。&lt;/p&gt;

&lt;h3 id=&#34;lrアイテム:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;LRアイテム&lt;/h3&gt;

&lt;p&gt;個別のLRアイテムは、以下のようなものです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;X -&amp;gt; A . B C [x,y,$]
Xは非終端記号
A,B,Cは終端記号または非終端記号
x,yは終端記号
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一見すると&lt;code&gt;X -&amp;gt; A B C&lt;/code&gt;のような構文規則のルールのように見えますが、相違点があります。&lt;/p&gt;

&lt;p&gt;まず、規則の右辺に&lt;code&gt;.&lt;/code&gt;という記号が存在します。
これは終端記号でも非終端記号でもなく、「現在この部分まで解析した」ということを示すマーカーです。
上記の場合、&lt;code&gt;X&lt;/code&gt;という記号の解析の途中で既に&lt;code&gt;A&lt;/code&gt;を読み終え、次は&lt;code&gt;B C&lt;/code&gt;が与えられることが期待されているということを意味します。&lt;/p&gt;

&lt;p&gt;次に、規則の右辺のさらに右に、&lt;code&gt;[x,y,$]&lt;/code&gt;という表記が存在します。
これはLR(1)法の(1)先読みのために用いる先読み記号の集合を表しています。
解析が進んで&lt;code&gt;X&lt;/code&gt;の解析が終わった場合、つまり&lt;code&gt;.&lt;/code&gt;の位置が右端まで移動した場合、その次には&lt;code&gt;x&lt;/code&gt;,&lt;code&gt;y&lt;/code&gt;,&lt;code&gt;$&lt;/code&gt;のいずれかの記号が来ることを意味します。
先読み記号は常に終端記号であることに注意してください。
また、&lt;code&gt;$&lt;/code&gt;は「入力の終わり」を表す記号で、これは便宜的に終端記号として扱います(&lt;a href=&#34;http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/&#34;&gt;第2回&lt;/a&gt;で内部的に追加したSymbol(EOF)トークンのことです)。&lt;/p&gt;

&lt;h3 id=&#34;dfaの構築:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;DFAの構築&lt;/h3&gt;

&lt;p&gt;まず、DFAを最初の状態で初期化します。
このとき、DFAのノード数は一つのみであり、そのノードは、以下のようなLRアイテム一つのみを要素とするアイテム集合を持ちます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S&#39; -&amp;gt; . S [$]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただし、&lt;code&gt;S&lt;/code&gt;は開始記号であり、&lt;code&gt;S&#39;&lt;/code&gt;は便宜的に追加した新しい非終端記号です。
便宜的には、&lt;code&gt;S&#39;&lt;/code&gt;について以下の規則が成り立つこととみなします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S&#39; -&amp;gt; S $
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを自己展開させることによって、構文解析のためのDFAを構築していきます。&lt;/p&gt;

&lt;h4 id=&#34;クロージャー展開:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;クロージャー展開&lt;/h4&gt;

&lt;p&gt;まず、初期化時点で存在するこのDFAノードは、まだ完全な状態にはなっていません。
一定のルールに従い、アイテム集合を「クロージャー展開」する必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;X -&amp;gt; α . Y β [x]
X,Yは非終端記号(X=Yであってもよい)
xは終端記号
α,βは任意の長さの終端記号または非終端記号の列
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というLRアイテムが存在する場合、&lt;code&gt;Y&lt;/code&gt;を左辺として&lt;code&gt;.&lt;/code&gt;が右辺の左端にあるような新しいLRアイテムを、アイテムセットに追加します。
ただし、先読み記号はFirst(βx)で得られる記号全てとします。
つまり、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;Y -&amp;gt; γ
γは任意の長さの終端記号または非終端記号の列
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような規則があった場合、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;Y -&amp;gt; . γ [First(βx)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というLRアイテムを新しく追加します。&lt;/p&gt;

&lt;p&gt;これを、新しいアイテムが追加されなくなるまで繰り返します。&lt;/p&gt;

&lt;p&gt;具体的に見て行きましょう。
以下の規則を仮定します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S -&amp;gt; 0
S -&amp;gt; X 1
X -&amp;gt; 0
Sは開始記号
S,Xは非終端記号
0,1は終端記号
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、開始記号は&lt;code&gt;S&lt;/code&gt;なので、最初のLRアイテムは以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S&#39; -&amp;gt; . S [$]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.&lt;/code&gt;の次にある&lt;code&gt;S&lt;/code&gt;を展開します。
先読み記号は&lt;code&gt;First($)=[$]&lt;/code&gt;です。
以下のアイテムを追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S -&amp;gt; . 0 [$]
S -&amp;gt; . X 1 [$]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに、新しく追加されたアイテムにも同様の処理を行うと、&lt;code&gt;.&lt;/code&gt;の次に&lt;code&gt;X&lt;/code&gt;があるため、これを展開します。
&lt;code&gt;0&lt;/code&gt;は終端記号のため、展開は行いません。
先読み記号は、&lt;code&gt;First(1$)=[1]&lt;/code&gt;です(First関数は終端記号の列の左端の記号を得るので、ここでは&lt;code&gt;1&lt;/code&gt;のみとなります)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;X -&amp;gt; . 0 [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上の規則では&lt;code&gt;0&lt;/code&gt;は終端記号のため、ここで展開は終了します。&lt;/p&gt;

&lt;p&gt;結果として、最初のDFAノードの持つアイテム集合は以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S&#39; -&amp;gt; . S [$]
S -&amp;gt; . 0 [$]
S -&amp;gt; . X 1 [$]
X -&amp;gt; . 0 [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上がクロージャー展開の処理です。
こうして展開したアイテム集合をもとに、新しいDFAノードを生成していきます。&lt;/p&gt;

&lt;h4 id=&#34;新しいdfaノードの生成:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;新しいDFAノードの生成&lt;/h4&gt;

&lt;p&gt;クロージャー展開が完了したアイテム集合から、一定のルールのもとで新しいDFAノードを生成します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;X -&amp;gt; α . A β [x]
Xは非終端記号
Aは終端記号または非終端記号(X=Aであってもよい)
xは終端記号
α,βは任意の長さの終端記号または非終端記号の列
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というLRアイテムが存在する場合、以下の新しいLRアイテムを生成します(そのDFAノードのアイテムセットには追加しません)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;X -&amp;gt; α A . β [x]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そのDFAノードの持つ全てのLRアイテムについてこの処理が終わったら、&lt;code&gt;.&lt;/code&gt;の左隣の記号、つまり&lt;code&gt;A&lt;/code&gt;の位置の記号ごとに新しいアイテム集合を作り、それを情報としてもつ新しいDFAノードを生成します。
そして既存のDFAノードから、&lt;code&gt;A&lt;/code&gt;をラベルとして新しいノードに対して辺を張ります。&lt;/p&gt;

&lt;p&gt;具体的には、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S&#39; -&amp;gt; . S [$]
S -&amp;gt; . 0 [$]
S -&amp;gt; . X 1 [$]
X -&amp;gt; . 0 [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というアイテム集合を持つDFAからは、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S&#39; -&amp;gt; S . [$]
S -&amp;gt; 0 . [$]
S -&amp;gt; X . 1 [$]
X -&amp;gt; 0 . [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という4つのLRアイテムが生成され、これは以下の3つに分けられます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;1. ラベル: S
S&#39; -&amp;gt; S . [$]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;2. ラベル: 0
S -&amp;gt; 0 . [$]
X -&amp;gt; 0 . [1]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;3. ラベル: X
S -&amp;gt; X . 1 [$]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このようにして新しく3つのDFAノードを生成し、もとのノードからそれぞれの記号をラベルとした辺を張ります。
あとは、新しいノード全てについて、同様にクロージャー展開を行い、さらに新しいDFAノードを生成していきます。
ただし、その過程で既存のノードと全く同じアイテム集合を持つDFAノードが作られた場合は、新しいノードとしてそこに辺を張るのではなく、かわりに重複する既存のノードに対して辺を張るものとします。&lt;/p&gt;

&lt;p&gt;この処理を繰り返し、DFAノードが新しく生成されなくなればDFAの構築は終了です。&lt;/p&gt;

&lt;h4 id=&#34;lalr法のみ-先読み部分のマージ:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;(LALR法のみ)先読み部分のマージ&lt;/h4&gt;

&lt;p&gt;LALR法では、この時点でDFAのサイズ縮小を行います。
そのアルゴリズムは、以下の通りです。&lt;/p&gt;

&lt;p&gt;まず、DFAの持つアイテム集合から、それぞれのLRアイテムの先読み部分のみを除いた場合に、全く同じアイテム集合を持つようなDFAノードの組を見つけます。
そして、そのようなDFAノードの組において、LRアイテムの先読み部分をそれぞれの和集合とするような新しいDFAノードを作り、それらのノードに対して辺を張っていたノードがあれば、その辺を新しいノードに対して張り直します。&lt;/p&gt;

&lt;p&gt;具体的に、以下のようなアイテム集合を持つ2つのDFAノードを考えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;DFAノードA:
X -&amp;gt; .Y Z [x]
Y -&amp;gt; .V W [x,y]

DFAノードB:
X -&amp;gt; .Y Z [z]
Y -&amp;gt; .V W [y,z]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この2つのDFAノードは、先読み部分を除けば一致しているため、マージして次のDFAノードCを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;DFAノードC:
X -&amp;gt; .Y Z [x,z]
Y -&amp;gt; .V W [x,y,z]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、DFAノードAまたはBに対して辺を張っているDFAノードが存在するならば、それらの辺をDFAノードCに向けたものに書き換えます。&lt;/p&gt;

&lt;h2 id=&#34;構文解析表と構文解析器:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;構文解析表と構文解析器&lt;/h2&gt;

&lt;p&gt;DFAが完成したら、それをもとにして構文解析表を生成していきます。
構文解析表はそれ自体がステートマシンの動作仕様を表すものであり、構文解析表が完成してしまえば、それに沿ってステートマシンを動作させることで構文解析が可能となります。&lt;/p&gt;

&lt;h3 id=&#34;構文解析を行うステートマシン:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;構文解析を行うステートマシン&lt;/h3&gt;

&lt;p&gt;構文解析表には、ステートマシンの現在の状態、および次の入力に応じて、4種類の命令のいずれかが記述されます。
構文解析を行うステートマシンは、現在の状態を示すスタックと、構文解析の結果を保持するスタックの2つのスタックを持ちます。
また、入力を一文字だけ確認するか、入力を消費して一文字先に進めることができます。
(この仕様自体は変更の余地があります。)&lt;/p&gt;

&lt;p&gt;ステートマシンは、構文解析表から(状態スタックの一番上にある状態, 現在見ている入力)の命令を実行します。
最初は(初期状態, 一文字目の入力)となります。&lt;/p&gt;

&lt;p&gt;以下に、4つのそれぞれの命令の説明を記します。
とはいえ、ステートマシンの仕様なんざ読んでいて動きが分かるわけもなく楽しくも何ともないため、参考資料の&lt;a href=&#34;http://www.slideshare.net/ichikaz3/lr-parsing&#34;&gt;LR parsing&lt;/a&gt;のスライドを確認していただくことをおすすめします。
ステートマシンの動きを視覚的に追いかけることができて非常にわかりやすいです。&lt;/p&gt;

&lt;h4 id=&#34;shift命令:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;shift命令&lt;/h4&gt;

&lt;p&gt;shift命令を受けると、ステートマシンは入力を一つ消費します。
shift命令には状態番号が付与されているので、ステートマシンは状態スタックにその数値を追加します。&lt;/p&gt;

&lt;h4 id=&#34;reduce命令:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;reduce命令&lt;/h4&gt;

&lt;p&gt;reduce命令は文法idが付与されています。
ステートマシンがreduce命令を受けると、示された文法規則を確認し、その右辺の記号の数だけ状態スタックからポップして取り除きます。
さらに、結果スタックからも右辺の記号の数だけ取り除き、取り除いた結果すべてを現在見ている規則の左辺の記号を親とする木構造の子にして、そうしてできた木を結果スタックに追加します(または、取り除いた結果および文法idを引数として何らかのプログラムを実行し、その結果をスタックに追加する場合もあります)。&lt;/p&gt;

&lt;p&gt;そしてその処理の終了後、構文解析表の(状態スタックの一番上にある状態、規則の左辺の記号)の位置にあるgoto命令を実行させます。&lt;/p&gt;

&lt;h4 id=&#34;goto命令:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;goto命令&lt;/h4&gt;

&lt;p&gt;goto命令は、reduce命令の直後に実行されることが期待されます。
goto命令には状態番号が付与されているので、ステートマシンは状態スタックにその数値を追加します。
shift命令と異なり、入力の消費は行いません。&lt;/p&gt;

&lt;h4 id=&#34;accept命令:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;accept命令&lt;/h4&gt;

&lt;p&gt;ステートマシンがaccept命令を受けると、それは構文解析が終了したことを意味します。
理想的な入力が与えられた場合、入力は全て消費され、結果スタックには最終的な構文解析結果のみが入っていることが期待されます。&lt;/p&gt;

&lt;h3 id=&#34;構文解析器:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;構文解析器&lt;/h3&gt;

&lt;p&gt;構文解析器は、上記の仕様をなぞって構文解析表を読み取ることのできるステートマシンそのものです。
よって、構文解析表さえ個々の構文にあわせて生成することができれば、それを構文解析器に与えることによってさまざまな構文の解析が可能になります。&lt;/p&gt;

&lt;h3 id=&#34;構文解析表の構築:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;構文解析表の構築&lt;/h3&gt;

&lt;p&gt;完成したDFAをもとにして、構文解析表を生成することができます。&lt;/p&gt;

&lt;h4 id=&#34;shiftおよびgotoオペレーションの登録:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;shiftおよびgotoオペレーションの登録&lt;/h4&gt;

&lt;p&gt;それぞれのDFAノードは、ステートマシンの状態と対応しています。
簡単のため、個々のDFAノードには一意なid(ステートマシンの状態番号)が割り振られているものとします。
すべてのDFAノードについて、そのノードから張られている辺を参照します。&lt;/p&gt;

&lt;p&gt;その辺のラベルの記号が終端記号であるならば、構文解析表の(そのDFAノードのid, ラベルの記号)の部分にshift命令を書き込み、その辺の向かう対象となるDFAノードのidを付与します。&lt;/p&gt;

&lt;p&gt;その辺のラベルの記号が非終端記号であるならば、同様にしてgoto命令を書き込みます。&lt;/p&gt;

&lt;h4 id=&#34;acceptおよびreduceオペレーションの登録:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;acceptおよびreduceオペレーションの登録&lt;/h4&gt;

&lt;p&gt;すべてのDFAノードについて、そのアイテム集合の持つLRアイテム一つ一つを確認していきます。
もしも&lt;code&gt;.&lt;/code&gt;の位置が右辺の末尾にある場合、そのLRアイテムの持つ先読み記号それぞれについて、以下の処理を行います。&lt;/p&gt;

&lt;p&gt;構文解析表の(そのDFAノードのid, 先読み記号)の部分にreduce命令を書き込み、そのLRアイテムのもととなっている規則のidを付与。&lt;/p&gt;

&lt;p&gt;ただし、その規則が&lt;code&gt;S&#39;&lt;/code&gt;に対応するものであった場合、かわりにaccept命令を書き込みます。&lt;/p&gt;

&lt;h4 id=&#34;shift-reduceコンフリクト:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;shift/reduceコンフリクト&lt;/h4&gt;

&lt;p&gt;shiftオペレーションおよびreduceオペレーションは、表の同じ位置に競合して書き込まれてしまうことがあります。
このような状況を、shift/reduceコンフリクトと呼びます。
なお、shift/reduceコンフリクトだけでなく、reduce/reduceコンフリクト、複数回競合しあった3つ以上の命令のコンフリクト等も発生する可能性があります(shift/shiftコンフリクトも発生する可能性があると聞きましたが、上記のアルゴリズムでshiftを登録している場合はDFAが壊れていない限り発生し得ない気がします)。&lt;/p&gt;

&lt;p&gt;コンフリクトが発生してしまった場合の対処法は、大きく分けて二種類存在します。&lt;/p&gt;

&lt;p&gt;まずひとつは、諦めることです。
コンフリクトが発生した時点でそれはLR(1)文法を逸脱しているため、もともと解析可能な構文ではありません。
構文規則を等価になるようにいろいろ書き換えるとうまくコンフリクトが消せる(かもしれない)ので、与える構文の見直しをします。&lt;/p&gt;

&lt;p&gt;もうひとつは、規則ごとにオペレーションの優先度を設定し、コンフリクトが発生した場合は強制的にどちらかの命令を実行すると決めてしまうことです。
これは一般的に行われている方法であり、かなり乱暴ですが大抵の場合はまあなんとかなります。&lt;/p&gt;

&lt;h2 id=&#34;参考資料:aebbcc1e0aae8e4a96be644adf00eb3f&#34;&gt;参考資料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回&lt;/a&gt;で紹介したものを今回もそのまま参考資料としているため、基本的にはそちらをご覧ください。
今回紹介した内容の理解を深めるのに特に役立つと思われるおすすめの資料を抜粋しておきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.cornell.edu/courses/cs412/2003sp/lectures/lec09.pdf&#34;&gt;Cornell CIS Introduction to Compilers Lecture 9: LR(1) Parsing&lt;/a&gt;&lt;br /&gt;
LR(1) DFA、クロージャー展開、構文解析表等について詳細な定義や図解等が記載されています。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/ichikaz3/lr-parsing&#34;&gt;LR parsing&lt;/a&gt;&lt;br /&gt;
クロージャー展開やDFAの構築、実際のステートマシンの動きに至るまで実際の動作過程を見ることができます。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;今回でおおまかなLR(1)構文解析器作りの解説を済ませたので、次回からは実装をしていくだけです。
誰も他人のソースコードの解説なんて読む気は起きないでしょうし、これ以上続ける意味があるのか大いに疑問ではあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回:かんたん構文解析入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;前回:儀式の下準備&lt;/a&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/04/04/lr-parser-generator-implementation-05/&#34;&gt;次回:LR(1)パーサジェネレータの実装&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第3回:儀式の下準備</title>
      <link>http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/</link>
      <pubDate>Tue, 21 Mar 2017 00:29:18 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/</guid>
      <description>
        

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/&#34;&gt;前回&lt;/a&gt;は字句解析器の作成を行ったので、次にLR(1)法による構文解析のためのパーサジェネレータの作成に入っていきます。
今回は、LR(1)構文解析器の構築のために必要な、終端記号と非終端記号の区別、Nulls集合、First集合の導出等を行えるようにしていきます。&lt;/p&gt;

&lt;p&gt;いよいよ構文解析部分の実装にとりかかるため、今後はLR(1)法に焦点を絞って解説していきます。&lt;/p&gt;

&lt;p&gt;今回はその準備段階として必要になる部分を作っていくため、どんどん実装を進めていきます。&lt;/p&gt;

&lt;h2 id=&#34;構文規則を定義する:54819cf28b4a2703da41ec17803c8ec7&#34;&gt;構文規則を定義する&lt;/h2&gt;

&lt;p&gt;まずは、前回字句規則を定義したように、構文規則を定義していく必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export interface LexDefinitionSection{
	token: Token|null;
	pattern: string|RegExp;
}
export type LexDefinitions = Array&amp;lt;LexDefinitionSection&amp;gt;;

export interface SyntaxDefinitionSection{
	ltoken: Token;
	pattern: Array&amp;lt;Token&amp;gt;;
}
export type SyntaxDefinitions = Array&amp;lt;SyntaxDefinitionSection&amp;gt;;

export interface GrammarDefinition{
	lex: LexDefinitions;
	syntax: SyntaxDefinitions;
	start_symbol: Token;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字句規則と構文規則を合わせて、上記のように定義しておきましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回&lt;/a&gt;で定義した構文規則をこのデータ形式に直すと、以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;const syntax:SyntaxDefinitions = [
	{
		ltoken: &amp;quot;EXP&amp;quot;,
		pattern: [&amp;quot;EXP&amp;quot;, &amp;quot;PLUS&amp;quot;, &amp;quot;TERM&amp;quot;]
	},
	{
		ltoken: &amp;quot;EXP&amp;quot;,
		pattern: [&amp;quot;TERM&amp;quot;]
	},
	{
		ltoken: &amp;quot;TERM&amp;quot;,
		pattern: [&amp;quot;TERM&amp;quot;, &amp;quot;ASTERISK&amp;quot;, &amp;quot;ATOM&amp;quot;]
	},
	{
		ltoken: &amp;quot;TERM&amp;quot;,
		pattern: [&amp;quot;ATOM&amp;quot;]
	},
	{
		ltoken: &amp;quot;ATOM&amp;quot;,
		pattern:[&amp;quot;DIGITS&amp;quot;]
	},
	{
		ltoken: &amp;quot;ATOM&amp;quot;,
		pattern:[&amp;quot;LPAREN&amp;quot;, &amp;quot;EXP&amp;quot;, &amp;quot;RPAREN&amp;quot;]
	}
];
const lex:LexDefinitions = [
	{token:&amp;quot;DIGITS&amp;quot;, pattern:/[1-9][0-9]*/},
	{token:&amp;quot;PLUS&amp;quot;, pattern:&amp;quot;+&amp;quot;},
	{token:&amp;quot;ASTERISK&amp;quot;, pattern:&amp;quot;*&amp;quot;},
	{token:&amp;quot;LPAREN&amp;quot;, pattern:&amp;quot;(&amp;quot;},
	{token:&amp;quot;RPAREN&amp;quot;, pattern:&amp;quot;)&amp;quot;},
	{token:null, pattern:/\s/},
	{token:&amp;quot;INVALID&amp;quot;, pattern:/./},
];
const grammar:GrammarDefinition = {
	lex: lex,
	syntax: syntax,
	start_symbol: &amp;quot;EXP&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ルール一行ごとに一つのオブジェクトを割り当てています。
また、&lt;code&gt;start_symbol&lt;/code&gt;の定義を加えていることに注意してください。
これは文字通り開始記号のことであり、最初にどの記号から構文解析を開始するか表すために必要です。
最終的に構文解析を行った結果として構文木を得た場合、この開始記号が構文木の根となります。&lt;/p&gt;

&lt;h2 id=&#34;終端記号と非終端記号を区別する:54819cf28b4a2703da41ec17803c8ec7&#34;&gt;終端記号と非終端記号を区別する&lt;/h2&gt;

&lt;p&gt;構文解析器を作るためには、与えられた構文から終端記号と非終端記号を区別できるようにする必要があります。
定義を再確認しておくと、規則の左辺に現れることのない記号が終端記号、現れる記号が非終端記号です。&lt;/p&gt;

&lt;p&gt;実装上難しい点は特にないので、簡単に済ませてしまいましょう。&lt;/p&gt;

&lt;p&gt;ひとまず、SymbolDiscriminatorというクラスを作って終端記号と非終端記号の問い合わせをできるようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// symboldiscriminator.d.ts
export declare class SymbolDiscriminator {
    private terminal_symbols;
    private nonterminal_symbols;
    constructor(syntaxdef: SyntaxDefinitions);
    getTerminalSymbols(): Set&amp;lt;Token&amp;gt;;
    getNonterminalSymbols(): Set&amp;lt;Token&amp;gt;;
    isTerminalSymbol(symbol: Token): boolean;
    isNonterminalSymbol(symbol: Token): boolean;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際のコードは以下を参照してください。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/symboldiscriminator.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/symboldiscriminator.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// コンストラクタの実装のみ抜粋
constructor(syntaxdef:SyntaxDefinitions){
	this.terminal_symbols = new Set&amp;lt;Token&amp;gt;();
	this.nonterminal_symbols = new Set&amp;lt;Token&amp;gt;();

	// 左辺値の登録
	for(let sect of syntaxdef){
		let symbol = sect.ltoken;
		// 構文規則の左辺に現れる記号は非終端記号
		this.nonterminal_symbols.add(symbol);
	}
	// 右辺値の登録
	for(let sect of syntaxdef){
		for(let symbol of sect.pattern){
			if(!this.nonterminal_symbols.has(symbol)){
				// 非終端記号でない(=左辺値に現れない)場合、終端記号である
				this.terminal_symbols.add(symbol);
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2つのSetを用意し、コンストラクタの呼び出し時に左辺に現れる記号とそうでない記号で分けています。
これで、トークンを与えるとそれが終端記号かどうか、非終端記号かどうかを判別できるようになりました。&lt;/p&gt;

&lt;p&gt;なおこの記事において、「トークン」と「記号」は概念上は同様の意味を持ちますが、前者はプログラム内で記号を表すための構造として扱い、理論的な概念について触れる際は後者を使うものとします。&lt;/p&gt;

&lt;h2 id=&#34;nulls集合とfirst集合:54819cf28b4a2703da41ec17803c8ec7&#34;&gt;Nulls集合とFirst集合&lt;/h2&gt;

&lt;p&gt;構文解析器の作成のためには、First集合というものを求める必要があります。
そしてFisrt集合を求めるためには、Nulls集合が必要です。&lt;/p&gt;

&lt;p&gt;First集合はFirst関数などとも呼ばれます。
まあ名前なんてどうでもいいのですが、とにかくFirstとNullsを導出しなければなりません。
順を追って見て行きましょう。
例に漏れず、&lt;a href=&#34;https://twitter.com/ki6o4&#34;&gt;うさぎさん(@ki6o4)&lt;/a&gt;の&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kimiyuki.net/blog/2016/08/03/context-free-grammar/&#34;&gt;文脈自由文法とその構文解析法 &amp;middot; うさぎ小屋&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が詳しいので厳密な定義等はそちらを参照してください(First,NullableはLL(1)の項で紹介されています)。&lt;/p&gt;

&lt;h3 id=&#34;nulls集合を求める:54819cf28b4a2703da41ec17803c8ec7&#34;&gt;Nulls集合を求める&lt;/h3&gt;

&lt;h4 id=&#34;nulls集合とは:54819cf28b4a2703da41ec17803c8ec7&#34;&gt;Nulls集合とは&lt;/h4&gt;

&lt;p&gt;ある終端記号または非終端記号について、それが「Nullableである」かどうかを判別する必要があります。
「Nullableな記号」を集めた集合をNulls集合ということにします。
記号がNullableであるとは、その記号から空列が導かれうることを意味します。&lt;/p&gt;

&lt;p&gt;今回題材としている数式の構文規則には、「右辺が存在しない」ルールはありません。
しかし、解析したい構文によっては、右辺が存在しない、つまり左辺から空列が導かれるルールが存在することがあります。
空列とはスペース(空白)等を意味するのではなく、長さ0の入力を意味します。
具体的には、次のようなルールを見てみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;X -&amp;gt; Y &amp;quot;0&amp;quot;
Y -&amp;gt; &amp;quot;1&amp;quot;
Y -&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;構文規則の三行目の右辺には何も書かれていません。
このような場合、&lt;code&gt;Y&lt;/code&gt;は&lt;code&gt;1&lt;/code&gt;もしくは空列となり得ます。
よって&lt;code&gt;X&lt;/code&gt;は、&lt;code&gt;10&lt;/code&gt;と&lt;code&gt;0&lt;/code&gt;の2通りが許容されるのです。
ここで、&lt;code&gt;Y&lt;/code&gt;は空列となり得るため、Nulls集合に含まれます。
さらに、次のような例を見てください。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;Z -&amp;gt; Y
Y -&amp;gt; &amp;quot;1&amp;quot;
Y -&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、&lt;code&gt;Z&lt;/code&gt;は&lt;code&gt;1&lt;/code&gt;と空列の2通りとなる可能性があります。
よって、&lt;code&gt;Z&lt;/code&gt;もNullableであるといえます。
このように、その記号自体が空列となるルールを指定していなくても、右辺の記号次第では空列となることがあります。
ひとつでも空列となるパターンが存在する場合、Nulls集合に含まなければなりません。
また当然ですが、左辺に現れることのない終端記号はNullableではありません。&lt;/p&gt;

&lt;h4 id=&#34;nulls集合を実装する:54819cf28b4a2703da41ec17803c8ec7&#34;&gt;Nulls集合を実装する&lt;/h4&gt;

&lt;p&gt;なにやら面倒そうですが、実装はそう複雑ではありません。
NullableSetクラスを作ってみましょう。&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/nullableset.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/nullableset.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// nullableset.ts
export class NullableSet{
	private nulls:Set&amp;lt;Token&amp;gt;;
	constructor(private syntax: SyntaxDefinitions){
		this.generateNulls();
	}
	// nulls初期化
	private generateNulls(){
		// 制約条件を導出するために、
		// 空列になりうる記号の集合nullsを導出
		this.nulls = new Set&amp;lt;Token&amp;gt;();
		for(let rule of this.syntax){
			// 右辺の記号の数が0の規則を持つ記号は空列になりうる
			if(rule.pattern.length == 0){
				this.nulls.add(rule.ltoken);
			}
		}

		// 変更が起きなくなるまでループする
		let flg_changed:boolean = true;
		while(flg_changed){
			flg_changed = false;
			for(let rule of this.syntax){
				// 既にnullsに含まれていればスキップ
				if(this.isNullable(rule.ltoken)) continue;

				let flg_nulls = true;
				// 右辺に含まれる記号がすべてnullableの場合はその左辺はnullable
				for(let token of rule.pattern){
					if(!this.isNullable(token)){
						// 一つでもnullableでない記号があるならnon-nullable
						flg_nulls = false;
						break;
					}
				}
				if(flg_nulls){
					flg_changed = true;
					this.nulls.add(rule.ltoken);
				}
			}
		}
	}
	public isNullable(x:Token){
		return this.nulls.has(x);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アルゴリズムは以下の通りです。&lt;br /&gt;
まず、右辺の記号の数が0になるような規則を持っている記号は明らかにNullableです。
そのため、初期化段階として、そのような規則を探してNulls集合に追加します。&lt;br /&gt;
次に、それ以外の記号がNullableであるためには、規則の右辺がすべてNullableな記号である必要があります。
そこで、すべての規則を調べ、その右辺の記号がすべて既存のNull集合に含まれているならば、その記号もNulls集合に追加します。&lt;br /&gt;
この処理を、一巡しても新しいNullableな規則が追加されなくなるまで繰り返せば終了です。&lt;/p&gt;

&lt;h3 id=&#34;first集合を求める:54819cf28b4a2703da41ec17803c8ec7&#34;&gt;First集合を求める&lt;/h3&gt;

&lt;h4 id=&#34;first集合とは:54819cf28b4a2703da41ec17803c8ec7&#34;&gt;First集合とは&lt;/h4&gt;

&lt;p&gt;たとえば先ほど挙げた&lt;code&gt;X&lt;/code&gt;が&lt;code&gt;10&lt;/code&gt;や&lt;code&gt;0&lt;/code&gt;となるように、非終端記号は規則をたどっていくと終端記号のみの列に変換することができます。
構文解析を行うためには、ある非終端記号から得られるそのような終端記号の列のうち、最も左側にどのような終端記号が来るのかを知る必要があります。
今解析している記号の次に非終端記号が来るときに、実際にどのような終端記号が来るのかを調べることによって、(1)先読み(&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回&lt;/a&gt;参照)が可能となるわけです。&lt;/p&gt;

&lt;p&gt;このように、ある非終端記号と、そこから得られる可能性のある終端記号の列の先頭に来る記号の集合を対応付けたものを、First集合またはFirst関数と呼びます。
たとえば、先ほどの&lt;code&gt;X&lt;/code&gt;を例にすると、&lt;code&gt;First(X)&lt;/code&gt;は、&lt;code&gt;10&lt;/code&gt;と&lt;code&gt;0&lt;/code&gt;のそれぞれ左端の記号をとって&lt;code&gt;{1, 0}&lt;/code&gt;となります。&lt;/p&gt;

&lt;p&gt;Aが終端記号であるなら、&lt;code&gt;First(A)&lt;/code&gt;は&lt;code&gt;{A}&lt;/code&gt;(A自身のみを要素とする集合)です。
また、Firstに与える引数は記号だけでなく記号列である可能性もあります。
&lt;code&gt;First(YA)&lt;/code&gt;なら、&lt;code&gt;Y&lt;/code&gt;がNullableであるため、&lt;code&gt;YA&lt;/code&gt;から得られうる文字列の左端になりうるのは&lt;code&gt;1&lt;/code&gt;と&lt;code&gt;A&lt;/code&gt;なので、&lt;code&gt;{1, A}&lt;/code&gt;のようになるでしょう。&lt;/p&gt;

&lt;h4 id=&#34;first集合の実装:54819cf28b4a2703da41ec17803c8ec7&#34;&gt;First集合の実装&lt;/h4&gt;

&lt;p&gt;話がごちゃごちゃしてきましたが、実装に移りましょう。
基本的なアルゴリズムは、以下のようになります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ある記号&lt;code&gt;A&lt;/code&gt;が終端記号なら、&lt;code&gt;First(A)&lt;/code&gt;は&lt;code&gt;{A}&lt;/code&gt;である。全ての終端記号についてそのように初期化する。&lt;/li&gt;
&lt;li&gt;非終端記号に対応するFirst集合は、まず空集合で初期化する。&lt;/li&gt;
&lt;li&gt;ルール &lt;code&gt;X -&amp;gt; Y1 Y2 ... Yi&lt;/code&gt; について、以下の制約を生成する。

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;First(X) ⊇ First(Y1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Y1&lt;/code&gt;がNullableなら &lt;code&gt;First(X) ⊇ First(Y2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Y1&lt;/code&gt;および&lt;code&gt;Y2&lt;/code&gt;がともにNullableなら &lt;code&gt;First(X) ⊇ First(Y3)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Y1&lt;/code&gt;および&lt;code&gt;Y2&lt;/code&gt;および&lt;code&gt;Y3&lt;/code&gt;がともにNullableなら &lt;code&gt;First(X) ⊇ First(Y4)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;以下繰り返し&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;生成した制約に従い、スーパーセット側にサブセット側の集合の持つ記号を追加していく(制約の解消)。&lt;/li&gt;
&lt;li&gt;制約の解消を全ての集合に変化がなくなるまで繰り返す。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;わかりにくいですね。
ちなみにこのアルゴリズムは、言葉で定義するよりもプログラムを書いたほうがわかりやすい類のものです。&lt;/p&gt;

&lt;p&gt;とはいえちょっとコードが長いので、URLから参照をお願いします。
&lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/firstset.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/parsergenerator/firstset.ts&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// firstset.d.ts
export declare class FirstSet {
    private syntax;
    private symbols;
    private first_map;
    private nulls;
    constructor(syntax: SyntaxDefinitions, symbols: SymbolDiscriminator);
    private generateFirst();
    get(arg: Token): Set&amp;lt;Token&amp;gt;;
    get(arg: Array&amp;lt;Token&amp;gt;): Set&amp;lt;Token&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実のところNulls集合はFirst集合を求める時にしか使わないので、First関数のprivateメンバとしてNullableSetインスタンスを生成して使用します。
SymbolDiscriminatorは他でも使いまわす必要があるので、コンストラクタ引数による依存性の注入を行います。&lt;/p&gt;

&lt;p&gt;また、First関数の引数には単一の記号だけでなく、記号列も与えられるようにする必要があります。
getメソッドではトークンを引数にとるだけでなく、トークンの配列も引数として与えることができるようにします。
トークンの配列が与えられた場合は、左から順に個別のトークンのFirst関数を呼び、そのトークンがNullableである限り、その右隣のFirst関数も呼び出し、その結果として得られた記号全てを要素とする集合を返すものとします。&lt;/p&gt;

&lt;p&gt;説明が適当かつわかりにくくて申し訳ありませんが、どうせ準備段階なので軽く飛ばして先に進めていきましょう(&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回&lt;/a&gt;に参考資料をまとめてあるため、詳細かつ厳密に知りたい方はそちらを参照してください)。&lt;/p&gt;

&lt;p&gt;これでひとまずFirst集合の導出まで終わったので、次回からは構文解析表の作成にとりかかります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;第1回:かんたん構文解析入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/&#34;&gt;前回:字句解析器の実装&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/&#34;&gt;次回:かんたんLR(1)法入門&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第2回:字句解析器の実装</title>
      <link>http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/</link>
      <pubDate>Sat, 11 Feb 2017 18:13:48 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/</guid>
      <description>
        

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;前回&lt;/a&gt;は構文解析の概略を紹介したので、今回から実装に移っていきたいと思います。
まずは字句解析器を用意する必要があるため、今回は字句解析器の作成について紹介します。&lt;/p&gt;

&lt;p&gt;なお今回から実際のプログラムを記述していきますが、使用言語はTypeScriptとします。&lt;/p&gt;

&lt;p&gt;パーサジェネレータを作るのに比べれば字句解析器を作るのは非常に単純です。
早速はじめていきましょう。&lt;/p&gt;

&lt;h2 id=&#34;字句解析器の仕様を確認する:33ced0e1bdc35ac00ed380cf2d7265fa&#34;&gt;字句解析器の仕様を確認する&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;前回&lt;/a&gt;の記事でも紹介しましたが、字句解析器の行う処理は以下のような流れになります。&lt;/p&gt;

&lt;p&gt;まず、解析するべき入力を文字列として受け取ります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;9 + 11 * (2 + 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに加えて、字句規則を用意します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;数字: /[1-9][0-9]*/
プラス: &amp;quot;+&amp;quot;
アステリスク: &amp;quot;*&amp;quot;
左括弧: &amp;quot;(&amp;quot;
右括弧: &amp;quot;)&amp;quot;
(読み捨て): /\s/
(不正): /./
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字句解析器は受け取った入力を先頭から順に字句規則にあてはめ、マッチするものがあればそのトークンを割り当てます。
結果として得られる出力は、以下のようなリストになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;数字: 9
プラス: +
数字: 11
アステリスク: *
左括弧: (
数字: 2
プラス: +
数字: 1
右括弧: )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得られたトークンのリストを構文解析器の入力として渡すことで、構文解析器は文法の解析のみに注力することができます。&lt;/p&gt;

&lt;h2 id=&#34;字句規則を定義する:33ced0e1bdc35ac00ed380cf2d7265fa&#34;&gt;字句規則を定義する&lt;/h2&gt;

&lt;p&gt;実際に解析を行うタイミングでは文字列のみを入力として受け取りますが、字句解析器の生成時には字句規則が必要です。
そのため、予め字句規則を別の設定ファイルなどに書いておくなどして用意しておかなければなりません。
ただし、&lt;strong&gt;字句規則の解析には構文解析器が必要&lt;/strong&gt;となるため、現時点ではプログラム内にハードコーディングしておくなどする必要があります。
今回は、字句規則を内部的に以下のようなデータ構造で扱うこととして、しばらくは字句規則をその内部データの形式で直接書くことにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// 定義
export type Token = string|symbol;
export interface LexDefinitionSection{
	token: Token|null;
	pattern: string|RegExp;
}
export type LexDefinitions = Array&amp;lt;LexDefinitionSection&amp;gt;;

// 実際の字句規則
const lex: LexDefinitions = [
	{token:&amp;quot;DIGITS&amp;quot;, pattern:/[1-9][0-9]*/},
	{token:&amp;quot;PLUS&amp;quot;, pattern:&amp;quot;+&amp;quot;},
	{token:&amp;quot;ASTERISK&amp;quot;, pattern:&amp;quot;*&amp;quot;},
	{token:&amp;quot;LPAREN&amp;quot;, pattern:&amp;quot;(&amp;quot;},
	{token:&amp;quot;RPAREN&amp;quot;, pattern:&amp;quot;)&amp;quot;},
	{token:null, pattern:/\s/},
	{token:&amp;quot;INVALID&amp;quot;, pattern:/./},
];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この字句規則の定義について、実用上の理由で追加したいくつかの仕様に注意する必要があります。&lt;/p&gt;

&lt;p&gt;Tokenの型定義にsymbolを含めている点についてはここで説明せずに後述することとします。&lt;/p&gt;

&lt;h3 id=&#34;入力の読み捨て:33ced0e1bdc35ac00ed380cf2d7265fa&#34;&gt;入力の読み捨て&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;{token:null, pattern:/\s/}
// (読み捨て): /\s/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この部分は、何らかの空白文字が入力に存在していればマッチングされます。
&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; を解析する際、ここに含まれている空白は文法上何の意味も持たず、&lt;code&gt;9+11*(2+1)&lt;/code&gt; のように入力が与えられたとしても解析結果は変化しません。
このような場合、構文解析器に空白の情報を与えることすらせずに、字句解析器上で空白を検知した段階でその情報を捨ててしまったほうが、構文解析器に余計な処理をさせずに済みます。&lt;/p&gt;

&lt;p&gt;今回は、トークンのラベル部分にnullを指定することで、読み取った結果をトークンとして保持することなく読み捨てることを表すようにしています。&lt;/p&gt;

&lt;h3 id=&#34;正規表現パターンと文字列パターンの使い分け:33ced0e1bdc35ac00ed380cf2d7265fa&#34;&gt;正規表現パターンと文字列パターンの使い分け&lt;/h3&gt;

&lt;p&gt;(ごちゃごちゃ書いている割に小手先のテクニックという感じが強いため、よくわからなければ読み飛ばしてください)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{token:&amp;quot;PLUS&amp;quot;, pattern:&amp;quot;+&amp;quot;}&lt;/code&gt; のように、パターン部分に正規表現ではなく文字列を用いて記述している箇所があります。
すべて正規表現を使って記述するのではなく文字列も許容している理由として、まず&lt;code&gt;/\+/&lt;/code&gt;のように特殊記号をエスケープせずに済む点が挙げられます。
そして、「文字列でパターンを記述した場合は、アルファベットの途中でトークンを区切らないようにする」というルールを用いることで、一部のパターンを簡潔に書くことが可能になります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vwxyz&lt;/code&gt; という入力を考えてみましょう。
ここでもし、&lt;code&gt;&amp;quot;vwx&amp;quot;&lt;/code&gt; にマッチする規則と、&lt;code&gt;&amp;quot;vwxyz&amp;quot;&lt;/code&gt; にマッチする規則の2つが存在した場合、&lt;code&gt;&amp;quot;vwxyz&amp;quot;&lt;/code&gt; の規則を先に書かない限り、入力&lt;code&gt;vwxyz&lt;/code&gt; は&lt;code&gt;&amp;quot;vwx&amp;quot; + yz&lt;/code&gt; とみなされ、&lt;code&gt;&amp;quot;yz&amp;quot;&lt;/code&gt; に対応する規則が存在しなければエラーとなります。
これを回避するためには、よりマッチするパターンが長い規則を常に短い規則よりも先に書くようにする必要がありますが、面倒です。
そこで、正規表現ではなく文字列で&lt;code&gt;&amp;quot;vwx&amp;quot;&lt;/code&gt; などのパターンが定義され、かつその末尾の文字が&lt;code&gt;\w&lt;/code&gt; にマッチする場合、マッチした部分の一文字先の文字が&lt;code&gt;\w&lt;/code&gt; 以外でなければマッチしないようにします。
これは、正規表現で&lt;code&gt;/vwx(?!\w)/&lt;/code&gt; 、&lt;code&gt;/vwxyz(?!\w)/&lt;/code&gt; というような否定的前方先読みをパターンの最後に追加することに相当します。
このルールを追加することで、正規表現を用いる場合よりも簡潔に記述可能となります。&lt;/p&gt;

&lt;h2 id=&#34;字句解析器を実装する:33ced0e1bdc35ac00ed380cf2d7265fa&#34;&gt;字句解析器を実装する&lt;/h2&gt;

&lt;p&gt;ではLexerクラスを作っていきましょう。
とはいえ字句規則さえ定義してしまえば、やることはほとんどありません。
コンストラクタ引数として字句規則データを受け取って保持しておくようにして、解析実行時に上から順に字句規則のマッチングを試みるだけです。&lt;/p&gt;

&lt;p&gt;今回はコード量が少ないので、 &lt;a href=&#34;https://github.com/Tatamo/parsergenerator/blob/master/src/lexer.ts&#34;&gt;https://github.com/Tatamo/parsergenerator/blob/master/src/lexer.ts&lt;/a&gt; 全体をそのまま貼り付けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// token.ts
export type Token = string|symbol;
export const SYMBOL_EOF:Token = Symbol(&amp;quot;EOF&amp;quot;);
export const SYMBOL_SYNTAX:Token = Symbol(&amp;quot;S&#39;&amp;quot;);
export const SYMBOL_DOT:Token = Symbol(&amp;quot;.&amp;quot;);

export type TokenList = Array&amp;lt;{token:Token, value:string}&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// lexer.ts
/// LexDefinitionsの定義は先述のものと同一
import {Token, SYMBOL_EOF, TokenList} from &amp;quot;./token&amp;quot;;
import {LexDefinitions} from &amp;quot;./grammar&amp;quot;;

export interface ILexer{
	exec(str: string):TokenList;
}

export class Lexer implements ILexer{
	constructor(public def: LexDefinitions){
		// 正しいトークン定義が与えられているかチェック
		for(var i=0; i&amp;lt;this.def.length; i++){
			var token_pattern = this.def[i].pattern;
			if(typeof token_pattern == &amp;quot;string&amp;quot;){
				continue;
			}
			else if(token_pattern instanceof RegExp){
				// フラグを整形する
				let flags:string = &amp;quot;&amp;quot;;
				// gフラグは邪魔なので取り除く
				// i,m,uフラグがあれば維持する
				if(token_pattern.ignoreCase){
					flags += &amp;quot;i&amp;quot;;
				}
				if(token_pattern.multiline){
					flags += &amp;quot;m&amp;quot;;
				}
				if(token_pattern.unicode){
					flags += &amp;quot;u&amp;quot;;
				}
				// yフラグは必ずつける
				flags += &amp;quot;y&amp;quot;;
				// フラグをつけなおして新しい正規表現オブジェクトにする
				this.def[i].pattern = new RegExp(token_pattern, flags);
				continue;
			}
			throw new Error(&amp;quot;invalid token definition: neither string nor RegExp object&amp;quot;);
		}
	}
	exec(str: string):TokenList{
		var result:TokenList = [];
		let lastindex = 0;
		while(lastindex &amp;lt; str.length){
			for(var i=0; i&amp;lt;this.def.length; i++){
				var token:Token|null = this.def[i].token;
				var token_pattern = this.def[i].pattern;
				var match:string;
				if(typeof token_pattern == &amp;quot;string&amp;quot;){
					let last_tmp = lastindex+token_pattern.length;
					if(str.substring(lastindex,last_tmp) != token_pattern) continue;
					if(last_tmp &amp;lt; str.length &amp;amp;&amp;amp; /\w/.test(token_pattern.slice(-1)) &amp;amp;&amp;amp; /\w/.test(str[last_tmp])) continue; // ヒットした文字の末尾が\wで、そのすぐ後ろが\wの場合はスキップ
					match = token_pattern;
					lastindex += token_pattern.length;
				}
				else{
					// token_pattern: RegExp
					token_pattern.lastIndex = lastindex;
					let m = token_pattern.exec(str);
					if(m === null) continue; // マッチ失敗
					match = m[0];
					lastindex = token_pattern.lastIndex; // lastindexを進める
				}
				// tokenがnullなら処理を飛ばします
				if(token != null){
					result.push({token:token, value:match});
				}
				break;
			}
		}
		// 最後にEOFトークンを付与
		result.push({token:SYMBOL_EOF, value:&amp;quot;&amp;quot;});
		return result;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まずコンストラクタでは、与えられた字句規則に簡単な型チェックと正規表現の整形を行っています。
グローバルマッチは今回は邪魔なだけなので、与えられた正規表現にgフラグがついていれば取り除きます。
ES2015でRegExpに追加されたstickyフラグ(&lt;strong&gt;ほぼ&lt;/strong&gt;全ての主要モダンブラウザ上で実装済み)を使うと楽なので、ここでyフラグの追加も行います。&lt;/p&gt;

&lt;p&gt;execメソッドでは入力を読み終えるまでマッチングを繰り返し、&lt;code&gt;{token:Token, value:string}&lt;/code&gt; というオブジェクトを結果の配列に追加していきます。
先述のようにパターンが文字列であれば&lt;code&gt;\w&lt;/code&gt;が連続した場所では区切らないようにして、マッチングが成功するたびにインデックス位置を先に進めていきます。&lt;/p&gt;

&lt;p&gt;また、すべての入力を読み終えた後、最後にSymbol(EOF)を名前としたトークンを結果に追加します。
これは入力の末尾を意味するトークンで、構文解析の際に内部的に使用されます。&lt;/p&gt;

&lt;p&gt;(Symbolは、それ自身と比較しない限り&lt;code&gt;==&lt;/code&gt;や&lt;code&gt;===&lt;/code&gt;の評価結果が常にfalseになるプリミティブ型で、ES2015で追加されたものです。
字句規則で定義されたトークンとの衝突が発生しないようにここでSymbolを使用していますが、Symbolそのものはオブジェクトのプロパティとして使用することで後方互換性を維持することを目的としてJavaScriptに追加された型であるため、この用途で用いるのに適しているのかどうかは議論の余地があります。
とはいえプログラミング言語個別の問題はこの記事の主題とは関係がないため、詳しくは言及しません。)&lt;/p&gt;

&lt;p&gt;この字句解析器に先ほどの字句規則を与え、&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; を入力すると、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
	{token:&amp;quot;DIGITS&amp;quot;, value:&amp;quot;9&amp;quot;},
	{token:&amp;quot;PLUS&amp;quot;, value:&amp;quot;+&amp;quot;},
	{token:&amp;quot;DIGITS&amp;quot;, value:&amp;quot;11&amp;quot;},
	{token:&amp;quot;ASTERISK&amp;quot;, value:&amp;quot;*&amp;quot;},
	{token:&amp;quot;LPAREN&amp;quot;, value:&amp;quot;(&amp;quot;},
	{token:&amp;quot;DIGITS&amp;quot;, value:&amp;quot;2&amp;quot;},
	{token:&amp;quot;PLUS&amp;quot;, value:&amp;quot;+&amp;quot;},
	{token:&amp;quot;DIGITS&amp;quot;, value:&amp;quot;1&amp;quot;},
	{token:&amp;quot;RPAREN&amp;quot;, value:&amp;quot;)&amp;quot;},
	{token:Symbol(EOF), value:&amp;quot;&amp;quot;}
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という結果が得られます。
これでトークンの並びを得ることに成功したので、次回以降はいよいよパーサジェネレータの作成に移っていくことになります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/&#34;&gt;前回:かんたん構文解析入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://tatamo.81.la/blog/2017/03/21/lr-parser-generator-implementation-03/&#34;&gt;次回:儀式の下準備&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第1回:かんたん構文解析入門</title>
      <link>http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/</link>
      <pubDate>Thu, 22 Dec 2016 03:03:09 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/</guid>
      <description>
        

&lt;p&gt;この記事は&lt;a href=&#34;http://www.adventar.org/calendars/1881&#34;&gt;Kobe University Advent Calendar 2016&lt;/a&gt;の21日の記事です。また遅刻か。
なお私は当該大学の学部2年(2016年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;構文解析ができるプログラマはちょっとかっこいいですよね。
「構文解析？ああ、できますよ」とか言って自分のスキルを自慢できそうな印象があります。&lt;/p&gt;

&lt;p&gt;(ほぼ)フルスクラッチでTypeScriptによるLR(1)パーサジェネレータを実装した(ついでにLALR(1)パーサも作れる)ので、これを完成させるまでの流れを紹介していこうと思います。&lt;/p&gt;

&lt;p&gt;今回は構文解析自体の入門編となります。&lt;/p&gt;

&lt;p&gt;自作したパーサジェネレータは &lt;a href=&#34;https://github.com/Tatamo/parsergenerator&#34;&gt;https://github.com/Tatamo/parsergenerator&lt;/a&gt; にあります。&lt;br /&gt;
今のところパーサジェネレータ部分は完成、基本的な構文解析なら問題なくこなせるので構文規則や字句規則を外部から読み取って構文解析してパーサジェネレータに渡すような処理や、全体の見通しを良くするための設計の見直しやリファクタリング等を行っている段階です。
ドキュメント作ってなくてすみません。&lt;/p&gt;

&lt;h2 id=&#34;構文解析をしたい:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;構文解析をしたい&lt;/h2&gt;

&lt;p&gt;構文解析、時々見かけるフレーズです。
プログラマなら覚えておいて損はない技術……かどうかはわかりませんが、そういう類のスキルに(傍からは)見えます。&lt;br /&gt;
ぜひやりましょう。&lt;/p&gt;

&lt;p&gt;ひとまず、何をやりたいのかを明確にする必要があります。&lt;br /&gt;
この記事では、「入力として与えられるLR(1)文法に属する文法に従ったトークン列をパース(構文解析)することで、その構造を構文木として出力する」ことを目標とします。
何を言っているのかさっぱりわかりませんね、わからなくていいです。&lt;/p&gt;

&lt;p&gt;順を追って説明する必要がありますが、詳細は適宜省略します。
そのため、まずは今回主に参照した資料を列挙しておきます。&lt;/p&gt;

&lt;h2 id=&#34;参考資料一覧:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;参考資料一覧&lt;/h2&gt;

&lt;p&gt;より詳しく知りたい方は、下記に挙げる資料やそこで紹介されている参考文献などを参照されるのが良いと思われます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.cornell.edu/courses/cs412/2003sp/lectures/lec09.pdf&#34;&gt;Cornell CIS Introduction to Compilers Lecture 9: LR(1) Parsing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jaist.ac.jp/~kshirai/lec/i223/04a.pdf&#34;&gt;JAIST 自然言語処理論Ｉ 4.文法2(構文解析) その1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jaist.ac.jp/~kshirai/lec/i223/04b.pdf&#34;&gt;JAIST 自然言語処理論Ｉ 4.文法2(構文解析) その2&lt;/a&gt;
(注：「LR法による構文解析」として紹介されているアルゴリズムはSLR法)&lt;br /&gt;
上記3つはネット上にアップロードされている特定の大学の講義資料ですが、公開の規定等を確認していないためリンクを張ることに不都合があるようなら知らせていただけると助かります。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Canonical_LR_parser&#34;&gt;Canonical LR parser - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/ichikaz3/lr-parsing&#34;&gt;LR parsing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kimiyuki.net/blog/2016/08/03/context-free-grammar/&#34;&gt;文脈自由文法とその構文解析法 &amp;middot; うさぎ小屋&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/uhyo_&#34;&gt;うひょ(@uhyo_)さん&lt;/a&gt; 生き字引。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;構文解析とは-ざっくり:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;構文解析とは？(ざっくり)&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; という数式を考えてみます。
構文解析をすることによる最終的な目的は、この数式を(たとえば)文字列として与えると、結果としてこの数式の答えが&lt;code&gt;42&lt;/code&gt;であることを導く、といったことです。&lt;/p&gt;

&lt;p&gt;そのためには、以下のものが必要になります：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数式を表現する構文規則&lt;/li&gt;
&lt;li&gt;上記構文規則を解析するように作られた構文解析器(Parser)&lt;/li&gt;
&lt;li&gt;解析された構文を処理するプログラム&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さらに、これらの構文解析に入る前の下準備のために以下が必要です：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;文字列をトークンとして分割して表現するための字句規則&lt;/li&gt;
&lt;li&gt;上記字句規則をもとに、文字列を読み取ってトークンを返す字句解析器(Lexical Analyzer、略してLexer)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ちなみに、今回の記事の目標は、それらに加えて以下のものを実装することです：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;構文規則および字句規則を入力として与えることで、構文解析器そのものを自動生成するパーサジェネレータ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;実際の構文解析を行う手順とはずれてしまいますが、紹介した順番に沿って構文解析器→字句解析器の順に解説していきます。&lt;/p&gt;

&lt;h3 id=&#34;構文解析器-パーサ:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;構文解析器(パーサ)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; という数式を解析するためには、まずこの数式がどのようなルールで記述されているのかを(再)定義する必要があります。
そのルールをを表すのが構文規則です。
構文規則を書き表すルールは、たとえば&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%90%E3%83%83%E3%82%AB%E3%82%B9%E3%83%BB%E3%83%8A%E3%82%A6%E3%82%A2%E8%A8%98%E6%B3%95&#34;&gt;BNF&lt;/a&gt;など様々な種類がありますが、基本的な発想としては&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S -&amp;gt; X Y Z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように左辺の記号を右辺の記号の並びによって定義することで行います。&lt;/p&gt;

&lt;p&gt;具体的に見てみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;式 -&amp;gt; 式 &amp;quot;+&amp;quot; 項
式 -&amp;gt; 項
項 -&amp;gt; 項 &amp;quot;*&amp;quot; 因子
項 -&amp;gt; 因子
因子 -&amp;gt; 数
因子 -&amp;gt; &amp;quot;(&amp;quot; 式 &amp;quot;)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;妥当ですね。
&lt;code&gt;式 -&amp;gt; 式 + 項&lt;/code&gt; と &lt;code&gt;式 -&amp;gt; 項&lt;/code&gt;の２つの規則が、再帰的な繰り返しを表現していることに注意してください。
たとえば、&lt;code&gt;項&lt;/code&gt;は当然&lt;code&gt;式&lt;/code&gt;ですし、&lt;code&gt;項 + 項&lt;/code&gt;も&lt;code&gt;式(-&amp;gt;項) + 項&lt;/code&gt; より&lt;code&gt;式&lt;/code&gt;となります。
さらに、&lt;code&gt;項 + 項 + 項&lt;/code&gt;は最初の&lt;code&gt;項 + 項&lt;/code&gt;が&lt;code&gt;式&lt;/code&gt;なので、&lt;code&gt;式(-&amp;gt;項 + 項) + 項&lt;/code&gt; より&lt;code&gt;式&lt;/code&gt;です。
よって、&lt;code&gt;式&lt;/code&gt;は&lt;code&gt;項&lt;/code&gt;を&lt;code&gt;&amp;quot;+&amp;quot;&lt;/code&gt;によって任意の回数だけ繋げたものであり、同様に&lt;code&gt;項&lt;/code&gt;は&lt;code&gt;因子&lt;/code&gt;を&lt;code&gt;&amp;quot;*&amp;quot;&lt;/code&gt;で繋げたものとなります。
最後に、&lt;code&gt;因子&lt;/code&gt;は単なる&lt;code&gt;数&lt;/code&gt;かもしれませんし、または&lt;code&gt;&amp;quot;(&amp;quot;&lt;/code&gt;と&lt;code&gt;&amp;quot;)&amp;quot;&lt;/code&gt;で囲まれた&lt;code&gt;式&lt;/code&gt;かもしれません。
これは括弧で囲まれた部分の式が他の部分よりも高い優先順位となることを表現しています。&lt;/p&gt;

&lt;p&gt;たとえば&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt;は、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;式{ [9] [+] [11 * (2 + 1)] }
式{ 項{ [9] } &amp;quot;+&amp;quot; 項{ [11] [*] [(2 + 1)] } }
式{ 項{ 因子{9} } &amp;quot;+&amp;quot; 項{ 因子{11} &amp;quot;*&amp;quot; 因子{ [(] [2 + 1] [)] } } }
式{ 項{ 因子{9} } &amp;quot;+&amp;quot; 項{ 因子{11} &amp;quot;*&amp;quot; 因子{ &amp;quot;(&amp;quot; 式{ [2] [+] [1] } &amp;quot;)&amp;quot; } } }
式{ 項{ 因子{9} } &amp;quot;+&amp;quot; 項{ 因子{11} &amp;quot;*&amp;quot; 因子{ &amp;quot;(&amp;quot; 式{ 項{ [2] } &amp;quot;+&amp;quot; 項{ [1] } } &amp;quot;)&amp;quot; } } }
式{ 項{ 因子{9} } &amp;quot;+&amp;quot; 項{ 因子{11} &amp;quot;*&amp;quot; 因子{ &amp;quot;(&amp;quot; 式{ 項{ 因子{2} } &amp;quot;+&amp;quot; 項{ 因子{1} } } &amp;quot;)&amp;quot; } } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように展開されます(こうして得られた構造をどう解析するかについては省略します)。この、解析対象→構文木の変換を自動で行うのがパーサです。&lt;/p&gt;

&lt;p&gt;ちなみにですが、この構文規則は解析したい対象ごとにあなたが一から書き上げる必要があります。&lt;/p&gt;

&lt;h3 id=&#34;字句解析器-レキシカルアナライザ:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;字句解析器(レキシカルアナライザ)&lt;/h3&gt;

&lt;p&gt;上記構文規則では、&lt;code&gt;+&lt;/code&gt;や&lt;code&gt;*&lt;/code&gt;のような演算子、&lt;code&gt;数&lt;/code&gt;についての規定はありません。
これらの「左辺に現れない記号」を、「終端記号」と呼びます。左辺に現れる記号は非終端記号と呼ばれます。&lt;/p&gt;

&lt;p&gt;通常、&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; のような入力は文字列で与えられますが、記号と記号の間には複数もしくは0個の空白が挿入されている可能性もあります。
しかし以下のような構文規則を定義するのは本質的ではありません：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;空白 -&amp;gt; &amp;quot; &amp;quot;
空白 -&amp;gt; &amp;quot; &amp;quot; 空白
数字 -&amp;gt; &amp;quot;0&amp;quot; | &amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | ... | &amp;quot;9&amp;quot;
数字 -&amp;gt; (&amp;quot;0&amp;quot; | &amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | ... | &amp;quot;9&amp;quot;) 数字
数 -&amp;gt; (&amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | &amp;quot;3&amp;quot; ... | &amp;quot;9&amp;quot;) 数字
ただし、|は「または」を表す
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そこで、通常は「入力として与えられた文字列」を「終端記号として分類されたトークンの列」に変換する処理をはさみ、これによって得られたトークンを構文解析器に与えます。
トークンとは終端記号と、必要ならばそれに紐付いた元々の情報を保持しておいたものです。たとえば、&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt;は、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;数字: 9
プラス: +
数字: 11
アステリスク: *
左括弧: (
数字: 2
プラス: +
数字: 1
右括弧: )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような9つのトークンの列に分けることができます。
構文解析器はそのトークンがどのような終端記号に対応しているかは見ますが、たとえば個々の数字が何であるかを判断することはしません。
これによって、構文解析器は本質的な文法の解析のみに注力することができます。&lt;/p&gt;

&lt;p&gt;この処理をするのが字句解析器で、どのような文字や文字列が与えられた場合に何という終端記号かを判別するための規則が字句規則です。&lt;/p&gt;

&lt;p&gt;字句規則は、例えば以下のような書き方になるでしょう：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;数字: /[1-9][0-9]*/
プラス: &amp;quot;+&amp;quot;
アステリスク: &amp;quot;*&amp;quot;
左括弧: &amp;quot;(&amp;quot;
右括弧: &amp;quot;)&amp;quot;
(読み捨て): /\s/
(不正): /./
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでは字句規則の表現のために、文字列および正規表現を使用しています。
通常(?)字句規則は上から順に文字列の先頭部分を当てはめていき、マッチするものがあればその終端記号に対応付けます。
そのため、&lt;code&gt;(不正)&lt;/code&gt;の部分は入力された文字全てにマッチする正規表現&lt;code&gt;/./&lt;/code&gt;が使用されていますが、これは上の規則のいずれにも当てはまらなかった場合にのみマッチします。&lt;/p&gt;

&lt;p&gt;与えられた文字列を前から順番に見ていくだけなので、字句解析器の実装はパーサやパーサジェネレータの実装と比べると単純です。&lt;/p&gt;

&lt;h3 id=&#34;パーサジェネレータ:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;パーサジェネレータ&lt;/h3&gt;

&lt;p&gt;ここまで構文解析器(パーサ)と字句解析器(レキシカルアナライザ)について見てきました。
基本的にはこの2つによって構文解析を行うことができ、基本的な流れとしては&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;入力となるような解析したい言語を用意する&lt;/li&gt;
&lt;li&gt;字句規則を用意して、それをもとにしたレキシカルアナライザを用意する&lt;/li&gt;
&lt;li&gt;レキシカルアナライザに入力を与え、トークンの列を取得する&lt;/li&gt;
&lt;li&gt;構文規則を用意して、それをもとにしたパーサを用意する&lt;/li&gt;
&lt;li&gt;パーサにトークンの列を与え、解析結果を得る&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となります。
パーサジェネレータとは何かというと、この 4. の部分を自動化するものです。
(LR法の)構文解析器は、内部的には入力を受け取ってスタックに積みながら状態遷移を繰り返すオートマトンにすぎません。
そのため、どの入力が与えられればどのような状態に遷移するかを示す「構文解析表」を得ることができれば、その構文を解析するパーサを作成することができます。
パーサジェネレータは、構文規則を読み取ることでこの構文解析表をつくり上げるという処理を主に行います。&lt;/p&gt;

&lt;p&gt;字句解析器程度ならわざわざジェネレータを作らなくても、字句規則そのものを字句解析器に渡せば良い感じに字句解析してくれるようにできますが、パーサジェネレータも「構文解析表の構築後、それをもとにして構文解析を行う」ような機能がついていればそれはパーサであるとも言えます。
わざわざパーサとパーサジェネレータが分けられているのは、一つには計算資源の乏しかった昔はパーサジェネレータがオンメモリで展開した構文解析表をもとにそのままパーサとして振る舞うというようなことが少なく、構文解析表を与えることで「パーサのソースコード」を出力するようなものが一般的だったからではないかと思われます(適当な思いつきを言っています)。
もっとも、パーサジェネレータがパーサを生成する際の処理にかかる時間を省略したい場合、予めパーサをコンパイルしておけるようにするのは妥当といえるでしょう。
字句解析器のための「字句解析器ジェネレータ」も実際に存在していますが、ここでは簡単のために字句解析器はコンストラクタに字句規則を与えれば勝手に良い感じの字句解析を行ってくれるようになるものと思ってもらえればよいです。&lt;/p&gt;

&lt;h3 id=&#34;文脈自由言語について:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;文脈自由言語について&lt;/h3&gt;

&lt;p&gt;構文解析器が解析対象とする「言語」がどのようなものであるかについてはいろいろな定義がなされています。&lt;/p&gt;

&lt;p&gt;これについては、参考資料でも紹介した&lt;a href=&#34;https://twitter.com/ki6o4&#34;&gt;うさぎさん(@ki6o4)&lt;/a&gt;の&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kimiyuki.net/blog/2016/08/03/context-free-grammar/&#34;&gt;文脈自由文法とその構文解析法 &amp;middot; うさぎ小屋&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が詳しいため、こちらを参照していただくことをおすすめします。
ここでは、厳密な話はあまりせずにごくごく簡単に触れていこうと思います。&lt;/p&gt;

&lt;p&gt;構文解析の対象とするのは、基本的に文脈自由言語となります。
構文解析の手法にも様々なものがありますが、それらの手法の中には文脈自由言語すべてを解析できるわけではないものも多く、たとえばLR(1)法ならLR(1)文法やLR(1)言語というように、ある手法で解析できる文法や、解析できる言語全体をその手法の名前で表される言語として表現することがあります。&lt;/p&gt;

&lt;h3 id=&#34;解析手法と言語のクラス:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;解析手法と言語のクラス&lt;/h3&gt;

&lt;p&gt;いくつかの手法を主観を交えて乱暴に紹介していきます。&lt;/p&gt;

&lt;h4 id=&#34;先読み:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;先読み&lt;/h4&gt;

&lt;p&gt;**この項は下のLR法などの項を「先読み」してから戻ってきて読むことをおすすめします**&lt;/p&gt;

&lt;p&gt;たとえばLR(1)法のように、数字を括弧でくくって(k)と表現している手法がいくつかあります。このkは何文字先読みするかを示していて、たとえば(1)ならば1文字先読みするという意味です。
先読み数については、たとえばLR法については以下のようなことが言われています。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;LR(k)で表せる文法のクラス ⊆ LR(k+1)先読みで表せるクラス である&lt;/li&gt;
&lt;li&gt;LR(k)文法によって受理可能な言語のクラスは、LR(1)のそれと等しい&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.より、基本的には(1)について考えることが多いようです。&lt;/p&gt;

&lt;h4 id=&#34;ll-1-法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;LL(1)法&lt;/h4&gt;

&lt;p&gt;「再帰を使って構文解析する」という発想としては単純なもの。
LL(1)文法のクラスはLR(1)よりも大幅に小さいものの、それでもLALR(1)文法を外れた文法を解析できたりします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S -&amp;gt; S + E
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような、右辺の一番左の場所に左辺の記号が登場するような「左再帰則」を読むことができません。ナンセンス。&lt;/p&gt;

&lt;h4 id=&#34;lr-0-法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;LR(0)法&lt;/h4&gt;

&lt;p&gt;先読み数が0なのでよわい。&lt;/p&gt;

&lt;h4 id=&#34;slr法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;SLR法&lt;/h4&gt;

&lt;p&gt;SLRのSはSimpleの意味です。LR(0)から単純な先読みを加えることでLR(0)よりも解析可能な文法が増えますが、それでもLALR(1)には及びません。&lt;/p&gt;

&lt;h4 id=&#34;lr-1-法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;LR(1)法&lt;/h4&gt;

&lt;p&gt;LR(0)に対し、1文字だけ先読みして次にどのような入力が期待されるかを判断。
LR(1)文法がそれなりに広いという点で優秀な一方、LR(0)に比べて構文解析表の大きさが爆発しやすいという欠点がある、と言われています。
しかし今の時代はそんなものは大した欠点になり得ない気がします。&lt;/p&gt;

&lt;h4 id=&#34;lalr-1-法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;LALR(1)法&lt;/h4&gt;

&lt;p&gt;プログラミング言語を解析するコンパイラなどによく使われている手法です。
LALR(1)のLAはLook-Aheadの略で、まずLR(1)法で構文解析表を作ってから、文法部分が同じで先読み記号だけが違うような状態をマージするという点がLR(1)法と異なります。
表を併合してしまうためにLR(1)法よりも解析可能な文法のクラスが小さくなるものの、実用上はほとんど問題にならず、LR(1)法の構文解析表が大きくなりすぎるという欠点を補える手法です。&lt;/p&gt;

&lt;p&gt;ただし、一度LR(1)法の表を作ること変わりはないのでメモリ消費量はそう変わらないし、大きなデータも問題なく扱える今の時代にわざわざ構文解析表を数十パーセント程度削減したところで何の意味があるのかという疑問があります。&lt;/p&gt;

&lt;p&gt;また、LALR法のLAはLook-Aheadの略だと言いましたが、注意しなければならないのは&lt;strong&gt;Look-Ahead(先読み)を行うのはLALR法固有の手法ではない&lt;/strong&gt;ということです。  先読み自体はLR(1)法でもやりますし、LALR(1)はあくまでLR(1)の先読み部分をマージしたものにすぎません。
私はLALR法の名前の付け方はあまり良くないと思っていて、MLR法(Merged Look-Ahead LR法)とかなんとか、そういう感じの名前に変えたほうが良いと思います。&lt;/p&gt;

&lt;h4 id=&#34;glr法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;GLR法&lt;/h4&gt;

&lt;p&gt;「あいまいな」解釈が可能な文法があった場合、考えられうるすべての可能性を探索してしまうことによって解決する手法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;「お魚くわえた猫を追いかけるサザエさん」&lt;/code&gt;で魚をくわえているのが猫とサザエさんの両方に解釈できるように、一つの入力に対して複数の結果が得られることがあります。
どちらかというと自然言語処理向きかもしれません。&lt;/p&gt;

&lt;h4 id=&#34;cyk法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;CYK法&lt;/h4&gt;

&lt;p&gt;強力なアルゴリズムにより、文脈自由言語すべてを比較的高速に解析可能。
ただし、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;S -&amp;gt; NP VP
VP -&amp;gt; v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように、チョムスキー標準形といわれるような、「右辺が非終端記号ちょうど2つか終端記号1つでなければならない」、つまり結果として得られる構造が二分木になっていなければならないというナンセンスにも程がある制約を課されます(アルゴリズムの改良や規則の変換、得られた木構造の後処理などによって回避は可能ですが)。&lt;/p&gt;

&lt;p&gt;このCYK法の計算量オーダーは&lt;code&gt;O(n^3)&lt;/code&gt;程度で、文脈自由言語全てを解析可能なアルゴリズムの中では高速ですが、この記事で紹介されている他のアルゴリズムよりは低速となります。
たとえばLR(1)法は文脈自由言語全体を解析出来ないかわりに&lt;code&gt;O(n)&lt;/code&gt;で解析が可能です。&lt;/p&gt;

&lt;p&gt;プログラミング言語の解析では、言語の開発者が文法自体をある程度自由に定義することができるため、文脈自由言語の一部だけでなく全体を解析したいという需要はあまり発生しません。&lt;/p&gt;

&lt;h2 id=&#34;lr-1-パーサジェネレータをつくろう:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;LR(1)パーサジェネレータをつくろう&lt;/h2&gt;

&lt;p&gt;構文解析の大まかな流れはわかりました。
とりあえず字句規則と構文規則を用意して、あとはどうにかしてこの構文を読んでくれるようなパーサを用意すれば構文解析ができそうです(字句解析器なんてのは適当にやってもすぐ用意できます)。&lt;/p&gt;

&lt;p&gt;先ほど紹介したような手法によって構文ごとに一からパーサをプログラミングするようなことはやりたくないので、パーサジェネレータを用いてパーサを自動的に生成してもらえば事は済みそうですね。&lt;/p&gt;

&lt;p&gt;ここに&lt;a href=&#34;https://www.gnu.org/software/bison/&#34;&gt;Bison&lt;/a&gt;という有名なパーサジェネレータがあります。
今の時代にわざわざCやC++で構文解析なんてしたくないのでしたら、Pythonで&lt;a href=&#34;http://www.dabeaz.com/ply/&#34;&gt;PLY&lt;/a&gt;とか、JavaScriptの&lt;a href=&#34;https://github.com/zaach/jison&#34;&gt;jison&lt;/a&gt;というものなど、いくらでも選択肢があります。
これらのうち一つを選んで、チュートリアルを読んでパーサを作っていくのがいいでしょう。&lt;/p&gt;

&lt;p&gt;というわけで、前段を書いていると結構分量が膨らんでしまったため、今回はここで区切ります。&lt;/p&gt;

&lt;p&gt;では次回からは、構文解析を行えるようになるため、LR(1)法を用いたパーサジェネレータを実際に作っていく流れを紹介していきたいと思います。&lt;/p&gt;

&lt;p&gt;えっちょっとまって、今パーサジェネレータは既存のものを使えばいいって言ったよね、ねえ&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2017/02/11/lr-parser-generator-implementation-02/&#34;&gt;次回:字句解析器の実装&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Javaのリフレクションを悪用してクラス設計してみる</title>
      <link>http://tatamo.81.la/blog/2016/12/15/java-generics-and-reflection/</link>
      <pubDate>Thu, 15 Dec 2016 01:11:23 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/12/15/java-generics-and-reflection/</guid>
      <description>
        

&lt;p&gt;この記事は&lt;a href=&#34;http://www.adventar.org/calendars/1881&#34;&gt;Kobe University Advent Calendar 2016&lt;/a&gt;の14日の記事です。遅刻です。
なお私は当該大学の学部2年(2016年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最近、大学の授業などで少しだけJavaに触れる機会があったので、ちょっとした黒魔術っぽいことでもやってみようと思います。&lt;/p&gt;

&lt;p&gt;と思ったのですが、記事を書こうとして調べていたら普通に書きたかったことをわかりやすく書いている記事がありました。&lt;br /&gt;
* &lt;a href=&#34;http://d.hatena.ne.jp/Nagise/20131121/1385046248&#34;&gt;new T()したいケースへの対処法 - プログラマーの脳みそ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;もう帰っていいですかね。&lt;/p&gt;

&lt;h2 id=&#34;総称型tに対してt-classやnew-t-したい:c600ddb79433125511402a932eb728b1&#34;&gt;総称型Tに対してT.classやnew T()したい&lt;/h2&gt;

&lt;h3 id=&#34;ジェネリクスとは:c600ddb79433125511402a932eb728b1&#34;&gt;ジェネリクスとは&lt;/h3&gt;

&lt;p&gt;わざわざ書くまでもないとは思いますが、ジェネリクスについておさらいをしておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ArrayList&amp;lt;String&amp;gt; strlist = new ArrayList&amp;lt;String&amp;gt;();
ArrayList&amp;lt;Integer&amp;gt; intlist = new ArrayList&amp;lt;Integer&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ArrayList&lt;T&gt;に対し、ジェネリクスとしてStringやIntegerなど、リストの要素として入れたい型をTの部分に具体的に書くことで、一つのクラスであるArrayListに利用者側が好きな要素を入れることができるようになります。&lt;/p&gt;

&lt;p&gt;ジェネリクスを用いて自分でメソッドを定義する場合は、以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;T&amp;gt; void doSomething(T arg){
	// doSomething
}

// TをSomeClassのサブクラスに限定する
public &amp;lt;T extends SomeClass&amp;gt; void notDoAnything(T arg){
	return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらのメソッドを呼び出すときは、&lt;code&gt;hoge.&amp;lt;SomeClass&amp;gt;doSomething();&lt;/code&gt;のようになります。&lt;br /&gt;
どうして&lt;code&gt;hoge.doSomething&amp;lt;SomeClass&amp;gt;();&lt;/code&gt;じゃないんだろう。&lt;/p&gt;

&lt;h3 id=&#34;ジェネリクスはt-classやnew-t-をさせてくれない:c600ddb79433125511402a932eb728b1&#34;&gt;ジェネリクスはT.classやnew T()をさせてくれない&lt;/h3&gt;

&lt;p&gt;Javaのジェネリクスでは、以下のコードはコンパイルエラーとなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;T extends SomeClass&amp;gt; List&amp;lt;T&amp;gt; getSubClassList(List&amp;lt;SomeClass&amp;gt; list){
	return list
		.stream()
		.filter(value -&amp;gt; value instanceof T) // ここでlistの要素valueがTのインスタンスかどうか判別したい -&amp;gt; error
		.collect(Collectors.toList());
}

public &amp;lt;T extends SomeClass&amp;gt; List&amp;lt;T&amp;gt; getSubClassList2(List&amp;lt;SomeClass&amp;gt; list){
	return list
		.stream()
		.filter(value -&amp;gt; value.getClass() == T.class) // instanceofがだめならclassを取得して判別したい -&amp;gt; error
		.collect(Collectors.toList());
}

public &amp;lt;T&amp;gt; void doSomething(String arg){
	T foo = new T(arg); // T型の新しいインスタンスfooを作りたい -&amp;gt; error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ジェネリクス型に対して、hoge instanceof T、T.class、new T()といった操作を行うことはできません。
残念でしたね。&lt;/p&gt;

&lt;h2 id=&#34;なぜしたいのか:c600ddb79433125511402a932eb728b1&#34;&gt;なぜしたいのか&lt;/h2&gt;

&lt;h3 id=&#34;もしかして-設計が間違っている:c600ddb79433125511402a932eb728b1&#34;&gt;もしかして： 設計が間違っている&lt;/h3&gt;

&lt;p&gt;先ほどのgetSubClassListメソッドを見てみましょう。
正しく動くかどうかはさておき、やりたいことは以下の通りです：&lt;br /&gt;
* SomeClassとそのサブクラスを含んだリストlistの要素のうち、SomeClassのサブクラスTのインスタンスだけを要素とする新しいリストを取得したい。&lt;/p&gt;

&lt;p&gt;そもそも、抽象化された集合から具体的なクラスのインスタンスを取り出そうとすること自体がオブジェクト指向やポリモーフィズムの考え方に対する反逆である可能性があります。&lt;/p&gt;

&lt;p&gt;SomeClassのリストであるlistをイテレートして、それぞれの要素のdoSomething()メソッドを呼べば、あとはそれがSomeClassのインスタンスであろうと、もしくはSomeClassを継承した別のクラスのインスタンスであろうと、外部からはただdoSomething()メソッドを呼ぶだけで操作が完結していなければなりません。
それがサブクラス固有のふるまいをするとしても、その実装はそのクラス自身に隠蔽されるべきなのです。&lt;/p&gt;

&lt;p&gt;よって、サブクラスだけを取り出そうとする試み自体がナンセンスなものである可能性が非常に高く、まずそのような試みが必要になる設計そのものを見直す必要があります。&lt;/p&gt;

&lt;p&gt;終わり。&lt;/p&gt;

&lt;h3 id=&#34;そうも言っていられない:c600ddb79433125511402a932eb728b1&#34;&gt;そうも言っていられない&lt;/h3&gt;

&lt;p&gt;実際その通りなのですが、それではこの記事が続きません。&lt;/p&gt;

&lt;p&gt;ここからは、少し具体的なプログラムの設計を例にとって考えてみたいと思います。&lt;br /&gt;
あなたはちょっとしたゲームを作るためのフレームワークを作っています。
その一部分が以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 抽象的なゲーム内エンティティクラス
public abstract class Entity {
	private int x;
	private int y;
	public Entity(int x, int y){
		this.setX(x);
		this.setY(y);
	}
	public int getX() { return x; }
	public void setX(int x) { this.x = x; }
	public int getY() { return y; }
	public void setY(int y) { this.y = y; }

	public abstract void update(EntityManager manager);
}

// なんでもかんでも××Managerという名前を付けるのはやめましょう
public class EntityManager {
	private ArrayList&amp;lt;Entity&amp;gt; all_entities;
	public EntityManager(){
		this.all_entities = new ArrayList&amp;lt;Entity&amp;gt;();
	}
	public void add(Entity e){
		this.all_entities.add(e);
	}
	public ArrayList&amp;lt;Entity&amp;gt; getAll() {
		return new ArrayList&amp;lt;Entity&amp;gt;(this.all_entities);
	}
	public void updateAll(){
		this.all_entities.forEach(e-&amp;gt;e.update(this));
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なんのことはありませんね。
ゲーム内に登場するエンティティを表す抽象クラスEntityを作り、それをEntityManagerで管理します(なんでもかんでも××Managerという名前を付けるのはManagerクラスの肥大化を招きかねないため避けるべきであるなどという話もありますが、今回は置いておきます)。
たとえば毎フレームごとにメインループ内で&lt;code&gt;EntityManager#updateAll()&lt;/code&gt;を呼び出すことで、全てのエンティティの更新を行ったりすることが想定されます。
オーソドックスなループ駆動型のゲームプログラム設計です。&lt;br /&gt;
Entityインスタンスを作成するためのFactory Methodパターンを使うべきとか、そういう話もあっちでやってください。&lt;/p&gt;

&lt;p&gt;あとは、このフレームワークの利用者にはEntityクラスを継承したクラスを作らせ、それをもとにゲームを作ってもらえればいいだけです。
以下のクラスを追加してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// あなたです
public class Player extends Entity{
	private int hp; // プレイヤーはヒットポイントを持ちます
	public Player(int x, int y, int hp){
		super(x, y);
		this.setHp(hp);
	}
	public int getHp() { return hp; }
	public void setHp(int hp) { this.hp = hp; }
	@Override
	public void update(EntityManager manager){
		// プレイヤーが動きます
	}
}

// 敵です
public class Enemy extends Entity {
	private int damage; // 敵がプレイヤーに与えることのできるダメージ値です
	public Enemy(int x, int y, int damage){
		super(x, y);
		this.setDamage(damage);
	}
	public int getDamage() { return damage; }
	public void setDamage(int damage) { this.damage = damage; }
	@Override
	public void update() {
		// 敵が動きます
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プレイヤーと敵を登場させました。
常命の者であるプレイヤーにはヒットポイントが定められており、敵はこれを脅かすダメージ値を持っています。&lt;/p&gt;

&lt;p&gt;注意しておく必要があるのは、これらのクラスはあくまでフレームワークの利用者が作るものだということです。
よって、EntityクラスやEntityManagerクラスからはこのようなEntityサブクラスの存在を知ることはできません。&lt;br /&gt;
知る必要もないというのがオブジェクト指向の考え方だったはずです。
そうですよね？&lt;/p&gt;

&lt;p&gt;ここで、「敵のダメージ値を参照して、プレイヤーのヒットポイントを減らす」処理をしたいという需要が当然生まれます。
実装の方法はいろいろあると思いますが、ひとまずこの処理を、Enemyのメソッドとして書いてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 敵です
public class Enemy extends Entity {
	private int damage; // 敵がプレイヤーに与えることのできるダメージ値です
	public Enemy(int x, int y, int damage){
		super(x, y);
		this.setDamage(damage);
	}
	public int getDamage() { return damage; }
	public void setDamage(int damage) { this.damage = damage; }
	@Override
	public void update(EntityManager manager) {
		// 敵が動きます
		// プレイヤーがいたらダメージを与えます
		manager.getAll().forEach((entity)-&amp;gt;{ // 全てのエンティティを調べる
			if(entity instanceof Player){ //  エンティティがプレイヤーなら
				if(this.getX() == entity.getX() &amp;amp;&amp;amp; this.getY() == entity.getY()){ // プレイヤーと敵の座標が同じなら
					this.doDamage((Player) entity); // ダメージを与える
				}
			}
		});
	}
	public void doDamage(Player p){
		p.setHp(p.getHp() - this.getDamage()); // プレイヤーのヒットポイントをダメージ値分だけ減らします
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここであなたは気を利かせます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;manager.getAll().forEach((entity)-&amp;gt;{
	if(entity instanceof Player){
		if(...){
			...
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この部分です、どう見ても冗長ですし、いちいち全エンティティのリストをforEachで回しているので高速化も望めませんし、同様のコードクローンが至る所に発生するのは目に見えています。&lt;/p&gt;

&lt;p&gt;できるならたとえばこう書きたい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;manager.&amp;lt;Player&amp;gt;getAllOfSubClass().forEach((player)-&amp;gt;{
	if(...){
		...
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでPlayerクラスだけが得られるなら、呼び出し側のコード量は減りますし、もしあなたがO(n^2)の処理をO(nlogn)に落とすような作業に慣れているなら、Managerクラスの内側でより高速になるような最適化を行い、その実装も内部に隠蔽することができます。&lt;/p&gt;

&lt;p&gt;また、ゲームのセーブとロードをするときのことも考えてみます。
たとえばデータのセーブを行うときはとりあえずオブジェクトを文字列化するとして、&lt;br /&gt;
&lt;code&gt;public String Entity#serialize()&lt;/code&gt;などといったメソッドを作ってセーブし、ロード時には文字列配列を引数として受け取るようオーバーロードされたコンストラクタを使用してオブジェクトを再生成するといったことが考えられます。
そういうことはFactory Methodあたりに委譲するべきな気もしますし、うまくやらないとフレームワークの利用者側の負担が増える気もしますが、今は置いておきます。&lt;/p&gt;

&lt;p&gt;結局、セーブデータのロード時にこのようなコードを書くことになるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public &amp;lt;E extends Entity&amp;gt; E createEntity(List&amp;lt;String&amp;gt; args){ // 可変長引数としてもよい
		return new E(args); // ジェネリクス型はnewできない -&amp;gt; error
	}
	public loadSaveData(SaveData savedata){
		// セーブデータから1行ずつ読み込んでオブジェクトを再生成する
		... {
			entityManager.add(this.createEntity(agrs));
		}
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかしジェネリクス型はnewできないため、コンパイルエラーとなります。&lt;/p&gt;

&lt;h2 id=&#34;解決策:c600ddb79433125511402a932eb728b1&#34;&gt;解決策&lt;/h2&gt;

&lt;p&gt;さて、だいぶん勿体つけたが、解決編に入ろう。&lt;/p&gt;

&lt;p&gt;……というか、例として取り上げた題材が無理やりすぎた気がしてやる気が尽きかけてきました。&lt;/p&gt;

&lt;h3 id=&#34;リフレクションを使用する:c600ddb79433125511402a932eb728b1&#34;&gt;リフレクションを使用する&lt;/h3&gt;

&lt;p&gt;Javaにはリフレクションという機能があり、プログラムの実行中にクラス名やメソッド名を動的に取り扱うことができます。
これのClass&lt;T&gt;型を、ジェネリクスと併用しましょう。
&lt;code&gt;EntityManager#getAllOfSubClass&lt;/code&gt;メソッドを考えてみます。
実装は以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	@SuppressWarnings(&amp;quot;unchecked&amp;quot;)
	public &amp;lt;E extends Entity&amp;gt; List&amp;lt;E&amp;gt; getAllOfSubClass(Class&amp;lt;E&amp;gt; cls){
		return (List&amp;lt;E&amp;gt;) all_entities.stream()
			.filter(entity -&amp;gt; entity.getClass() == cls)
			.collect(Collectors.toList());
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを呼び出す際は、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;entityManager.getAllOfSubClass(Player.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにして、Class型の&lt;code&gt;クラス名.class&lt;/code&gt;を引数として与えます。
ここで型推論が働くので、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;entityManager.&amp;lt;Player&amp;gt;getAllOfSubClass(Player.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにPlayerクラス名を2度も書く必要はありません。&lt;/p&gt;

&lt;p&gt;また、Playerクラスだけでなく、Playerクラスを継承したクラスも含めて判別したいときは、以下のようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	@SuppressWarnings(&amp;quot;unchecked&amp;quot;)
	public &amp;lt;E extends Entity&amp;gt; List&amp;lt;E&amp;gt; getAllOfSubClass(Class&amp;lt;E&amp;gt; cls){
		return (List&amp;lt;E&amp;gt;) all_entities.stream()
			.filter(entity -&amp;gt; cls.isAssignableFrom(entity.getClass()))
			.collect(Collectors.toList());
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;createEntity&lt;/code&gt;メソッドも、以下のようにすれば書くことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public &amp;lt;E extends Entity&amp;gt; E createEntity(Class&amp;lt;E&amp;gt; cls, List&amp;lt;String&amp;gt; args){
		// cls型のString[]を引数にとるコンストラクタを呼び出す
		return cls.getConstructor(new Class&amp;lt;?&amp;gt;[] { String[].class }).newInstance(args);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やや黒魔術じみてきました。
実際にはE型がString[]を引数にとるコンストラクタを持つということが担保されていないためこれだけでは動かず、例外回避のためにいろいろやる必要があります。&lt;/p&gt;

&lt;p&gt;最初の例に戻ってみましょう。&lt;code&gt;getSubClassList&lt;/code&gt;は、以下のように書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;T extends SomeClass&amp;gt; List&amp;lt;T&amp;gt; getSubClassList(List&amp;lt;SomeClass&amp;gt; list, Class&amp;lt;T&amp;gt; cls){
	return list
		.stream()
		.filter(value -&amp;gt; value.getClass() == cls)
		.collect(Collectors.toList());
}

// 呼び出し側
getSubClassList(list, SubClassOfSomeClass.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;めでたしめでたし。&lt;/p&gt;

&lt;h3 id=&#34;おまけ:c600ddb79433125511402a932eb728b1&#34;&gt;おまけ&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public &amp;lt;T&amp;gt; int getStaticValue(Class&amp;lt;T&amp;gt; cls) throws Exception{ // なにがthrows Exceptionだやる気あんのか
	return (int) cls.getMethod(&amp;quot;getStaticValue&amp;quot;).invoke(null);
}

// 呼び出し
getStaticValue(SomeClass.class); // SomeClass.getStaticValue() を呼んでいるのと同じになる
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;staticメソッドも呼び出し可能なうえ、「そのクラスに与えられた名前のstaticメソッドが存在しない場合、その親クラスの同名のstaticメソッドを呼び出す」というようなふるまいを疑似的に再現することも可能です。&lt;/p&gt;

&lt;h2 id=&#34;おわり:c600ddb79433125511402a932eb728b1&#34;&gt;おわり&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Class&amp;lt;T&amp;gt; cls&lt;/code&gt;を引数にとり、&lt;code&gt;value.getClass() == cls&lt;/code&gt;で比較を行うのは、実質的にはinstanceofの迂回といえます。&lt;br /&gt;
この程度なら型安全性は一応担保されますが、コンストラクタやメソッドの取得と呼び出しまで始めた場合、throw宣言やcatch節が山のように膨らんだり、メソッドの存在確認や型の確認などに多大なコストを支払う必要がありそうです。
実際に使用するには相当の覚悟を必要とするでしょう。&lt;strong&gt;やめましょう。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;自分でプログラムを組んでいる際にこのような需要が発生することが時々あったので、Javaではリフレクションを使うことで強引に解決できると知って記事を書いてみましたが、自分の中ではむしろ「設計が悪い」の一言に実感が沸くという結果となった気がします。&lt;br /&gt;
今回例に挙げたゲームプログラムの設計はまさしく昔私が作ったものそのものなのですが、記事を書く上で「リフレクションを使いたい理由付け」を明確にしようとすればするほど、その理由が無理やりなものにしかならないのではないかという気持ちに陥りました。
途中まで書いた記事がグダグダになりそうな予感がしてくると結構精神的につらい。&lt;br /&gt;
……うーん。Abstract Factoryパターンとか、もととなるクラスが増えるとそれに合わせてFactoryクラスも増やさないといけないのがあまり好きじゃないので、そのあたりも動的になんとかできないかなどと思っていたのですが、なかなか難しいようです。&lt;/p&gt;

&lt;p&gt;私感としては、instanceof Tの代用としてClass型を使用する程度は許容できますが、普通のプログラムを書くならそれ以上は安易に手を出すべきではないという印象です。&lt;/p&gt;

&lt;p&gt;プログラミングをするときはまともな設計をするようにしましょう。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>FreecivCalc2を公開しました</title>
      <link>http://tatamo.81.la/blog/2016/05/26/freecivcalc2-released/</link>
      <pubDate>Thu, 26 May 2016 15:47:37 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/05/26/freecivcalc2-released/</guid>
      <description>
        

&lt;p&gt;Freecivのユニット同士の戦闘勝率を手軽に行えるソフトであるFreecivCalcの新バージョン、FreecivCalc2を公開しました。&lt;/p&gt;

&lt;p&gt;FreecivCalc2: &lt;a href=&#34;http://tatamo.81.la/freecivcalc2/&#34;&gt;http://tatamo.81.la/freecivcalc2/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以前から公開していた&lt;a href=&#34;http://m06t625.81.la/files/FreecivCalc.html&#34;&gt;FreecivCalc&lt;/a&gt;はSilverlight上で動作するソフトのため、現状では動作するブラウザがほとんどなくなってきています。&lt;/p&gt;

&lt;p&gt;そこでHTML5+JavaScript/TypeScriptに移植し、機能やインターフェースを大幅に見直したFreecivCalc2を開発しました。&lt;/p&gt;

&lt;p&gt;Chrome, Opera, Firefox, Edgeでの動作を確認しています。&lt;/p&gt;

&lt;h2 id=&#34;freecivcalc2の新機能:0fe09111c483b88d0d4fda3fcdc49d63&#34;&gt;FreecivCalc2の新機能&lt;/h2&gt;

&lt;p&gt;FreecivCalc2の画面からユニットを選択し、各種補正情報を入力することで戦闘勝率を表示できます。また詳細結果タブを開くことで、戦闘後のユニットHPの期待値を表示できるほか、タブを保持しておくことで復数の戦闘の予測結果を見比べることなどができます。&lt;/p&gt;

&lt;p&gt;従来バージョンでは、地形による防御ボーナスの適用の可否や特定のユニット同士の戦闘にかかる特殊補正などの補正の情報を手動で入力する必要がありました。
FreecivCalc2ではこれらの特殊補正は自動で適用されるため、Freecivの複雑な戦闘補正を十分に把握していない場合でも正確に戦闘勝率の予測が可能です。
ユニットにかけられている補正の一覧は、詳細結果タブ内で確認することができます。&lt;/p&gt;

&lt;h2 id=&#34;複数の言語-多様なルールセットに対応可能な拡張性:0fe09111c483b88d0d4fda3fcdc49d63&#34;&gt;複数の言語、多様なルールセットに対応可能な拡張性&lt;/h2&gt;

&lt;p&gt;戦闘補正の自動適用を実現するために、ユニットの情報や補正の条件など、ルールセットに関連するすべての情報を外部データ化しました。
これによってclassicルールセットだけでなく、多様なルールセットに対応することが可能です。
同時に、FreecivCalc2のインターフェース部分もテンプレートを用いて外部ファイルからコンテンツ内容を流し込んでいるため、容易に多言語化が可能になっています。&lt;/p&gt;

&lt;p&gt;現状では、classicルールセットを日本語および英語の2か国語で対応しています。&lt;/p&gt;

&lt;h2 id=&#34;開発について:0fe09111c483b88d0d4fda3fcdc49d63&#34;&gt;開発について&lt;/h2&gt;

&lt;p&gt;FreecivCalc2は三条項BSDライセンス下で公開されています。&lt;/p&gt;

&lt;p&gt;ローカル環境でのビルド、他のルールセットや言語に対応させるためのデータセットの文法などについては&lt;a href=&#34;https://github.com/Tatamo/freecivcalc2&#34;&gt;GitHubリポジトリ&lt;/a&gt;上で記述しているため、そちらを参照してください。&lt;/p&gt;

&lt;p&gt;FreecivCalc2は大半をTypeScriptで、jQuery UIのウィジェット定義など一部を生のJavaScriptで書いています。&lt;/p&gt;

&lt;p&gt;また使用したライブラリはjQuery, jQuery UI, amChartsです。
当初jQueryを使う予定はなかったのですが、ユニット選択用のUIとしてコンボボックスを実現するためのライブラリを探していたところjQuery UIが最も用途に適っていたため採用し、その流れでjQueryも使用することになりました。
amChartsは簡単にグラフを表示できるライブラリとして使いやすそうだったため使用しました。&lt;/p&gt;

&lt;p&gt;その他、外部JSONファイルからテンプレートを通してHTMLファイルを生成するためのテンプレートエンジンとしてEJSを使用しました。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Hugoを導入してブログを作った デプロイ編</title>
      <link>http://tatamo.81.la/blog/2016/01/05/hugo-deployment/</link>
      <pubDate>Tue, 05 Jan 2016 20:50:32 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/01/05/hugo-deployment/</guid>
      <description>
        

&lt;p&gt;&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;によって構築したサイトを、GitHub,Wercker,DeployBotを経由してWebサーバー上にデプロイした流れです。今回はHugo自体はほとんど触れていません。&lt;/p&gt;

&lt;h2 id=&#34;werckerを使って自動ビルドする:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;Werckerを使って自動ビルドする&lt;/h2&gt;

&lt;p&gt;まずはビルドを手元ではなくオンライン上で自動的に行うようにします。
記事を書いて反映させる際は記事編集→ビルド→アップロードという3つの手順を踏みますが、これによってビルド作業を手元で行わなくてもよくなります。
また、Hugoの環境がなくても、gitさえ使うことができれば記事の更新を行うことができるようになります。&lt;/p&gt;

&lt;p&gt;今回使用した&lt;a href=&#34;http://wercker.com/&#34;&gt;Wercker&lt;/a&gt;は、このような自動ビルド作業およびデプロイ作業を自動化してくれるCIサービスです。
Werckerを利用した自動デプロイは、&lt;a href=&#34;https://gohugo.io/tutorials/automated-deployments/&#34;&gt;Hugoの公式ドキュメント&lt;/a&gt;に記事があるため、これを参考に行います。
この記事はGitHub Pagesへのデプロイまで解説してありますが、今回の環境ではFTPによるサーバーへのアップロードが必要だったため、もうひと手間かける必要がありました。&lt;/p&gt;

&lt;h3 id=&#34;wercker-ymlの記述:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;wercker.ymlの記述&lt;/h3&gt;

&lt;p&gt;公式ドキュメントによる解説にも書いてありますが、Werckerによる自動ビルド/デプロイを利用するには、対象のGitHubリポジトリ内にwercker.ymlというファイルを作成し、そこに設定やビルド時の処理を記述する必要があります。
既にHugoビルド用の設定を作ってくれている人がいるので、それを利用すれば簡単にビルドができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;box: debian 
build:
  steps:
    - arjen/hugo-build:
        version: &amp;quot;0.14&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけでHugoのビルドが可能です。
ビルドが完了しただけではまだ目的のサーバーにHugoサイトがアップロードされていませんので、続いてデプロイの設定を行います。&lt;/p&gt;

&lt;h2 id=&#34;werckerとdeploybotを使って自動デプロイする:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;WerckerとDeployBotを使って自動デプロイする&lt;/h2&gt;

&lt;p&gt;前述のように、今回使用している環境ではWebサーバーにFTPでアップロードすることが目的のため、デプロイはwerckerからlftpを使用して行おうとしましたが、うまくいきませんでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;box: debian 
build:
  steps:
    - arjen/hugo-build:
        version: &amp;quot;0.14&amp;quot;
deploy:
  steps:
    - install-packages:
        packages: lftp
    - script:
        name: mirror over lftp
        code: |
            lftp -u $DEPLOY_FTP_USER,$DEPLOY_FTP_PASS -e &amp;quot;set ftp:passive-mode off;set ftp:ssl-allow off;set net:timeout 5;set net:max-retries 3;set net:reconnect-interval-max 60;mirror -enR public /blog;quit&amp;quot; $DEPLOY_FTP_SERVER
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lftpでの接続に失敗し、アップロードを行うことができませんでした。
PASVモードのon/off、sslを使用しないようにするなどのオプションを試みましたが、コネクションがうまく確立できず失敗しました。&lt;/p&gt;

&lt;p&gt;後日また調べてみたいと思っていますが、ひとまずFTPでのアップロードを行うため、別のサービスを利用することにしました。
&lt;a href=&#34;http://deploybot.com/&#34;&gt;DeployBot&lt;/a&gt;は1プロジェクトまで無料で利用できるサービスで、FTPによるアップロードにも対応しているため、これを利用しました。
DeployBotによるデプロイは、&lt;a href=&#34;http://creative-tweet.net/blog/2015/10/usage-hugo-2.html&#34;&gt;Hugoをセットアップしてデプロイするまで［後編］CIサービスでビルドからデプロイを自動化するまで | creative tweet.&lt;/a&gt;で解説されているので、ここを参考にして行いました。&lt;/p&gt;

&lt;p&gt;全体としては、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;記事を書いてGitHub上にpushする&lt;/li&gt;
&lt;li&gt;Werckerが更新を検知して自動的にビルドを行い、別のGitHubリポジトリを更新する&lt;/li&gt;
&lt;li&gt;そのリポジトリの更新を検知してDeployBotによって自動的にサーバーへアップロードする&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;というような流れでのデプロイを行いました。&lt;/p&gt;

&lt;p&gt;Werckerから別のGitHubリポジトリへのpushを行うようにするため、公式ドキュメントに書かれている通りにwercker.ymlを書き換えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;box: debian 
build:
  steps:
    - arjen/hugo-build:
        version: &amp;quot;0.14&amp;quot;
deploy:
  steps:
    - install-packages:
        packages: git ssh-client
    - leipert/git-push:
        gh-oauth: $GIT_TOKEN
        basedir: public
        repo: $GITHUB_REPO
        clean_removed_files: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$GIT_TOKEN&lt;/code&gt;および&lt;code&gt;$GITHUB_REPO&lt;/code&gt;は、werckerの設定画面でdeploy targetごとに変数を定義できるため、そこに記述します。$GIT_TOKENはprotectedにチェックを入れ、外部から取得できないようにしておきます。&lt;/p&gt;

&lt;p&gt;あとはwerckerのデプロイ先に指定したGitHubリポジトリをDeployBotに登録するだけです。
DeployBotはリポジトリが更新されるとその内容をそのままサーバー上へアップロードしてくれ、設定も簡単でした。
これで目的のサーバーへの自動デプロイが完了しました。&lt;/p&gt;

&lt;h2 id=&#34;補足など:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;補足など&lt;/h2&gt;

&lt;h3 id=&#34;githubリポジトリの分割:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;GitHubリポジトリの分割&lt;/h3&gt;

&lt;p&gt;Hugoのビルドをローカルでは行わないようにしたため、リポジトリ内に/publicを含める必要がありません。.gitignoreに次の行を記述します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;public/
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;リポジトリA:publicディレクトリを除くHugoディレクトリ&lt;/li&gt;
&lt;li&gt;リポジトリB:生成されたpublicディレクトリの内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;というようなGitHubリポジトリ構成とし、リポジトリBはWerckerとDeployBotをリンクさせるために使用するため手動では触れません。&lt;/p&gt;

&lt;h3 id=&#34;werckerの設定:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;Werckerの設定&lt;/h3&gt;

&lt;h4 id=&#34;dockerの使用:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;Dockerの使用&lt;/h4&gt;

&lt;p&gt;Werckerにプロジェクトを登録する際、wercker.yml設定の項目で「Dockerを使用する」かどうかのチェックボックスが存在します。
Werckerで使用するboxはDockerを使用しているものと使用していないものがあり、Hugo公式ドキュメントで使用しているbox:debianなどはDockerを使用しているため、Docker使用の設定をオンにしておかないと、&lt;a href=&#34;http://thleap.net/blog/recovering-wercker/&#34;&gt;boxが見つからないというエラー&lt;/a&gt;が発生します。
逆にwercker/defaultなどのDockerを使用しないboxを使用する場合、設定をオンにしておく必要はないでしょう。
(なお私はWerckerのBoxについてはよくわかっていません。Hugoをデプロイする場合は公式ドキュメント通りにdebianを使用すればいいのではないでしょうか。wercker/defaultでは環境のセットアップに15秒ほどかかりますが、debianでは1秒で済みます。)&lt;/p&gt;

&lt;h4 id=&#34;デプロイターゲット登録時のauto-deploy設定:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;デプロイターゲット登録時のAuto deploy設定&lt;/h4&gt;

&lt;p&gt;ちょっとしたこと(というかちゃんと読めばわかること)ですが、werckerででプロイターゲットを登録する時、&amp;rdquo;auto deploy successful builds to branch(es):&amp;ldquo;という設定項目でブランチ名を指定する箇所がありますが、これはどのブランチが更新されたときに自動的にビルドが走るかを指定するものであり、デプロイ先のブランチ名を指定するものではありません。
GitHubからGitHubへのデプロイを行うときは少し混乱するかもしれません。&lt;/p&gt;

&lt;p&gt;なお、デプロイ先のGitHubブランチ名は前述したwercker.yml内に指定する箇所があります。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上で、Hugoで生成したサイトを自動的にデプロイすることができました。
とはいえWerckerから直接デプロイすることに失敗したためにやや回りくどい方法をとっており、いずれ改善したいと思っています。&lt;/p&gt;

&lt;p&gt;Werckerはビルドごとに環境を最初から設定するため、ライブラリのインストールなども毎回行われ、ビルド環境が整うまでに1分ほどかかります。
手元でビルドができる環境ならばローカルでビルドしてアップロードしたほうが明らかに速いので、すぐに更新したいときなどはデプロイまでにかなり時間がかかる印象を受けます。
Werckerを経由せず、手動でアップロードできる方法も用意しておいたほうがいいのかもしれません。&lt;/p&gt;

&lt;p&gt;また、稀にですがWerckerのビルドが最初のsetup environmentの段階で動かなくなり、Abortも効かない状態でビルドに失敗したことがありました。
デプロイを自動で行っているとはいえ、結局デプロイがうまくいったかどうか確認しないといけないのは問題かもしれません。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Hugoを導入してブログを作った サイト構築編</title>
      <link>http://tatamo.81.la/blog/2015/12/17/hugo-implementation/</link>
      <pubDate>Thu, 17 Dec 2015 03:51:04 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2015/12/17/hugo-implementation/</guid>
      <description>
        

&lt;p&gt;この記事は&lt;a href=&#34;http://www.adventar.org/calendars/891&#34;&gt;KobeUniv Advent Calendar 2015&lt;/a&gt;の17日の記事です。なんとか期日に間に合いそうです。
なお私は当該大学の学部1年(2015年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;このブログを作るにあたって、&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;を使用しました。
Hugoを用いたサイト構築の基本的な考え方や流れの紹介、その際に詰まったことなど。&lt;/p&gt;

&lt;h2 id=&#34;そもそもhugoって何:618f10612e6a9a223dbbbddb739583ff&#34;&gt;そもそもHugoって何&lt;/h2&gt;

&lt;p&gt;静的なWebサイトを生成するためのエンジンです。
つまり:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;まずレイアウトを用意します&lt;/li&gt;
&lt;li&gt;次に記事を書きます&lt;/li&gt;
&lt;li&gt;hugoを実行します&lt;/li&gt;
&lt;li&gt;記事がHTMLに変換され、Webサイトが生成されます&lt;/li&gt;
&lt;li&gt;生成されたサイトをまるごとサーバーにアップロードします&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;これでWebサイトの完成というわけです。
あくまで静的なサイトなので、サーバーサイドでプログラムを走らせる必要もありません。&lt;/p&gt;

&lt;h2 id=&#34;hugoを使ってみる:618f10612e6a9a223dbbbddb739583ff&#34;&gt;Hugoを使ってみる&lt;/h2&gt;

&lt;p&gt;Hugoのインストール等については、既に多くの情報がネット上にあるため割愛します。&lt;/p&gt;

&lt;h3 id=&#34;hugoの基本的なディレクトリ構成:618f10612e6a9a223dbbbddb739583ff&#34;&gt;Hugoの基本的なディレクトリ構成&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ hugo new site name_of_my_site
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行することで、サイト用のディレクトリが生成されます。
中には、config.tomlといくつかのディレクトリが生成されているはずです。
config.tomlはサイト全体の設定を記述するファイルです。なお、代わりにconfig.yamlとしてYAMLで記述することなども可能です。お好みで変更しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd name_of_my_site/
$ ls -p
archetypes/  config.toml  content/  data/  layouts/  static/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;contentディレクトリは、記事ファイルを配置する場所です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ hugo new hoge.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとするとcontent内にmdファイル(記事は主にMarkdownで記述します)が生成されますので、これを編集して記事を作ることになります。&lt;/p&gt;

&lt;p&gt;また、layoutディレクトリにはWebサイトの基礎となるテンプレートを配置します。
基本的には独自のテンプレート記法が用いられたhtmlファイルを使います。
既存のテーマを利用する場合は、themesディレクトリを作り、そこに同様のテンプレートが同梱されたテーマを配置することになります。&lt;/p&gt;

&lt;p&gt;staticディレクトリには、CSSや画像などの静的なファイルを配置します。
このディレクトリ内にあるファイルは、生成時にサイトのルートディレクトリにそのままコピーされます。&lt;/p&gt;

&lt;p&gt;基本的には、この3つ(または4つ)のディレクトリの働きを把握しておけば、Hugoでサイトを作りはじめるのに不足はないかと思われます。&lt;/p&gt;

&lt;p&gt;また、hugoコマンドなどによって生成された完成品のサイトは、publicというディレクトリが作られてそこに配置されます。
サイトを公開するときは、publicディレクトリ下に生成されたファイルをすべてアップロードします。
なお、publicディレクトリ内に不要になったファイルがあったとしても、サイト生成時に削除されません。本番サイトの生成時にはpublicディレクトリを一度削除してからビルドを行うのが良いと思われます。&lt;/p&gt;

&lt;h3 id=&#34;レイアウトしてみる:618f10612e6a9a223dbbbddb739583ff&#34;&gt;レイアウトしてみる&lt;/h3&gt;

&lt;h4 id=&#34;テーマを使う:618f10612e6a9a223dbbbddb739583ff&#34;&gt;テーマを使う&lt;/h4&gt;

&lt;p&gt;いくつものHugoのレイアウトが&lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;公開されて&lt;/a&gt;います。基本的には、この中から気に入ったものを使うのが良さそうです。themesディレクトリ直下にテーマごとのディレクトリを作り、その中にテーマファイルを配置します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git clone --recursive https://github.com/spf13/hyde themes/hyde
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テーマを適用するときは、configファイル内でテーマを指定するか、hugoコマンドの実行時に&lt;code&gt;hugo -t hyde&lt;/code&gt;または&lt;code&gt;hugo server -t hyde&lt;/code&gt;のように-tオプションでテーマを指定します。ここで指定するテーマ名は、themes直下に配置したディレクトリの名前となります。
テーマを適用すると、hugoディレクトリ直下のファイルが読み込まれるよりも先に、そのテーマディレクトリ下に存在するファイルが読み込まれるようになります。&lt;/p&gt;

&lt;p&gt;既存のテーマを使用する場合、テーマによってconfigに記述する必要のある内容が大きく異なる可能性があります。READMEにどのような項目を記述すればいいかが書かれていると思いますので、必ず確認するのがいいでしょう。&lt;/p&gt;

&lt;h4 id=&#34;自分でレイアウトする:618f10612e6a9a223dbbbddb739583ff&#34;&gt;自分でレイアウトする&lt;/h4&gt;

&lt;p&gt;HugoはGo言語のテンプレートエンジンを使用しており、各種パラメータを呼び出したり、部分ごとにHTMLファイルを分けて再利用することでサイトのレイアウトを記述していくことができます。&lt;/p&gt;

&lt;p&gt;自分でHugoサイトをレイアウトする場合、確実に一定の学習コストが必要となるので、ここでは詳細には触れません。Hugoは公式ドキュメントが充実しているので、&lt;a href=&#34;https://gohugo.io/tutorials/creating-a-new-theme/&#34;&gt;公式チュートリアル&lt;/a&gt;などから始めるのがいいでしょう。また基本的なことであれば調べれば日本語の情報も得られると思います。&lt;/p&gt;

&lt;h2 id=&#34;詰まったことなど:618f10612e6a9a223dbbbddb739583ff&#34;&gt;詰まったことなど&lt;/h2&gt;

&lt;p&gt;今回はHTMLやCSSを自分で書いてサイトを一つ作りたいと思っていた&lt;del&gt;のと、自分以外のテーマ作者名の表記がページに現れるのが気に食わなかった&lt;/del&gt;ので、このサイトでは既存のテーマを使用せず、自前でレイアウトを記述して構築しました。
その途中で、いくつか不具合に遭遇して詰まったりしました。&lt;/p&gt;

&lt;h3 id=&#34;バージョン0-14-配列の並び替えにバグがある:618f10612e6a9a223dbbbddb739583ff&#34;&gt;(バージョン0.14)配列の並び替えにバグがある&lt;/h3&gt;

&lt;p&gt;サイドバーに最近の投稿やタグ・カテゴリの一覧を表示させる際、たとえば&lt;code&gt;.Reverse&lt;/code&gt;や&lt;code&gt;.ByDate&lt;/code&gt;で並び替えを行うと、ページによって正常に並び替えが行われなかったり、ビルドするたびに並び順が変わる、低確率で配列の中身が重複して表示されたりします。
これは並び替えを行う関数が配列そのものに変更を加えているのが原因です。さらにビルド時に並列処理が行われることで処理順がビルドのたびに変化し得るため、同じ記述をしていてもページによって表示される内容が変わるといった不具合が発生したり、そのバグの再現性が低くなったりします。&lt;/p&gt;

&lt;p&gt;このバグは開発版のバージョン0.15では&lt;a href=&#34;https://discuss.gohugo.io/t/error-when-trying-to-sort/1390/4&#34;&gt;修正済み&lt;/a&gt;であり、現行のバージョン0.14まででのみ発生します。&lt;/p&gt;

&lt;h3 id=&#34;rssuriオプションは使ってはいけない:618f10612e6a9a223dbbbddb739583ff&#34;&gt;RSSUriオプションは使ってはいけない&lt;/h3&gt;

&lt;p&gt;Hugoではビルド時に自動的にRSSフィードも生成されますが、そのファイル名は常にindex.xmlとなります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rssuri = &amp;quot;rss.xml&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにconfigファイル中に記述することで、RSSファイル名を変更する機能がありますが、この機能には&lt;a href=&#34;https://github.com/spf13/hugo/issues/1147&#34;&gt;いくつもの欠陥がある&lt;/a&gt;ため使ってはいけません。(2015年12月、バージョン0.14時点)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ルートディレクトリ直下のRSSファイルのファイル名はこの設定によって変更できるが、それ以外のRSSファイルはすべてindex.xmlのままになってしまう&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.RSSlink&lt;/code&gt;などの変数を呼び出すと、間違ったリンクが返される&lt;/li&gt;
&lt;li&gt;RSSファイル内のURLが間違ったものになる&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;hugoを使ってみた感想:618f10612e6a9a223dbbbddb739583ff&#34;&gt;Hugoを使ってみた感想&lt;/h2&gt;

&lt;p&gt;Hugoはシンプルで生成が非常に速いという評判があったため導入してみましたが、実際にサイトを構築してみると確かにそのような設計であることがよく感じられました。必要最小限の機能を持つように出来ており、簡潔なディレクトリ構造はとてもわかりやすいです。
生成速度についてはまだ記事数が少ないため何とも言えませんが、今のところは一瞬でビルドが完了するので良い感じだと思います。&lt;/p&gt;

&lt;p&gt;とはいえ、レイアウトから自前で書き始めるといくつかの不満点が出てきます。
レイアウトに使用するテンプレートはHugoの全体の印象に反して煩雑です。そのため、Hugo特有のレイアウトの記述方法にある程度習熟しておくことは不可欠となります。
しかし、Hugoは公式ドキュメントが非常に豊富ではあるのですが、決して使いやすいというわけではないと思います。
全体を通して解説風のドキュメントとなっているために最初はわかりやすいのですが、それ故にリファレンスとしての機能を十分に果たしておらず、また別途APIリファレンスなどがあるわけでもないので、テンプレートなどの機能を調べるのがやや困難です。
(とはいえ、基本はGo言語のテンプレートエンジンを用いているらしいので、既にGoに慣れている方にとっては問題ないのかもしれません)&lt;/p&gt;

&lt;p&gt;Hugoで使用するパラメータは、TaxonomyやPaginatorの概念が存在していることによってやや複雑な構造をしているため、ドキュメントの見通しが悪いのは問題になりがちだと思います。(rangeで.Data等で提供される配列の中身を回す時とTaxonomyを回すときの扱い方が微妙に異なるなど)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上、Hugoを使ったサイト構築の紹介でした。
Hugoでサイトを作ってからWeb上にデプロイするまでも一苦労あったので、後日その流れについても書いてみたいと思っています。&lt;/p&gt;

&lt;p&gt;あとページのデザイン難しいです。
CSS周りについても記事を書いてみたいですが、あまりに試行錯誤の連続なので何も書くことがないかもしれません……&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>highlight.jsをインライン要素にも適用できるようにした</title>
      <link>http://tatamo.81.la/blog/2015/12/12/apply-highlightjs-to-inline/</link>
      <pubDate>Sat, 12 Dec 2015 01:01:51 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2015/12/12/apply-highlightjs-to-inline/</guid>
      <description>
        

&lt;p&gt;このブログのシンタックスハイライトには&lt;a href=&#34;https://highlightjs.org/&#34;&gt;highlight.js&lt;/a&gt;を使用しています。&lt;/p&gt;

&lt;p&gt;デフォルトでは適用できないインラインのコードのハイライトも行えるようにしましたので、適用の流れなど。&lt;/p&gt;

&lt;h2 id=&#34;highlight-jsって何:dbe2fecfd9603c43589f9d37f36eba56&#34;&gt;highlight.jsって何&lt;/h2&gt;

&lt;p&gt;JavaScriptによって、Webページ内のソースコードを色付けしてくれるものです。
たとえば:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(1,101) :
	print (&amp;quot;Fizz&amp;quot; if not i%3 else &amp;quot;&amp;quot;) + (&amp;quot;Buzz&amp;quot; if not i%5 else &amp;quot;&amp;quot;) or i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://highlightjs.org/static/demo/&#34;&gt;highlight.js demo&lt;/a&gt;を見れば、どのようにハイライトされるのか、どのようなテーマがあるのかが簡単にわかるので良いと思います。
(しかし思うのですが、自分のサイトに導入を検討する際に、この濃い赤色の背景色だと白色の背景と感覚が違ってくるのでやや選びにくいのではないでしょうか……。
コンソールから&lt;code class=&#34;js&#34;&gt;document.body.style.backgroundColor=&amp;ldquo;#FFFFFF&amp;rdquo;;&lt;/code&gt;とでも入力して、背景を白く変更してから見てみるのがいいかもしれません。)&lt;/p&gt;

&lt;h2 id=&#34;インライン要素でもハイライトできるようにしてみた:dbe2fecfd9603c43589f9d37f36eba56&#34;&gt;インライン要素でもハイライトできるようにしてみた&lt;/h2&gt;

&lt;p&gt;通常では、highlight.jsによるハイライトは&lt;code class=&#34;html&#34;&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&lt;/code&gt;から&lt;code class=&#34;html&#34;&gt;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/code&gt;で囲まれたブロック要素にのみ適用され、インライン要素に適用することはできません。1行の中にコードを埋め込みたいことも多いので、これではやや不便です。&lt;/p&gt;

&lt;p&gt;Markdownの展開方法に適用できるように、&lt;code class=&#34;html&#34;&gt;&amp;lt;code&amp;gt;&amp;lt;/code&amp;gt;&lt;/code&gt;で囲まれた要素をハイライトすることにします。
既に先人たちが記事を書いてくれているので、基本的にはそれを参考にするだけでした。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://kenzauros.com/blog/apply-highlight-js-to-inline-source-code/&#34;&gt;highlight.jsでインラインのソースコードもハイライトする | blog@kenzauros.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://swiftrithm.com/blog/highlightjs-install/&#34;&gt;軽いとうわさのhighlight.jsをTwenty Fifteenに導入、ソースコードを綺麗に表示 &amp;#8211; SWIFTRITHM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上記のサイトでは共にJQueryを用いていますが、このサイトでは特にJQueryを導入する気もなかったため、生のJavaScript+DOMで適当に書き直しました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script&amp;gt;
// hljs.initHighlightingOnLoad();
window.addEventListener(&amp;quot;DOMContentLoaded&amp;quot;, function(){
	var elements = document.getElementsByTagName(&amp;quot;code&amp;quot;);
	var l=elements.length;
	for(var i=0; i&amp;lt;l;i++){
		var el = elements[i];
		hljs.highlightBlock(el);
		if(el.parentNode.tagName.toLowerCase() != &amp;quot;pre&amp;quot;) {
			el.style.display = &amp;quot;inline&amp;quot;;
			el.style.margin = &amp;quot;0 2px&amp;quot;;
			el.style.padding = &amp;quot;1px 3px&amp;quot;;
		}
	}
}, false);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常&lt;code&gt;hljs.initHighlightingOnLoad();&lt;/code&gt;を呼ぶところを、上記のコードで置き換えるだけで完了です。
親要素が&lt;code class=&#34;html&#34;&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;ではない場合にインライン化するようにしています。
またスタイルの指定も同時に行っているので、別途CSSを記述する必要はありません。&lt;/p&gt;

&lt;p&gt;既に記事内で何回も使用しているので今更感はありますが、実際にインラインのコードがハイライトされるか見てみましょう。
たとえば、このように:&lt;code class=&#34;py&#34;&gt;print &amp;ldquo;\n&amp;rdquo;.join([&amp;ldquo;Fizz&amp;rdquo;&lt;em&gt;(not i%3)+&amp;ldquo;Buzz&amp;rdquo;&lt;/em&gt;(not i%5) or str(i) for i in range(1,101)])&lt;/code&gt;1行のコードでもうまくハイライトされているのがわかります。
やったね。&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>