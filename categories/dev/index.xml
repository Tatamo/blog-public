<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dev on わたしろぐ</title>
    <link>http://tatamo.81.la/blog/categories/dev/</link>
    <description>Recent content in Dev on わたしろぐ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Thu, 22 Dec 2016 03:03:09 +0900</lastBuildDate>
    <atom:link href="http://tatamo.81.la/blog/categories/dev/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LR(1)パーサジェネレータを自作して構文解析をする 第1回:かんたん構文解析入門</title>
      <link>http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/</link>
      <pubDate>Thu, 22 Dec 2016 03:03:09 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/12/22/lr-parser-generator-implementation/</guid>
      <description>
        

&lt;p&gt;この記事は&lt;a href=&#34;http://www.adventar.org/calendars/1881&#34;&gt;Kobe University Advent Calendar 2016&lt;/a&gt;の21日の記事です。また遅刻か。
なお私は当該大学の学部2年(2016年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;構文解析ができるプログラマはちょっとかっこいいですよね。
「構文解析？ああ、できますよ」とか言って自分のスキルを自慢できそうな印象があります。&lt;/p&gt;

&lt;p&gt;(ほぼ)フルスクラッチでTypeScriptによるLR(1)パーサジェネレータを実装した(ついでにLALR(1)パーサも作れる)ので、これを完成させるまでの流れを紹介していこうと思います。&lt;/p&gt;

&lt;p&gt;今回は構文解析自体の入門編となります。&lt;/p&gt;

&lt;p&gt;自作したパーサジェネレータは &lt;a href=&#34;https://github.com/Tatamo/parsergenerator&#34;&gt;https://github.com/Tatamo/parsergenerator&lt;/a&gt; にあります。&lt;br /&gt;
今のところパーサジェネレータ部分は完成、基本的な構文解析なら問題なくこなせるので構文規則や字句規則を外部から読み取って構文解析してパーサジェネレータに渡すような処理や、全体の見通しを良くするための設計の見直しやリファクタリング等を行っている段階です。
ドキュメント作ってなくてすみません。&lt;/p&gt;

&lt;h2 id=&#34;構文解析をしたい:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;構文解析をしたい&lt;/h2&gt;

&lt;p&gt;構文解析、時々見かけるフレーズです。
プログラマなら覚えておいて損はない技術……かどうかはわかりませんが、そういう類のスキルに(傍からは)見えます。&lt;br /&gt;
ぜひやりましょう。&lt;/p&gt;

&lt;p&gt;ひとまず、何をやりたいのかを明確にする必要があります。&lt;br /&gt;
この記事では、「入力として与えられるLR(1)文法に属する文法に従ったトークン列をパース(構文解析)することで、その構造を構文木として出力する」ことを目標とします。
何を言っているのかさっぱりわかりませんね、わからなくていいです。&lt;/p&gt;

&lt;p&gt;順を追って説明する必要がありますが、詳細は適宜省略します。
そのため、まずは今回主に参照した資料を列挙しておきます。&lt;/p&gt;

&lt;h2 id=&#34;参考資料一覧:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;参考資料一覧&lt;/h2&gt;

&lt;p&gt;より詳しく知りたい方は、下記に挙げる資料やそこで紹介されている参考文献などを参照されるのが良いと思われます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.cornell.edu/courses/cs412/2003sp/lectures/lec09.pdf&#34;&gt;Cornell CIS Introduction to Compilers Lecture 9: LR(1) Parsing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jaist.ac.jp/~kshirai/lec/i223/04a.pdf&#34;&gt;JAIST 自然言語処理論Ｉ 4.文法2(構文解析) その1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jaist.ac.jp/~kshirai/lec/i223/04b.pdf&#34;&gt;JAIST 自然言語処理論Ｉ 4.文法2(構文解析) その2&lt;/a&gt;
(注：「LR法による構文解析」として紹介されているアルゴリズムはSLR法)&lt;br /&gt;
上記3つはネット上にアップロードされている特定の大学の講義資料ですが、公開の規定等を確認していないためリンクを張ることに不都合があるようなら知らせていただけると助かります。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Canonical_LR_parser&#34;&gt;Canonical LR parser - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/ichikaz3/lr-parsing&#34;&gt;LR parsing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kimiyuki.net/blog/2016/08/03/context-free-grammar/&#34;&gt;文脈自由文法とその構文解析法 &amp;middot; うさぎ小屋&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/uhyo_&#34;&gt;うひょ(@uhyo_)さん&lt;/a&gt; 生き字引。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;構文解析とは-ざっくり:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;構文解析とは？(ざっくり)&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; という数式を考えてみます。
構文解析をすることによる最終的な目的は、この数式を(たとえば)文字列として与えると、結果としてこの数式の答えが&lt;code&gt;42&lt;/code&gt;であることを導く、といったことです。&lt;/p&gt;

&lt;p&gt;そのためには、以下のものが必要になります：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数式を表現する構文規則&lt;/li&gt;
&lt;li&gt;上記構文規則を解析するように作られた構文解析器(Parser)&lt;/li&gt;
&lt;li&gt;解析された構文を処理するプログラム&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さらに、これらの構文解析に入る前の下準備のために以下が必要です；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;文字列をトークンとして分割して表現するための字句規則&lt;/li&gt;
&lt;li&gt;上記字句規則をもとに、文字列を読み取ってトークンを返す字句解析器(Lexical Analyzer、略してLexer)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ちなみに、今回の記事の目標は、それらに加えて以下のものを実装することです：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;構文規則および字句規則を入力として与えることで、構文解析器そのものを自動生成するパーサジェネレータ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;実際の構文解析を行う手順とはずれてしまいますが、紹介した順番に沿って構文解析器→字句解析器の順に解説していきます。&lt;/p&gt;

&lt;h3 id=&#34;構文解析器-パーサ:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;構文解析器(パーサ)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; という数式を解析するためには、まずこの数式がどのようなルールで記述されているのかを(再)定義する必要があります。
そのルールをを表すのが構文規則です。
構文規則を書き表すルールは、たとえば&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%90%E3%83%83%E3%82%AB%E3%82%B9%E3%83%BB%E3%83%8A%E3%82%A6%E3%82%A2%E8%A8%98%E6%B3%95&#34;&gt;BNF&lt;/a&gt;など様々な種類がありますが、基本的な発想としては&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;S -&amp;gt; X Y Z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように左辺の記号を右辺の記号の並びによって定義することで行います。&lt;/p&gt;

&lt;p&gt;具体的に見てみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;式 -&amp;gt; 式 &amp;quot;+&amp;quot; 項
式 -&amp;gt; 項
項 -&amp;gt; 項 &amp;quot;*&amp;quot; 因子
項 -&amp;gt; 因子
因子 -&amp;gt; 数
因子 -&amp;gt; &amp;quot;(&amp;quot; 式 &amp;quot;)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;妥当ですね。
&lt;code&gt;式 -&amp;gt; 式 + 項&lt;/code&gt; と &lt;code&gt;式 -&amp;gt; 項&lt;/code&gt;の２つの規則が、再帰的な繰り返しを表現していることに注意してください。
たとえば、&lt;code&gt;項&lt;/code&gt;は当然&lt;code&gt;式&lt;/code&gt;ですし、&lt;code&gt;項 + 項&lt;/code&gt;も&lt;code&gt;式(-&amp;gt;項) + 項&lt;/code&gt; より&lt;code&gt;式&lt;/code&gt;となります。
さらに、&lt;code&gt;項 + 項 + 項&lt;/code&gt;は最初の&lt;code&gt;項 + 項&lt;/code&gt;が&lt;code&gt;式&lt;/code&gt;なので、&lt;code&gt;式(-&amp;gt;項 + 項) + 項&lt;/code&gt; より&lt;code&gt;式&lt;/code&gt;です。
よって、&lt;code&gt;式&lt;/code&gt;は&lt;code&gt;項&lt;/code&gt;を&lt;code&gt;&amp;quot;+&amp;quot;&lt;/code&gt;によって任意の回数だけ繋げたものであり、同様に&lt;code&gt;項&lt;/code&gt;は&lt;code&gt;因子&lt;/code&gt;を&lt;code&gt;&amp;quot;*&amp;quot;&lt;/code&gt;で繋げたものとなります。
最後に、&lt;code&gt;因子&lt;/code&gt;は単なる&lt;code&gt;数&lt;/code&gt;かもしれませんし、または&lt;code&gt;&amp;quot;(&amp;quot;&lt;/code&gt;と&lt;code&gt;&amp;quot;)&amp;quot;&lt;/code&gt;で囲まれた&lt;code&gt;式&lt;/code&gt;かもしれません。
これは括弧で囲まれた部分の式が他の部分よりも高い優先順位となることを表現しています。&lt;/p&gt;

&lt;p&gt;たとえば&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt;は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;式{ [9] [+] [11 * (2 + 1)] }
式{ 項{ [9] } &amp;quot;+&amp;quot; 項{ [11] [*] [(2 + 1)] } }
式{ 項{ 因子{9} } &amp;quot;+&amp;quot; 項{ 因子{11} &amp;quot;*&amp;quot; 因子{ [(] [2 + 1] [)] } } }
式{ 項{ 因子{9} } &amp;quot;+&amp;quot; 項{ 因子{11} &amp;quot;*&amp;quot; 因子{ &amp;quot;(&amp;quot; 式{ [2] [+] [1] } &amp;quot;)&amp;quot; } } }
式{ 項{ 因子{9} } &amp;quot;+&amp;quot; 項{ 因子{11} &amp;quot;*&amp;quot; 因子{ &amp;quot;(&amp;quot; 式{ 項{ [2] } &amp;quot;+&amp;quot; 項{ [1] } } &amp;quot;) &amp;quot;} } }
式{ 項{ 因子{9} } &amp;quot;+&amp;quot; 項{ 因子{11} &amp;quot;*&amp;quot; 因子{ &amp;quot;(&amp;quot; 式{ 項{ 因子{2} } &amp;quot;+&amp;quot; 項{ 因子{1} } } &amp;quot;)&amp;quot; } } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように展開されます(こうして得られた構造をどう解析するかについては省略します)。この、解析対象→構文木の変換を自動で行うのがパーサです。&lt;/p&gt;

&lt;p&gt;ちなみにですが、この構文規則は解析したい対象ごとにあなたが一から書き上げる必要があります。&lt;/p&gt;

&lt;h3 id=&#34;字句解析器-レキシカルアナライザ:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;字句解析器(レキシカルアナライザ)&lt;/h3&gt;

&lt;p&gt;上記構文規則では、&lt;code&gt;+&lt;/code&gt;や&lt;code&gt;*&lt;/code&gt;のような演算子、&lt;code&gt;数&lt;/code&gt;についての規定はありません。
これらの「左辺に現れない記号」を、「終端記号」と呼びます。左辺に現れる記号は非終端記号と呼ばれます。&lt;/p&gt;

&lt;p&gt;通常、&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt; のような入力は文字列で与えられますが、記号と記号の間には複数もしくは0個の空白が挿入されている可能性もあります。
しかし以下のような構文規則を定義するのは本質的ではありません：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;空白 -&amp;gt; &amp;quot; &amp;quot;
空白 -&amp;gt; &amp;quot; &amp;quot; + 空白
数字 -&amp;gt; &amp;quot;0&amp;quot; | &amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | ... | &amp;quot;9&amp;quot;
数字 -&amp;gt; (&amp;quot;0&amp;quot; | &amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | ... | &amp;quot;9&amp;quot;) 数字
数 -&amp;gt; (&amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | &amp;quot;3&amp;quot; ... | &amp;quot;9&amp;quot;) 数字
ただし、|は「または」を表す
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そこで、通常は「入力として与えられた文字列」を「終端記号として分類されたトークンの列」に変換する処理をはさみ、これによって得られたトークンを構文解析器に与えます。
トークンとは終端記号と、必要ならばそれに紐付いた元々の情報を保持しておいたものです。たとえば、&lt;code&gt;9 + 11 * (2 + 1)&lt;/code&gt;は、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;数字: 9
プラス: +
数字: 11
アステリスク: *
左括弧: (
数字: 2
プラス: +
数字: 1
右括弧: )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような9つのトークンの列に分けることができます。
構文解析器はそのトークンがどのような終端記号に対応しているかは見ますが、たとえば個々の数字が何であるかを判断することはしません。
これによって、構文解析器は本質的な文法の解析のみに注力することができます。&lt;/p&gt;

&lt;p&gt;この処理をするのが字句解析器で、どのような文字や文字列が与えられた場合に何という終端記号かを判別するための規則が字句規則です。&lt;/p&gt;

&lt;p&gt;字句規則は、例えば以下のような書き方になるでしょう：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;数字: /[1-9][0-9]/
プラス: &amp;quot;+&amp;quot;
アステリスク: &amp;quot;*&amp;quot;
左括弧: &amp;quot;(&amp;quot;
右括弧: &amp;quot;)&amp;quot;
(読み捨て): /\s/
(不正): /./
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでは字句規則の表現のために、文字列および正規表現を使用しています。
通常(?)字句規則は上から順に文字列の先頭部分を当てはめていき、マッチするものがあればその終端記号に対応付けます。
そのため、&lt;code&gt;(不正)&lt;/code&gt;の部分は入力された文字全てにマッチする正規表現&lt;code&gt;/./&lt;/code&gt;が使用されていますが、これは上の規則のいずれにも当てはまらなかった場合にのみマッチします。&lt;/p&gt;

&lt;p&gt;与えられた文字列を前から順番に見ていくだけなので、字句解析器の実装はパーサやパーサジェネレータの実装と比べると単純です。&lt;/p&gt;

&lt;h3 id=&#34;パーサジェネレータ:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;パーサジェネレータ&lt;/h3&gt;

&lt;p&gt;ここまで構文解析器(パーサ)と字句解析器(レキシカルアナライザ)について見てきました。
基本的にはこの2つによって構文解析を行うことができ、基本的な流れとしては&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;入力となるような解析したい言語を用意する&lt;/li&gt;
&lt;li&gt;字句規則を用意して、それをもとにしたレキシカルアナライザを用意する&lt;/li&gt;
&lt;li&gt;レキシカルアナライザに入力を与え、トークンの列を取得する&lt;/li&gt;
&lt;li&gt;構文規則を用意して、それをもとにしたパーサを用意する&lt;/li&gt;
&lt;li&gt;パーサにトークンの列を与え、解析結果を得る&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となります。
パーサジェネレータとは何かというと、この 4. の部分を自動化するものです。
(LR法の)構文解析器は、内部的には入力を受け取ってスタックに積みながら状態遷移を繰り返すオートマトンにすぎません。
そのため、どの入力が与えられればどのような状態に遷移するかを示す「構文解析表」を得ることができれば、その構文を解析するパーサを作成することができます。
パーサジェネレータは、構文規則を読み取ることでこの構文解析表をつくり上げるという処理を主に行います。&lt;/p&gt;

&lt;p&gt;字句解析器程度ならわざわざジェネレータを作らなくても、字句規則そのものを字句解析器に渡せば良い感じに字句解析してくれるようにできますが、パーサジェネレータも「構文解析表の構築後、それをもとにして構文解析を行う」ような機能がついていればそれはパーサであるとも言えます。
わざわざパーサとパーサジェネレータが分けられているのは、一つには計算資源の乏しかった昔はパーサジェネレータがオンメモリで展開した構文解析表をもとにそのままパーサとして振る舞うというようなことが少なく、構文解析表を与えることで「パーサのソースコード」を出力するようなものが一般的だったからではないかと思われます(適当な思いつきを言っています)。
実際、字句解析器のための「字句解析器ジェネレータ」も存在していますが、ここでは簡単のために字句解析器はコンストラクタに字句規則を与えれば勝手に良い感じの字句解析を行ってくれるものと思ってもらえればよいです。&lt;/p&gt;

&lt;h3 id=&#34;文脈自由言語について:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;文脈自由言語について&lt;/h3&gt;

&lt;p&gt;構文解析器が解析対象とする「言語」がどのようなものであるかについてはいろいろな定義がなされています。&lt;/p&gt;

&lt;p&gt;これについては、参考資料でも紹介した&lt;a href=&#34;https://twitter.com/ki6o4&#34;&gt;うさぎさん(@ki6o4)&lt;/a&gt;の&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kimiyuki.net/blog/2016/08/03/context-free-grammar/&#34;&gt;文脈自由文法とその構文解析法 &amp;middot; うさぎ小屋&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が詳しいため、こちらを参照していただくことをおすすめします。
ここでは、厳密な話はあまりせずにごくごく簡単に触れていこうと思います。&lt;/p&gt;

&lt;p&gt;構文解析の対象とするのは、基本的に文脈自由言語となります。
構文解析の手法にも様々なものがありますが、それらの手法の中には文脈自由言語すべてを解析できるわけではないものも多く、たとえばLR(1)法ならLR(1)文法やLR(1)言語というように、ある手法で解析できる文法や、解析できる言語全体をその手法の名前で表される言語として表現することがあります。&lt;/p&gt;

&lt;h3 id=&#34;解析手法と言語のクラス:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;解析手法と言語のクラス&lt;/h3&gt;

&lt;p&gt;いくつかの手法を主観を交えて乱暴に紹介していきます。&lt;/p&gt;

&lt;h4 id=&#34;先読み:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;先読み&lt;/h4&gt;

&lt;p&gt;**この項は下のLR法などの項を「先読み」してから戻ってきて読むことをおすすめします**&lt;/p&gt;

&lt;p&gt;たとえばLR(1)法のように、数字を括弧でくくって(k)と表現している手法がいくつかあります。このkは何文字先読みするかを示していて、たとえば(1)ならば1文字先読みするという意味です。
先読み数については、たとえばLR法については以下のようなことが言われています。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;LR(k)で表せる文法のクラス ⊆ LR(k+1)先読みで表せるクラス である&lt;/li&gt;
&lt;li&gt;LR(k)文法によって受理可能な言語のクラスは、LR(1)のそれと等しい&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.より、基本的には(1)について考えることが多いようです。&lt;/p&gt;

&lt;h4 id=&#34;ll-1-法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;LL(1)法&lt;/h4&gt;

&lt;p&gt;「再帰を使って構文解析する」という発想としては単純なもの。
LL(1)文法のクラスはLR(1)よりも大幅に小さいものの、それでもLALR(1)文法を外れた文法を解析できたりします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;S -&amp;gt; S + E
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような、右辺の一番左の場所に左辺の記号が登場するような「左再帰則」を読むことができません。ナンセンス。&lt;/p&gt;

&lt;h4 id=&#34;lr-0-法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;LR(0)法&lt;/h4&gt;

&lt;p&gt;先読み数が0なのでよわい。&lt;/p&gt;

&lt;h4 id=&#34;slr法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;SLR法&lt;/h4&gt;

&lt;p&gt;SLRのSはSimpleの意味です。LR(0)から単純な先読みを加えることでLR(0)よりも解析可能な文法が増えますが、それでもLALR(1)には及びません。&lt;/p&gt;

&lt;h4 id=&#34;lr-1-法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;LR(1)法&lt;/h4&gt;

&lt;p&gt;LR(0)に対し、1文字だけ先読みして次にどのような入力が期待されるかを判断。
LR(1)文法がそれなりに広いという点で優秀な一方、LR(0)に比べて構文解析表の大きさが爆発しやすいという欠点がある、と言われています。
しかし今の時代はそんなものは大した欠点になり得ない気がします。&lt;/p&gt;

&lt;h4 id=&#34;lalr-1-法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;LALR(1)法&lt;/h4&gt;

&lt;p&gt;プログラミング言語を解析するコンパイラなどによく使われている手法です。
LALR(1)のLAはLook-Aheadの略で、まずLR(1)法で構文解析表を作ってから、文法部分が同じで先読み記号だけが違うような状態をマージするという点がLR(1)法と異なります。
表を併合してしまうためにLR(1)法よりも解析可能な文法のクラスが小さくなるものの、実用上はほとんど問題にならず、LR(1)法の構文解析表が大きくなりすぎるという欠点を補える手法です。&lt;/p&gt;

&lt;p&gt;ただし、一度LR(1)法の表を作ること変わりはないのでメモリ消費量はそう変わらないし、大きなデータも問題なく扱える今の時代にわざわざ構文解析表を数十パーセント程度削減したところで何の意味があるのかという疑問があります。&lt;/p&gt;

&lt;p&gt;また、LALR法のLAはLook-Aheadの略だと言いましたが、注意しなければならないのは&lt;strong&gt;Look-Ahead(先読み)を行うのはLALR法固有の手法ではない&lt;/strong&gt;ということです。  先読み自体はLR(1)法でもやりますし、LALR(1)はあくまでLR(1)の先読み部分をマージしたものにすぎません。
私はLALR法の名前の付け方はあまり良くないと思っていて、MLR法(Merged Look-Ahead LR法)とかなんとか、そういう感じの名前に変えたほうが良いと思います。&lt;/p&gt;

&lt;h4 id=&#34;glr法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;GLR法&lt;/h4&gt;

&lt;p&gt;「あいまいな」解釈が可能な文法があった場合、考えられうるすべての可能性を探索してしまうことによって解決する手法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;「足の速い猫を追いかけるサザエさん」&lt;/code&gt;が足が速いのが猫とサザエさんの両方に解釈できるように、一つの入力に対して複数の結果が得られることがあります。
どちらかというと自然言語処理向きかもしれません。&lt;/p&gt;

&lt;h4 id=&#34;cyk法:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;CYK法&lt;/h4&gt;

&lt;p&gt;非常に強力なアルゴリズムにより、文脈自由言語すべてを高速に解析可能。
ただし、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;S -&amp;gt; NP VP
VP -&amp;gt; v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように、チョムスキー標準形といわれるような、「右辺が終端記号ちょうど2つか非終端記号1つでなければならない」、つまり結果として得られる構造が二分木になっていなければならないというナンセンスにも程がある制約を課されます(アルゴリズムの改良や規則の変換、得られた木構造の後処理などによって回避は可能ですが)。
そりゃあそれだけ制約が強ければ高速な処理も実現できるだろうと。&lt;/p&gt;

&lt;p&gt;よってCYK法で受理可能な言語は文脈自由言語の全体ですが、CKY文法(=チョムスキー標準系で書くことのできる文法)は著しく小さいと言える気がします。&lt;/p&gt;

&lt;h2 id=&#34;lr-1-パーサジェネレータをつくろう:4f3ac79f73d5f2d4c7087437a39bd22b&#34;&gt;LR(1)パーサジェネレータをつくろう&lt;/h2&gt;

&lt;p&gt;構文解析の大まかな流れはわかりました。
とりあえず字句規則と構文規則を用意して、あとはどうにかしてこの構文を読んでくれるようなパーサを用意すれば構文解析ができそうです(字句解析器なんてのは適当にやってもすぐ用意できます)。&lt;/p&gt;

&lt;p&gt;先ほど紹介したような手法によって構文ごとに一からパーサをプログラミングするようなことはやりたくないので、パーサジェネレータを用いてパーサを自動的に生成してもらえば事は済みそうですね。&lt;/p&gt;

&lt;p&gt;ここに&lt;a href=&#34;https://www.gnu.org/software/bison/&#34;&gt;Bison&lt;/a&gt;という有名なパーサジェネレータがあります。
今の時代にわざわざCやC++で構文解析なんてしたくないのでしたら、Pythonで&lt;a href=&#34;http://www.dabeaz.com/ply/&#34;&gt;PLY&lt;/a&gt;とか、Javascriptの&lt;a href=&#34;https://github.com/zaach/jison&#34;&gt;jison&lt;/a&gt;というものなど、いくらでも選択肢があります。
これらのうち一つを選んで、チュートリアルを読んでパーサを作っていくのがいいでしょう。&lt;/p&gt;

&lt;p&gt;というわけで、前段を書いていると結構分量が膨らんでしまったため、今回はここで区切ります。&lt;/p&gt;

&lt;p&gt;では次回からは、構文解析を行えるようになるため、LR(1)法を用いたパーサジェネレータを実際に作っていく流れを紹介していきたいと思います。&lt;/p&gt;

&lt;p&gt;えっちょっとまって、今パーサジェネレータは既存のものを使えばいいって言ったよね、ねえ&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Javaのリフレクションを悪用してクラス設計してみる</title>
      <link>http://tatamo.81.la/blog/2016/12/15/java-generics-and-reflection/</link>
      <pubDate>Thu, 15 Dec 2016 01:11:23 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/12/15/java-generics-and-reflection/</guid>
      <description>
        

&lt;p&gt;この記事は&lt;a href=&#34;http://www.adventar.org/calendars/1881&#34;&gt;Kobe University Advent Calendar 2016&lt;/a&gt;の14日の記事です。遅刻です。
なお私は当該大学の学部2年(2016年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最近、大学の授業などで少しだけJavaに触れる機会があったので、ちょっとした黒魔術っぽいことでもやってみようと思います。&lt;/p&gt;

&lt;p&gt;と思ったのですが、記事を書こうとして調べていたら普通に書きたかったことをわかりやすく書いている記事がありました。&lt;br /&gt;
* &lt;a href=&#34;http://d.hatena.ne.jp/Nagise/20131121/1385046248&#34;&gt;new T()したいケースへの対処法 - プログラマーの脳みそ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;もう帰っていいですかね。&lt;/p&gt;

&lt;h2 id=&#34;総称型tに対してt-classやnew-t-したい:c600ddb79433125511402a932eb728b1&#34;&gt;総称型Tに対してT.classやnew T()したい&lt;/h2&gt;

&lt;h3 id=&#34;ジェネリクスとは:c600ddb79433125511402a932eb728b1&#34;&gt;ジェネリクスとは&lt;/h3&gt;

&lt;p&gt;わざわざ書くまでもないとは思いますが、ジェネリクスについておさらいをしておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;ArrayList&amp;lt;String&amp;gt; strlist = new ArrayList&amp;lt;String&amp;gt;();
ArrayList&amp;lt;Integer&amp;gt; intlist = new ArrayList&amp;lt;Integer&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ArrayList&lt;T&gt;に対し、ジェネリクスとしてStringやIntegerなど、リストの要素として入れたい型をTの部分に具体的に書くことで、一つのクラスであるArrayListに利用者側が好きな要素を入れることができるようになります。&lt;/p&gt;

&lt;p&gt;ジェネリクスを用いて自分でメソッドを定義する場合は、以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public &amp;lt;T&amp;gt; void doSomething(T arg){
	// doSomething
}

// TをSomeClassのサブクラスに限定する
public &amp;lt;T extends SomeClass&amp;gt; void notDoAnything(T arg){
	return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらのメソッドを呼び出すときは、&lt;code&gt;hoge.&amp;lt;SomeClass&amp;gt;doSomething();&lt;/code&gt;のようになります。&lt;br /&gt;
どうして&lt;code&gt;hoge.doSomething&amp;lt;SomeClass&amp;gt;();&lt;/code&gt;じゃないんだろう。&lt;/p&gt;

&lt;h3 id=&#34;ジェネリクスはt-classやnew-t-をさせてくれない:c600ddb79433125511402a932eb728b1&#34;&gt;ジェネリクスはT.classやnew T()をさせてくれない&lt;/h3&gt;

&lt;p&gt;Javaのジェネリクスでは、以下のコードはコンパイルエラーとなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public &amp;lt;T extends SomeClass&amp;gt; List&amp;lt;T&amp;gt; getSubClassList(List&amp;lt;SomeClass&amp;gt; list){
	return list
		.stream()
		.filter(value -&amp;gt; value instanceof T) // ここでlistの要素valueがTのインスタンスかどうか判別したい -&amp;gt; error
		.collect(Collectors.toList());
}

public &amp;lt;T extends SomeClass&amp;gt; List&amp;lt;T&amp;gt; getSubClassList2(List&amp;lt;SomeClass&amp;gt; list){
	return list
		.stream()
		.filter(value -&amp;gt; value.getClass() == T.class) // instanceofがだめならclassを取得して判別したい -&amp;gt; error
		.collect(Collectors.toList());
}

public &amp;lt;T&amp;gt; void doSomething(String arg){
	T foo = new T(arg); // T型の新しいインスタンスfooを作りたい -&amp;gt; error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ジェネリクス型に対して、hoge instanceof T、T.class、new T()といった操作を行うことはできません。
残念でしたね。&lt;/p&gt;

&lt;h2 id=&#34;なぜしたいのか:c600ddb79433125511402a932eb728b1&#34;&gt;なぜしたいのか&lt;/h2&gt;

&lt;h3 id=&#34;もしかして-設計が間違っている:c600ddb79433125511402a932eb728b1&#34;&gt;もしかして： 設計が間違っている&lt;/h3&gt;

&lt;p&gt;先ほどのgetSubClassListメソッドを見てみましょう。
正しく動くかどうかはさておき、やりたいことは以下の通りです：&lt;br /&gt;
* SomeClassとそのサブクラスを含んだリストlistの要素のうち、SomeClassのサブクラスTのインスタンスだけを要素とする新しいリストを取得したい。&lt;/p&gt;

&lt;p&gt;そもそも、抽象化された集合から具体的なクラスのインスタンスを取り出そうとすること自体がオブジェクト指向やポリモーフィズムの考え方に対する反逆である可能性があります。&lt;/p&gt;

&lt;p&gt;SomeClassのリストであるlistをイテレートして、それぞれの要素のdoSomething()メソッドを呼べば、あとはそれがSomeClassのインスタンスであろうと、もしくはSomeClassを継承した別のクラスのインスタンスであろうと、外部からはただdoSomething()メソッドを呼ぶだけで操作が完結していなければなりません。
それがサブクラス固有のふるまいをするとしても、その実装はそのクラス自身に隠蔽されるべきなのです。&lt;/p&gt;

&lt;p&gt;よって、サブクラスだけを取り出そうとする試み自体がナンセンスなものである可能性が非常に高く、まずそのような試みが必要になる設計そのものを見直す必要があります。&lt;/p&gt;

&lt;p&gt;終わり。&lt;/p&gt;

&lt;h3 id=&#34;そうも言っていられない:c600ddb79433125511402a932eb728b1&#34;&gt;そうも言っていられない&lt;/h3&gt;

&lt;p&gt;実際その通りなのですが、それではこの記事が続きません。&lt;/p&gt;

&lt;p&gt;ここからは、少し具体的なプログラムの設計を例にとって考えてみたいと思います。&lt;br /&gt;
あなたはちょっとしたゲームを作るためのフレームワークを作っています。
その一部分が以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;// 抽象的なゲーム内エンティティクラス
public abstract class Entity {
	private int x;
	private int y;
	public Entity(int x, int y){
		this.setX(x);
		this.setY(y);
	}
	public int getX() { return x; }
	public void setX(int x) { this.x = x; }
	public int getY() { return y; }
	public void setY(int y) { this.y = y; }

	public abstract void update(EntityManager manager);
}

// なんでもかんでも××Managerという名前を付けるのはやめましょう
public class EntityManager {
	private ArrayList&amp;lt;Entity&amp;gt; all_entities;
	public EntityManager(){
		this.all_entities = new ArrayList&amp;lt;Entity&amp;gt;();
	}
	public void add(Entity e){
		this.all_entities.add(e);
	}
	public ArrayList&amp;lt;Entity&amp;gt; getAll() {
		return new ArrayList&amp;lt;Entity&amp;gt;(this.all_entities);
	}
	public void updateAll(){
		this.all_entities.forEach(e-&amp;gt;e.update(this));
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なんのことはありませんね。
ゲーム内に登場するエンティティを表す抽象クラスEntityを作り、それをEntityManagerで管理します(なんでもかんでも××Managerという名前を付けるのはManagerクラスの肥大化を招きかねないため避けるべきであるなどという話もありますが、今回は置いておきます)。
たとえば毎フレームごとにメインループ内で&lt;code&gt;EntityManager#updateAll()&lt;/code&gt;を呼び出すことで、全てのエンティティの更新を行ったりすることが想定されます。
オーソドックスなループ駆動型のゲームプログラム設計です。&lt;br /&gt;
Entityインスタンスを作成するためのFactory Methodパターンを使うべきとか、そういう話もあっちでやってください。&lt;/p&gt;

&lt;p&gt;あとは、このフレームワークの利用者にはEntityクラスを継承したクラスを作らせ、それをもとにゲームを作ってもらえればいいだけです。
以下のクラスを追加してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;// あなたです
public class Player extends Entity{
	private int hp; // プレイヤーはヒットポイントを持ちます
	public Player(int x, int y, int hp){
		super(x, y);
		this.setHp(hp);
	}
	public int getHp() { return hp; }
	public void setHp(int hp) { this.hp = hp; }
	@Override
	public void update(EntityManager manager){
		// プレイヤーが動きます
	}
}

// 敵です
public class Enemy extends Entity {
	private int damage; // 敵がプレイヤーに与えることのできるダメージ値です
	public Enemy(int x, int y, int damage){
		super(x, y);
		this.setDamage(damage);
	}
	public int getDamage() { return damage; }
	public void setDamage(int damage) { this.damage = damage; }
	@Override
	public void update() {
		// 敵が動きます
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プレイヤーと敵を登場させました。
常命の者であるプレイヤーにはヒットポイントが定められており、敵はこれを脅かすダメージ値を持っています。&lt;/p&gt;

&lt;p&gt;注意しておく必要があるのは、これらのクラスはあくまでフレームワークの利用者が作るものだということです。
よって、EntityクラスやEntityManagerクラスからはこのようなEntityサブクラスの存在を知ることはできません。&lt;br /&gt;
知る必要もないというのがオブジェクト指向の考え方だったはずです。
そうですよね？&lt;/p&gt;

&lt;p&gt;ここで、「敵のダメージ値を参照して、プレイヤーのヒットポイントを減らす」処理をしたいという需要が当然生まれます。
実装の方法はいろいろあると思いますが、ひとまずこの処理を、Enemyのメソッドとして書いてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;// 敵です
public class Enemy extends Entity {
	private int damage; // 敵がプレイヤーに与えることのできるダメージ値です
	public Enemy(int x, int y, int damage){
		super(x, y);
		this.setDamage(damage);
	}
	public int getDamage() { return damage; }
	public void setDamage(int damage) { this.damage = damage; }
	@Override
	public void update(EntityManager manager) {
		// 敵が動きます
		// プレイヤーがいたらダメージを与えます
		manager.getAll().forEach((entity)-&amp;gt;{ // 全てのエンティティを調べる
			if(entity instanceof Player){ //  エンティティがプレイヤーなら
				if(this.getX() == entity.getX() &amp;amp;&amp;amp; this.getY() == entity.getY()){ // プレイヤーと敵の座標が同じなら
					this.doDamage((Player) entity); // ダメージを与える
				}
			}
		});
	}
	public void doDamage(Player p){
		p.setHp(p.getHp() - this.getDamage()); // プレイヤーのヒットポイントをダメージ値分だけ減らします
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここであなたは気を利かせます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;manager.getAll().forEach((entity)-&amp;gt;{
	if(entity instanceof Player){
		if(...){
			...
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この部分です、どう見ても冗長ですし、いちいち全エンティティのリストをforEachで回しているので高速化も望めませんし、同様のコードクローンが至る所に発生するのは目に見えています。&lt;/p&gt;

&lt;p&gt;できるならたとえばこう書きたい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;manager.&amp;lt;Player&amp;gt;getAllOfSubClass().forEach((player)-&amp;gt;{
	if(...){
		...
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでPlayerクラスだけが得られるなら、呼び出し側のコード量は減りますし、もしあなたがO(n^2)の処理をO(nlogn)に落とすような作業に慣れているなら、Managerクラスの内側でより高速になるような最適化を行い、その実装も内部に隠蔽することができます。&lt;/p&gt;

&lt;p&gt;また、ゲームのセーブとロードをするときのことも考えてみます。
たとえばデータのセーブを行うときはとりあえずオブジェクトを文字列化するとして、&lt;br /&gt;
&lt;code&gt;public String Entity#serialize()&lt;/code&gt;などといったメソッドを作ってセーブし、ロード時には文字列配列を引数として受け取るようオーバーロードされたコンストラクタを使用してオブジェクトを再生成するといったことが考えられます。
そういうことはFactory Methodあたりに委譲するべきな気もしますし、うまくやらないとフレームワークの利用者側の負担が増える気もしますが、今は置いておきます。&lt;/p&gt;

&lt;p&gt;結局、セーブデータのロード時にこのようなコードを書くことになるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;	public &amp;lt;E extends Entity&amp;gt; E createEntity(List&amp;lt;String&amp;gt; args){ // 可変長引数としてもよい
		return new E(args); // ジェネリクス型はnewできない -&amp;gt; error
	}
	public loadSaveData(SaveData savedata){
		// セーブデータから1行ずつ読み込んでオブジェクトを再生成する
		... {
			entityManager.add(this.createEntity(agrs));
		}
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかしジェネリクス型はnewできないため、コンパイルエラーとなります。&lt;/p&gt;

&lt;h2 id=&#34;解決策:c600ddb79433125511402a932eb728b1&#34;&gt;解決策&lt;/h2&gt;

&lt;p&gt;さて、だいぶん勿体つけたが、解決編に入ろう。&lt;/p&gt;

&lt;p&gt;……というか、例として取り上げた題材が無理やりすぎた気がしてやる気が尽きかけてきました。&lt;/p&gt;

&lt;h3 id=&#34;リフレクションを使用する:c600ddb79433125511402a932eb728b1&#34;&gt;リフレクションを使用する&lt;/h3&gt;

&lt;p&gt;Javaにはリフレクションという機能があり、プログラムの実行中にクラス名やメソッド名を動的に取り扱うことができます。
これのClass&lt;T&gt;型を、ジェネリクスと併用しましょう。
&lt;code&gt;EntityManager#getAllOfSubClass&lt;/code&gt;メソッドを考えてみます。
実装は以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;	@SuppressWarnings(&amp;quot;unchecked&amp;quot;)
	public &amp;lt;E extends Entity&amp;gt; List&amp;lt;E&amp;gt; getAllOfSubClass(Class&amp;lt;E&amp;gt; cls){
		return (List&amp;lt;E&amp;gt;) all_entities.stream()
			.filter(entity -&amp;gt; entity.getClass() == cls)
			.collect(Collectors.toList());
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを呼び出す際は、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;entityManager.getAllOfSubClass(Player.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにして、Class型の&lt;code&gt;クラス名.class&lt;/code&gt;を引数として与えます。
ここで型推論が働くので、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;entityManager.&amp;lt;Player&amp;gt;getAllOfSubClass(Player.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにPlayerクラス名を2度も書く必要はありません。&lt;/p&gt;

&lt;p&gt;また、Playerクラスだけでなく、Playerクラスを継承したクラスも含めて判別したいときは、以下のようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;	@SuppressWarnings(&amp;quot;unchecked&amp;quot;)
	public &amp;lt;E extends Entity&amp;gt; List&amp;lt;E&amp;gt; getAllOfSubClass(Class&amp;lt;E&amp;gt; cls){
		return (List&amp;lt;E&amp;gt;) all_entities.stream()
			.filter(entity -&amp;gt; cls.isAssignableFrom(entity.getClass()))
			.collect(Collectors.toList());
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;createEntity&lt;/code&gt;メソッドも、以下のようにすれば書くことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;	public &amp;lt;E extends Entity&amp;gt; E createEntity(Class&amp;lt;E&amp;gt; cls, List&amp;lt;String&amp;gt; args){
		// cls型のString[]を引数にとるコンストラクタを呼び出す
		return cls.getConstructor(new Class&amp;lt;?&amp;gt;[] { String[].class }).newInstance(args);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やや黒魔術じみてきました。
実際にはE型がString[]を引数にとるコンストラクタを持つということが担保されていないためこれだけでは動かず、例外回避のためにいろいろやる必要があります。&lt;/p&gt;

&lt;p&gt;最初の例に戻ってみましょう。&lt;code&gt;getSubClassList&lt;/code&gt;は、以下のように書けます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public &amp;lt;T extends SomeClass&amp;gt; List&amp;lt;T&amp;gt; getSubClassList(List&amp;lt;SomeClass&amp;gt; list, Class&amp;lt;T&amp;gt; cls){
	return list
		.stream()
		.filter(value -&amp;gt; value.getClass() == cls)
		.collect(Collectors.toList());
}

// 呼び出し側
getSubClassList(list, SubClassOfSomeClass.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;めでたしめでたし。&lt;/p&gt;

&lt;h3 id=&#34;おまけ:c600ddb79433125511402a932eb728b1&#34;&gt;おまけ&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public &amp;lt;T&amp;gt; int getStaticValue(Class&amp;lt;T&amp;gt; cls) throws Exception{ // なにがthrows Exceptionだやる気あんのか
	return (int) cls.getMethod(&amp;quot;getStaticValue&amp;quot;).invoke(null);
}

// 呼び出し
getStaticValue(SomeClass.class); // SomeClass.getStaticValue() を呼んでいるのと同じになる
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;staticメソッドも呼び出し可能なうえ、「そのクラスに与えられた名前のstaticメソッドが存在しない場合、その親クラスの同名のstaticメソッドを呼び出す」というようなふるまいを疑似的に再現することも可能です。&lt;/p&gt;

&lt;h2 id=&#34;おわり:c600ddb79433125511402a932eb728b1&#34;&gt;おわり&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Class&amp;lt;T&amp;gt; cls&lt;/code&gt;を引数にとり、&lt;code&gt;value.getClass() == cls&lt;/code&gt;で比較を行うのは、実質的にはinstanceofの迂回といえます。&lt;br /&gt;
この程度なら型安全性は一応担保されますが、コンストラクタやメソッドの取得と呼び出しまで始めた場合、throw宣言やcatch節が山のように膨らんだり、メソッドの存在確認や型の確認などに多大なコストを支払う必要がありそうです。
実際に使用するには相当の覚悟を必要とするでしょう。&lt;strong&gt;やめましょう。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;自分でプログラムを組んでいる際にこのような需要が発生することが時々あったので、Javaではリフレクションを使うことで強引に解決できると知って記事を書いてみましたが、自分の中ではむしろ「設計が悪い」の一言に実感が沸くという結果となった気がします。&lt;br /&gt;
今回例に挙げたゲームプログラムの設計はまさしく昔私が作ったものそのものなのですが、記事を書く上で「リフレクションを使いたい理由付け」を明確にしようとすればするほど、その理由が無理やりなものにしかならないのではないかという気持ちに陥りました。
途中まで書いた記事がグダグダになりそうな予感がしてくると結構精神的につらい。&lt;br /&gt;
……うーん。Abstract Factoryパターンとか、もととなるクラスが増えるとそれに合わせてFactoryクラスも増やさないといけないのがあまり好きじゃないので、そのあたりも動的になんとかできないかなどと思っていたのですが、なかなか難しいようです。&lt;/p&gt;

&lt;p&gt;私感としては、instanceof Tの代用としてClass型を使用する程度は許容できますが、普通のプログラムを書くならそれ以上は安易に手を出すべきではないという印象です。&lt;/p&gt;

&lt;p&gt;プログラミングをするときはまともな設計をするようにしましょう。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>FreecivCalc2を公開しました</title>
      <link>http://tatamo.81.la/blog/2016/05/26/freecivcalc2-released/</link>
      <pubDate>Thu, 26 May 2016 15:47:37 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/05/26/freecivcalc2-released/</guid>
      <description>
        

&lt;p&gt;Freecivのユニット同士の戦闘勝率を手軽に行えるソフトであるFreecivCalcの新バージョン、FreecivCalc2を公開しました。&lt;/p&gt;

&lt;p&gt;FreecivCalc2: &lt;a href=&#34;http://tatamo.81.la/freecivcalc2/&#34;&gt;http://tatamo.81.la/freecivcalc2/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以前から公開していた&lt;a href=&#34;http://m06t625.81.la/files/FreecivCalc.html&#34;&gt;FreecivCalc&lt;/a&gt;はSilverlight上で動作するソフトのため、現状では動作するブラウザがほとんどなくなってきています。&lt;/p&gt;

&lt;p&gt;そこでHTML5+JavaScript/TypeScriptに移植し、機能やインターフェースを大幅に見直したFreecivCalc2を開発しました。&lt;/p&gt;

&lt;p&gt;Chrome, Opera, Firefox, Edgeでの動作を確認しています。&lt;/p&gt;

&lt;h2 id=&#34;freecivcalc2の新機能:0fe09111c483b88d0d4fda3fcdc49d63&#34;&gt;FreecivCalc2の新機能&lt;/h2&gt;

&lt;p&gt;FreecivCalc2の画面からユニットを選択し、各種補正情報を入力することで戦闘勝率を表示できます。また詳細結果タブを開くことで、戦闘後のユニットHPの期待値を表示できるほか、タブを保持しておくことで復数の戦闘の予測結果を見比べることなどができます。&lt;/p&gt;

&lt;p&gt;従来バージョンでは、地形による防御ボーナスの適用の可否や特定のユニット同士の戦闘にかかる特殊補正などの補正の情報を手動で入力する必要がありました。
FreecivCalc2ではこれらの特殊補正は自動で適用されるため、Freecivの複雑な戦闘補正を十分に把握していない場合でも正確に戦闘勝率の予測が可能です。
ユニットにかけられている補正の一覧は、詳細結果タブ内で確認することができます。&lt;/p&gt;

&lt;h2 id=&#34;複数の言語-多様なルールセットに対応可能な拡張性:0fe09111c483b88d0d4fda3fcdc49d63&#34;&gt;複数の言語、多様なルールセットに対応可能な拡張性&lt;/h2&gt;

&lt;p&gt;戦闘補正の自動適用を実現するために、ユニットの情報や補正の条件など、ルールセットに関連するすべての情報を外部データ化しました。
これによってclassicルールセットだけでなく、多様なルールセットに対応することが可能です。
同時に、FreecivCalc2のインターフェース部分もテンプレートを用いて外部ファイルからコンテンツ内容を流し込んでいるため、容易に多言語化が可能になっています。&lt;/p&gt;

&lt;p&gt;現状では、classicルールセットを日本語および英語の2か国語で対応しています。&lt;/p&gt;

&lt;h2 id=&#34;開発について:0fe09111c483b88d0d4fda3fcdc49d63&#34;&gt;開発について&lt;/h2&gt;

&lt;p&gt;FreecivCalc2は三条項BSDライセンス下で公開されています。&lt;/p&gt;

&lt;p&gt;ローカル環境でのビルド、他のルールセットや言語に対応させるためのデータセットの文法などについては&lt;a href=&#34;https://github.com/Tatamo/freecivcalc2&#34;&gt;GitHubリポジトリ&lt;/a&gt;上で記述しているため、そちらを参照してください。&lt;/p&gt;

&lt;p&gt;FreecivCalc2は大半をTypeScriptで、jQuery UIのウィジェット定義など一部を生のJavaScriptで書いています。&lt;/p&gt;

&lt;p&gt;また使用したライブラリはjQuery, jQuery UI, amChartsです。
当初jQueryを使う予定はなかったのですが、ユニット選択用のUIとしてコンボボックスを実現するためのライブラリを探していたところjQuery UIが最も用途に適っていたため採用し、その流れでjQueryも使用することになりました。
amChartsは簡単にグラフを表示できるライブラリとして使いやすそうだったため使用しました。&lt;/p&gt;

&lt;p&gt;その他、外部JSONファイルからテンプレートを通してHTMLファイルを生成するためのテンプレートエンジンとしてEJSを使用しました。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Hugoを導入してブログを作った デプロイ編</title>
      <link>http://tatamo.81.la/blog/2016/01/05/hugo-deployment/</link>
      <pubDate>Tue, 05 Jan 2016 20:50:32 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2016/01/05/hugo-deployment/</guid>
      <description>
        

&lt;p&gt;&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;によって構築したサイトを、GitHub,Wercker,DeployBotを経由してWebサーバー上にデプロイした流れです。今回はHugo自体はほとんど触れていません。&lt;/p&gt;

&lt;h2 id=&#34;werckerを使って自動ビルドする:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;Werckerを使って自動ビルドする&lt;/h2&gt;

&lt;p&gt;まずはビルドを手元ではなくオンライン上で自動的に行うようにします。
記事を書いて反映させる際は記事編集→ビルド→アップロードという3つの手順を踏みますが、これによってビルド作業を手元で行わなくてもよくなります。
また、Hugoの環境がなくても、gitさえ使うことができれば記事の更新を行うことができるようになります。&lt;/p&gt;

&lt;p&gt;今回使用した&lt;a href=&#34;http://wercker.com/&#34;&gt;Wercker&lt;/a&gt;は、このような自動ビルド作業およびデプロイ作業を自動化してくれるCIサービスです。
Werckerを利用した自動デプロイは、&lt;a href=&#34;https://gohugo.io/tutorials/automated-deployments/&#34;&gt;Hugoの公式ドキュメント&lt;/a&gt;に記事があるため、これを参考に行います。
この記事はGitHub Pagesへのデプロイまで解説してありますが、今回の環境ではFTPによるサーバーへのアップロードが必要だったため、もうひと手間かける必要がありました。&lt;/p&gt;

&lt;h3 id=&#34;wercker-ymlの記述:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;wercker.ymlの記述&lt;/h3&gt;

&lt;p&gt;公式ドキュメントによる解説にも書いてありますが、Werckerによる自動ビルド/デプロイを利用するには、対象のGitHubリポジトリ内にwercker.ymlというファイルを作成し、そこに設定やビルド時の処理を記述する必要があります。
既にHugoビルド用の設定を作ってくれている人がいるので、それを利用すれば簡単にビルドができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;box: debian 
build:
  steps:
    - arjen/hugo-build:
        version: &amp;quot;0.14&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけでHugoのビルドが可能です。
ビルドが完了しただけではまだ目的のサーバーにHugoサイトがアップロードされていませんので、続いてデプロイの設定を行います。&lt;/p&gt;

&lt;h2 id=&#34;werckerとdeploybotを使って自動デプロイする:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;WerckerとDeployBotを使って自動デプロイする&lt;/h2&gt;

&lt;p&gt;前述のように、今回使用している環境ではWebサーバーにFTPでアップロードすることが目的のため、デプロイはwerckerからlftpを使用して行おうとしましたが、うまくいきませんでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;box: debian 
build:
  steps:
    - arjen/hugo-build:
        version: &amp;quot;0.14&amp;quot;
deploy:
  steps:
    - install-packages:
        packages: lftp
    - script:
        name: mirror over lftp
        code: |
            lftp -u $DEPLOY_FTP_USER,$DEPLOY_FTP_PASS -e &amp;quot;set ftp:passive-mode off;set ftp:ssl-allow off;set net:timeout 5;set net:max-retries 3;set net:reconnect-interval-max 60;mirror -enR public /blog;quit&amp;quot; $DEPLOY_FTP_SERVER
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lftpでの接続に失敗し、アップロードを行うことができませんでした。
PASVモードのon/off、sslを使用しないようにするなどのオプションを試みましたが、コネクションがうまく確立できず失敗しました。&lt;/p&gt;

&lt;p&gt;後日また調べてみたいと思っていますが、ひとまずFTPでのアップロードを行うため、別のサービスを利用することにしました。
&lt;a href=&#34;http://deploybot.com/&#34;&gt;DeployBot&lt;/a&gt;は1プロジェクトまで無料で利用できるサービスで、FTPによるアップロードにも対応しているため、これを利用しました。
DeployBotによるデプロイは、&lt;a href=&#34;http://creative-tweet.net/blog/2015/10/usage-hugo-2.html&#34;&gt;Hugoをセットアップしてデプロイするまで［後編］CIサービスでビルドからデプロイを自動化するまで | creative tweet.&lt;/a&gt;で解説されているので、ここを参考にして行いました。&lt;/p&gt;

&lt;p&gt;全体としては、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;記事を書いてGitHub上にpushする&lt;/li&gt;
&lt;li&gt;Werckerが更新を検知して自動的にビルドを行い、別のGitHubリポジトリを更新する&lt;/li&gt;
&lt;li&gt;そのリポジトリの更新を検知してDeployBotによって自動的にサーバーへアップロードする&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;というような流れでのデプロイを行いました。&lt;/p&gt;

&lt;p&gt;Werckerから別のGitHubリポジトリへのpushを行うようにするため、公式ドキュメントに書かれている通りにwercker.ymlを書き換えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;box: debian 
build:
  steps:
    - arjen/hugo-build:
        version: &amp;quot;0.14&amp;quot;
deploy:
  steps:
    - install-packages:
        packages: git ssh-client
    - leipert/git-push:
        gh-oauth: $GIT_TOKEN
        basedir: public
        repo: $GITHUB_REPO
        clean_removed_files: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$GIT_TOKEN&lt;/code&gt;および&lt;code&gt;$GITHUB_REPO&lt;/code&gt;は、werckerの設定画面でdeploy targetごとに変数を定義できるため、そこに記述します。$GIT_TOKENはprotectedにチェックを入れ、外部から取得できないようにしておきます。&lt;/p&gt;

&lt;p&gt;あとはwerckerのデプロイ先に指定したGitHubリポジトリをDeployBotに登録するだけです。
DeployBotはリポジトリが更新されるとその内容をそのままサーバー上へアップロードしてくれ、設定も簡単でした。
これで目的のサーバーへの自動デプロイが完了しました。&lt;/p&gt;

&lt;h2 id=&#34;補足など:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;補足など&lt;/h2&gt;

&lt;h3 id=&#34;githubリポジトリの分割:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;GitHubリポジトリの分割&lt;/h3&gt;

&lt;p&gt;Hugoのビルドをローカルでは行わないようにしたため、リポジトリ内に/publicを含める必要がありません。.gitignoreに次の行を記述します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public/
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;リポジトリA:publicディレクトリを除くHugoディレクトリ&lt;/li&gt;
&lt;li&gt;リポジトリB:生成されたpublicディレクトリの内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;というようなGitHubリポジトリ構成とし、リポジトリBはWerckerとDeployBotをリンクさせるために使用するため手動では触れません。&lt;/p&gt;

&lt;h3 id=&#34;werckerの設定:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;Werckerの設定&lt;/h3&gt;

&lt;h4 id=&#34;dockerの使用:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;Dockerの使用&lt;/h4&gt;

&lt;p&gt;Werckerにプロジェクトを登録する際、wercker.yml設定の項目で「Dockerを使用する」かどうかのチェックボックスが存在します。
Werckerで使用するboxはDockerを使用しているものと使用していないものがあり、Hugo公式ドキュメントで使用しているbox:debianなどはDockerを使用しているため、Docker使用の設定をオンにしておかないと、&lt;a href=&#34;http://thleap.net/blog/recovering-wercker/&#34;&gt;boxが見つからないというエラー&lt;/a&gt;が発生します。
逆にwercker/defaultなどのDockerを使用しないboxを使用する場合、設定をオンにしておく必要はないでしょう。
(なお私はWerckerのBoxについてはよくわかっていません。Hugoをデプロイする場合は公式ドキュメント通りにdebianを使用すればいいのではないでしょうか。wercker/defaultでは環境のセットアップに15秒ほどかかりますが、debianでは1秒で済みます。)&lt;/p&gt;

&lt;h4 id=&#34;デプロイターゲット登録時のauto-deploy設定:288053c42ac37fddb3dbfcd51f807cce&#34;&gt;デプロイターゲット登録時のAuto deploy設定&lt;/h4&gt;

&lt;p&gt;ちょっとしたこと(というかちゃんと読めばわかること)ですが、werckerででプロイターゲットを登録する時、&amp;rdquo;auto deploy successful builds to branch(es):&amp;ldquo;という設定項目でブランチ名を指定する箇所がありますが、これはどのブランチが更新されたときに自動的にビルドが走るかを指定するものであり、デプロイ先のブランチ名を指定するものではありません。
GitHubからGitHubへのデプロイを行うときは少し混乱するかもしれません。&lt;/p&gt;

&lt;p&gt;なお、デプロイ先のGitHubブランチ名は前述したwercker.yml内に指定する箇所があります。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上で、Hugoで生成したサイトを自動的にデプロイすることができました。
とはいえWerckerから直接デプロイすることに失敗したためにやや回りくどい方法をとっており、いずれ改善したいと思っています。&lt;/p&gt;

&lt;p&gt;Werckerはビルドごとに環境を最初から設定するため、ライブラリのインストールなども毎回行われ、ビルド環境が整うまでに1分ほどかかります。
手元でビルドができる環境ならばローカルでビルドしてアップロードしたほうが明らかに速いので、すぐに更新したいときなどはデプロイまでにかなり時間がかかる印象を受けます。
Werckerを経由せず、手動でアップロードできる方法も用意しておいたほうがいいのかもしれません。&lt;/p&gt;

&lt;p&gt;また、稀にですがWerckerのビルドが最初のsetup environmentの段階で動かなくなり、Abortも効かない状態でビルドに失敗したことがありました。
デプロイを自動で行っているとはいえ、結局デプロイがうまくいったかどうか確認しないといけないのは問題かもしれません。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Hugoを導入してブログを作った サイト構築編</title>
      <link>http://tatamo.81.la/blog/2015/12/17/hugo-implementation/</link>
      <pubDate>Thu, 17 Dec 2015 03:51:04 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2015/12/17/hugo-implementation/</guid>
      <description>
        

&lt;p&gt;この記事は&lt;a href=&#34;http://www.adventar.org/calendars/891&#34;&gt;KobeUniv Advent Calendar 2015&lt;/a&gt;の17日の記事です。なんとか期日に間に合いそうです。
なお私は当該大学の学部1年(2015年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;このブログを作るにあたって、&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;を使用しました。
Hugoを用いたサイト構築の基本的な考え方や流れの紹介、その際に詰まったことなど。&lt;/p&gt;

&lt;h2 id=&#34;そもそもhugoって何:618f10612e6a9a223dbbbddb739583ff&#34;&gt;そもそもHugoって何&lt;/h2&gt;

&lt;p&gt;静的なWebサイトを生成するためのエンジンです。
つまり:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;まずレイアウトを用意します&lt;/li&gt;
&lt;li&gt;次に記事を書きます&lt;/li&gt;
&lt;li&gt;hugoを実行します&lt;/li&gt;
&lt;li&gt;記事がHTMLに変換され、Webサイトが生成されます&lt;/li&gt;
&lt;li&gt;生成されたサイトをまるごとサーバーにアップロードします&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;これでWebサイトの完成というわけです。
あくまで静的なサイトなので、サーバーサイドでプログラムを走らせる必要もありません。&lt;/p&gt;

&lt;h2 id=&#34;hugoを使ってみる:618f10612e6a9a223dbbbddb739583ff&#34;&gt;Hugoを使ってみる&lt;/h2&gt;

&lt;p&gt;Hugoのインストール等については、既に多くの情報がネット上にあるため割愛します。&lt;/p&gt;

&lt;h3 id=&#34;hugoの基本的なディレクトリ構成:618f10612e6a9a223dbbbddb739583ff&#34;&gt;Hugoの基本的なディレクトリ構成&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo new site name_of_my_site
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行することで、サイト用のディレクトリが生成されます。
中には、config.tomlといくつかのディレクトリが生成されているはずです。
config.tomlはサイト全体の設定を記述するファイルです。なお、代わりにconfig.yamlとしてYAMLで記述することなども可能です。お好みで変更しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd name_of_my_site/
$ ls -p
archetypes/  config.toml  content/  data/  layouts/  static/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;contentディレクトリは、記事ファイルを配置する場所です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo new hoge.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとするとcontent内にmdファイル(記事は主にMarkdownで記述します)が生成されますので、これを編集して記事を作ることになります。&lt;/p&gt;

&lt;p&gt;また、layoutディレクトリにはWebサイトの基礎となるテンプレートを配置します。
基本的には独自のテンプレート記法が用いられたhtmlファイルを使います。
既存のテーマを利用する場合は、themesディレクトリを作り、そこに同様のテンプレートが同梱されたテーマを配置することになります。&lt;/p&gt;

&lt;p&gt;staticディレクトリには、CSSや画像などの静的なファイルを配置します。
このディレクトリ内にあるファイルは、生成時にサイトのルートディレクトリにそのままコピーされます。&lt;/p&gt;

&lt;p&gt;基本的には、この3つ(または4つ)のディレクトリの働きを把握しておけば、Hugoでサイトを作りはじめるのに不足はないかと思われます。&lt;/p&gt;

&lt;p&gt;また、hugoコマンドなどによって生成された完成品のサイトは、publicというディレクトリが作られてそこに配置されます。
サイトを公開するときは、publicディレクトリ下に生成されたファイルをすべてアップロードします。
なお、publicディレクトリ内に不要になったファイルがあったとしても、サイト生成時に削除されません。本番サイトの生成時にはpublicディレクトリを一度削除してからビルドを行うのが良いと思われます。&lt;/p&gt;

&lt;h3 id=&#34;レイアウトしてみる:618f10612e6a9a223dbbbddb739583ff&#34;&gt;レイアウトしてみる&lt;/h3&gt;

&lt;h4 id=&#34;テーマを使う:618f10612e6a9a223dbbbddb739583ff&#34;&gt;テーマを使う&lt;/h4&gt;

&lt;p&gt;いくつものHugoのレイアウトが&lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;公開されて&lt;/a&gt;います。基本的には、この中から気に入ったものを使うのが良さそうです。themesディレクトリ直下にテーマごとのディレクトリを作り、その中にテーマファイルを配置します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone --recursive https://github.com/spf13/hyde themes/hyde
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テーマを適用するときは、configファイル内でテーマを指定するか、hugoコマンドの実行時に&lt;code&gt;hugo -t hyde&lt;/code&gt;または&lt;code&gt;hugo server -t hyde&lt;/code&gt;のように-tオプションでテーマを指定します。ここで指定するテーマ名は、themes直下に配置したディレクトリの名前となります。
テーマを適用すると、hugoディレクトリ直下のファイルが読み込まれるよりも先に、そのテーマディレクトリ下に存在するファイルが読み込まれるようになります。&lt;/p&gt;

&lt;p&gt;既存のテーマを使用する場合、テーマによってconfigに記述する必要のある内容が大きく異なる可能性があります。READMEにどのような項目を記述すればいいかが書かれていると思いますので、必ず確認するのがいいでしょう。&lt;/p&gt;

&lt;h4 id=&#34;自分でレイアウトする:618f10612e6a9a223dbbbddb739583ff&#34;&gt;自分でレイアウトする&lt;/h4&gt;

&lt;p&gt;HugoはGo言語のテンプレートエンジンを使用しており、各種パラメータを呼び出したり、部分ごとにHTMLファイルを分けて再利用することでサイトのレイアウトを記述していくことができます。&lt;/p&gt;

&lt;p&gt;自分でHugoサイトをレイアウトする場合、確実に一定の学習コストが必要となるので、ここでは詳細には触れません。Hugoは公式ドキュメントが充実しているので、&lt;a href=&#34;https://gohugo.io/tutorials/creating-a-new-theme/&#34;&gt;公式チュートリアル&lt;/a&gt;などから始めるのがいいでしょう。また基本的なことであれば調べれば日本語の情報も得られると思います。&lt;/p&gt;

&lt;h2 id=&#34;詰まったことなど:618f10612e6a9a223dbbbddb739583ff&#34;&gt;詰まったことなど&lt;/h2&gt;

&lt;p&gt;今回はHTMLやCSSを自分で書いてサイトを一つ作りたいと思っていた&lt;del&gt;のと、自分以外のテーマ作者名の表記がページに現れるのが気に食わなかった&lt;/del&gt;ので、このサイトでは既存のテーマを使用せず、自前でレイアウトを記述して構築しました。
その途中で、いくつか不具合に遭遇して詰まったりしました。&lt;/p&gt;

&lt;h3 id=&#34;バージョン0-14-配列の並び替えにバグがある:618f10612e6a9a223dbbbddb739583ff&#34;&gt;(バージョン0.14)配列の並び替えにバグがある&lt;/h3&gt;

&lt;p&gt;サイドバーに最近の投稿やタグ・カテゴリの一覧を表示させる際、たとえば&lt;code&gt;.Reverse&lt;/code&gt;や&lt;code&gt;.ByDate&lt;/code&gt;で並び替えを行うと、ページによって正常に並び替えが行われなかったり、ビルドするたびに並び順が変わる、低確率で配列の中身が重複して表示されたりします。
これは並び替えを行う関数が配列そのものに変更を加えているのが原因です。さらにビルド時に並列処理が行われることで処理順がビルドのたびに変化し得るため、同じ記述をしていてもページによって表示される内容が変わるといった不具合が発生したり、そのバグの再現性が低くなったりします。&lt;/p&gt;

&lt;p&gt;このバグは開発版のバージョン0.15では&lt;a href=&#34;https://discuss.gohugo.io/t/error-when-trying-to-sort/1390/4&#34;&gt;修正済み&lt;/a&gt;であり、現行のバージョン0.14まででのみ発生します。&lt;/p&gt;

&lt;h3 id=&#34;rssuriオプションは使ってはいけない:618f10612e6a9a223dbbbddb739583ff&#34;&gt;RSSUriオプションは使ってはいけない&lt;/h3&gt;

&lt;p&gt;Hugoではビルド時に自動的にRSSフィードも生成されますが、そのファイル名は常にindex.xmlとなります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rssuri = &amp;quot;rss.xml&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにconfigファイル中に記述することで、RSSファイル名を変更する機能がありますが、この機能には&lt;a href=&#34;https://github.com/spf13/hugo/issues/1147&#34;&gt;いくつもの欠陥がある&lt;/a&gt;ため使ってはいけません。(2015年12月、バージョン0.14時点)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ルートディレクトリ直下のRSSファイルのファイル名はこの設定によって変更できるが、それ以外のRSSファイルはすべてindex.xmlのままになってしまう&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.RSSlink&lt;/code&gt;などの変数を呼び出すと、間違ったリンクが返される&lt;/li&gt;
&lt;li&gt;RSSファイル内のURLが間違ったものになる&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;hugoを使ってみた感想:618f10612e6a9a223dbbbddb739583ff&#34;&gt;Hugoを使ってみた感想&lt;/h2&gt;

&lt;p&gt;Hugoはシンプルで生成が非常に速いという評判があったため導入してみましたが、実際にサイトを構築してみると確かにそのような設計であることがよく感じられました。必要最小限の機能を持つように出来ており、簡潔なディレクトリ構造はとてもわかりやすいです。
生成速度についてはまだ記事数が少ないため何とも言えませんが、今のところは一瞬でビルドが完了するので良い感じだと思います。&lt;/p&gt;

&lt;p&gt;とはいえ、レイアウトから自前で書き始めるといくつかの不満点が出てきます。
レイアウトに使用するテンプレートはHugoの全体の印象に反して煩雑です。そのため、Hugo特有のレイアウトの記述方法にある程度習熟しておくことは不可欠となります。
しかし、Hugoは公式ドキュメントが非常に豊富ではあるのですが、決して使いやすいというわけではないと思います。
全体を通して解説風のドキュメントとなっているために最初はわかりやすいのですが、それ故にリファレンスとしての機能を十分に果たしておらず、また別途APIリファレンスなどがあるわけでもないので、テンプレートなどの機能を調べるのがやや困難です。
(とはいえ、基本はGo言語のテンプレートエンジンを用いているらしいので、既にGoに慣れている方にとっては問題ないのかもしれません)&lt;/p&gt;

&lt;p&gt;Hugoで使用するパラメータは、TaxonomyやPaginatorの概念が存在していることによってやや複雑な構造をしているため、ドキュメントの見通しが悪いのは問題になりがちだと思います。(rangeで.Data等で提供される配列の中身を回す時とTaxonomyを回すときの扱い方が微妙に異なるなど)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上、Hugoを使ったサイト構築の紹介でした。
Hugoでサイトを作ってからWeb上にデプロイするまでも一苦労あったので、後日その流れについても書いてみたいと思っています。&lt;/p&gt;

&lt;p&gt;あとページのデザイン難しいです。
CSS周りについても記事を書いてみたいですが、あまりに試行錯誤の連続なので何も書くことがないかもしれません……&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>highlight.jsをインライン要素にも適用できるようにした</title>
      <link>http://tatamo.81.la/blog/2015/12/12/apply-highlightjs-to-inline/</link>
      <pubDate>Sat, 12 Dec 2015 01:01:51 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2015/12/12/apply-highlightjs-to-inline/</guid>
      <description>
        

&lt;p&gt;このブログのシンタックスハイライトには&lt;a href=&#34;https://highlightjs.org/&#34;&gt;highlight.js&lt;/a&gt;を使用しています。&lt;/p&gt;

&lt;p&gt;デフォルトでは適用できないインラインのコードのハイライトも行えるようにしましたので、適用の流れなど。&lt;/p&gt;

&lt;h2 id=&#34;highlight-jsって何:dbe2fecfd9603c43589f9d37f36eba56&#34;&gt;highlight.jsって何&lt;/h2&gt;

&lt;p&gt;JavaScriptによって、Webページ内のソースコードを色付けしてくれるものです。
たとえば:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(1,101) :
	print (&amp;quot;Fizz&amp;quot; if not i%3 else &amp;quot;&amp;quot;) + (&amp;quot;Buzz&amp;quot; if not i%5 else &amp;quot;&amp;quot;) or i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://highlightjs.org/static/demo/&#34;&gt;highlight.js demo&lt;/a&gt;を見れば、どのようにハイライトされるのか、どのようなテーマがあるのかが簡単にわかるので良いと思います。
(しかし思うのですが、自分のサイトに導入を検討する際に、この濃い赤色の背景色だと白色の背景と感覚が違ってくるのでやや選びにくいのではないでしょうか……。
コンソールから&lt;code&gt;document.body.style.backgroundColor=&amp;quot;#FFFFFF&amp;quot;;&lt;/code&gt;とでも入力して、背景を白く変更してから見てみるのがいいかもしれません。)&lt;/p&gt;

&lt;h2 id=&#34;インライン要素でもハイライトできるようにしてみた:dbe2fecfd9603c43589f9d37f36eba56&#34;&gt;インライン要素でもハイライトできるようにしてみた&lt;/h2&gt;

&lt;p&gt;通常では、highlight.jsによるハイライトは&lt;code&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&lt;/code&gt;から&lt;code&gt;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/code&gt;で囲まれたブロック要素にのみ適用され、インライン要素に適用することはできません。1行の中にコードを埋め込みたいことも多いので、これではやや不便です。&lt;/p&gt;

&lt;p&gt;Markdownの展開方法に適用できるように、&lt;code&gt;&amp;lt;code&amp;gt;&amp;lt;/code&amp;gt;&lt;/code&gt;で囲まれた要素をハイライトすることにします。
既に先人たちが記事を書いてくれているので、基本的にはそれを参考にするだけでした。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://kenzauros.com/blog/apply-highlight-js-to-inline-source-code/&#34;&gt;highlight.jsでインラインのソースコードもハイライトする | blog@kenzauros.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://swiftrithm.com/blog/highlightjs-install/&#34;&gt;軽いとうわさのhighlight.jsをTwenty Fifteenに導入、ソースコードを綺麗に表示 &amp;#8211; SWIFTRITHM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上記のサイトでは共にJQueryを用いていますが、このサイトでは特にJQueryを導入する気もなかったため、生のJavaScript+DOMで適当に書き直しました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script&amp;gt;
// hljs.initHighlightingOnLoad();
window.addEventListener(&amp;quot;DOMContentLoaded&amp;quot;, function(){
	var elements = document.getElementsByTagName(&amp;quot;code&amp;quot;);
	var l=elements.length;
	for(var i=0; i&amp;lt;l;i++){
		var el = elements[i];
		hljs.highlightBlock(el);
		if(el.parentNode.tagName.toLowerCase() != &amp;quot;pre&amp;quot;) {
			el.style.display = &amp;quot;inline&amp;quot;;
			el.style.margin = &amp;quot;0 2px&amp;quot;;
			el.style.padding = &amp;quot;1px 3px&amp;quot;;
		}
	}
}, false);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常&lt;code&gt;hljs.initHighlightingOnLoad();&lt;/code&gt;を呼ぶところを、上記のコードで置き換えるだけで完了です。
親要素が&lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;ではない場合にインライン化するようにしています。
またスタイルの指定も同時に行っているので、別途CSSを記述する必要はありません。&lt;/p&gt;

&lt;p&gt;既に記事内で何回も使用しているので今更感はありますが、実際にインラインのコードがハイライトされるか見てみましょう。
たとえば、このように:&lt;code&gt;print &amp;quot;\n&amp;quot;.join([&amp;quot;Fizz&amp;quot;*(not i%3)+&amp;quot;Buzz&amp;quot;*(not i%5) or str(i) for i in range(1,101)])&lt;/code&gt;1行のコードでもうまくハイライトされているのがわかります。
やったね。&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>