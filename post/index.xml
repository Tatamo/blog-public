<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on わたしろぐ</title>
    <link>http://tatamo.81.la/blog/post/</link>
    <description>Recent content in Posts on わたしろぐ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Tue, 10 Dec 2019 23:59:59 +0900</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>自動化というゲームジャンルの成立と変遷</title>
      <link>http://tatamo.81.la/blog/2019/12/10/automation-games/</link>
      <pubDate>Tue, 10 Dec 2019 23:59:59 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2019/12/10/automation-games/</guid>
      <description>
        &lt;p&gt;この記事は&lt;a href=&#34;https://adventar.org/calendars/4690&#34;&gt;Kobe University Advent Calendar 2019&lt;/a&gt;の9日の記事です(遅刻…)。
なお私は当該大学の修士1年(2019年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;私がフォローしているゲームジャンルの一つで、近年よく見かけるようになった「自動化ゲー」について、これまでのタイトルを振り返るとともに語っていきたいと思います。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;一部のゲーマー、特にゲーマー兼プログラマであるような人たちに強く支持されているゲームのジャンルとして、「自動化」というものがあります。
これは比較的最近成立した(と私は思っている)カテゴリで、最も有名かつよくできた作品として&lt;a href=&#34;https://factorio.com/&#34;&gt;Factorio&lt;/a&gt;が挙げられますが、このゲームがリリースされたのは2016年です。&lt;/p&gt;

&lt;p&gt;この種のカテゴリでゲームが作られ始めていることは一般にあまり認知されていない印象があり、自動化(&lt;a href=&#34;https://store.steampowered.com/tags/ja/Automation/&#34;&gt;Automation&lt;/a&gt;)という括りでこれらのゲームについて言及された例は(少なくとも日本のインターネット上では)ほとんど見たことがありません。
そこで、本記事ではこれら自動化ゲーにどのようなものが存在してきたのかを見ていきながら、その成り立ちを振り返ることにします。&lt;/p&gt;

&lt;p&gt;なお、この記事ではゲーム全般に関する最低限の事前知識として、&lt;a href=&#34;https://www.minecraft.net/&#34;&gt;Minecraft&lt;/a&gt;がだいたいどのようなゲームかわかる(プレイしたことがある/プレイを見たことがある)程度を想定しています。&lt;/p&gt;

&lt;h2 id=&#34;自動化ゲーとは&#34;&gt;自動化ゲーとは&lt;/h2&gt;

&lt;p&gt;その名の通り、自動化ゲーは「自動化」をゲームの主題(の一部)としているものを指します。&lt;/p&gt;

&lt;p&gt;資源やアイテムの獲得・生産などの目標が与えられたとき、プレイヤーやプレイヤーキャラクターの手作業ではコストや手間が膨大になりすぎるものを、「アイテムをたくさん作る」のではなく「アイテムをたくさん作ってくれる設備を作る」ことによって解決し、その過程自体をゲームプレイに組み込んだものが(特に黎明期の)自動化ゲーといえるものです。&lt;/p&gt;

&lt;p&gt;おそらく一番話の通りやすいであろうMinecraftを例に出すと、たとえば農作物を育てて食料を得る場合、まずは畑に種を植えて育ったら収穫する、という手順を手作業で行うでしょう。
次に、ボタンを押すと水が流れるような仕組みをつくり、作物の収穫作業の一部を効率的に行えるようにすることもあるかもしれません。
さらに、NPCの村人(農家)の「付近の農作物の収穫と種まきを行う」という性質を利用すると、プレイヤーは一切手を出さなくても自動で農作物の育成が行われ、待っているだけで作物が手に入るような設備を作ることもできます。&lt;/p&gt;

&lt;p&gt;アイテムが少ない労力で、または労力ゼロで手に入るようになると、プレイヤーはより価値の高い、複雑な作業工程を必要とする新しいアイテムの獲得にとりかかることができます。
やがては、その新しいアイテムも自動的に生産できるようになっていくかもしれません。
このような自動化の過程そのものに楽しみを見出し、アイテムの自動生産施設のようなものを次々に作っていくのが自動化ゲーのメインテーマであるといえます。&lt;/p&gt;

&lt;p&gt;このあたりもゲームによって違ってくるところはありますが、いくつかの(私がプレイした)作品については、後に個別の紹介を行います。&lt;/p&gt;

&lt;h3 id=&#34;隣接するゲームジャンル-および相対的位置付け&#34;&gt;隣接するゲームジャンル、および相対的位置付け&lt;/h3&gt;

&lt;p&gt;自動化と似たような位置付け、または上位にあたるようなゲームジャンルをいくつか提示し、同時にそれらとの比較によって自動化ゲーがどのようなものであるかを見ていきます。&lt;/p&gt;

&lt;h4 id=&#34;シミュレーション&#34;&gt;シミュレーション&lt;/h4&gt;

&lt;p&gt;シミュレーションゲームという言葉の指す範囲が広すぎてよくわからないところはありますが、おおよその自動化ゲーはシミュレーションゲームに含まれるでしょう。
特にSimCityやTropicoのような都市建設・経営シミュレーションは典型的な資源管理要素を持ったゲームであり、これらの要素が自動化要素と同居していることはよくあります。&lt;/p&gt;

&lt;h5 id=&#34;資源管理&#34;&gt;資源管理&lt;/h5&gt;

&lt;p&gt;あらゆるゲームが資源管理、いわゆるリソースマネジメントの側面を持つという考えもありますが、基本的には、手元にある限られた資源を効率的に分配し、拡大再生産を行いながら資源の枯渇が起きないようにするゲーム要素のことを指します。
シミュレーションゲーム、またはストラテジーゲームの内政等でよく意識させられますが、よりシンプルな例としてはサバイバルゲームがあり、たとえば食料というリソースの枯渇はプレイヤーキャラクターの死・ゲームオーバーを意味するため、プレイヤーはこれを回避するべく行動します。&lt;/p&gt;

&lt;p&gt;資源管理ゲー、といった場合は、具体的には&lt;a href=&#34;https://store.steampowered.com/app/242920/&#34;&gt;Banished&lt;/a&gt;のようなゲームを指すことが多い印象があります。
その系譜として、なぜかFactorioと比較されることの多い&lt;a href=&#34;https://store.steampowered.com/app/294100/&#34;&gt;RimWorld&lt;/a&gt;や、自動化要素も多く含んだ&lt;a href=&#34;https://store.steampowered.com/app/457140/&#34;&gt;Oxygen Not Included&lt;/a&gt;などが該当し、自動化ゲーとの繋がりは大きいといえます。&lt;/p&gt;

&lt;p&gt;「限られた数のキャラクターの仕事をうまく管理し、持続可能なコロニーの成立を目指す」というようなゲーム目的を考えると、究極の目的はシステム全体の自動化、とみなすこともできるのかもしれませんが、この手のゲームは完全放置ですべての資源が増えていくようなシステムを作らせてはくれない気がします。&lt;/p&gt;

&lt;p&gt;特にこの文脈で資源管理ゲーという単語を用いた場合、だいたいの自動化ゲーは資源管理ゲーの下位ジャンルにあたるとされます。
一方で、資源管理ゲーの重要な要素として「資源の枯渇を避けなければならない(特定の資源が尽きるとゲームオーバー)」というものがある気がしますが、純粋なゲームジャンルとしての自動化ゲーを見た場合、必ずしも資源の枯渇を避けるような動機付けがされる必要はないので、資源管理ゲーに含まれない自動化ゲー、というものは考えられます。&lt;/p&gt;

&lt;h4 id=&#34;パズル&#34;&gt;パズル&lt;/h4&gt;

&lt;p&gt;「自動化パズル」というゲームは複数存在し、そこそこ人気があります。
与えられた問題に対してその条件をみたすシステムを作る、という点から「プログラミングパズル」と呼ばれることもあり、自動化というゲームジャンルがプログラマに人気があるのも頷けるところです。&lt;/p&gt;

&lt;p&gt;また、自動化ゲーではクエストのような形でプレイヤーに目標が示される形式になっている作品も多く、段階的に目標を達成していく手順は、パズルを順番に解いていくことと重ねることもできます。
もっとも、このようなパズルゲームに分類される自動化ゲーを自動化ゲーと呼ぶかどうかについては、個人的には疑問を感じるところでもあります。&lt;/p&gt;

&lt;p&gt;あくまで一意見でしかありませんが、自動化パズルゲーとそうでない自動化ゲーの違いは、ステージクリアの概念にあると考えます。
Factorioは「やめ時が見つからないゲーム」にあたるとされていますが、それに寄与している重要な要素の一つとして、一度作った自動化設備はその後ずっとシステムの一部として動き続ける、という点があります。
ゲームの進展とともに、自動化のために使えるパーツの性能も向上していき、より効率的に自動生産が可能になるのですが、一方で上位パーツが解放される前に作られた施設は旧態依然とした低効率のままです。
そして生産物の需要の高まりとともにレガシーな生産ラインの存在がシステム全体のボトルネックとなりうるため、一度作った施設も中長期的な間隔で見直しが必要となります。
つまりゲームが進めば進むほどに考えることが増え、常にTODOキューにタスクが貯まった状態が維持され、「やめ時が見つからなく」なるわけです。
ステージクリア型のパズルゲームの場合、次のステージに作ったものは持ち越しとならないため、ゲーム全体の印象は大きく変わります。&lt;/p&gt;

&lt;p&gt;具体的な作品の例を挙げるなら、&lt;a href=&#34;https://store.steampowered.com/sale/zachtronics&#34;&gt;Zachtronics&lt;/a&gt;が作っているゲーム、と言えばだいたい事足りるでしょう。
それ以外では&lt;a href=&#34;https://store.steampowered.com/app/984800/&#34;&gt;Automachef&lt;/a&gt;が最近発売されました。
あとは&lt;a href=&#34;https://store.steampowered.com/app/375820/&#34;&gt;Human Resource Machine&lt;/a&gt;が思い浮かびますが、これは自動化というより完全にプログラミングです。&lt;/p&gt;

&lt;h2 id=&#34;自動化ゲーの成立と変遷&#34;&gt;自動化ゲーの成立と変遷&lt;/h2&gt;

&lt;p&gt;いくつかのゲームについて、リリース順に見ていくことによって自動化ゲーがどのように移り変わってきたのかを振り返ります。&lt;/p&gt;

&lt;h3 id=&#34;minecraft&#34;&gt;Minecraft&lt;/h3&gt;

&lt;p&gt;自動化というゲームジャンルの成立において、&lt;a href=&#34;https://www.minecraft.net/&#34;&gt;Minecraft&lt;/a&gt;とそのMODコミュニティの存在を抜きにして語ることはできないでしょう。
Zachtronicsによるプログラミングパズルの&lt;a href=&#34;https://store.steampowered.com/app/92800/SpaceChem/&#34;&gt;SpaceChem&lt;/a&gt;を除けば、自動化ゲー黎明期の歴史はそのままMinecraftにおけるMOD開発の歴史と言い換えることができます。
そのため、この記事でもMinecraftについては特に多くの紙面を割くことになります。&lt;/p&gt;

&lt;h4 id=&#34;バニラ&#34;&gt;バニラ&lt;/h4&gt;

&lt;p&gt;バニラというのは、「MODが入っていない」という意味です。&lt;/p&gt;

&lt;p&gt;Minecraftにはレッドストーン回路と呼ばれる要素が早くから組み込まれており、ゲームの中で論理回路が構成できるようになっていました。
これはゲーム内のオブジェクトから入力を受け付けたり、逆に回路の信号を用いてオブジェクトに影響を与えることも可能であるため、複雑な制御機構を要するような機械でもMinecraft内で作成できてしまうという自由度の高さがありました。&lt;/p&gt;

&lt;p&gt;そして、その回路機能を用いて一部作業を自動化すれば、効率的なゲームプレイができるということもプレイヤーに対するモチベーションを与えました。&lt;/p&gt;

&lt;p&gt;最新バージョンのMinecraftでは、先述した農作物や、敵のモンスターからのドロップ品全般、重要な鉱石である鉄や金も、「放置していれば勝手に増えていく」ような仕組みを作り上げることが可能です。
一度そのような施設を作ってしまえばそこから生産されるアイテムは事実上無制限に入手可能となるわけですが、そのような施設を作り上げることにも資源コストがかかることから、手間とリターンのトレードオフがあり、探索や探検を主体としたゲームプレイに悪影響を与えるには至らないという巧さがあります。&lt;/p&gt;

&lt;h4 id=&#34;minecraft1-2-5-工業化mod&#34;&gt;Minecraft1.2.5+工業化MOD&lt;/h4&gt;

&lt;p&gt;Minecraft バージョン1.2.5は2012年にリリースされたバージョンで、初期のMinecraftにおいて最も盛んにMOD開発が行われたバージョンです。
(厳密には1.2.5までの時点で既に開発は盛んだったのですが、次のバージョンである1.3に対応したMODを作るのが大変だったため、1.3以降への互換性対応を放棄して1.2.5でしばらく更新が続けられたMODが多数存在したという形になります)&lt;/p&gt;

&lt;p&gt;今更ですが、MODとは(主に)開発元とは関係のない第三者が、ゲームに追加の要素を付け足したりすることを言います。
Minecraftでは、UIの改良などの便利機能を追加するものや、バニラにないアイテムを追加したり、新しいダンジョンや地形などをゲーム内の世界に登場させるようなMODが作られています。&lt;/p&gt;

&lt;p&gt;その中で、IndustrialCraft2(IC2)、BuildCraft(BC)をはじめとした、工業化MODと呼ばれるMOD群が登場しました。
これらのMODの画期的であった点として、大規模な自動化要素の追加とエネルギー要素の導入が挙げられます。
まず、バニラのMinecraftでは不可能であったアイテムの自動クラフトを可能にしたり、バニラでは手作業を排することのできないようなアイテムの生産工程を自動化するような「機械」が追加され、これらの機械を使えばバニラ以上に多くの種類のアイテムが自動で入手できる(ような施設を作ることができる)ようになります。
同時に「石炭を燃やして発電する」だとか「石油(追加アイテム)を燃やして発電する」といった要素が導入され、機械を動かすためにはエネルギーが必要であるため、「作業を自動化するための機械を動かすための燃料の確保の自動化」が要求されるなど、アイテムの生産という目的に対して考えるべきことが増えていきます。&lt;/p&gt;

&lt;p&gt;「アイテム生産のための機械作りのための機械作りのための素材作りのための機械稼働のための燃料確保のための自動化施設作り」と、プレイヤーは複雑に絡み合った依存関係を一つ一つ解決していかなければなりません。
具体的な例としては、たとえば機械を動かすエネルギーを届けるためには送電線が必要で、送電線を作るには銅線が必要で、そのためには銅のインゴットを平たい板に伸ばしてからカッティングしないといけません。
最初の機械を動かすための数本だけの銅線なら手作業でも作れますが、コストが嵩むため「銅線を作る機械」を早いうちに作る必要があり、そのような機械を作るためには素材アイテムである制御回路が必要で……といった具合になります。&lt;/p&gt;

&lt;p&gt;もちろん、このような大変な作業を経た暁には、工業時代が幕開けて大量のアイテムを得られるようになったり、なんか技術が進んで空を飛べるようになったりと、様々な報酬が約束されています。
逆に、このような工程を自動化施設の作成という手順を踏まずに手作業でゴリ押そうとした場合、作業コストが指数関数的に増大して遠くないうちに詰むようになっています。&lt;/p&gt;

&lt;p&gt;一度施設を作ってしまえば大きなリターンが得られ、次の段階に進めるといった要素がここには無数に埋め込まれており、アイテム生産のための素材の依存関係がそのままレベルデザインとなっています。
このような自動化ゲームのコアとなる要素は、この時代の工業化MODで既に確立されていました。&lt;/p&gt;

&lt;p&gt;MODは(時々プログラムが競合を起こしますが)基本的に複数同時に導入することができるため、有名な工業化MODを複数入れて遊ぶことが主流でした。
次第に、特定のMOD同士を協調動作させるようなMOD(MODごとに別々に導入されるエネルギーを相互変換できるようにするなど)や、特定のMODが導入されていることを前提としたMODなども作られるようになっていきます。
大規模なMODの開発だけではなく、それを補助する小さなMODを作ることでもゲーム性の向上につながることから、MODコミュニティという特性はこの新しい形のゲームプレイに対して非常に良い影響を与えました。&lt;/p&gt;

&lt;p&gt;いくつかのMODを軽く紹介しておきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IndustrialCraft2

&lt;ul&gt;
&lt;li&gt;Minecraftに電力の概念と工業機械と原子力と鬼のような数の中間素材アイテムをもたらした工業MOD。&lt;/li&gt;
&lt;li&gt;追加される道具も採掘ドリル/レーザーとか飛行用ジェットパックとか原子爆弾とかそこそこ魅力的だったのも○。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;BuildCraft

&lt;ul&gt;
&lt;li&gt;今でも若干禁忌っぽさのある、「鉱石の自動採掘」を可能にしたMOD(とはいえ全自動ではない)。&lt;/li&gt;
&lt;li&gt;最大の貢献は「アイテム導管」の追加。あちらにあるアイテムをこちらに移す、という作業の自動化はその後のMinecraftにおける工業化の一つの核となる。

&lt;ul&gt;
&lt;li&gt;それ故に時代が進歩しすぎたためか、今見るとこのMODのアイテム導管は使い難くて仕方がない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;そもそも&lt;em&gt;Build&lt;/em&gt; Craftのはずなのに建設要素よりも採掘要素ばかり当てにされている。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ForestryForMinecraft

&lt;ul&gt;
&lt;li&gt;農業関連の自動化設備を追加するMOD。バニラのMinecraftにおいて「木を伐る」作業は未だに効率化困難なタスクのひとつ。&lt;/li&gt;
&lt;li&gt;農産物の自動生産も魅力的だが、隠れた目玉は「蜂の交配」。メンデルの法則に従った品種改良では無限に時間が溶けました(Industrious蜂はもう何度作ったかわからない)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;RedPower2

&lt;ul&gt;
&lt;li&gt;レッドストーン回路は場所を取るので、いくつかのゲートを1ブロックにまとめることができて便利。&lt;/li&gt;
&lt;li&gt;自走機械のようなものが作れたが、今から考えると「複数のブロックを継続的に移動させる」というのはそもそもMinecraftのシステム上やらないほうがいい&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;minecraft1-7-10-工業化mod&#34;&gt;Minecraft1.7.10+工業化MOD&lt;/h4&gt;

&lt;p&gt;バージョン1.2.5のように、「たくさんのMODが作られたバージョン」というのがいくつかあります。
基本的には、その次のバージョンでゲームの内部仕様が大きく変わるなどでMinecraft本体の更新に取り残されるMODが多発したバージョン、という気はしますが。
2014年にリリースされたバージョン1.7.10はその最たる例で、敢えて最新のバージョンではなく1.7.10を遊ぶ価値があるほどにMODが充実しています。&lt;/p&gt;

&lt;p&gt;とはいえ工業化というゲームの主な要素は1.2.5時代には既に出揃っていたため、バージョン1.7.10では後続のMODの登場による改良とバリエーションの増加、そしてMODパックの充実がメインになります。
加えて、これまでMODごとに独自のエネルギー単位が設定されていましたが、多くのMODの間で一つのエネルギー単位を共通で使えるようになり、遊びやすさが向上しています。&lt;/p&gt;

&lt;p&gt;1.2.5時代に提示された「工業化Minecraft」という遊び方に対して、それに呼応した新しいMODが多数登場したのがこの時代です。
有名なMODですら数が多すぎていくつかを精選するだけでも大変ですが、ここでも多少言及しておきます。
なお、1.2.5で挙げた主要な工業化MODは、(RedPower2の後継プロジェクトも含めると)すべて1.7.10でも利用することができます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;EnderIO

&lt;ul&gt;
&lt;li&gt;1.2.5の次の時代を提示した新しい工業化MOD(当時)。&lt;/li&gt;
&lt;li&gt;アイテム輸送が大幅に改良された。EnderIO以前はアイテム導管と送電線がそれぞれ1ブロックのスペースを取るので配管が大変だったが、これらを1本でまとめることができるようになった&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;AppliedEnergistics2

&lt;ul&gt;
&lt;li&gt;アイテムストレージMOD。アイテムを「データ化」して一箇所にまとめられるため、アイテムの集中管理が容易になる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Botania

&lt;ul&gt;
&lt;li&gt;工業化MODの正反対に位置する「魔術MOD」、の見た目をしつつ実態は独自の自動化システムを内包した工業化MOD。個人的にはかなり好き。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;DraconicEvolution

&lt;ul&gt;
&lt;li&gt;工業化のさらに先にあるエンドコンテンツの提供。基本的に中盤まではMOD要素に触れることすらできない。&lt;/li&gt;
&lt;li&gt;エネルギーのワイヤレス伝送が可能となり、送電線が全く場所を取らなくなるのでとても良いが解放が遅すぎるのがネック。&lt;/li&gt;
&lt;li&gt;だいたいの場合エンドコンテンツがこれになるのでそろそろワンパターンで飽きる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;また、1.7.10より、MODパックと呼ばれるものが整備され、普及していきました。
工業化MODを含め、MinecraftのMODは複数導入するのが前提とみなされており、いわゆる「工業化Minecraft」のMOD環境を整備しようとした場合、導入MOD数が100を越えるのは珍しくありません。&lt;/p&gt;

&lt;p&gt;それに加えて、「銅鉱石」などはよく追加されるポピュラーなアイテムのため、別々のMODで生成された同名アイテムが複数種類存在してしまうこともあります。
これはMOD開発環境が整備されたことで、「鉱石辞書」と呼ばれる機能により相互運用が可能になっていますが、依然として同名のアイテムが複数種生成されることはあり、その回避のために一つのMOD以外の鉱石生成を無効化するよう設定する必要が生じることがあります。
似たようなアイテムではクラフトのレシピも重複してしまうことがあり、片方のアイテムのレシピが上書きされて入手不可能になるなどの弊害もあるため、これらも調整が必要です。
また、そもそも複数のMODを導入することによるゲームバランスの偏りは無視できず、あるMODが低コスト高効率の発電機を実装していた場合に他のMODの発電機が全く使われなくなる、といった問題も生じることがあります。&lt;/p&gt;

&lt;p&gt;これらの諸問題のため、同時に導入したいMODの数が増えれば増えるほど、満足にゲームをプレイするまでのハードルが高くなってしまいます。
そこで、複数のMODを競合しないように設定し、そのMOD構成を配布するMODパックが登場しました。&lt;/p&gt;

&lt;p&gt;近年ではMODの配布が&lt;a href=&#34;https://minecraft.curseforge.com/&#34;&gt;CurseForge&lt;/a&gt;を利用する形に一極化しつつあることも伴い、CurseForgeのプラットフォーム上で提供されるMODパックは従来のMOD導入と違って非常に簡単に導入することができ、自分で詳細な設定をしなくてもすぐにプレイできます。
加えて、人気のあるMODパックはMOD間のバランスもよく考えられていることが多いため、プレイヤーにとってはとてもありがたい存在になります。&lt;/p&gt;

&lt;p&gt;MODパックの登場によって可能となった遊び方として、クエスト形式で複数のMODの要素を横断的にプレイする、というものがあります。
工業化MODに顕著な傾向ですが、そのMODのエネルギーシステムやアイテムの種類、独自の機能等をある程度把握していなければ、どう進めていいかわからない状態に陥ることもあります。
MODパックに同梱されているクエストブックMODなどの機能により、次に何をすればよいかという目標が提示されることがあり、このようなMODパックは不慣れなプレイヤーのためのチュートリアルとしての役割も果たすことができます。&lt;/p&gt;

&lt;p&gt;MODのチュートリアルとしてのクエスト方式の進化系に、SkyBlockやStoneBlockといった、周囲の世界に何もない状態からMOD要素だけで生産施設を構築していく、MOD要素を使わざるを得ない形式のMODパックもあります。&lt;/p&gt;

&lt;h4 id=&#34;minecraft1-12-2-工業化mod&#34;&gt;Minecraft1.12.2+工業化MOD&lt;/h4&gt;

&lt;p&gt;MODパック等々書きたかったことを上でほとんど書いてしまったのでここに書くことがありません。
1.12.2は2017年にリリースされたもので、MODが比較的充実しており、また比較的最新のバージョンに近いバージョンです。
もう少し古くて1.7.10よりは新しいバージョンとしては、1.10.2もMODが充実しているように思います。&lt;/p&gt;

&lt;p&gt;基本的なUIの向上に加えて、MODパックに至るまでの環境が既に整った上で迎えた時代であるため、MOD導入の段階からプレイに至るまで「モダンな」MOD体験ができるでしょう。
モダンなMOD開発環境に乗っかった新しいMODや、1.7.10からのアップデートを乗り越えて開発が継続されたMODなどで構成されているため、洗練されたプレイ感を味わうことができる印象にあります。&lt;/p&gt;

&lt;p&gt;また、1.7.10に「取り残された」MODが多くあることなどから、それまでの時代のMODに親しんでいてもまた違ったMOD構成でのゲームプレイを楽しめます。
たとえば1.7.10では何もない世界で鉱石を入手するにはまず砂利や砂をふるいにかけていましたが、1.12.2では盆栽を育てたりします(？？)&lt;/p&gt;

&lt;p&gt;まあ殆どMinecraftの話になってきましたし、自動化に関する要素についてはMinecraftのMOD開発の流れの中で改良されていったことについては既に見てきた通りですので、次に向かいましょう。
いくつかMODを紹介したいとも思いましたが、1.7.10の時点でも存在していたがバージョンアップで遊びやすくなったMOD、などが多い気がしたので割愛します。&lt;/p&gt;

&lt;h3 id=&#34;factorio&#34;&gt;Factorio&lt;/h3&gt;

&lt;p&gt;自動化というゲームジャンルはMinecraftのMODコミュニティの中で着実に育てられてきましたが、一本のゲームタイトルとして大きなインパクトを与えた作品といえば、&lt;a href=&#34;https://factorio.com/&#34;&gt;Factorio&lt;/a&gt;でしょう。
2016年というリリース年はMinecraftバージョン1.7.10よりも後で、このゲームは&lt;a href=&#34;https://www.reddit.com/r/nerdcubed/comments/2c9rh7/nerd%C2%B3_fw_factorio/cjdtffh/&#34;&gt;Minecraftの工業化MODに影響を受けた&lt;/a&gt;ものです。&lt;/p&gt;

&lt;p&gt;FactorioはAutomationを主題としたおそらく初の作品でありながら、同時に非常に完成されたゲームとなっています。&lt;/p&gt;

&lt;p&gt;基本的なゲームシステムは、あちらで作ったアイテムをベルトコンベアに載せ、こちらに流してきて他のアイテムと一緒に組み立て機械に放り込むことで新しいアイテムを生産し、それをまたコンベアに載せて向こうへ流す……といったことの繰り返しです。
要求されるアイテムの生産工程の複雑さが増すにつれて生産ラインの周到な設計が必要となり、また技術の陳腐化や需要の爆発的増大などによって一度作った施設のリファクタリングを迫られる機会もあります。&lt;/p&gt;

&lt;p&gt;生産ラインを構築する上では、取り回しがよく局所輸送に適したベルトコンベア、信号待ちなどの調整が必要だが長距離・大規模輸送が可能な列車、手はかかるが輸送経路のためのスペースを取らずに直接アイテムを移動可能な輸送ロボットと、複数のアイテム輸送方式が提供されていることや、生産する施設が大規模になり、多くの繰り返しが発生してしまう場合に予めパターンを設定しておきロボットに建設を任せる建設計画機能が用意されていることなど、必要と思われる要素は纏まっておりやはり非常に完成度が高いといえます。&lt;/p&gt;

&lt;p&gt;また資源管理要素とサバイバル要素も含んでおり、施設の稼働には電力が必要ですが、(特に初期Tierの)発電機はハイペースで環境を汚染し、環境汚染が広がるとそれに引き寄せられた「敵」が襲ってくるというシステムになっています。
そのため、ゲーム中盤では生産力の拡大に加えて施設を守るための防衛力の確保も課題となります。&lt;/p&gt;

&lt;p&gt;このサバイバル要素についてはMinecraftからの影響が見られますが、後発の自動化ゲーにはこのような要素を廃したものも多くリリースされています。
また、「一次資源が枯渇する」ことについても言及しておいたほうがよいかもしれません。&lt;/p&gt;

&lt;p&gt;Minecraftと同じで、Factorioのゲームマップは探索した分だけ広がっていきますから、鉱脈から鉱石を掘りつくしてしまっても、新たに鉱脈を見つければよいため、本当に資源が枯渇するということはありません。
ですが、どこかの鉱脈が枯渇した場合、代替となる新しい鉱脈に採掘設備を再設置する必要があります。
当然生産された一次資源を加工場に届けるための鉄道路線の拡張が必要になることもあります。
これらの作業は効率化はできても完全な自動化を行うことはできず、また全体で大量のアイテムを生産するようになると、それにともなって莫大な一次資源が消費されるため、鉱脈が枯渇するまでの間隔が短くなっていきます。&lt;/p&gt;

&lt;p&gt;このような仕様は、自動化を楽しむという目的からすれば手間がかかるだけとも捉えられるため、他のゲームでは全リソースが無限に採掘可能になっている例も多くあります。
とはいえ、どれだけ掘っても尽きることのない鉱床というのもナンセンスなものではあるので、ここはゲーム性との相談になってくるのかもしれません。&lt;/p&gt;

&lt;p&gt;また、この作品と後述のFactory Town、あと&lt;a href=&#34;https://store.steampowered.com/app/457140/&#34;&gt;Oxygen Not Included&lt;/a&gt;についていえることですが、特に用もないのに論理回路が使えるようになっています。
Minecraftの潮流から回路が組めるようにしたい気持ちはわかるし、それを使うことで便利になる場面もごく僅かに存在してはいるんですが、実際あってもなくても大差ないのにとりあえず入れてある感が否めません。
とても便利な「機械」が提供されているのに、今更論理ゲートで喜ぶというのも世界観に対してミスマッチという気はします。&lt;/p&gt;

&lt;p&gt;いろいろと書きましたが、現状、自動化というゲームジャンルのエッセンスはすべてFactorioに詰まっているといえるタイトルであるため、自動化ゲーをやりたい場合はこれをやれば間違いはないでしょう。
まあ、最初に手を出すゲームとしては他にもう少しやさしい作品があるかもしれませんが。&lt;/p&gt;

&lt;p&gt;FactorioがMinecraft+工業化MODを参考にしたのと同様に、Factorio以後のタイトルは全て少なからずこのゲームの影響を受けているのでは、と思います。&lt;/p&gt;

&lt;h3 id=&#34;factory-town&#34;&gt;Factory Town&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://store.steampowered.com/app/860890/&#34;&gt;Factory Town&lt;/a&gt;は、2019年3月に早期アクセスとしてリリースされたゲームです。
資源の獲得や施設の稼働にワーカーというリソースが必要で、ワーカーの上限を増やすためには町を大きくしていく必要がある、という点では資源管理の要素を持ったゲームにも見えますが、基本的に詰みがないので単純に自動生産ラインの作成に没頭できるゲームといえます。&lt;/p&gt;

&lt;p&gt;Factorioは2Dでしたが、Factory Townは3D視点で自動化を進めていきます。
また、プレイヤーキャラクターは存在しません。&lt;/p&gt;

&lt;p&gt;独特な点として、「丸い物」を「水平または低いところへ」移動させることのできるシュート(Chute)の存在など、高低差を生かした生産ラインを組み上げることのできるシステムや、ゲーム中盤以降に登場する、施設とは別レイヤーで構築可能な魔術クリスタルの輸送ネットワークの存在を挙げられるかもしれません。&lt;/p&gt;

&lt;p&gt;時間制限も詰みもなく、資源が非枯渇であることや、終盤に近づくまではエネルギーの概念も無いこと、それぞれの施設の稼働速度を知ることができることなどから、じっくりと考えて最も効率的な自動生産ラインを追求することのできるゲームであるといえます。
全体的に見てFactorioよりもとっつきやすそうな印象はあるのですが、とはいえゲームが進んでくるとその分多くの施設を用意しなければならず、またFactorioのように建設パターンを登録しておくこともできません(そもそも、地形が真っ平らではないので同じものを並べようとしてもそのスペースがないこともあります)。&lt;/p&gt;

&lt;p&gt;まだUIが洗練されきっていないところもあり、足場を大量に設置するときなどは3D視点も相まって設置ミスをしやすい気もします。
また、生産施設が大量に並ぶ終盤になるに従ってCPUに対する負荷も上がるため、処理の最適化は自動化ゲーにとって重要な要素の一つですが、このゲームはどちらかというと終盤の処理負荷が高めな気がします。&lt;/p&gt;

&lt;p&gt;とはいえ、全体的に生産ラインを組むことに集中できるゲームであり、また序盤の立ち上がりもシンプルかつ楽しいものなので、とっときやすさという面ではおすすめ度の高い作品です。&lt;/p&gt;

&lt;h3 id=&#34;satisfactory&#34;&gt;Satisfactory&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.epicgames.com/store/ja/product/satisfactory/home&#34;&gt;Satisfactory&lt;/a&gt;は、2019年3月に早期アクセスとしてリリースされたゲームです。ちなみにEpic専売です。
このゲームは3Dの一人称視点での自動化ゲームで、敵の存在はありますがプレイヤーの施設を攻撃するというようなことはなく、近づかなければ襲ってこない比較的無害な類のものです。&lt;/p&gt;

&lt;p&gt;こちらも資源は非枯渇のため、一度設置した生産ラインは電力不足でも起きない限りアイテムを生産し続けます。
敵にぶつかると死んだりしますが、お腹が空いたり食料がなくなって詰みというようなこともないので、こちらもじっくり考えて自動化に取り組むことができます。
FPSという独自性を抜きにすれば、生産施設からコンベアを引いて次の加工施設に渡す、と、非常にオーソドックスな自動化の流れになっています。
まあ言うことはあまりないんですが、生産用の機械がかっこよくて、しかもFPSの視点で見れるので作った自動工場は非常にさまになります。
一方で生産機械はひとつひとつが巨大なのであまりばかでかい生産ラインを作るには向かず、また綺麗な3Dのグラフィックで機械を大量に並べることになるので、施設を作りまくった際のPCへの負荷は高い部類です。&lt;/p&gt;

&lt;p&gt;現状ではそこまで勧められるほどの作品には感じませんが、悪くはないです。&lt;/p&gt;

&lt;h3 id=&#34;autonauts&#34;&gt;Autonauts&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://store.steampowered.com/app/979120/&#34;&gt;Autonauts&lt;/a&gt;は2019年の10月にリリースされたゲームです。スコットランド製だそうです(タイトル画面に書いてありました)。
3D視点のゲームですが、Factory Townのような標高に関する要素は存在せず、2次元のマップ上で生産ラインを構築していきます。&lt;/p&gt;

&lt;p&gt;このゲームの特徴は、「ベルトコンベアが存在しない」点にあるといえます。
これまでの自動化ゲーとは、基本的に施設から施設へとベルトコンベアを使ってアイテムを流すようなゲームでしたが、この作品ではすべての作業はプログラミングしたロボットにやらせます。
いわゆるビジュアルプログラミングですが、プレイヤーキャラクターの動作を記録させるといった形で命令を記述し、制御構文もwhileループただひとつで、if文もありません。&lt;/p&gt;

&lt;p&gt;独自の、かつ簡潔なゲームシステムで自動化ゲーを実現しており、プログラミングとはいっても非常にシンプルなものであるため、遊びやすさはとても高いように思います。
ポップなゲームの雰囲気や段階的に目標が提示される方式と合わせて、自動化ゲー初心者やプログラミングに触れてみたい子供にとっても非常に良い作品となる可能性を秘めているように感じるのですが、その観点から見た場合、ゲーム内マニュアルの貧弱さが足を引っ張っているのが残念なところです。
アイテムが何に使えるかといった説明や一部の道具の使い方がゲーム内のどこにも記述されていないことがあり、もう少しゲームプレイに関する情報にアクセスしやすいようになっていれば文句なしに勧めることのできる作品ではあるのですが、現状では情報不足からいくつか罠があるかなといった感じです。&lt;/p&gt;

&lt;p&gt;全ての作業をロボットにやらせるという作風は、隣接した加工設備と倉庫の間でアイテムを移動するだけでロボットが1体必要になる、という場面などでは、そのためだけにロボットをプログラムするのも手間ですし、ベルトコンベアが欲しいと感じることもあります。
しかし、逆に生産の規模が大きくなるに従って、これはむしろメリットとなるようにも感じてきています。&lt;/p&gt;

&lt;p&gt;従来の自動化ゲーでは、生産施設のキャパシティが足りなくなった場合、その施設と同じものを増設して対処する必要がありました。
一方でロボットに作業をさせている場合、ある程度作業施設に余裕を持たせていた場合、単にロボットの数を増やすだけで対処が完了することもあります。
ベルトコンベアという設置物が存在しないことによってその流速がボトルネックになることはなく、ロボットであれば流速を上げるには数を増やせば足りるので、ある程度のスケーラビリティが自動的に確保されるような仕組みになっているのは良い点だといえます。
また、「この施設からこの施設へ」というプログラムをロボットに与えていると、命令が指しているのはあくまで施設というオブジェクトであるため、施設を丸ごと移設したり、拡張のために場所を少し変えたりしても、ロボットがそのまま動作を継続してくれるという嬉しい利点もあります。&lt;/p&gt;

&lt;p&gt;あとは、プレイヤーができることはだいたい全部ロボットにやらせることができる、ということにはなっているのですが、厳密には「プレイヤーキャラクターが」できることはロボットでもできる、です。
どう違うのかという点ですが、建物の設置指示や建物の撤去、移動などは、一度建物メニューを開いてから行います。
そのため、これはプレイヤーキャラクターが行っている作業ではないので、プログラムに組み込むことができません。
一度作った施設などは、ノーコストで移動でき、撤去すると在庫として登録されるため、要求される素材コストを改めて支払う必要がありません。
そこで、よく使う保管庫や床などは予め作っておきたいと考えるのですが、建設予定地点に素材を持っていって建てることはロボットがやってくれても、実際の建設指示を出す作業の自動化はできません。
自動化ゲーというジャンルのゲームである故か、あらゆることを自動化したいと思ってしまうものではありますが、ここは割り切るところでしょう。&lt;/p&gt;

&lt;p&gt;また、ゲームを進めているとロボットの数は3桁を越えてきますが、特に重いと感じることはありません。
ゲームそのもののクロックよりも遅いクロック周期でロボットが動作していることで、全体的に負荷がかかりにくいゲームシステムになっているのかもしれません。&lt;/p&gt;

&lt;p&gt;発売されて間もないゲームということもあり、今のところ情報不足が足を引っ張ってしまっている点はあるのですが、ゲームそのもののはとてもよくできており、プレイしやすさも楽しさも高いレベルにあるように感じます。&lt;/p&gt;

&lt;h2 id=&#34;自動化ゲーの抱える課題とこれからについて&#34;&gt;自動化ゲーの抱える課題とこれからについて&lt;/h2&gt;

&lt;p&gt;Minecraftにおける工業化MODと呼ばれるものの中から自動化というゲーム要素が見出され、それがゲームのメインテーマたりうるものであったということを本記事では見てきました。
ここで、現在の自動化ゲーの抱えている課題について考えてみたいと思います。&lt;/p&gt;

&lt;h3 id=&#34;プレイヤーに対する動機付け&#34;&gt;プレイヤーに対する動機付け&lt;/h3&gt;

&lt;p&gt;従来のMinecraftでは、自動化はプレイスタイルのひとつであり、手作業でアイテムを収集するような他のプレイスタイルと比較した際にアイテム自動生産の優位性が得られることも、プレイヤーが自動化施設を作ろうとするモチベーションの一部であったと考えることができます。
一方で、自動化を行わなければゲームを進行できない場合、手作業に対する優位性、というようなものはプレイヤーに対する報酬として働かなくなることに注意する必要があります。&lt;/p&gt;

&lt;p&gt;「自分で生産ラインを作れた嬉しさ」「生産されたアイテムの数が増えていく喜び」「出来上がった生産ラインが稼働しているところを見る楽しさ」は自動化ゲーの面白さの重要な部分ではありますが、これだけでプレイヤーがずっと満足していられるかというと怪しいものです。
ポストFactorioの時代である2019年において、単に自動化をするだけのゲームを作った場合、どうしてもFactorio等の先発の自動化ゲーと比較される傾向にありますので、どのように差別化するかという点も重要になってくるのではないかと思っています。&lt;/p&gt;

&lt;h3 id=&#34;ゲームの進行に伴う作業コストの増大&#34;&gt;ゲームの進行に伴う作業コストの増大&lt;/h3&gt;

&lt;p&gt;自動化ゲーでは、ゲームが進むにつれて要求される生産工程が複雑になり、作らなければいけない施設の数も増加していきます。
その際、どうしてもプレイヤーが行う必要のある作業量が多くなる傾向にあります。&lt;/p&gt;

&lt;p&gt;作りたい施設のデザインが決まっていても、それを作るために100回ぐらいクリックしなければならないとなると、ゲームの本質とは異なった点で作業ゲー感が出てしまい、自動化ラインを作る手が重くなりがちです。
それに関連して、一度生産ラインを設置してみたところ思ったように作れなかった、というようなこともありますから、撤去や移動などの形での修正が簡単にできるようになっていればいるほど、トライアンドエラーが容易になるため心理的抵抗が低減できるように感じます。&lt;/p&gt;

&lt;p&gt;Factorioでは、予め用意したパターンを繰り返し並べることができるブループリントという形でこの問題に対する解答としているように感じます。
Factorioは生産能力を上げるために同じ生産施設を複数並列稼働させる、というケースが多いゲームですので、ゲーム性にマッチする形でプレイヤーの作業量をある程度低減することに成功しています。
また、Autonautsでは、そもそも同じ生産施設を複数ならべなくてもよい形のゲームシステムであることによって、ゲームが進行してもプレイヤーの作業量の増加がゆるやかになるようにデザインされています。
Factorioに類似したシステムを採用した自動化ゲーでは、たとえば「施設Aの時間あたりの出力速度は2」「施設Bの入力速度は3」であった場合、全体の作業効率を最大化させようとすると、施設Aを3基、施設Bを2基並べるというのが基本的な解決策となりますが、このように同じものを複数作らせる、というケースが多く発生するゲームほど作業コストの増大には注意を払わなければならないのかもしれなせん。&lt;/p&gt;

&lt;p&gt;このような問題はUIの洗練度合いとも関連しており、出たばかりの新作ほどUIがこなれていないため、既存の作品と比較して操作性が良くないような印象を与えてしまう傾向にある点も懸念すべき事項であるように思います。&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;近年になって自動化というゲームジャンルが見出され、現在ではヒット作やそれを後追いする作品も出てきています。
つい先月に&lt;a href=&#34;https://store.steampowered.com/app/1112790/&#34;&gt;Automation Empire&lt;/a&gt;もリリースされたばかりですので、早いうちに購入してプレイしたいと思っています。&lt;/p&gt;

&lt;p&gt;この先どうなるのかはわかりませんが、今のところ自動化を題材にしたゲームが充実しつつある時期にあるのではないかと思っており、今後の新タイトルの登場にも非常に期待しています。&lt;/p&gt;

&lt;p&gt;とはいえ、キラータイトルにしてジャンルの完成形を示した感のある&lt;a href=&#34;https://factorio.com/&#34;&gt;Factorio&lt;/a&gt;の存在感は非常に大きく、Factorioに代わるゲームタイトルや、同ジャンルのゲームが複数生まれたことによって明らかとなってきた、自動化ゲー全般が抱える課題点について明確な解答を示しうる作品の登場も待たれているように感じます。&lt;/p&gt;

&lt;p&gt;Factorioの次、といえるゲームがいつまでも現れず、新タイトルの目新しさがなくなってしまうとジャンル全体が飽きられていずれ新作が出なくなってしまうのでは、という懸念は今まさに感じているところではあります。
とはいえ、&lt;a href=&#34;https://store.steampowered.com/app/860890/&#34;&gt;Factory Town&lt;/a&gt;では「プレイヤーキャラクターがいない」ことや、&lt;a href=&#34;https://www.epicgames.com/store/ja/product/satisfactory/home&#34;&gt;Satisfactory&lt;/a&gt;でFPS視点での綺麗なグラフィックで巨大工場を眺める楽しみが見出されたこと、「ベルトコンベア」の概念を廃した&lt;a href=&#34;https://store.steampowered.com/app/979120/&#34;&gt;Autonauts&lt;/a&gt;の登場など、様々な試みは確実に行われているので、今後もこのジャンルの移り変わりに期待を持ちながらいろいろな自動化ゲーを楽しんでいければと思っています。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>シンフォニック=レインの紹介、またはファルシータ・フォーセットについての考察のようなもの</title>
      <link>http://tatamo.81.la/blog/2019/09/04/symphonic-rain/</link>
      <pubDate>Wed, 04 Sep 2019 21:43:24 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2019/09/04/symphonic-rain/</guid>
      <description>
        &lt;p&gt;シンフォニック=レインをプレイして余韻に浸っているので、ゲームの紹介と感想などを書きます。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;シンフォニック-レイン&#34;&gt;シンフォニック=レイン&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kogado.com/sw/contents/kuroneko/sr2017/ja/&#34;&gt;シンフォニック=レイン&lt;/a&gt;は、2004年に発売されたノベルゲーム(18禁ではない)です。
2017年に&lt;a href=&#34;https://store.steampowered.com/app/629650/Symphonic_Rain/&#34;&gt;Steam版&lt;/a&gt;、2018年に&lt;a href=&#34;https://ec.nintendo.com/JP/ja/titles/70010000015356&#34;&gt;Nintendo Switch版&lt;/a&gt;がHDリマスター版としてリリースされており、オリジナル版の原画担当本人が全面的に描き直す形でグラフィックを刷新したものとなっています。&lt;/p&gt;

&lt;p&gt;雨が降り続ける街ピオーヴァを舞台に、ちょっとしんみりとした切ない雰囲気の作品です。&lt;/p&gt;

&lt;p&gt;柔らかい絵柄と本作のストーリーに深く絡み合った音楽が雰囲気を引き立ててくれます。&lt;/p&gt;

&lt;p&gt;本作は音ゲー要素も含んでおり、音楽学校に通う主人公の演奏に合わせてプレイヤーも楽曲を演奏することになります。
主人公が卒業発表に向けて課題曲を練習していく、というストーリーに沿って演奏パートが挿入されるため、何度も演奏を繰り返すごとに次第に上達していく感覚が、楽曲の雰囲気と相まって没入感をより高めてくれるように感じます。&lt;/p&gt;

&lt;p&gt;(キーボードをタイミング良く打鍵するタイプの演奏パートですが、システム自体に慣れが必要なため、最初は難易度が高く感じられるかもしれません。
また、楽曲によっては序盤から結構な高難易度を突きつけられることがあります。
演奏の成功/失敗によってストーリーが変化することもあるので、難しすぎると感じた場合は設定から難易度を下げたりオートプレイでスキップする選択肢も用意されています。)&lt;/p&gt;

&lt;p&gt;また、収録されている楽曲10曲はすべて岡崎律子さんが手がけており、同時に岡崎律子さんの最後の作品でもあります。
これらについては安っぽい言葉で語りすぎるのも嫌なので、あまり詳しくは言及しませんが、楽曲単体でも、作品全体の一部分として見ても本当に素晴らしいものです。&lt;/p&gt;

&lt;p&gt;シナリオ面も非常におすすめできる内容ですが、個人的には事前に情報が無いほうがより楽しむことができる作品だと思いますので、ここではあまり触れません。
購入を決めた場合は、インターネットでの情報収集は控えめにして実際にプレイしてみるのが良いのではないでしょうか。&lt;/p&gt;

&lt;p&gt;ちなみにヒロインの攻略順は任意で大丈夫です。
この順番で攻略したほうがよい、というのはありません(強いて言えば、「雨のmusique」は他の曲と比べて難易度が高いため、まだ慣れていない状態でルートに入った場合は難易度を下げても良いかもしれません)。&lt;/p&gt;

&lt;p&gt;どのような作品かについての詳細は、&lt;a href=&#34;https://www.kogado.com/sw/contents/kuroneko/sr2017/ja/&#34;&gt;公式サイト&lt;/a&gt;、または紹介記事 &lt;a href=&#34;https://ascii.jp/elem/000/001/544/1544812/&#34;&gt;ASCII.jp：誰のために雨は降る 感情を揺さぶる音楽ゲームノベル「Symphonic Rain」:Steam&lt;/a&gt; あたりを読んでいただければ把握しやすいのではないかと思います。
テキスト・グラフィック・サウンドのすべてが一体となって世界観を作り上げているとても良質な作品ですので、これらのページを見て雰囲気が良いなと思った方はすぐに購入してしまって間違いないです。
おすすめの作品です。&lt;/p&gt;

&lt;iframe src=&#34;https://store.steampowered.com/widget/629650/&#34; frameborder=&#34;0&#34; width=&#34;646&#34; height=&#34;190&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;(Steamに毒されてしまったみなさん向けの情報として、Steam版/Switch版ともに時々値下がりします。
セールの時期になるとだいたい3,000円より安くなるので、その際が買い時でしょう。
もちろん定価で購入するだけの価値は十分にある作品です。)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;ファルシータ-フォーセットについて&#34;&gt;ファルシータ・フォーセットについて&lt;/h2&gt;

&lt;p&gt;ここからはこの記事の本題というか、本作に登場するキャラクターの一人であるファルシータについての感想・考察となります。
または、こうであってほしいという願望をもとにした結論ありきの個人的な解釈の可能性があります。&lt;/p&gt;

&lt;p&gt;以降の内容は、一部ルートのシナリオの内容を全面的に扱っているため、まだプレイされていない方が読まれると作品の楽しみを損なってしまうおそれがあります。
そのため、&lt;strong&gt;本作品の全ルートをクリアした方以外は閲覧をお控えください&lt;/strong&gt;。&lt;/p&gt;

&lt;script&gt;
    function show(){
        document.getElementById(&#39;ff&#39;).style.display=&#39;&#39;;
        document.getElementById(&#39;show&#39;).style.display=&#39;none&#39;;
    }
&lt;/script&gt;

&lt;p&gt;&lt;button id=&#34;show&#34;, onclick=&#34;show()&#34;&gt;続きを読む&lt;/button&gt;
&lt;!-- なぜかこのdivの有無によってhugoのパース結果が変わる --&gt;
&lt;div&gt;&lt;/div&gt;
&lt;section id=&#34;ff&#34; style=&#34;display:none&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;時系列&#34;&gt;時系列&lt;/h2&gt;

&lt;p&gt;まずはファルの行動に注目しながら時系列を追っていきます。&lt;/p&gt;

&lt;h3 id=&#34;シナリオ開始前-開始直後&#34;&gt;シナリオ開始前～開始直後&lt;/h3&gt;

&lt;p&gt;夏の定期演奏でクリスのフォルテールを聴き、気に入ったと言って早速コーデル先生と接触します。
その後の行動はは本編開始時の11/28まで描写されていませんが、3ヶ月ぶりにコーデル先生を訪ねた際、既にアーシノとある程度の交流を持っていることが示唆されています(プレリュード03)。
本人曰く「忙しかった」とのことですが、実際クリスとの接触を図るまでに期間が空きすぎているような印象もあります。
もしくは、アーシノから情報を聞き出すことでクリスがパートナーを見つけそうな気配がないことを察知していたため、外堀を埋めることを優先したのかもしれません。
(「色々な人と音を合わせてからパートナーを決める」ということも言っていますが、これは特にアーシノに向けては都合の良い言い訳として使えるでしょう。本編開始前に他の候補と練習をしたかどうかは分かりませんが、クリスとの接触後はスケジュール的にクリス以外と練習をする時間はほぼないはずです)&lt;/p&gt;

&lt;p&gt;初週はいよいよチェナーコロでクリスに話しかけ、傘まで用意して接近を図ります。
その翌々日にはトルティニタに詰め寄られますが(al fineルート)、クリスの前でなければなりふり構わず初対面の相手にも敵意を剥き出しにするトルタに対して、ファルは完全に躱しきった上に新しい情報源として目をつけ、「パートナーになったら話を聞かせてくれませんか」と約束を取り付けます。
それどころか、トルタはファルの振る舞いに感化され、クリスが他の誰かを選ぶのならその人にすべてを話し、自分は役目を降りたほうが良いのかもしれないとまで思い始めます。
全方位敵なしの圧倒的な強さはさすがといったところですね。
ところでal fineルートではクリスとファルの接触は水曜日ですが、クリスの動き次第ではコーデル先生を訪問した月曜日(28日)のうちに早速クリスを捕まえていることになります。
なかなかの行動力です。&lt;/p&gt;

&lt;h3 id=&#34;パートナー決定まで&#34;&gt;パートナー決定まで&lt;/h3&gt;

&lt;p&gt;一度音を合わせて相性が悪くないことを確認したのもあってか、誘導を駆使したり強引に誘いをかけたり、あたかもその強引さを反省しているかのようなそぶりを見せつけたりしてパートナーに選ばれるよう働きかけていきます。
ところでクリスのパートナーになればトルタから話を聞くという約束をしていたはずですが、パートナーとして確定する当日には既にクリスの恋人であるアリエッタの存在をトルタから「無理に聞き出して」います。
もはやパートナーとして選ばれることは確実と踏んでいたのでしょうか(この時点では当日朝にファルを選ばずに共通エンド行きの選択肢が残っています)。&lt;/p&gt;

&lt;h4 id=&#34;ファルルート以外に入った場合&#34;&gt;(ファルルート以外に入った場合)&lt;/h4&gt;

&lt;p&gt;トルタルートではフォルテール科の発表日に発表をしていないため、少なくともフォルテール科の3年生とはパートナーを組んでいないことがわかります。ソロかもしれませんし、リセルシアは1年生のためパートナーとして組むことも可能でしょう。
なおアーシノは発表後にファルに待ちぼうけを食らわされた描写があります。
もはや何の利用価値もなくなった(むしろ卒業演奏までは何か利用する価値があったのか？)ということでしょう。&lt;/p&gt;

&lt;p&gt;リセルートでは、クリスと組めそうにないことを把握すると鮮やかに身を引きますが、クリスの返答次第では「プロになったときはよろしく」と将来的に利用できるよう貸しを作っておく周到さです。&lt;/p&gt;

&lt;h3 id=&#34;パートナー決定後&#34;&gt;パートナー決定後&lt;/h3&gt;

&lt;p&gt;ナターレ後、ファルとクリスはそれぞれに思い悩み悲しむような出来事を経験し、そしてその感情が演奏に魅力を与えることに気付いていきます。&lt;/p&gt;

&lt;p&gt;1/11にクリスとトルタがファルとアーシノに鉢合わせしますが、途端にアーシノとトルタの様子がおかしくなります。
アーシノは年末にクリスとファルが二人でいる際に会っていましたが、この時ファルは常に敬語で話していました。
この日はクリスに対しては崩れた口調で話し、アーシノには敬語で話しています。
ファルがアーシノに気を持たせつつ都合よく利用し続けていた、ということが示唆されますが、アーシノはこの距離感を見せつけられることでファルに対して疑念を抱き、またトルタは(昼間にクリスの話を聞き、自分の役割を終えてファルに託すことを受け入れつつあるようでしたが)、ファルとアーシノの関係が続いていること、それに加えてこのアーシノの様子から、不穏なものを感じ取らずにはいられなかったというところでしょうか。
ファルとしては、クリスとの関係性が非常に良好に推移しており、アーシノにフォルテール奏者としての利用価値は見出していないことから、この段階で必要であればアーシノを切り捨てる選択はいつでもできる状況であったと考えられます。&lt;/p&gt;

&lt;p&gt;そしてアリエッタとファルの二人に対する気持ちの揺れ動きから、悲しみと降雨量とフォルテールの音の深みを増していったクリスですが、卒業演奏3日前にして開き直り、自身のファルへの好意を認めて受け入れ、一転して現状に満足するようになります。
クリスがほかの結末を辿ったときに、もしかしたらコーデル先生がトルタに語ったかもしれない(al fineルート)言葉のように、「彼が幸せを感じれば感じるほど、その音に魅力がなくなって」しまいます。&lt;/p&gt;

&lt;p&gt;1/18の夜、ファルはクリスの変化の理由に気付いてクリスに幸せかどうか尋ね、クリスはそれを肯定します。
翌日、ファルはクリスとの練習後にアーシノと会い、指定した時間に自宅を訪れるよう誘導します。
(ファルがクリスに部屋で待つように指示して鍵を渡す場面以降の声色が、感情を殺している感じがあって好きです)
20時15分、窓の外を見ながら(来訪者が自室に近付いてくるのを確認しながら)タイミングを合わせて話し始め、最も効果的かつ最大限にアーシノを傷つける様子をクリスに対して演出します。&lt;/p&gt;

&lt;p&gt;以降の展開はクリスの選択に委ねられ、複数のエンディングに分岐します。&lt;/p&gt;

&lt;h3 id=&#34;エンディング&#34;&gt;エンディング&lt;/h3&gt;

&lt;h4 id=&#34;バッドエンド-演奏失敗&#34;&gt;バッドエンド(演奏失敗)&lt;/h4&gt;

&lt;p&gt;あれだけ練習を重ねた曲の演奏に失敗するという事態は、ファルが言うように、クリスが当てつけとして故意に手を抜かなければ起きるものではありません。
突然の裏切りにさまざまな感情が渦巻いていたとしても、自身の演奏を汚してそれに応えることはクリスにはできないとファルは考えたことでしょう。&lt;/p&gt;

&lt;p&gt;この結末に至るということは、その思惑が外れたことになります。
ファルにとっては完全な敗北であり、プロへの道も大きく回り道をしなけければならなくなるかもしれません。
一方で、このような結果になる可能性は相当に低いとはいえ、ファルが検討していないはずはありません。
彼女の計算高さからして、この演奏で失敗してもプロへの道が完全に閉ざされることはありえませんし、彼女はこの結末を受け入れなければならないリスクも当然引き受けた上で行動を起こしたに違いありません。&lt;/p&gt;

&lt;h4 id=&#34;バッドエンド-可もなく不可もなく&#34;&gt;バッドエンド(可もなく不可もなく)&lt;/h4&gt;

&lt;p&gt;裏切りを受け、それでもクリスの感情は激しく昂ることなく、ただ演奏をこなす結末です。
ファルのプロへの道は近づきもせず、かといって遠ざかりもしないでしょう。
ファルとしては思惑が外れた形ですが、卒業演奏前日の時点で既にクリスの音はファルにとって全く価値を感じさせないものになっていたでしょうから、結果として何もしないよりも悪い形の結末ではない、と彼女は思うのではないでしょうか。&lt;/p&gt;

&lt;h4 id=&#34;バッドエンド-演奏成功&#34;&gt;バッドエンド(演奏成功)&lt;/h4&gt;

&lt;p&gt;個人的には、ある意味最も「納得のいく」結末であるように感じます。
卒業演奏は成功し、ファルは夢の実現に大きく近づきます。
ファルの裏切りに失望したクリスは彼女のもとを去りますが、それは彼女の言うように「幸せな」選択であったといえるでしょう。&lt;/p&gt;

&lt;p&gt;最後の演奏でファルの感情がクリスに流れ込んだとき、そこに迷いはありませんでした。
しかしそれは、クリスを徹底的に利用しようと決めたために迷いがなくなった、というだけとは思えません。
全ての選択をクリスに委ねた上で、彼がどちらを選んでも受け入れるだけの覚悟がゆえの迷いのなさではないでしょうか。
それこそが夢のために進み続けることのできるファルの強さであるともいえます。&lt;/p&gt;

&lt;h4 id=&#34;グッドエンド&#34;&gt;グッドエンド&lt;/h4&gt;

&lt;p&gt;それでもクリスはファルと共にゆくことを選択し、彼女にとっての至上の価値であり続けることを望みますが、皮肉にも、クリスがこの選択に至ることで、彼はファルにとっての価値を失います。
ファルとの未来を受け入れるという心象の変化は、卒業演奏直前で彼の音楽が魅力を失くしたのと同じ構図であり、すぐにクリスの演奏はファルが望むに足るものには遠く及ばなくなるでしょう。
そして、それでもクリスを片翼として共に高みを目指すことを決めたファルが行うべきことは、再びクリスを、今度は二度と止むことのない雨の中へと突き落とすこと以外にありません。&lt;/p&gt;

&lt;h2 id=&#34;ファルシータの迷い&#34;&gt;ファルシータの迷い&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;ひとつの夢のため&lt;br /&gt;
あきらめなきゃならないこと&lt;br /&gt;
たとえば　今　それが恋だとしたら　迷う&lt;br /&gt;
居場所はどこだろう　私の役割はなに？&lt;br /&gt;
ずっとずっと思ってた&lt;br /&gt;
そして　みつけた気がしたの&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;small&gt;出典： 岡崎律子『メロディー』&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;仮にファルが最初から最後までただクリスを利用しようとしか思っていなかったのであれば、クリスを裏切り、傷つけ、失望させ、深い悲しみを与えることこそが卒業演奏を成功に導くためにとるべき行動です。
これはフォルテールの音に魅力を取り戻すにとどまらず、より大きな成功を得るチャンスでもあります。
発表前日の段階でクリスの音が魅力を失っていることを考慮して各エンディングの結末を振り返ってみると、ほとんどの結末でファルがプロに近付くために得るものこそあれ、失うものは少ないことがわかります。
クリスもファルも音楽に対しては常に真摯であったため、クリスが演奏の手を抜くことは考え難く、裏目に出る公算も低いと考えられます。&lt;/p&gt;

&lt;p&gt;よって他者を利用するためだけの存在として捉え、誰も信じず誰にも感謝することのないファルシータ・フォーセットは、何の迷いもなくクリスを裏切ることを選択するでしょう。
しかし、この夢のために恋をあきらめようとして迷う彼女の姿がそこにはあります。&lt;/p&gt;

&lt;h2 id=&#34;本当の自分&#34;&gt;本当の自分&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;手をつないで歩いたり&lt;br /&gt;
さむいね　うなずいたり&lt;br /&gt;
わけあうと幸せね&lt;br /&gt;
どうして今まで気づかずに&lt;/p&gt;

&lt;p&gt;Look at me　Listen to me　アタシヲアイシテ&lt;br /&gt;
だれも知らない心　見抜いてくれたら…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;small&gt;出典： 岡崎律子『雨のmusique』&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;最初は、彼女にとっての他の大勢の人間と同じように、クリスはファルにとって利用するためだけの存在でした。
しかし、クリスに接近し、彼に気に入られようと振る舞ううちに、ファル自身もまたクリスに対して好意を持ってしまいます。&lt;/p&gt;

&lt;p&gt;もっとも、クリスの音に惹かれてしまった時点で、遅かれ早かれ、ファルはそこにパートナーとしての利用価値以上のものを感じずにはいられなかったのかもしれません。
本作では、音楽性と人間性が類似するという趣旨の描写が幾度か登場します。
ファルがクリスの奏でる悲しみの音に惹かれた以上、人間的な部分でも惹かれずにはいられなかったはずです。
クリスが(敢えて人間的な部分とは分けて語りつつも)言うように、音楽的に惹かれてしまっているから仕方ないのです。&lt;/p&gt;

&lt;p&gt;クリスとの関わりの中で、「少しだけやさしい気持ち」になれることを感じたファル。
一方で、ファルはそれまでの人生で磨き上げてきた処世術によって、ごく自然に「クリスにとってのファル」を演じることができてしまいます。&lt;/p&gt;

&lt;p&gt;クリスが見ている「真面目で、優しくて、一生懸命」なファルと、他人を利用するだけの存在とみなし、必要なら傷つけることも厭わない本当の自分とのギャップ。
クリスとの関係を幸せに思いながらも、それはただ演じているだけの自分でしかないと感じるもどかしさ。
本当の自分を知ってほしいけれど、酷い人間だと知られてしまったら今までの関係を保てないかもしれないという不安。&lt;/p&gt;

&lt;p&gt;彼女もまた、葛藤を抱えていました。&lt;/p&gt;

&lt;h2 id=&#34;ファルシータの選択&#34;&gt;ファルシータの選択&lt;/h2&gt;

&lt;p&gt;とはいえ、クリスが悲しみの音色を持ち続けている限りにおいては、クリスを手に入れることとクリスの音を手に入れることの間に違いはありませんでした。
これらを両立させられないことに気付いてしまったとき、ファルはクリスよりも先に、物語の結末に決定的な影響を及ぼす選択を迫られます。&lt;/p&gt;

&lt;p&gt;ファルに初めて芽生えた感情である、恋に恋するかのような純粋な気持ちと、彼女がこれまでの人生の全てを捧げてきた夢。
彼女にとって、夢のために進み続けることを諦めるという選択はありません。
それは何もなかった頃の自分に逆戻りすることに等しく、彼女の生き方の否定であるというばかりか、彼女にとって前に進み続けることこそが、それまでの人生で踏みつけてきた人たちに対する責務、あるいは贖罪でもあるからです。&lt;/p&gt;

&lt;p&gt;誰よりも努力し、前に進み続けることでしか生きられない彼女が、先に進むために彼女自身の想いを捨てなければならない。
選ぶことのできるはずのない、あまりにも残酷な選択。あるいは、これは彼女にとっての報いなのか。&lt;/p&gt;

&lt;p&gt;ファルがクリスを裏切ったとき、本当は彼女の中で答えなんて出ていなかったのかもしれません。
それでも、もう後戻りのできないところまで来てしまっていました。&lt;/p&gt;

&lt;h2 id=&#34;本当の自分-1&#34;&gt;「本当の自分」&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;ここでならば言える&lt;br /&gt;
今まで言えなかったことや&lt;br /&gt;
胸の内さえも　口をついて出るメロディー&lt;br /&gt;
やがて　覚悟が芽ばえていた&lt;br /&gt;
この夢のためならば　他を捨ててかまわない&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;small&gt;出典： 岡崎律子『メロディー』&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;アーシノを見せしめのように傷つけ、私はこれほどまでに酷い人間なのだと言い張りながらも受容を求めるファル。
その姿はまるで、アリエッタとして見せてきた側面も受け入れてほしいと願うトルティニタの裏返しのようでもあります。&lt;/p&gt;

&lt;p&gt;確かに彼女は、クリスの前での自分の振る舞いに葛藤を抱えていました。
しかし、「そのまま隠せれば良かったんだけど、隠せなかった」と言っているように、夢と恋のどちらかを選ぶことが避けて通れない状況に陥らなければ、必ずしもファルが酷い人間であるところを見せつける必要はなく、また彼女自身もそれを積極的に望んではいなかったように思われます。&lt;/p&gt;

&lt;p&gt;ファルが孤児院を訪れたとき、そこで何があったかは語られていませんが、それはファルが「悲しみ、思い悩む」ようなことであったと示唆されています。
孤児院には二度と戻りたくないと嫌悪感をあらわにし、グラーヴェもリセルシアも嫌っていると言った彼女が、本当にただ酷い人間だったというのであれば、利用する対象しかいないはずのそこで何を思い悩むことがあったというのでしょうか。&lt;/p&gt;

&lt;p&gt;悪いことと知っていながらルールを破る、そんな一面をファルが冗談めかして明かした際、それはより長く練習を続けていたいという本心ではないかとクリスは返しています。
彼女の根底にあるのは歌を追い求める姿であり、それは偽善的な振る舞いでも、その裏返しとしての露悪的な振る舞いでもない。
酷い人間としてのファルは彼女の一面でこそあれ、それだけが彼女の本来の姿と言い切れるものではないのではないか。
そうであるとすれば、このクリスの返答はファルにとって救いとなり得るものであったかもしれません。&lt;/p&gt;

&lt;p&gt;しかし、そんな救いも、彼女は否定してしまいます。
「本当の自分」は酷い人間で、つまりクリスの前での振る舞いは単なる演技で、&lt;strong&gt;そのとき感じた幸せも、「本当の自分」ではない&lt;/strong&gt;。
「本当の自分」はクリスの&lt;strong&gt;フォルテールの音が&lt;/strong&gt;好きで、そしてクリスを&lt;strong&gt;&lt;em&gt;愛して&lt;/em&gt;&lt;/strong&gt;いる。
そう自分に言い聞かせながら。&lt;/p&gt;

&lt;p&gt;本当の自分を知ったうえで、それでも好きだと言って欲しい。&lt;/p&gt;

&lt;p&gt;「本当の自分」を知ってもらえばクリスは失望し、悲しみを感じるに違いない。
自分のことを嫌いになるかもしれない。
それでも好きでいてほしいという本心の吐露か。
否。
それは、夢のために全てを捨て、泣きそうになりながら自身の恋さえも否定してしまう、ファルの悲痛な叫びではないでしょうか。&lt;/p&gt;

&lt;p&gt;もはや、ファルの想いが報われることは二度とありません。
クリスが彼女を受け入れ、共に歩むと決めたとしても、もはや捨て去った恋心にその気持ちが届くことはないでしょう。
既に彼女は自ら抱いた感情を捨て、かわりに愛という言葉で塗り潰してしまったのだから。&lt;/p&gt;

&lt;p&gt;自分の隠していた一面を知り、それでも好きだと言ってくれる、ファルが本当に待ち望んでいたはずのクリスの気持ちさえも。
前に進み続ける覚悟を決めた彼女は、自分の夢のために利用し尽くすでしょう。&lt;/p&gt;

&lt;p&gt;実のところ、ファルシータエンドにおいてクリスがファルを受け入れた後、互いに相手のことを「好きだ」と言うことは一度もありません。
このエンディングでファルとクリスは、「側にいる」「愛している」という言葉を使うだけです。
一方で、それよりも前に「愛している」という言葉が使われるのは一度きりです。
その場面を思い出してみてください。
果たして、この「愛」とは二人の間でどのような意味を持つ言葉なのでしょうか。&lt;/p&gt;

&lt;h2 id=&#34;メロディー&#34;&gt;メロディー&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;つめたいと思うでしょう&lt;br /&gt;
振り向かない私を　だけど&lt;br /&gt;
時には　どちらかを選ぶこと　避けて通れない&lt;br /&gt;
皮肉なもの　そして&lt;br /&gt;
抱えてるカナシミこそが　奏でるメロディー&lt;br /&gt;
それは　とても力を持つ&lt;br /&gt;
さよなら　ありがとう&lt;br /&gt;
言えなかった言葉たちを&lt;br /&gt;
奏でましょう&lt;br /&gt;
君のその背中に　祈りを込めて&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;small&gt;出典： 岡崎律子『メロディー』&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;この箇所の歌詞は、演奏成功後にクリスに拒まれた結末を歌っているように思えます。
先程も書きましたが、個人的にはこのバッドエンドが一番しっくりくるような気がしています。&lt;/p&gt;

&lt;p&gt;コーデル先生がトルタに語ったかもしれない(al fineルート)言葉では、クリスは「幸せを感じれば感じるほど、その音に魅力がなくなって」いくと言われていますが、しかしこうも言われています。
「幸せの先にも、きっと素晴らしい音はあるはずだ。例え今の地位、彼の魅力となっている音を失ったとしても」と。&lt;/p&gt;

&lt;p&gt;さまざまな感情が音楽に魅力を与えるのであれば、幸せに思う気持ちもまた音に魅力を与えるかもしれない。
ファルがその考えに行き着いたかどうかはわかりません。
皮肉なことに、ファルはクリスの悲しみが奏でる音にこそ惹かれてしまっていました。
夢のためにクリスを利用すると決めたとき、ファルにはクリスを幸せから遠ざける以外の手段を持てなかったのです。&lt;/p&gt;

&lt;p&gt;もしくは、夢よりも恋を選び、その先で幸せに満ちた音色を奏でるファルとクリス。
そのような未来絵図に、自分自身の存在を彼女はどうしても描き出すことができなかったのかもしれません。
それは、これまでの彼女の人生を、誰かを傷つけてでも進み続けてきた道筋を否定することでしか辿り着くことができない場所だったから。&lt;/p&gt;

&lt;p&gt;ところで、クリスが側にいて利用価値を持ち続ける限りにおいてはファルは彼を利用せずにはいられませんが、クリスがファルのもとを去るならば、もはや彼はファルにとって価値のある人間ではありません。
逆に言えば、もうファルはクリスを利用しなくて良いことになります。&lt;/p&gt;

&lt;p&gt;「誰にも感謝しない」と言い放った彼女がそんなクリスを想い祈ることができる結末は、彼女の行く先に微かな希望を感じさせるものではないでしょうか。&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;ファルシータ・フォーセットは、歌うことが好きで、歌を歌って生きるという夢のためにあらゆる努力を惜しみません。
才能にも恵まれていて、頭がよく計画性も実行力も兼ね備え、努力を惜しまないどころか手段も選ばないし、その行動の全てが自らの夢の実現のために捧げられている、そんな少女です。
彼女は人と人は利用しあうだけの存在だと語り、誰にも感謝せず、時に誰かを裏切り傷つけることも厭わず、ただ夢のためだけに生きてきました。&lt;/p&gt;

&lt;p&gt;彼女がクリスと出会い、彼の音に惹かれ、そして、彼自身に惹かれ、…やがて夢と恋のどちらか片方だけを選ばなければならなくなったとき、彼女はついに恋を選ぶことができませんでした。&lt;/p&gt;

&lt;p&gt;いつか報われていたかもしれない未来も、初めて抱いたやさしい感情さえも捨て去ることができる強さと、それでも傷つかずにはいられない弱さを持った彼女に。&lt;/p&gt;

&lt;p&gt;去っていくクリスの背中に感謝の祈りを奏でる彼女に。&lt;/p&gt;

&lt;p&gt;少しだけ、涙を流しましょう。
&lt;/section&gt;&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>atcoder-cli チュートリアル</title>
      <link>http://tatamo.81.la/blog/2018/12/07/atcoder-cli-tutorial/</link>
      <pubDate>Fri, 07 Dec 2018 23:22:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/12/07/atcoder-cli-tutorial/</guid>
      <description>
        &lt;p&gt;&lt;a href=&#34;https://www.npmjs.com/package/atcoder-cli&#34;&gt;atcoder-cli&lt;/a&gt;の使用方法を解説していきます。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;atcoder-cliは、&lt;a href=&#34;https://beta.atcoder.jp/&#34;&gt;AtCoder&lt;/a&gt;用のコマンドラインツールです。
このツールの特徴については、&lt;a href=&#34;http://tatamo.81.la/blog/2018/12/07/atcoder-cli/&#34;&gt;紹介記事&lt;/a&gt;をご覧ください。&lt;/p&gt;

&lt;h2 id=&#34;インストール&#34;&gt;インストール&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ pip3 install online-judge-tools
$ npm install -g atcoder-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;詳細なインストール手順は、&lt;a href=&#34;2018/12/07/atcoder-cli-installation-guide/&#34;&gt;atcoder-cli インストールガイド&lt;/a&gt; を参照してください。&lt;/p&gt;

&lt;h2 id=&#34;atcoder-cliのインストール確認&#34;&gt;atcoder-cliのインストール確認&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;※行頭の「&lt;code&gt;$&lt;/code&gt;」は入力しないでください&lt;/p&gt;

&lt;p&gt;&lt;code&gt;acc&lt;/code&gt;コマンドが使用できれば、インストールは正しく行えています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kmyk/online-judge-tools&#34;&gt;online-judge-tools&lt;/a&gt;がインストールされている場合、atcoder-cliは自動的にそれを検知します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc check-oj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を入力して、availableと表示されれば連携機能が有効になっています。&lt;/p&gt;

&lt;h2 id=&#34;atcoderへのログイン&#34;&gt;AtCoderへのログイン&lt;/h2&gt;

&lt;p&gt;atcoder-cliを使用するためには、初回使用時にAtCoderへのログインが必要になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc login
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンドでAtCoderにログインしてください。
ユーザー名とパスワードの入力を求められますが、パスワードは安全のため入力しても画面には表示されないので注意してください。&lt;/p&gt;

&lt;p&gt;ユーザー名・パスワードはatcoder-cliによって保存されることはありません。
そのかわりにログインセッションの情報が設定ファイルとして保存されますが、共用のPCなどで他の人が使用する可能性がある場合は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc logout
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で現在のログイン状態を破棄することができます。&lt;/p&gt;

&lt;p&gt;ログインしている状態かどうか知るためには、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc session
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を使用してください。&lt;/p&gt;

&lt;p&gt;online-judge-toolsを使用している場合は、&lt;code&gt;oj&lt;/code&gt;コマンドを使用してそちらでもログインしておく必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ oj login https://beta.atcoder.jp/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でログインを行ってください。&lt;/p&gt;

&lt;h2 id=&#34;atcoder-cliでコンテスト用ディレクトリを作成する&#34;&gt;atcoder-cliでコンテスト用ディレクトリを作成する&lt;/h2&gt;

&lt;p&gt;以後、online-judge-toolsを使用している前提とします。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://beta.atcoder.jp/contests/abc101&#34;&gt;ABC101&lt;/a&gt;のコンテストの問題を解くことを想定してみましょう。&lt;/p&gt;

&lt;p&gt;ABC101のURLは &lt;a href=&#34;https://beta.atcoder.jp/contests/abc101&#34;&gt;https://beta.atcoder.jp/contests/abc101&lt;/a&gt; ですが、この末尾の&lt;code&gt;abc101&lt;/code&gt;がこのコンテストのIDとなります。
&lt;code&gt;acc n&lt;/code&gt;コマンドにこのIDを指定することで、ABC101用のディレクトリを作らせてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc new abc101
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンドを実行すると、問題の一覧が表示されます。
上下キーでカーソルを移動し、スペースキーで選択することで、サンプルケースをダウンロードしてくる問題を選ぶことができます。
この問題は後から追加することもできます。
一番上のA問題は予め選択されているはずなので、今回はそのままエンターキーを押しましょう。&lt;/p&gt;

&lt;p&gt;コマンドの実行が完了すると、&lt;code&gt;abc101&lt;/code&gt;という名前のディレクトリが作られていると思います。
このディレクトリの中に移動してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd abc101
$ ls # ディレクトリの中身を表示
a  contest.acc.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;a/&lt;/code&gt;という名前のディレクトリと、&lt;code&gt;contest.acc.json&lt;/code&gt;というファイルが一つ存在していると思います。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;contest.acc.json&lt;/code&gt;は、atcoder-cliがコンテストや問題の情報を取得したり、問題ディレクトリの情報を管理するためのファイルです。
通常の使用中は、このファイルに触る機会はありません。&lt;/p&gt;

&lt;p&gt;ディレクトリ&lt;code&gt;a/&lt;/code&gt;に移動してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd a/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このディレクトリの中には、&lt;code&gt;tests/&lt;/code&gt;という名前のディレクトリが既に存在しています。
&lt;code&gt;online-judge-tools&lt;/code&gt;との連携機能により、自動的に問題のサンプルケースがダウンロードされたものです。&lt;/p&gt;

&lt;p&gt;この&lt;code&gt;a/&lt;/code&gt;ディレクトリの中で、問題を解いていきます。
たとえば、&lt;code&gt;main.cpp&lt;/code&gt;という名前のファイルを作り、&lt;a href=&#34;https://beta.atcoder.jp/contests/abc101/tasks/abc101_a&#34;&gt;A問題&lt;/a&gt;を解くプログラムを書いてみましょう。&lt;/p&gt;

&lt;h2 id=&#34;問題を提出する&#34;&gt;問題を提出する&lt;/h2&gt;

&lt;p&gt;書き終わったら、正しくプログラムが書けているか確認します。&lt;/p&gt;

&lt;p&gt;online-judge-toolsは入出力ケースの自動テスト機能を備えているため、自動ダウンロードされたサンプルケースを用いてテストができます。
現在atcoder-cliはテストに関する機能の連携が未実装のため、詳しくは&lt;a href=&#34;https://kimiyuki.net/blog/2017/01/19/pr-online-judge-tools/&#34;&gt;online-judge-toolsの解説記事&lt;/a&gt;を参照してください。&lt;/p&gt;

&lt;p&gt;問題文で与えられた入力例について正しい答えが得られていることを確認したら、プログラムの提出をしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc submit main.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;atcoder-cliでは、提出するファイルを指定するだけで提出先を自動的に判別します。
たとえば、&lt;code&gt;abc101/a/&lt;/code&gt;ディレクトリの中にあるプログラムはABC101のA問題のプログラムとして提出が行われます。&lt;/p&gt;

&lt;p&gt;提出が完了してA問題を解き終わったら、一つ上のディレクトリに戻りましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;問題用ディレクトリを追加する&#34;&gt;問題用ディレクトリを追加する&lt;/h2&gt;

&lt;p&gt;次はB問題を解いていくので、B問題用の新しいディレクトリを作る必要があります。
コンテストディレクトリの中で&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc add
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンドを入力すると、再び問題を選択する画面になります。
先程既にディレクトリを作ったA問題は選択できなくなっています。&lt;/p&gt;

&lt;p&gt;このようにして問題用のディレクトリを作って問題を解いていくのが、atcoder-cliでコンテストに取り組む流れになります。&lt;/p&gt;

&lt;h2 id=&#34;デフォルト動作の設定&#34;&gt;デフォルト動作の設定&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;acc new&lt;/code&gt;コマンドや&lt;code&gt;acc add&lt;/code&gt;コマンドで問題ディレクトリを作成する際、毎回問題を選択してエンターキーを押さないといけないのが煩雑に感じるかもしれません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンドによって、現在のグローバル設定を確認することができます。
この中に、&lt;code&gt;default-task-choice: inquire&lt;/code&gt; と書かれた行があるのではないかと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc config default-task-choice next
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとすることで、問題の選択方法を変更することができます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;next&lt;/code&gt;を指定することで、問題を選ぶ画面を出さずに次の一問だけを自動で選ぶようにしたり、&lt;code&gt;all&lt;/code&gt;を指定することで全ての問題ディレクトリを最初に作るようにできます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;default-task-choice&lt;/code&gt;に設定可能な選択肢については、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc add -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で確認することができます。&lt;/p&gt;

&lt;p&gt;また、グローバル設定で設定可能な項目の一覧は、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc cnfig -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で確認できます。&lt;/p&gt;

&lt;h2 id=&#34;テンプレート設定&#34;&gt;テンプレート設定&lt;/h2&gt;

&lt;p&gt;予めマクロの定義や入力を受け付ける部分などの雛形が書かれたプログラムファイルを用意しておくことで、問題ディレクトリを作成する際にそのファイルをコピーして配置することができます。&lt;/p&gt;

&lt;p&gt;たとえば、C++用のテンプレートを用意するには、まずatcoder-cliの設定ファイルが配置されたディレクトリに移動し、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd `acc config-dir`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここに&lt;code&gt;cpp&lt;/code&gt; という名前のディレクトリを作ります。
テンプレートの名前は、このディレクトリ名によって決定されます。&lt;/p&gt;

&lt;p&gt;その中に、コピーしたい雛形である&lt;code&gt;main.cpp&lt;/code&gt;ファイルと、&lt;code&gt;template.json&lt;/code&gt;ファイルを作成します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;template.json&lt;/code&gt;ファイルには以下のように記述します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;task&amp;quot;:{
    &amp;quot;program&amp;quot;: [&amp;quot;main.cpp&amp;quot;],
    &amp;quot;submit&amp;quot;: &amp;quot;main.cpp&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;template.json&lt;/code&gt;を配置したら、&lt;code&gt;acc templates&lt;/code&gt;コマンドを使ってテンプレートが正常に認識されているか確認します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc templates
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正しく読み込まれていれば、&lt;code&gt;cpp&lt;/code&gt;という名前の項目が表示されます。&lt;/p&gt;

&lt;p&gt;実際にこのテンプレートを利用するには、&lt;code&gt;acc new&lt;/code&gt;コマンドと&lt;code&gt;acc add&lt;/code&gt;コマンドを実行する際に、&lt;code&gt;--template&lt;/code&gt;オプションを使用して使用するテンプレートを指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc add --template cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このようにして問題ディレクトリを作成すると、その中に&lt;code&gt;main.cpp&lt;/code&gt;がコピーされます。
また&lt;code&gt;template.json&lt;/code&gt;の&lt;code&gt;&amp;quot;submit&amp;quot;&lt;/code&gt;プロパティに&lt;code&gt;main.cpp&lt;/code&gt;を設定しているため、問題ディレクトリの中にいる場合は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc submit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように、明示的にファイルを指定しなくても&lt;code&gt;main.cpp&lt;/code&gt;が提出対象のファイルであると判断されます。&lt;/p&gt;

&lt;p&gt;頻繁に使用するテンプレートは、常に&lt;code&gt;--template&lt;/code&gt;オプションをつけるかわりに、グローバル設定からデフォルトのテンプレートとして設定することが可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc config default-template cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これにより、&lt;code&gt;acc new&lt;/code&gt;コマンドと&lt;code&gt;acc add&lt;/code&gt;コマンドの実行時に自動的に&lt;code&gt;cpp&lt;/code&gt;テンプレートが使用されるようになります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;template.json&lt;/code&gt;についてのより詳細な情報は、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc template -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と入力すると知ることができます。&lt;/p&gt;

&lt;h2 id=&#34;その他&#34;&gt;その他&lt;/h2&gt;

&lt;p&gt;使用可能なコマンドの一覧は、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で表示することができます。&lt;/p&gt;

&lt;p&gt;また、コマンドごとの詳細な解説、利用可能なオプションを知るためには、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ acc &amp;lt;コマンド名&amp;gt; -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を使用してください。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がatcoder-cliの基本的な使い方になります。
このツールによってAtCoderで問題を解く作業の効率化ができることを願っています。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>atcoder-cli インストールガイド</title>
      <link>http://tatamo.81.la/blog/2018/12/07/atcoder-cli-installation-guide/</link>
      <pubDate>Fri, 07 Dec 2018 23:21:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/12/07/atcoder-cli-installation-guide/</guid>
      <description>
        &lt;p&gt;&lt;a href=&#34;https://www.npmjs.com/package/atcoder-cli&#34;&gt;atcoder-cli&lt;/a&gt;のインストール方法を解説していきます。&lt;/p&gt;

&lt;h2 id=&#34;わかる人向け&#34;&gt;わかる人向け&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ pip3 install online-judge-tools
$ npm install -g atcoder-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上です。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;インストールガイド&#34;&gt;インストールガイド&lt;/h2&gt;

&lt;p&gt;atcoder-cliをインストールするためには、Node.js環境が必要です。
また、Python3で動作する&lt;a href=&#34;https://github.com/kmyk/online-judge-tools&#34;&gt;online-judge-tools&lt;/a&gt;を併用することを強く推奨しているため、こちらも同時にインストールします。&lt;/p&gt;

&lt;p&gt;※ 以後、コマンド例の行頭の「&lt;code&gt;$&lt;/code&gt;」はターミナルのプロンプト記号を表しているため、実際に入力する必要はありません。
&lt;code&gt;$&lt;/code&gt;より後の部分を入力して実行してください。&lt;/p&gt;

&lt;h3 id=&#34;事前準備-windowsでwslを使う場合&#34;&gt;事前準備：WindowsでWSLを使う場合&lt;/h3&gt;

&lt;p&gt;Windowsの場合、直接言語環境をインストールする方法と、&lt;abbr title=&#34;Windows Subsystem for Linux&#34;&gt;WSL&lt;/abbr&gt;を使う方法があります。
どちらを使用するかはお好みですが、Linuxの使い方がわかるという方はWSLを選択するとよいでしょう。
WSLを使う場合は設定より有効化し、ストアからUbuntuなどのLinuxディストリビューションをインストールします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参考: &lt;a href=&#34;https://qiita.com/yoshikingt/items/ab86411e6031459db805&#34;&gt;https://qiita.com/yoshikingt/items/ab86411e6031459db805&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;WSLのインストール後は、Linuxの場合のインストール方法を参照してください。&lt;/p&gt;

&lt;h3 id=&#34;事前準備-macの場合&#34;&gt;事前準備：Macの場合&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://brew.sh/index_ja&#34;&gt;Homebrew&lt;/a&gt;の使用を想定します。
&lt;code&gt;brew&lt;/code&gt;コマンドが存在しない場合、以下のコマンドをターミナルで実行することでインストールしてください。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ /usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行が完了したら、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ brew -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コマンドをターミナルで実行して、エラーなどが起きずにHomebrewのバージョン名が表示されていることを確認してください。&lt;/p&gt;

&lt;h3 id=&#34;必要な環境のインストール&#34;&gt;必要な環境のインストール&lt;/h3&gt;

&lt;p&gt;Python3とNode.jsの両方をインストールしてください。
OSごとにインストール方法が違うため、お使いのOSの欄を参照してください。&lt;/p&gt;

&lt;p&gt;環境によってはもう少し良いやり方がある場合もありますが、この記事では少ない手順でインストールが完了することを目的として方法を選んでいます。&lt;/p&gt;

&lt;h4 id=&#34;windows&#34;&gt;Windows&lt;/h4&gt;

&lt;h5 id=&#34;python3&#34;&gt;Python3&lt;/h5&gt;

&lt;p&gt;公式インストーラーより&lt;a href=&#34;https://www.python.org/downloads/windows/&#34;&gt;Python&lt;/a&gt;をインストールします。
最新バージョンの&amp;rdquo;Download Windows x86-64 web-based installer&amp;rdquo;からインストーラーをダウンロードし、実行してください。
インストール時に、&amp;rdquo;Add Python 3.x to PATH&amp;rdquo;のチェックを忘れずに入れるようにしましょう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参考: &lt;a href=&#34;https://azriton.github.io/2017/07/25/Python-3.6-64bit%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/&#34;&gt;https://azriton.github.io/2017/07/25/Python-3.6-64bit%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;node-js&#34;&gt;Node.js&lt;/h5&gt;

&lt;p&gt;公式インストーラーより&lt;a href=&#34;https://nodejs.org/ja/download/&#34;&gt;Node.js&lt;/a&gt;をインストールします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参考: &lt;a href=&#34;https://qiita.com/taiponrock/items/9001ae194571feb63a5e&#34;&gt;https://qiita.com/taiponrock/items/9001ae194571feb63a5e&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;mac-linux&#34;&gt;Mac/Linux&lt;/h4&gt;

&lt;p&gt;端末コンソールを開いて作業をしてください。&lt;/p&gt;

&lt;h5 id=&#34;python3-1&#34;&gt;Python3&lt;/h5&gt;

&lt;p&gt;Linuxの場合は、&lt;code&gt;brew&lt;/code&gt;のかわりにディストリビューションごとのパッケージマネージャを使用してください。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ # Macの場合はこちらを実行してください
$ brew install python3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ # UbuntuまたはDebianを使用している場合はこちらを実行してください
$ # 他のLinuxディストリビューションを使っている人はこんな記事を読むまでもなくインストールを終わらせていると思われるため触れません
$ sudo apt-get install python3
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;node-js-1&#34;&gt;Node.js&lt;/h5&gt;

&lt;p&gt;パッケージマネージャによって古いバージョンのNodeしか手に入らないことがあるので、&lt;a href=&#34;https://github.com/creationix/nvm&#34;&gt;nvm&lt;/a&gt;を使ってインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコマンドの実行が完了したら、一度ターミナルを閉じてください。
新しいターミナルを開き、続きのコマンドを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ nvm install node
$ npm install -g npm
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;atcoder-cli-online-judge-toolsのインストール&#34;&gt;atcoder-cli, online-judge-toolsのインストール&lt;/h3&gt;

&lt;p&gt;言語環境のインストールが正しく行われていることを確認します。
Windowsの場合はコマンドプロンプトを、Mac/Linuxの場合は端末コンソールを開いてください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip3 -V
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と入力してエンターキーを押し、バージョン番号が表示されることを確認してください。&lt;/p&gt;

&lt;p&gt;同様にして、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行し、バージョン番号が表示されることを確認してください。&lt;/p&gt;

&lt;p&gt;「コマンドが見つかりません」や「command not found」、それに似たメッセージが表示される場合はPython3およびNode.jsのインストールに失敗している可能性があります。
その場合は再度手順を確認してインストールし直したり、「Python3 インストール (+OS名)」などで検索して調べてください。&lt;/p&gt;

&lt;p&gt;問題がなかった場合は、atcoder-cliおよびonline-judge-toolsのインストールを行います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g atcoder-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;pip3 install online-judge-tools
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とそれぞれ入力してエンターキーを押すことで、atcoder-cliとonline-judge-toolsがインストールされます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;acc -h
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;oj -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とそれぞれ入力し、ヘルプが表示されることを確認してください。&lt;/p&gt;

&lt;p&gt;ここまででインストール作業は完了です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;2018/12/07/atcoder-cli-tutorial/&#34;&gt;atcoder-cli チュートリアル&lt;/a&gt;に進み、atcoder-cliの基本的な使い方を確認しましょう。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>コマンドラインツールatcoder-cliを公開しました</title>
      <link>http://tatamo.81.la/blog/2018/12/07/atcoder-cli/</link>
      <pubDate>Fri, 07 Dec 2018 23:20:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/12/07/atcoder-cli/</guid>
      <description>
        &lt;p&gt;この記事は&lt;a href=&#34;https://adventar.org/calendars/3095&#34;&gt;Competitive Programming (2) Advent Calendar 2018&lt;/a&gt;の7日の記事です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://beta.atcoder.jp/&#34;&gt;AtCoder&lt;/a&gt;のためのコマンドラインツール、&lt;a href=&#34;https://www.npmjs.com/package/atcoder-cli&#34;&gt;atcoder-cli&lt;/a&gt;をリリースしました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;2018/12/07/atcoder-cli-installation-guide/&#34;&gt;インストールガイド&lt;/a&gt;と&lt;a href=&#34;2018/12/07/atcoder-cli-tutorial/&#34;&gt;チュートリアル&lt;/a&gt;の記事も用意しています。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;モチベーション&#34;&gt;モチベーション&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://beta.atcoder.jp/&#34;&gt;AtCoder&lt;/a&gt;のコンテストで問題を解く際に、問題用のディレクトリを作る、プログラム用のファイルを用意する、問題を解き終わったらソースコードをコピーして提出するなど、プログラムを書く以外の部分で手間がかかることがあります。
そのため、問題を提出する、プログラムがサンプルケースで失敗しないかチェックする、問題を解くのに必要なファイルやディレクトリを構築する、といった処理をコマンドラインから実行できればコンテスト中の処理の自動化が可能になり、快適に問題を解くことができるようになります。&lt;/p&gt;

&lt;p&gt;コマンドラインからAtCoderに問題を提出したりするツールとしては、&lt;a href=&#34;https://github.com/kmyk/online-judge-tools&#34;&gt;online-judge-tools&lt;/a&gt;などが存在します。&lt;/p&gt;

&lt;p&gt;とはいえ、既存のツールでは複数のコンテストサイトを動作対象としていることなどから、「プログラムを提出するたびに提出先の問題IDやURLを指定しなければならない」といった問題点がありました。
提出ファイルのコピペなどの手間を省くためにコマンドラインツールを使っているはずなのに、その提出先を指定するためにURLをブラウザからコピーしてくる必要があるのでは本末転倒感があります。&lt;/p&gt;

&lt;p&gt;また、問題を一問解く度にプログラムのテンプレートを用意したり、既存ツールを用いてサンプルケースをダウンロードしてくるのも手間がかかります。&lt;/p&gt;

&lt;p&gt;そこで、数ある競技プログラミングのサイトの中からAtCoderに特化することで、コンテスト中にコンソールに打ち込むコマンドの数を極限まで減らせるようにするツールとして、&lt;a href=&#34;https://www.npmjs.com/package/atcoder-cli&#34;&gt;atcoder-cli&lt;/a&gt;を開発しました。&lt;/p&gt;

&lt;p&gt;atcoder-cliはディレクトリ構成から自動的に提出するコンテスト・問題を検出し、短いコマンドの入力だけで問題を提出できるようにするのみならず、テンプレートを自動的に展開する機能などを備えており、AtCoder用のプロジェクト管理ツールとしても機能するソフトウェアです。
また、online-judge-toolsとの連携によって、サンプルケースの自動ダウンロードなどの機能を余計なURL指定なしで快適に使用できるようになります。&lt;/p&gt;

&lt;h2 id=&#34;インストール方法&#34;&gt;インストール方法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ npm install -g atcoder-cli
$ acc -v # 正しくインストールされたかどうか確認する
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;atcoder-cliはnpmパッケージとして公開しているため、node.jsが必要です。
また、&lt;a href=&#34;https://github.com/kmyk/online-judge-tools&#34;&gt;online-judge-tools&lt;/a&gt;はインストールされていなくても問題なく動作しますが、連携機能のため同時にインストールしておくことを強く推奨します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;2018/12/07/atcoder-cli-installation-guide/&#34;&gt;atcoder-cli インストールガイド&lt;/a&gt;を公開していますので、詳しいインストール手順はそちらをお読みください。&lt;/p&gt;

&lt;h2 id=&#34;特徴&#34;&gt;特徴&lt;/h2&gt;

&lt;p&gt;詳細な機能については&lt;a href=&#34;https://github.com/Tatamo/atcoder-cli&#34;&gt;README&lt;/a&gt;や&lt;code&gt;acc [COMMAND] -h&lt;/code&gt;コマンドを参照してください。
日本語の解説記事として、&lt;a href=&#34;2018/12/07/atcoder-cli-tutorial/&#34;&gt;atcoder-cli チュートリアル&lt;/a&gt;があります。&lt;/p&gt;

&lt;h3 id=&#34;コンテスト情報取得&#34;&gt;コンテスト情報取得&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;$ acc contest abc100
AtCoder Beginner Contest 100  https://beta.atcoder.jp/contests/abc100
$ acc tasks abc100
A  Happy Birthday!           https://beta.atcoder.jp/contests/abc100/tasks/abc100_a
B  Ringo&#39;s Favorite Numbers  https://beta.atcoder.jp/contests/abc100/tasks/abc100_b
C  *3 or /2                  https://beta.atcoder.jp/contests/abc100/tasks/abc100_c
D  Patisserie ABC            https://beta.atcoder.jp/contests/abc100/tasks/abc100_d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CLIツールとして、問題のURLなどをコマンドラインから取得できます。他のシェルコマンドと組み合わせることで、AtCoderに関連する処理を自動化する際に役立てることができます。&lt;/p&gt;

&lt;h3 id=&#34;コンテスト用ディレクトリ作成&#34;&gt;コンテスト用ディレクトリ作成&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ acc new abc100 # abc100用のディレクトリを作成
$ cd abc100
$ cat contest.acc.json
{
  &amp;quot;contest&amp;quot;: {
    &amp;quot;id&amp;quot;: &amp;quot;abc100&amp;quot;,
    &amp;quot;title&amp;quot;: &amp;quot;AtCoder Beginner Contest 100&amp;quot;,
    &amp;quot;url&amp;quot;: &amp;quot;https://beta.atcoder.jp/contests/abc100&amp;quot;
  },
  &amp;quot;tasks&amp;quot;: [
    {
      &amp;quot;id&amp;quot;: &amp;quot;abc100_a&amp;quot;,
      &amp;quot;label&amp;quot;: &amp;quot;A&amp;quot;,
      &amp;quot;title&amp;quot;: &amp;quot;Happy Birthday!&amp;quot;,
      &amp;quot;url&amp;quot;: &amp;quot;https://beta.atcoder.jp/contests/abc100/tasks/abc100_a&amp;quot;,
      &amp;quot;directory&amp;quot;: {
        &amp;quot;path&amp;quot;: &amp;quot;a&amp;quot;,
        &amp;quot;testdir&amp;quot;: &amp;quot;tests&amp;quot;
      }
    },
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;atcoder-cliでは、コンテストごとにディレクトリを作成してプログラムを管理します。
デフォルトではコンテストディレクトリ内でさらに問題ごとにディレクトリを分け、その中で問題を解いていくことを想定していますが、コンテストディレクトリ直下でディレクトリを分けずに複数のプログラムファイルを配置することもサポートしています。&lt;/p&gt;

&lt;p&gt;この際に、以下のような処理を自動的に行うことができます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;サンプルケースの自動ダウンロード (online-judge-toolsが必要)&lt;/li&gt;
&lt;li&gt;テンプレートを予め用意しておくことで、プログラム等のファイルを問題ディレクトリにコピー&lt;/li&gt;
&lt;li&gt;任意のシェルコマンドを実行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらを組み合わせることで、コンテスト用ディレクトリを作成した時点であらゆる前準備を終えることができます。&lt;/p&gt;

&lt;h3 id=&#34;提出機能&#34;&gt;提出機能&lt;/h3&gt;

&lt;p&gt;atcoder-cli本体は今のところAtCoderにファイルを提出する機能を備えていませんが、内側でonline-judge-toolsを呼び出すことにより、もともとのonline-judge-toolsの機能よりもさらに簡単に問題を提出することができるようになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ oj s https://beta.atcoder.jp/contests/abc100/tasks/abc100_a main.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;online-judge-toolsでは問題の提出のために上記のコマンドが必要でしたが、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ acc s main.cpp # s はsubmitの省略名
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;atcoder-cliはファイルが配置されたディレクトリから自動的に提出するべき問題を判別し、URLなどを明示する必要がなくなっています。&lt;/p&gt;

&lt;p&gt;さらに、問題テンプレート機能を使用すれば提出するプログラムのファイル名を予め指定しておくことができるため、以下のように一切の引数を与えることなく提出が可能になります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ acc s # これだけで提出ができる！
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;高速な応答性&#34;&gt;高速な応答性&lt;/h3&gt;

&lt;p&gt;レスポンスの速さはCLIツールにとって重要な要素であるため、依存パッケージのロードを必要なタイミングまで遅延させることで、そのコマンドの実行時に使用されないパッケージの読み込みを防止して応答性を高めています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ time acc -h
...
real    0m0.093s
user    0m0.080s
sys     0m0.008s
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;類似ツール&#34;&gt;類似ツール&lt;/h2&gt;

&lt;h3 id=&#34;kmyk-online-judge-tools-https-github-com-kmyk-online-judge-tools&#34;&gt;&lt;a href=&#34;https://github.com/kmyk/online-judge-tools&#34;&gt;kmyk/online-judge-tools&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;AtCoderに限定せず様々なサイトに対応

&lt;ul&gt;
&lt;li&gt;それ故にややコマンドのタイプ数が増えやすい傾向にある&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;テストツールとしての機能も有する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;atcoder-cliは現状online-judge-toolsにどっぷり依存しているので頭が上がりません。
便利なツールを作って頂いてありがとうございます。&lt;/p&gt;

&lt;p&gt;とはいえatcoder-cliはnpm, ojはpipでインストールしないといけないため、atcoder-cli単体で同等の機能が提供できたほうがインストールの手間は減ると思うので好ましいのかもしれません(サンプルケースの取得はアドホックにやらざるを得ないし、提出ファイルの言語指定も割とつらさがあるので既にあるものをあまり再実装したくない)。&lt;/p&gt;

&lt;h3 id=&#34;nodchip-onlinejudgehelper-https-github-com-nodchip-onlinejudgehelper&#34;&gt;&lt;a href=&#34;https://github.com/nodchip/OnlineJudgeHelper&#34;&gt;nodchip/OnlineJudgeHelper&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;様々なサイトに対応、多機能&lt;/li&gt;
&lt;li&gt;outdated&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;URLをすべて入力しなくても、コンテストID+問題IDでの提出ができるため少しは楽です。
年単位でメンテナンスされていなかったり、アカウントのパスワードをローカルに置いておくことを求められたりするので、今使うには微妙かもしれません。&lt;/p&gt;

&lt;h3 id=&#34;xmlpro-atam-https-github-com-xmlpro-atam&#34;&gt;&lt;a href=&#34;https://github.com/XMLPro/atam&#34;&gt;XMLPro/atam&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;AtCoder用の問題提出ツール&lt;/li&gt;
&lt;li&gt;node.jsで動作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;AtCoder専用のツールで、現状では問題提出のみの機能を持っています。
npmからインストールすることができ、連携が比較的容易と思われるので、今後連携機能の実装を行うかもしれません。&lt;/p&gt;

&lt;h2 id=&#34;contribution&#34;&gt;Contribution&lt;/h2&gt;

&lt;p&gt;バグ報告、要望などは&lt;a href=&#34;https://github.com/Tatamo/atcoder-cli/issues&#34;&gt;https://github.com/Tatamo/atcoder-cli/issues&lt;/a&gt;で受け付けています。&lt;/p&gt;

&lt;h2 id=&#34;余談&#34;&gt;余談&lt;/h2&gt;

&lt;p&gt;このツールが良いと思っていただけましたら、ぜひ&lt;strong&gt;&lt;a href=&#34;https://github.com/Tatamo/atcoder-cli&#34;&gt;★Starをください&lt;/a&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;というのも、AtCoder勢で利用していない人はほとんどいないであろう&lt;a href=&#34;https://kenkoooo.com/atcoder/&#34;&gt;AtCoder Problems&lt;/a&gt;が、その圧倒的な知名度と比較して&lt;a href=&#34;https://github.com/kenkoooo/AtCoderProblems&#34;&gt;GitHubリポジトリ&lt;/a&gt;についている★の数があまりに少ないのではないか、という話があります。&lt;/p&gt;

&lt;p&gt;★とはTwitterの&lt;del&gt;ふぁぼ&lt;/del&gt;いいねのようなものです。
競プロ勢はGitHubの使い方もよくわからないのだ、という不名誉な評判がつきかねませんから、ぜひ良いと思ったリポジトリには★を投げてみましょう。&lt;/p&gt;

&lt;p&gt;ここに&lt;a href=&#34;https://github.com/Tatamo/atcoder-cli&#34;&gt;良い練習台 (Tatamo/atcoder-cli)&lt;/a&gt;がありますね。&lt;/p&gt;

&lt;p&gt;GitHubのアカウントを持っていない方は、有効なメールアドレスとユーザー名、パスワードだけあれば&lt;a href=&#34;https://github.com/join&#34;&gt;https://github.com/join&lt;/a&gt;から簡単にアカウントの作成を行うことができます。
(&lt;a href=&#34;https://www.google.co.jp/search?q=github+登録&#34;&gt;参考&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;ログインができたら&lt;a href=&#34;https://github.com/Tatamo/atcoder-cli&#34;&gt;適当なソフトウェア (Tatamo/atcoder-cli)&lt;/a&gt;のページに行き、ページの上の方にある「★Star」をクリック/タップするだけで★をつけることができます。&lt;/p&gt;

&lt;p&gt;(露骨な宣伝で申し訳ありません。
私のツールに★を投げる必要はありませんが、AtCoder Problemsは実際もっと★がついていてもよいのではと思っています。
皆さんどんどんGitHubで★を投げあいましょう)&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>ISUCON8予選 序盤環境構築覚え書き</title>
      <link>http://tatamo.81.la/blog/2018/09/16/isucon8-qual-2/</link>
      <pubDate>Sun, 16 Sep 2018 18:00:01 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/09/16/isucon8-qual-2/</guid>
      <description>
        &lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2018/09/16/isucon8-qual/&#34;&gt;一つ前&lt;/a&gt;の記事は予選の流れや感想を書きましたが、こちらは&lt;a href=&#34;http://isucon.net/archives/52193980.html&#34;&gt;ISUCON8&lt;/a&gt;の予選の序盤にやったことのメモです。&lt;/p&gt;

&lt;p&gt;予備知識ほぼゼロで予選に突っ込んだ初心者のメモなので初歩的な内容だと思います。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;今回の予選で使用したリポジトリは &lt;a href=&#34;https://github.com/Tatamo/isucon8-q&#34;&gt;https://github.com/Tatamo/isucon8-q&lt;/a&gt; です。&lt;/p&gt;

&lt;h2 id=&#34;解析ツール&#34;&gt;解析ツール&lt;/h2&gt;

&lt;p&gt;初心者なので、ISUCONをやる人がだいたい入れてるらしいツールを入れました。
入れるツールは予選前日の夜に適当にググって決めました。&lt;/p&gt;

&lt;h3 id=&#34;netdata-https-github-com-firehol-netdata&#34;&gt;&lt;a href=&#34;https://github.com/firehol/netdata&#34;&gt;netdata&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;自動インストーラが用意されており、コマンド一発でモニタリングができるところまでいくのでとても便利です。
(私は担当ではなかったのでよくわかりませんが、メンバーは一応これを入れるのに手間取っていました… ファイアウォールの設定はちゃんと見るべきらしいです)
とりあえずベンチマークを走らせると負荷の状況が一目でわかりますし、負荷が上がることでベンチマークが実行されていることがわかって安心できたりします。&lt;/p&gt;

&lt;h3 id=&#34;alp-https-github-com-tkuchiki-alp&#34;&gt;&lt;a href=&#34;https://github.com/tkuchiki/alp&#34;&gt;alp&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;zipを落としてくるだけなのでこちらも導入が簡単です。
ただしnginxやh2oのログの形式をalpに対応したフォーマットに変えないといけないので注意が必要です。
実際これを使って表を眺めるだけでも重そうな処理がだいたいわかってくるような気がするので、入れておくべきだと思います。&lt;/p&gt;

&lt;h3 id=&#34;pt-query-digest-https-www-percona-com-doc-percona-toolkit-latest-pt-query-digest-html&#34;&gt;&lt;a href=&#34;https://www.percona.com/doc/percona-toolkit/LATEST/pt-query-digest.html&#34;&gt;pt-query-digest&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;入れましたが使いませんでした。
他の人が使ったのかどうかは知りません。
そもそもめちゃくちゃ重いクエリはalpのログやソースコードを見れば見当がつきますし、それで発見できない中程度の遅さのクエリの修正にまで取り掛かるだけの時間がありませんでした。&lt;/p&gt;

&lt;p&gt;今回は使用しませんでしたが、docker経由でphpMyAdminを使えばDBの見通しが良くなるので、導入してもよかったかと思います。&lt;/p&gt;

&lt;h2 id=&#34;デプロイ環境構築&#34;&gt;デプロイ環境構築&lt;/h2&gt;

&lt;p&gt;アプリケーションをgit管理するにしても、サーバー上で直接編集すると確実にコンフリクトします。
また、サーバーが3台あったので更新をいちいち手動で反映していると死にます。&lt;/p&gt;

&lt;h3 id=&#34;ssh&#34;&gt;SSH&lt;/h3&gt;

&lt;p&gt;自動デプロイの円滑化に絡んでくるため、SSHの設定は重要です。
まずローカルでは、メンバー全員で&lt;code&gt;~/.ssh/config&lt;/code&gt;の接続ホストを共有します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host isuA
	HostName 222.222.222.221
	User isucon

Host isuB
	HostName 222.222.222.222
	User isucon

Host isuC
	HostName 222.222.222.223
	User isucon
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにして、メンバー全員が同じ解決名でサーバーに入れるようにすることが必要です。
また、全メンバーは競技開始直後に&lt;code&gt;ssh-copy-id&lt;/code&gt;で自らの公開鍵を3台のサーバーすべてに送信しておきます。
&lt;code&gt;ssh-add&lt;/code&gt;で自分の秘密鍵をssh-agentに登録しておけば、SSH鍵のパスフレーズを入力せずサーバーに入れるようになります。&lt;/p&gt;

&lt;p&gt;次に、3台ある競技用マシンすべてで新しく鍵を作成し、これらをすべてGitHubに登録しておきます。&lt;/p&gt;

&lt;h3 id=&#34;github-private-repository&#34;&gt;GitHub private repository&lt;/h3&gt;

&lt;p&gt;メンバーがローカルで編集したファイルをGitHubにpushし、競技用サーバーではそれをpullするという構成にしました。
publicなリポジトリでこれをやってしまうとレギュレーション違反で失格なので注意が必要です。
とはいえ不具合が出た時などは直接サーバーに入ったほうが楽なこともあるので、基本は編集衝突を避けてローカルで編集しつつ臨機応変に、という感じです。&lt;/p&gt;

&lt;p&gt;私たちのチームでは、専用のGitHubアカウントを作ってそこに公開鍵を登録するようにしました。
(※GitHubの利用規約に抵触しないようにするため、 「**-bot」のような名前にして予選終了後は消すことで、&lt;a href=&#34;https://developer.github.com/v3/guides/managing-deploy-keys/#machine-users&#34;&gt;Machine user&lt;/a&gt;と言い張ることにします。実際自動化のために用いるので…)&lt;/p&gt;

&lt;p&gt;そして、前述したSSH公開鍵のGitHubへの登録ができたら、競技用サーバーに用意されているディレクトリをgit管理下に置きます。
このとき、&lt;code&gt;~/.gitconfig&lt;/code&gt; に以下のように書いておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[url &amp;quot;git@github.com:&amp;quot;]
	Insteadof = https://github.com/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでgithubへのアクセスがsshを経由して行われるようになります。
サーバーのファイルを直接編集してもコミットできるように、author情報も同時に書いておくといいかもしれません。&lt;/p&gt;

&lt;p&gt;必要ならssh-agentを起動するなどして、少なくとも認証なしでgit pullできるようになると良いです。&lt;/p&gt;

&lt;p&gt;git管理下に置く方法としては、3台あるうち適当な1台でgit管理したい全ファイルをGitHubにpushして、他のサーバーでは既に存在するファイル群を消してから同じ場所にgit cloneするのが早いと思います。&lt;/p&gt;

&lt;h3 id=&#34;デプロイ用スクリプトを用意する&#34;&gt;デプロイ用スクリプトを用意する&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.bitjourney.com/entry/2017/11/09/101740&#34;&gt;https://blog.bitjourney.com/entry/2017/11/09/101740&lt;/a&gt;&lt;br /&gt;
ここに「デプロイスクリプトは超大事」って書いてありました。
ここで紹介されている &lt;a href=&#34;https://github.com/gfx/isucon7-qualify&#34;&gt;https://github.com/gfx/isucon7-qualify&lt;/a&gt; のrestart.shとrestart-all-from-local.shを真似します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Tatamo/isucon8-q/blob/master/restart.sh&#34;&gt;https://github.com/Tatamo/isucon8-q/blob/master/restart.sh&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/Tatamo/isucon8-q/blob/master/restart-all-from-local.sh&#34;&gt;https://github.com/Tatamo/isucon8-q/blob/master/restart-all-from-local.sh&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;こんな感じになりました。
おそらく重要だと思うのは、&lt;code&gt;ssh isuA ...&lt;/code&gt; のようにメンバー全員でhost名が共有されていること、ローカルでのsshおよびサーバーの&lt;code&gt;restart.sh&lt;/code&gt;のgitコマンドが認証なしで通るようになっていることだと思います。
SSHまわりの設定をしておけば、一切の認証が発生しないため&lt;code&gt;./restart-all-from-local.sh&lt;/code&gt;の一発で全サーバーにGitHib上の最新のコミットを反映させることができます。&lt;/p&gt;

&lt;p&gt;実際のところ、おそらく競技サーバー側の鍵生成は必要なくて、ssh-agentで鍵を使い回せばローカルのgithub用公開鍵をそのまま使ってサーバーのgitを触れる気がしますが、あまりよく調べていません。&lt;/p&gt;

&lt;h3 id=&#34;リポジトリで管理する範囲について&#34;&gt;リポジトリで管理する範囲について&lt;/h3&gt;

&lt;p&gt;ホームディレクトリ以下にサービス名のついたフォルダがあったので、そこをgit管理すればいいかなと思いました。
nginxなどの設定ファイルの類は、リポジトリの下に&lt;code&gt;etc/&lt;/code&gt;みたいなフォルダを作ってそこで管理しました。
サーバーごとに分ける必要が出てきたらその都度増やします。
これも自動で反映できるよう、もともとの設定ファイルをシンボリックリンクに置き換えておきます。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;準備のための時間があるなら、これらの構築作業はchefやansibleやシェルスクリプトで自動化しておくと効果は高いと思います。
競技開始時にやるべきことは予め決めておけるので、そういった作業を簡単なコマンドで行えるようにしておけば確実に時間を節約できます。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>ISUCON8の予選に出場して負けました</title>
      <link>http://tatamo.81.la/blog/2018/09/16/isucon8-qual/</link>
      <pubDate>Sun, 16 Sep 2018 18:00:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/09/16/isucon8-qual/</guid>
      <description>
        &lt;p&gt;&lt;a href=&#34;http://isucon.net/archives/52193980.html&#34;&gt;isucon8&lt;/a&gt;の予選に参加しました。&lt;/p&gt;

&lt;p&gt;結果としてスコアなしで敗退しました。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;序盤に行った環境構築の記事は&lt;a href=&#34;http://tatamo.81.la/blog/2018/09/16/isucon8-qual-2/&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;今回の予選で使用したリポジトリは &lt;a href=&#34;https://github.com/Tatamo/isucon8-q&#34;&gt;https://github.com/Tatamo/isucon8-q&lt;/a&gt; です。&lt;/p&gt;

&lt;h2 id=&#34;メンバー編成&#34;&gt;メンバー編成&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/__tatamo__&#34;&gt;わたし&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/sensu_watson&#34;&gt;@sensu_watson&lt;/a&gt;氏, &lt;a href=&#34;https://twitter.com/uhyo_&#34;&gt;@uhyo_&lt;/a&gt;氏の チーム 🈚️ で参加しました。&lt;/p&gt;

&lt;p&gt;全員多少のサーバー運用経験はありますが、ちゃんとした構築を行ったりした経験はほとんどなく、どちらかというと普段はフロントエンド寄りがメインのメンバーが多い構成です。&lt;/p&gt;

&lt;h2 id=&#34;開始前&#34;&gt;開始前&lt;/h2&gt;

&lt;h3 id=&#34;前日まで&#34;&gt;前日まで&lt;/h3&gt;

&lt;p&gt;メンバー全員があまり暇ではなかったたため、事前の練習は時間が取れませんでした。
1週間前からConoHaでISUCON7のインスタンスを建てて軽く触った程度の対策しかできていません。&lt;/p&gt;

&lt;p&gt;私と@uhyo_氏がJavaScriptを読み書きできるので、nodejsを使用することにしました。&lt;/p&gt;

&lt;h3 id=&#34;当日朝&#34;&gt;当日朝&lt;/h3&gt;

&lt;p&gt;そもそもスロークエリとか&lt;code&gt;nginx.conf&lt;/code&gt;とか&lt;code&gt;/etc/systemd/system&lt;/code&gt;とか言われてもあまりよくわからないので、役割分担のしようがなさそうという雰囲気が漂っていました。
そのため開始直後の作業のみ割り振りを決めておき、それ以降はその場で適当になんとかすることにしました。&lt;/p&gt;

&lt;h2 id=&#34;経過&#34;&gt;経過&lt;/h2&gt;

&lt;h3 id=&#34;序盤&#34;&gt;序盤&lt;/h3&gt;

&lt;p&gt;それぞれデプロイ環境の構築、解析ツールのインストール、HTTPサーバーとDBの設定確認・変更と最初のベンチマークの起動を担当することになったため、作業にとりかかりました。
解析ツールとしては、ISUCON7 などでgoogle検索したら1ページ目に出てきた&lt;a href=&#34;https://github.com/tkuchiki/alp&#34;&gt;alp&lt;/a&gt;, &lt;a href=&#34;https://github.com/firehol/netdata&#34;&gt;netdata&lt;/a&gt;, &lt;a href=&#34;https://www.percona.com/doc/percona-toolkit/LATEST/pt-query-digest.html&#34;&gt;pt-query-digest&lt;/a&gt;を導入すると決めていました。&lt;/p&gt;

&lt;p&gt;始まる前はてっきりUbuntu+nginx+MySQLとかの構成かと思っていたんですが、蓋を開けてみるとRed Hat+H2O+MariaDBで、&lt;code&gt;nginx.conf&lt;/code&gt;がない…などと困惑することになりました。
当然H2Oを触ったことのある人は誰もいません。&lt;/p&gt;

&lt;p&gt;この段階で既に何かとトラブルが起きたりしていましたが、1時間経過ぐらいでアプリケーションの中身を読み進めるフェーズに入りました。
TypeScriptで書かれていたり&lt;code&gt;.prettierrc&lt;/code&gt;が置かれていたりしたのが意外でした(我々はTypeScriptで開発することが多いためこれはありがたいことです)が、@uhyo_氏曰く「&lt;code&gt;any&lt;/code&gt;が多いのでTypeScriptのありがたみが少ない」とのことでした。確かにそんな感じはしました。
私の環境ではなぜかブラウザでアプリケーションにアクセスした際にフロントのJavaScript側でエラーが出たりしたため、今回のアプリがどのようなものか把握するにも少し手間取ったりしました。&lt;/p&gt;

&lt;p&gt;alpのログと相談しつつ、&lt;code&gt;getEvent()&lt;/code&gt;がid一つごとにクエリを1回発行しているから重いね、などと言いつつも生SQLに怖気づいて手を入れられずにいる横で@uhyo_氏が着実に修正を加えていき、13時ごろにスコアが1,100から1,500に上昇して喜んだりしていました。&lt;/p&gt;

&lt;h3 id=&#34;中盤&#34;&gt;中盤&lt;/h3&gt;

&lt;p&gt;node.jsのログがとれていないのが厳しいという話になり、ログまわりを調べることにしました。
systemdに慣れている人がおらず、私が担当しましたがログをjournalに流し込んで取得するのに1時間はかかってしまいました。&lt;/p&gt;

&lt;p&gt;また、&lt;code&gt;/var/log/h2o/access.log&lt;/code&gt;がアクセスを受けても更新されないことを見つけたり、かと思えばしばらくして見に行くとログが溜まっていることに気付いたりして首を傾げたりする作業をしました。&lt;/p&gt;

&lt;p&gt;また残り時間が減ってきたので、これまで1台で稼働させていたサーバーを複数台構成に切り替えようという話になり、以降アプリケーションまわりはすべて@uhyo_氏が担当して私と@sensu_watson氏で構築にとりかかることにしました。&lt;/p&gt;

&lt;p&gt;15時に@uhyo_氏が対処していたループ中でのsheetsテーブル取得解消の成果が出て、ここスコアが約1,500点から8,435点に上がったので大喜びしました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2018/09/16/isucon8_screenshot.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2018/09/16/isucon8_screenshot.png&#34; alt=&#34;15時時点のスクリーンショット 8435点&#34;&gt;&lt;/a&gt;&lt;br /&gt;
我々の全盛期の様子 なんと学生1位&lt;/p&gt;

&lt;h3 id=&#34;終盤&#34;&gt;終盤&lt;/h3&gt;

&lt;p&gt;どうでもいいことですが、3台のプライベートIPの末尾が.3, .2, .1となっていることに気付かずにグローバルIPだけ見てサーバーリストの上から順にA,B,Cサーバーと名前をつけたところ、競技中にサーバーリストの並びが.1, .2, .3 に切り替わったので上からC,B,Aとなり一時混乱しました。&lt;/p&gt;

&lt;p&gt;netdataのグラフを見たところ、通信量やメモリ使用量よりもCPU使用率が飛び抜けて高負荷になっているようだったため、アプリケーション部分に2台割り当てて残りの1台をDBとすることに決めました。&lt;/p&gt;

&lt;p&gt;私はまずDBを1つのサーバーに切り出す作業を始め、これはデータベース側でユーザーに外部からのアクセスを許可しないといけない点で少しつまづきつつも、基本的には環境変数の値を変えるだけだったのでおおよそうまくいきました(少なくともこの時はそう思っていました)。&lt;/p&gt;

&lt;p&gt;続いてアプリケーション部分を2台に分けないといけないのですが、nginxですら誰も複数台構成を試した経験がないため非常に先行きが怪しい状況となっていました。
選択肢としてH2Oを捨ててnginxに切り替えるという手もあるのですが、環境構築にも手間取る我々の戦力では新しくアプリケーションをインストールする際に多大な面倒が生じうることは目に見えています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;upstream supercoolawesomeservice.com{
	server foo.com;
	server bar.com;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などと書けばnginxならロードバランスしてくれるということは知っていました(実際に試したことはない)が、H2Oのドキュメントを探したものの&lt;a href=&#34;https://github.com/h2o/h2o/issues/775&#34;&gt;どうにも難しそう&lt;/a&gt;な気配がしていました。&lt;/p&gt;

&lt;p&gt;とはいえ現状で足りていないのは計算資源であるため、適当な切り分け方だったとしてもサーバー1台よりはきっと良くなるに違いないだろう、ということで、なんとなく負荷が高そうに見えた &lt;code&gt;/api/users&lt;/code&gt; 以下に送られたリクエストだけをすべて2台目に流すことにしました。&lt;/p&gt;

&lt;p&gt;その作業中に、 &lt;code&gt;/initialize&lt;/code&gt;へのアクセスを受けるとDBではなくローカルファイル上の.shファイルが読まれるため、DBサーバーを別に分けると初期化処理に失敗することが判明しました。
そこでDBサーバーの停止させていたH2Oとnodejsを復活させ、&lt;code&gt;/initialize&lt;/code&gt;へのアクセスはこのDBサーバー上で処理することとしました。
しかしこの対策は別サーバーへのリダイレクトが成功しないと有効でないため、H2Oをリバースプロキシとして使用する設定が完了するまではDBも動かないという状況になってしまいました。&lt;/p&gt;

&lt;p&gt;この設定変更に2人とも苦戦し、3台構成がまともに動いたのは17時を大きくまわった頃で、残り時間は1時間もありませんでした。&lt;/p&gt;

&lt;p&gt;細々とした不具合を修正したりしたものの、17時40分ごろに走らせたベンチマークがすべて失敗し、スコアが🈚️なのはよくないということでロールバックを決定しました。
ここで、ネットワークまわりをロールバックする方針を採用したもののうまくいかず、アプリケーション部分も合わせて巻き戻したものの&lt;code&gt;initialize/&lt;/code&gt;か何かの処理が走らず失敗し、制限時間のためスコアなしの失格となりました。&lt;/p&gt;

&lt;p&gt;実際にはこのロールバック方針は誤りで、アプリケーションロジック側に不具合が生じて時おりエラーが出るようになっていたというのが原因でした。
nodejsのアプリケーション内でエラーが出ているというログは上がっていたのですが、それまで設定に手間取って何度もバグを出していたネットワークまわりが原因であるように思い込んでしまいました。&lt;/p&gt;

&lt;h2 id=&#34;反省会&#34;&gt;反省会&lt;/h2&gt;

&lt;p&gt;明らかな敗因としては練習不足で、これはまあわかりきっていたことなのでよいのですが、最終的にスコアなしで終わってしまった直接の原因としては不具合の出どころを見誤ったことにあると思います。
複数台構成に切り替える際に断続的に一部のサーバーが動かなくなったり復帰したりを繰り返していたのですが、各自の作業内容のリアルタイムでの共有が不十分だったため、アプリケーションの動作確認ができない時間ができてしまったり、生きているサーバーの情報が行き渡らずに1台構成での動作確認のためのベンチマークを走らせられなかったりしました。
そのため後半以降にベンチマークを実行できる機会が減ってしまい、結果としてネットワークとアプリケーションのどちらで落ちているのか確証が持てない状況が発生し、時間切れ直前の焦りも加わって大きな失敗となってしまいました。
これはログをしっかり読んでいれば・ログを取得しやすい環境を構築していれば防げたことでもあると思いますし、チームからはVCを導入しておいたほうがよかったかもしれないという意見もありました。&lt;/p&gt;

&lt;p&gt;まっとうに戦えるチームならこのぐらいのことは一瞬で終わらせているんだろうなあ、と思うことも多々ありました。
とはいえ、単純な設定変更や環境構築でも何らかの失敗をして時間がかかってしまうのは、ある意味最初から想定していたことではあります。
しかしせめてアプリケーションがちゃんと動く状態でのスコアがほしかったという悔しさがあります。
拙いながらも自分たちで考えた構成が動いているところが見たかったですし、アプリケーション側でもスコアへの影響の大きいスロークエリの改善コミットが入っていたので、これをスコアに結びつけられなかったことは残念です。&lt;/p&gt;

&lt;p&gt;私は最初JavaScriptを書いていくことになるかと思っていましたが、蓋を開けてみればアプリケーションはほぼ@uhyo_氏に投げてしまっていました。
実際生のSQLを動作を変えないまま書き換える能力は今の私にはなさそうな気もしたので、中盤までのスコア上昇を支えてくれた@uhyo_氏の活躍には感謝の念に堪えません。&lt;/p&gt;

&lt;p&gt;結局私がなにをしていたかというと、基本的には@sensu_watson氏と一緒に設定ファイルやログファイルを眺めてウンウン唸っていたのが主な仕事になるような気がしますが、過去10年で打った&lt;code&gt;systemctl&lt;/code&gt;コマンドの数を今日一日で軽く越えたり、見様見真似で全く未経験のサーバー複数台構成をその場ででっちあげたりすることができたので、これはこれで非常に刺激的な経験になったと思います。&lt;/p&gt;

&lt;p&gt;最後にはなりますが、この場で謝辞を述べられるべきすべての方々に感謝です。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>JavaScript/TypeScriptで競技プログラミングをするには 後編</title>
      <link>http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-02/</link>
      <pubDate>Fri, 09 Feb 2018 19:30:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-02/</guid>
      <description>
        &lt;p&gt;主要コンテストサイトのJavaScript対応状況、および私がJavaScript/TypeScriptで競技プログラミングをする時に気をつけていることなどを書きます。
今回は後者についてです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-01/&#34;&gt;前回の記事&lt;/a&gt;ではコンテストサイトのJavaScript対応状況をメインに書きました。
この記事では、実際にJavaScript/TypeScriptで競技プログラミングをする際に気をつけている点について書いていきます。&lt;/p&gt;

&lt;h2 id=&#34;競技プログラミングにおけるjavascriptの致命的な問題点&#34;&gt;競技プログラミングにおけるJavaScriptの致命的な問題点&lt;/h2&gt;

&lt;p&gt;残念ながら、JavaScriptが競技プログラミングに向いていない理由となる仕様がいくつか存在します。&lt;/p&gt;

&lt;h3 id=&#34;末尾再帰最適化が実装されていない上にコールスタック上限が小さく-変更できない&#34;&gt;末尾再帰最適化が実装されていない上にコールスタック上限が小さく、変更できない&lt;/h3&gt;

&lt;p&gt;JavaScriptではPythonの&lt;code&gt;sys.setrecursionlimit()&lt;/code&gt;のように再帰呼び出し回数の最大値を変更することができません。
コールスタックの上限は処理系に依存しますが、たとえばnode.js v5.12.0 (x64)では15712です。
また、末尾再帰最適化はES2015の仕様に盛り込まれていた内容ですが、現在においてもこれを実装している処理系は非常に少ないのが現状です。&lt;/p&gt;

&lt;p&gt;これらの要因のため、要素数が数万程度の何かに対して手っ取り早く再帰でDFSを書こうとすると、ほぼ間違いなくMaximum call stack size exceededで落ちます。
自分で配列をスタックとして使ってBFSと同じような書き方で書くか、DFS専用のイテレータでも自作しましょう。&lt;/p&gt;

&lt;h3 id=&#34;64bit整数値を扱う手段が存在しない&#34;&gt;64bit整数値を扱う手段が存在しない&lt;/h3&gt;

&lt;p&gt;JavaScriptのすべての数値は、いわゆるdouble型で保持されています。
&lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt;で確認できますが、整数値としての精度が保証される最大値は2^53-1までです。
これはおよそ9.0*10^15程度なので、入力中に10^18ぐらいの数値が与えられるとその時点で詰みです。&lt;/p&gt;

&lt;p&gt;まあ&lt;a href=&#34;https://github.com/broofa/node-int64&#34;&gt;Int64&lt;/a&gt;とか&lt;a href=&#34;https://github.com/silentmatt/javascript-biginteger&#34;&gt;biginteger&lt;/a&gt;的なものを使う・作るしかないです。&lt;/p&gt;

&lt;p&gt;余談ですが、JavaScriptは歴史的経緯から複数のJavaScriptファイルをまとめて一つのソースコードとすることが頻繁に行われているため、browserifyやwebpackといったツールを使えばサードパーティのライブラリを使うことは割と平気で可能です(ソースコード上限を越えなければ)。
しかし競技プログラミング的にどうなのかよくわからないので、私は今のところ自作以外のライブラリを使ったことはないです。&lt;/p&gt;

&lt;p&gt;まあできないことを気にしても仕方がありませんので、以上のような問題点が存在することを把握しておく、ということが大切です。&lt;/p&gt;

&lt;h2 id=&#34;入出力テンプレート&#34;&gt;入出力テンプレート&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import * as fs from &amp;quot;fs&amp;quot;;

const input = (fs.readFileSync(&amp;quot;/dev/stdin&amp;quot;, &amp;quot;utf8&amp;quot;) as string).split(&amp;quot;\n&amp;quot;);
const n = +input[0];
// const [n] = input[0].split(&amp;quot; &amp;quot;).map((x: string): number =&amp;gt; +x);
const a = [];
for(let i=0;i&amp;lt;n;i++){
	a.push(input[i+1].split(&amp;quot; &amp;quot;).map((x:string):number=&amp;gt;+x));
}

console.log(input);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;入力部分は多少長くなってしまうので、テンプレートを用意しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;N M
A1 A2 ... A3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というような入力に対しては、少し書き換えて&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;const [n, m] = input[0].split(&amp;quot; &amp;quot;).map((x: string): number =&amp;gt; +x);
const a = input[1].split(&amp;quot; &amp;quot;).map((x: string): number =&amp;gt; +x);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすれば対応できます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fs.readFileSync(&amp;quot;/dev/stdin&amp;quot;, &amp;quot;utf8&amp;quot;)&lt;/code&gt;部分がWindowsでは動かない気がするので、適当にUNIX環境を用意しましょう。&lt;/p&gt;

&lt;p&gt;package.jsonやtsconfig.jsonについては、&lt;a href=&#34;https://github.com/Tatamo/comp/tree/master/template/ts&#34;&gt;このへん&lt;/a&gt;に上げています。&lt;/p&gt;

&lt;h2 id=&#34;typescript-複数のプログラムを同時にコンパイルする際の注意&#34;&gt;(TypeScript) 複数のプログラムを同時にコンパイルする際の注意&lt;/h2&gt;

&lt;p&gt;npm scripts等で自動コンパイルを行っている場合などに、&lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/modules.html&#34;&gt;モジュール&lt;/a&gt;でない複数のTypeScriptプログラムを同時にコンパイルすると、すべてのプログラムの変数が同一スコープ上で扱われるため、&lt;code&gt;input&lt;/code&gt;などの変数が衝突してエラーになります。&lt;/p&gt;

&lt;p&gt;これは、それぞれのプログラムがモジュールであると認識されれば解決されます。
そのためのワークアラウンドとして、1行目でfsを取得する際に&lt;code&gt;require()&lt;/code&gt;ではなく&lt;code&gt;import&lt;/code&gt;文を使うようにしています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import * as fs from &amp;quot;fs&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;export&lt;/code&gt;を行っていなくても、TypeScript的にはこれだけでモジュールとして扱われるようなので、複数のプログラムを同時にコンパイルすることができるようになります。&lt;/p&gt;

&lt;h2 id=&#34;array-prototype-shift-の計算量はo-n&#34;&gt;Array.prototype.shift()の計算量はO(n)&lt;/h2&gt;

&lt;p&gt;JavaScriptで計算量について触れられている資料は少ないので、下手をすると&lt;a href=&#34;http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.shift&#34;&gt;仕様書&lt;/a&gt;まで見に行かないと気付けないのですが、&lt;code&gt;shift()&lt;/code&gt;の計算量はO(n)です。
inputに10万行程度の入力を入れて、先頭から1行ずつ&lt;code&gt;shift()&lt;/code&gt;で取り出すと、それだけで2秒が過ぎます。
&lt;code&gt;push()&lt;/code&gt;および&lt;code&gt;pop()&lt;/code&gt;は高速でできるので、普通の配列はスタックとしてのみ使用し、キューは自前で実装する必要があります。&lt;/p&gt;

&lt;p&gt;参考までに、私は次のようなコードを使用しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;export default class Queue&amp;lt;T&amp;gt; {
	private _in: Array&amp;lt;T&amp;gt;;
	private _out: Array&amp;lt;T&amp;gt;;

	get length(): number {
		return this._in.length + this._out.length;
	}

	constructor(iterable?: Iterable&amp;lt;T&amp;gt;) {
		this._in = iterable === undefined ? new Array&amp;lt;T&amp;gt;() : [...iterable];
		this._out = new Array&amp;lt;T&amp;gt;();
	}

	private _fix() {
		this._out = this._in.reverse().concat(this._out);
		this._in = new Array&amp;lt;T&amp;gt;();
	}

	push(...values: Array&amp;lt;T&amp;gt;): void {
		this._in.push(...values);
	}

	shift(): T | undefined {
		if (this._out.length === 0) this._fix();
		return this._out.pop();
	}

	toArray(): Array&amp;lt;T&amp;gt; {
		this._fix();
		return this._out.slice().reverse();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;array-prototype-fill-は同一オブジェクトで埋められる&#34;&gt;Array.prototype.fill()は同一オブジェクトで埋められる&lt;/h2&gt;

&lt;p&gt;まあこれは気付かなかった私がよくないという例ですが、一応。&lt;/p&gt;

&lt;p&gt;0埋めされた3×3の二次元配列を用意しようとして、次のようなコードを書いたとします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const a = new Array(3).fill(new Array(3).fill(0));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まあ確かに0埋めされた3×3の二次元配列は得られますが、a[0]とa[1]とa[2]は同じ一次元配列を参照しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;a[0][0] = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすると、aの中身は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[[1,0,0]
 [1,0,0]
 [1,0,0]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となってしまいます。
そのため、多次元配列を初期化するときは横着せずにforで回すようにするか、適当な要素を入れてからmapで埋めます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const a = new Array(3);
for(let i=0; i&amp;lt;3; i++){
	a[i].push(new Array(3).fill(0));
}

const a = new Array(3).fill([]).map(()=&amp;gt;new Array(3).fill());
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;以上が、私がJavaScript/TypeScriptで競技プログラミングをする際に気をつけている点です。&lt;/p&gt;

&lt;p&gt;こうして書き出してみると、数値が大きくなると詰むとか再帰がろくに使えないだとかでろくな言語じゃないなという感じですね。
競技プログラミングの問題自体がC/C++で解くことを想定されている節があるので、仕方のないことではあります。&lt;/p&gt;

&lt;p&gt;とはいえ、以上のことさえ気に留めていれば、JavaScript/TypeScriptを使っていることが原因で詰むことはほとんどないと思います。
JavaScriptそのものは非常に書きやすい言語なので、ハマりどころを把握した上で選択肢にしていただける方が増えればいいなと思っています。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>JavaScript/TypeScriptで競技プログラミングをするには 前編</title>
      <link>http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-01/</link>
      <pubDate>Fri, 09 Feb 2018 17:25:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-01/</guid>
      <description>
        &lt;p&gt;主要コンテストサイトのJavaScript対応状況、および私がJavaScript/TypeScriptで競技プログラミングをする時に気をつけていることなどを書きます。
今回は前者についてです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;追記：&lt;a href=&#34;http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-02/&#34;&gt;後編&lt;/a&gt;書きました。&lt;/p&gt;

&lt;p&gt;競技プログラミングをやるのにC++を選択しない時点で物好きという気はしますが、私は普段からTypeScriptをメインに使って問題を解いています。
この前AtCoder Problemsに&lt;a href=&#34;http://kenkoooo.com/atcoder/?kind=lang&#34;&gt;Language Owners Ranking&lt;/a&gt;ができていたので見てみたらTypeScriptで1位を取っていました(2018年2月時点)。
ちなみにJavaScriptランカーのAC数と比較すると3位にも入れていません。&lt;/p&gt;

&lt;p&gt;AtCoderレーティングは水色、コンテスト参加回数もぎりぎり二桁に達する程度で、あまり真面目にやっているほうではないので参考になるかどうかはわかりませんが、JavaScriptまたはTypeScriptで競技プログラミングをするときに気をつけるべき点などを書いていきます。&lt;/p&gt;

&lt;h2 id=&#34;javascriptで競技プログラミングをすることについて&#34;&gt;JavaScriptで競技プログラミングをすることについて&lt;/h2&gt;

&lt;p&gt;こんな記事を書いていて言うのもどうかと思いますが、他の言語ではなくJavaScriptを競技プログラミングに使用することに、何かメリットはあるのか？と聞かれれば、おそらく目立った利点を挙げることはできないと思います。&lt;/p&gt;

&lt;p&gt;とはいえ、&lt;code&gt;function&lt;/code&gt;だらけの黒魔術のようなコードとスクリプト言語特有の遅さは、ここ数年のJavaScriptの目覚ましい進化によって克服されてきています。
現在のJavaScript処理系はJITコンパイルが主流のため、C++やJavaのような言語には敵わないとはいえ、PythonやRubyのようなスクリプト言語よりも圧倒的に高速です。
またECMAScript2015の登場により、もはや&lt;code&gt;function&lt;/code&gt;と書く必要はなくなりました。&lt;/p&gt;

&lt;p&gt;もっとも、JavaScriptが競技プログラミングに不向きな理由もいくつか存在することは事実です(次の記事で紹介します)。
ですが、近年のJavaScriptが以前とは見違えるほどに書きやすい言語になったことから、決して選択肢に入らない言語ではないと私は考えています。&lt;/p&gt;

&lt;p&gt;JavaScriptを使用する最大のモチベーションは、それが書きやすい・手慣れた言語であるからという点に尽きると思いますが、これは重要なことです。&lt;/p&gt;

&lt;h2 id=&#34;コンテストサイトのモダンjavascriptやtypescript対応状況&#34;&gt;コンテストサイトのモダンJavaScriptやTypeScript対応状況&lt;/h2&gt;

&lt;p&gt;JavaScript/TypeScriptで競技プログラミングをするためには、コンテストサイトのオンラインジャッジシステムが少なくともJavaScriptに対応している必要があります。
特にJavaScriptという言語は、ECMAScript2015の策定によって言語仕様が大きく拡張され、その後もECMAScript2016, ECMAScript2017と機能追加が進んでおり、ここ数年間での移り変わりが非常に激しい言語であるため、言語環境が整備されていることの重要性は大きいです。&lt;/p&gt;

&lt;p&gt;ACM-ICPCではC/C++, Java, Python2/3しか使えないのは周知の事実ですが、比較的多くの言語に対応しているコンテストサイトであってもJavaScriptの対応が行き届いていないのが現状です。&lt;/p&gt;

&lt;p&gt;まずは、日本である程度知名度がある(と思われる)コンテストサイトについて、2018年2月現在でのJavaScriptの対応状況を見ていきたいと思います。
なおTopCoderはJavaScript非対応のため除外しています。&lt;/p&gt;

&lt;h3 id=&#34;atcoder-http-atcoder-jp&#34;&gt;&lt;a href=&#34;http://atcoder.jp/&#34;&gt;AtCoder&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript node v5.12.0&lt;/li&gt;
&lt;li&gt;TypeScript 2.1.6&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TypeScriptについてはnode.jsのバージョンが記載されていなかったのですが、おそらく5.12.0であると思われます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://node.green&#34;&gt;node.green&lt;/a&gt;によると、5.12.0ではES2015の対応率は59%程度となっており、次の項目の6.4.0で対応率が95%まで上昇していることを見ると残念な感じです。
しかしAtCoderで注目するべきは、オンラインジャッジ系のサイトでは非常に珍しく、TypeScriptに対応していることです。
たとえば、分割代入構文はnode.js v5.12.0では未対応のため、以下のコードはシンタックスエラーとなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const [a, b, ...c] = [1, 2, 3, 4, 5];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかしこれをTypeScript2.1.6に食わせると、勝手にES5(= Bad Old DaysのJavaScript)仕様にpolyfillしてトランスパイルしてくれるため、以下のJavaScriptコードが生成されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var _a = [1, 2, 3, 4, 5], a = _a[0], b = _a[1], c = _a.slice(2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;つまり言語欄でTypeScriptを選択することで、ES2015の仕様をもう少し多く使うことができるようになります。&lt;/p&gt;

&lt;p&gt;もっともProxyなんかは全く使うことができないのですが、とはいえSet・Map、class、アロー関数および分割代入が使えるので、競技プログラミングで用いる範囲内なら十分にモダンなJavaScriptを書くことができます。
コンパイラオプションなしでTypeScript2.1.6にSetやMapを食わせると&lt;code&gt;Cannot find name &#39;Map&#39;.&lt;/code&gt;等のエラーが出たような気もするのですが、AtCoder上だと特にエラーメッセージは表示されずに無理矢理動かしてくれます。&lt;/p&gt;

&lt;p&gt;TypeScriptはJavaScriptの完全なスーパーセットであるため、すべてのJavaScriptコードはTypeScriptコードとみなすことができます。
TypeScriptの仕様を全く使っていないJavaScriptを書いたとしても、AtCoderではTypeScriptとして提出することをおすすめします。&lt;/p&gt;

&lt;p&gt;なんともいえない感じですが、これでもモダンJavaScriptの対応状況としてはよっぽどマシなほうです。&lt;/p&gt;

&lt;h3 id=&#34;yukicoder-https-yukicoder-me&#34;&gt;&lt;a href=&#34;https://yukicoder.me/&#34;&gt;yukicoder&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;(正直ここがどれくらいの知名度があるのかあまり把握していませんが)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript node v9.2.1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;調べた中で最も最新バージョンに近く、ES2017までのほぼすべての機能が使用可能なJavaScript環境が用意されています。
モダンなJavaScriptを書きながら競技プログラミングを楽しみたいなら、このサイトはおすすめといえます。
TypeScriptには対応していませんが、まあトランスパイルされた.jsファイルを提出すれば済む話でしょう。&lt;/p&gt;

&lt;h3 id=&#34;aizu-online-judge-http-judge-u-aizu-ac-jp-onlinejudge&#34;&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/&#34;&gt;AIZU ONLINE JUDGE&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript node 0.10.36&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://judge.u-aizu.ac.jp/onlinejudge/AOJ_tutorial.pdf&#34;&gt;http://judge.u-aizu.ac.jp/onlinejudge/AOJ_tutorial.pdf&lt;/a&gt; に書いてありました。&lt;/p&gt;

&lt;p&gt;ほぼ完全なES5時代の遺物です。
どうしてもJavaScriptが書きたいなら、babel-polyfillあたりをかませてJavaScriptからさらに古い時代のJavaScriptにトランスパイルして提出するのがいいでしょう。&lt;/p&gt;

&lt;h3 id=&#34;codeforces-http-codeforces-com&#34;&gt;&lt;a href=&#34;http://codeforces.com/&#34;&gt;Codeforces&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript V8 4.8.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;node.jsを使っていただきたいところです。
V8 4.8.0はnode.jsでは5.12と6.0.0の間ぐらいなので、ES2015の対応状況ではAtCoderのやや上といったところです。古いことにかわりはありませんが。&lt;/p&gt;

&lt;p&gt;最大の問題点は、標準入出力の方法がnode.jsとは全く異なるという点です。
node.jsでは&lt;code&gt;console.log()&lt;/code&gt;で出力しますが、V8の場合は&lt;code&gt;print()&lt;/code&gt;か&lt;code&gt;write()&lt;/code&gt;になります。&lt;/p&gt;

&lt;p&gt;JavaScriptの処理系としてnode.jsを使わずにわざわざV8を生で叩いている人間ってどれくらいいるんでしょうか？
ちょっと怖いのであまり触れたくない感じです。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;ここまで書いていて思った以上に分量が膨らんでしまいました。
&lt;a href=&#34;http://tatamo.81.la/blog/2018/02/09/competitive-programming-using-js-and-ts-02/&#34;&gt;後編&lt;/a&gt;では、実際にJavaScript/TypeScriptで問題を解く上で気をつけている点を書いていきます。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>Freecivの操作、右ドラッグの活用について</title>
      <link>http://tatamo.81.la/blog/2018/02/08/freeciv-right-drag/</link>
      <pubDate>Thu, 08 Feb 2018 00:30:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2018/02/08/freeciv-right-drag/</guid>
      <description>
        &lt;p&gt;数年前に某所で書いた記事ですが、埋もれていて参照しづらくなっていたので手を加えて再掲することにしました。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Freecivに慣れてくると、迅速な操作のために都市タブを使うと便利だということに気付くでしょう。
このとき、ゲーム画面での右ドラッグと都市タブを併用するとさらに都市タブを使いやすくすることができます。
とはいえ、どうも右ドラッグという動作は癖が強く、使いどころが限られたものであるという印象が強いと思われています。
その特性を理解し、使いどころを見極めるとより効率的な帝国運営が可能になるでしょう。&lt;/p&gt;

&lt;p&gt;右ドラッグの基本的な使い方については、ヘルプの「操作」を参照します。&lt;/p&gt;

&lt;blockquote&gt;右クリック後にドラッグ: エリアごとユニットあるいは都市を選択する&lt;br&gt;
Shift+右クリック後にドラッグ: エリアの内容を既存の選択に追加する&lt;/blockquote&gt;

&lt;p&gt;Shiftキーとの併用は、既に選択されているものに追加が可能になるという効果があるようです。
では、右ドラッグ時の動作をいくつかの場合に分けて見てみましょう。&lt;/p&gt;

&lt;h3 id=&#34;1-都市外のユニットの選択&#34;&gt;(1) 都市外のユニットの選択&lt;/h3&gt;

&lt;p&gt;迎撃によるスタックキルを避けるため、艦隊を分散させて敵国領海に突入させることはよくある例です。
このような場合、右ドラッグで全部隊を選択し、テンキー移動をすることによって、陣形を保持したまま艦隊を前進させることができます。便利。&lt;/p&gt;

&lt;h3 id=&#34;2-都市の選択&#34;&gt;(2) 都市の選択&lt;/h3&gt;

&lt;p&gt;右ドラッグで、複数の都市を範囲に含めます。
そうしたら、都市タブを開きましょう。
都市の選択が保持された状態になっているので、本土の都市を全て選択する場合など、首都を選択→「選択」→「同じ島」よりも簡単です。
本土から同じ方向にある複数の海外領土をまとめて選択することもできます。+Shiftも組み合わせてとても便利。&lt;/p&gt;

&lt;p&gt;また、都市を含めて選択を行うと、インターフェイスが都市選択のモードに切り替わります。
都市を左クリックすることによって都市の選択/非選択の切り替えができるので、右ドラッグ選択の微調整に使用できて便利です。
このモードは、右クリックで視点を移動させたり、都市を含めずに再度右ドラッグするなどして解除できます。&lt;/p&gt;

&lt;h3 id=&#34;3-都市内外のユニットの選択&#34;&gt;(3) 都市内外のユニットの選択&lt;/h3&gt;

&lt;p&gt;都市内に待機しているユニット、都市外に駐留しているユニット、それらをまとめて選択できます。
とはいえ、都市内の防御ユニットもすべて選択されてしまうという欠点はあります。
同一タイル内の全ユニットを選択するショートカットであるVキーがあまり使われていないことを考えても、このやり方はあまり便利ではなさそうです。
また、必然的に都市選択も同時に行われます。&lt;/p&gt;

&lt;p&gt;さて、(3)はともかく、(1)や(2)は使いどころによっては結構便利そうです。ではどうして右クリックが癖の強い操作だと思われているのでしょうか。
最大の問題は、都市とユニットが同時に選択されることにあります。
③でユニットを一括選択する場合、都市選択も同時に行われるわけですが、やはりUIが都市選択モードになってしまうのです。
ユニットを選択後、マウスドラッグでユニットを移動させようとしても、一度右クリックなどで都市選択モードを解除しないとユニットは動きません。(※ショートカットキーでの操作は可能です)
また、(2)の操作を行うにしても、選択しようと思った都市とその範囲内にユニットが1つもいないといった状況はまずないでしょう。結果として(3)の状態になります。
都市を選択するためだけに、防御体勢をとっていたり見張りをしたりしているユニットを全て起こしてしまうのは便利とはいえません。&lt;/p&gt;

&lt;p&gt;結局、この性質のせいで装甲艦ラッシュのお供かノーガード野郎になるくらいしか使い道が見出せそうにありません。右ドラッグなんかをするよりも他の操作をしたほうが明らかに簡単だからです。では一体どうすればいいのか？&lt;/p&gt;

&lt;p&gt;そこで、オプション→ローカルクライアント→インターフェイス→「都市をユニットより優先して選択」にチェックを入れてみましょう。&lt;/p&gt;

&lt;p&gt;もし右ドラッグ範囲内に都市が含まれない場合、従来どおり(1)の使い方が可能です。
そしてもし都市が含まれている場合、&lt;strong&gt;範囲内のユニットは選択されず&lt;/strong&gt;に都市のみが選択され、都市選択モードに切り替わります。
これによって元々誰も使わない(3)の使い方はできなくなりますが、(2)の使い方をするときにユニットを起こすことがないため、より便利に都市の選択が可能になるのです。
結構便利なので試してみてもいいんじゃないでしょうか。&lt;/p&gt;

&lt;p&gt;ヘルプ→「操作」は読んでみるといろいろな発見がありそうです。
生産物のコピーアンドペーストやユニットの追加選択などは慣れると使い勝手が良いかもしれませんね。
ショートカットを駆使してfreecivを快適に操作して、より強大な帝国を作っていきましょう。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>ThinkPad X1 Carbonを購入しました</title>
      <link>http://tatamo.81.la/blog/2017/12/18/intro-new-moblie-pc/</link>
      <pubDate>Mon, 18 Dec 2017 21:00:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/12/18/intro-new-moblie-pc/</guid>
      <description>
        &lt;p&gt;この記事は&lt;a href=&#34;https://adventar.org/calendars/2491&#34;&gt;Kobe University Advent Calendar 2017&lt;/a&gt;の19日の記事です。
なお私は当該大学の学部3年(2017年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;新しいモバイルPCが先週届いたので、それについて書きます。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;購入したpc&#34;&gt;購入したPC&lt;/h2&gt;

&lt;p&gt;Lenovo ThinkPad X1 Carbon(2017モデル)を買いました。
基本的なスペックは以下の通りです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CPU: Core i7-7500U&lt;/li&gt;
&lt;li&gt;メモリ: 16GB 1866MHz&lt;/li&gt;
&lt;li&gt;ストレージ: 512GB SSD&lt;/li&gt;
&lt;li&gt;WWANなし&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;液晶サイズは14型、本体重量はおよそ1.13kgです。
お値段は約161kでした。&lt;/p&gt;

&lt;h2 id=&#34;新pc購入のモチベーション&#34;&gt;新PC購入のモチベーション&lt;/h2&gt;

&lt;p&gt;とにかく元々持っていたラップトップが重すぎたというのが大きな要因です。
大学に行くときなどかなり頻繁にPCを持って出るのですが、サイズが大きくて鞄に入れにくい上に重量が2.5kg以上と決して持ち運びに適したPCではなかったのです。&lt;/p&gt;

&lt;p&gt;実際のところスペック的にはまだまだ使えるマシンなのですが、今後大学院の修士課程まで行くことを考えると少なくとも3年以上はノートPCを頻繁に持ち運ぶ機会があることが想定され、その間ずっとPCを変えずに使い続けるのはつらいのではないかと感じました。&lt;/p&gt;

&lt;p&gt;そしていずれPCを変えることになるなら早いほうがいいに決まっているので、タンスに挟まっていた成人祝いの札束などを引っ張り出して新しいPCの購入に踏み切りました。&lt;/p&gt;

&lt;h2 id=&#34;pc選定の条件&#34;&gt;PC選定の条件&lt;/h2&gt;

&lt;p&gt;タンス預金の中身を検めると諭吉氏が16枚あったので、これに財布の中の一万円を加えた17万円を予算上限としました。&lt;/p&gt;

&lt;p&gt;その上で、新しいPCに求めるスペックを想定しました。
以下はその優先度の高い順に並べています。&lt;/p&gt;

&lt;h3 id=&#34;携帯性&#34;&gt;携帯性&lt;/h3&gt;

&lt;p&gt;今回のPC買い替えの動機でもあるので、軽くて持ち運びやすい、いわゆるモバイルPCにすることにしました。
とはいえ元のPCがあまりに重いため、ちょっとぐらいの差はわからないので極限まで軽さを求めることはしません。&lt;/p&gt;

&lt;p&gt;大きさについては、鞄に入れやすい程度には小さく収まってほしいですが、あまり小さくて液晶が見難くなっても困るので、やはり一般的なモバイルPCの範疇に収まっていることを条件としました。&lt;/p&gt;

&lt;h3 id=&#34;ストレージ&#34;&gt;ストレージ&lt;/h3&gt;

&lt;p&gt;私はデスクトップ機とノートPCで同じ環境を構築し、出先でも開発ができるようにしています。
これはつまり、WindowsとLinux(Debian)のデュアルブートを行うことを意味します。
ストレージ容量が256GBの場合、単純にOSごとに半分ずつ割り当てるとそれぞれ128GBしか使えず、これではやや不安が残ります。
というか、手元のラップトップを見たところWindowsだけで128GBなんて軽く越えていたので不安しかありません。
そのため、ストレージには512GB SSDを使用したいと考えました(SSDなのは前提条件として当然です)。&lt;/p&gt;

&lt;h3 id=&#34;メモリ&#34;&gt;メモリ&lt;/h3&gt;

&lt;p&gt;経験上、Chromeを立ち上げまくったりメモリを食うことをたくさんした場合、メモリの消費量がぴったり8GB前後になるという印象があります。
基本的には8GBで何の問題もありませんが、メモリをたくさん食っている状況下では、メモリが8GBだとちょうど溢れてしまう可能性があります。
なので16GBあると嬉しいですが、それによって値段が上がりすぎてしまうのであれば8GBのほうが良い、という想定になりました。&lt;/p&gt;

&lt;h3 id=&#34;cpu&#34;&gt;CPU&lt;/h3&gt;

&lt;p&gt;Core i3はさすがにどうかと思いますが、動画処理や画像処理等はしないですし、ゲームはノートPCなんて使わずに家のデスクトップでやるので高い性能はあまり必要ありません。
なのでCore i5でも積んでいれば十分と考えました。&lt;/p&gt;

&lt;h3 id=&#34;os&#34;&gt;OS&lt;/h3&gt;

&lt;p&gt;先述したようにデスクトップとノートPCで環境を揃える予定なので、macOSだと環境が違ってきてしまうのでやや評価が下がります。
デュアルブート自体Windows+Linuxよりは相性が悪い印象ですし、そもそもMacだとLinuxを入れるまでもなく普通にMac上に環境構築するので、結局デスクトップ機との環境統一が望めません。&lt;/p&gt;

&lt;p&gt;macOSは悪い選択肢ではありませんが、今回の使用目的ではWindowsのほうが優先されます。&lt;/p&gt;

&lt;h3 id=&#34;拡張性-端子類&#34;&gt;拡張性(端子類)&lt;/h3&gt;

&lt;p&gt;モバイルPCは往々にしてUSBポートが1個しか付いていなかったりすることが多いですが、個人的には2個以上あったほうが良いのではないかという考えです。&lt;/p&gt;

&lt;p&gt;また今の状況を考えると、USB Type-AかType-Cかというのも悩みどころです。
手元にType-Cの機器はないですが、今後のことを考えると欲しさはあります。
とはいえ変換ケーブルを持ち運ぶのも面倒なので、両方ついていれば長く使えそうだなと考えていました。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;全体的には、モバイルPCでかつ512GBのストレージを積めることを前提条件として考えました。
またOfficeについてはあまり使う予定がないため、選択可能なら非搭載とすることにしました。&lt;/p&gt;

&lt;h2 id=&#34;候補に上がったもの&#34;&gt;候補に上がったもの&lt;/h2&gt;

&lt;p&gt;結局どのPCを買うか悩んでいるときが一番楽しい&lt;/p&gt;

&lt;h3 id=&#34;surface-pro&#34;&gt;Surface Pro&lt;/h3&gt;

&lt;p&gt;2in1は目新しいので気になりましたが、液晶を自立させるために後ろにスタンドを必要とすることから、「新幹線・飛行機の小さいテーブルで使いにくい」「膝上で使いにくい」ということで候補から外しました。&lt;/p&gt;

&lt;h3 id=&#34;surface-laptop&#34;&gt;Surface Laptop&lt;/h3&gt;

&lt;p&gt;だったらクラムシェルにしようということで候補に上げました。
しかしCore i7+メモリ16GBまで積まないと512GBのストレージを選択することができず、しかもその場合のお値段なんと28万円を越えるためこれも除外しました。&lt;/p&gt;

&lt;h3 id=&#34;vaio-z&#34;&gt;VAIO Z&lt;/h3&gt;

&lt;p&gt;これも2in1ですが、天板が半分ぐらいのところで折り曲がってモード変更できるようになっており、通常使用時は普通のクラムシェルとして使えるので膝上性能ばっちりです。
非常にハイスペックなだけあって高いので、Core i5+メモリ8GB+SSD256GBの時点で20万円を越えることを確認して候補から外しました。&lt;/p&gt;

&lt;h3 id=&#34;macbook-air-macbook-pro&#34;&gt;Macbook Air, Macbook Pro&lt;/h3&gt;

&lt;p&gt;Core i5+メモリ8GB+SSD 512GBの構成で139k、Core i7の場合は155kと、予算的にはいい感じです。
しかし最大の問題として、そもそも積んでいるCPUが第5世代のものです。
単純に動作周波数で見ても、MBAのCore i7の動作周波数2.2GHzは現行の第7世代Core i3にすら劣ります。&lt;/p&gt;

&lt;p&gt;お値段が安いのは利点ですがCPUの古さのために相殺されてしまい、やはりモデルとして古すぎて今買うべきかと言われると疑問符が付くので保留とし、結局候補から外れました。&lt;/p&gt;

&lt;p&gt;MBPは第七世代CPUを使用可能ですが、Core i5(2.3GHz)+メモリ8GB+512GBで187kとなるので予算オーバーです。&lt;/p&gt;

&lt;h3 id=&#34;matebook-x&#34;&gt;Matebook X&lt;/h3&gt;

&lt;p&gt;華為のモバイルPCで、メモリは8GBのみ、512GB SSDを積むためにはCore i7モデルを選択する必要があります。
この場合の基本価格は174k程度で予算の上限を越えますが、実際にはもう少し安い価格で買えるようです。&lt;/p&gt;

&lt;p&gt;欠点があるとすれば、デザインがあまりにMacbookに似ているのでちょっと複雑な気持ちになりそうなところでしょうか。&lt;/p&gt;

&lt;h3 id=&#34;thinkpad-x1-carbon-thinkpad-x270&#34;&gt;Thinkpad X1 Carbon, Thinkpad X270&lt;/h3&gt;

&lt;p&gt;LenovoのThinkpadは常に割引されている状態で、日時によって割引率がどんどん変わっていくのでちゃんとした値段を出すのが難しいです。
一度割引率43%までは確認したので、とりあえず40%の割引がなされるものとして計算しました。&lt;/p&gt;

&lt;p&gt;Core i5+メモリ8GB+512GB SSDで159kとなり、予算に収まります。
なおCore i7+メモリ16GB+512GB SSDだと177kでした。&lt;/p&gt;

&lt;p&gt;X1 Carbonは14型液晶ですがサイズは13型PCとほぼ同等で、その上軽量化が図られているのでとても使いやすそうに感じました。
端子類もType-A USB端子が2つにType-C端子が2つ(電源込み)と十分な数があり、長く使い続けられそうです。&lt;/p&gt;

&lt;p&gt;また12.5型のThinkpad X270も候補に上げました。
これはX1 Carbonよりも重い一方でサイズは12.5型のため小さく、また同スペックでも1万円から2万円ほど安く買うことができます。&lt;/p&gt;

&lt;h2 id=&#34;thinkpad-x1-carbon購入&#34;&gt;Thinkpad X1 Carbon購入&lt;/h2&gt;

&lt;p&gt;最終的な候補としてMatebook X, Thinkpad X1 Carbon, Thinkpad X270が残りました。
デザイン的にはThinkpadが好みだったり、また知名度からの安心感もあるのでMatebookは除外し、X1 CarbonとX270のどちらかを買うことに決めました。&lt;/p&gt;

&lt;p&gt;とはいえこの2つは大きさと重さの違いが重要なので、実際に店頭で確かめることにしました。
ちょうど大阪に行く用事があったのでヨドバシ梅田に寄って実機を確かめましたが、X270は画面が小さすぎる印象があり、X1 Carbonを購入することに決めました。
ネットの情報ではX1 Carbonは従来機種よりも薄いためにトラックポイントの背が低く、操作性が落ちているということが書かれていましたが、Thinkpadを使ったことのない自分が店頭で触り比べてみた程度では違いが全くわからなかったので気にしないことにしました。&lt;/p&gt;

&lt;p&gt;価格を聞いてみたところ、販売店では常に直近のネット最安価格よりも1%程度割引率が高くなるらしく、44%の割引率が適用されたのでそのまま買うことにしました。&lt;/p&gt;

&lt;p&gt;この割引率ではi5+8GB+512GB SSDで148kと思った以上に安く、どうせならメモリを16GBに増やそうと思ったのですが、その場合はCPUもCore i7に上げなければならないということを伝えられました。
この場合のお値段は165kで、予算内には十分収まっています。&lt;/p&gt;

&lt;p&gt;ここに来てCore i5+メモリ8GBとi7+16GBのどちらにするかで非常に迷うことになってしまったのですが、高い買い物をするときは多少余計に払ってでも良いものを買えという親の教えを思い出し、Core i7+メモリ16GBにすることに決めました。&lt;/p&gt;

&lt;h2 id=&#34;使用感など&#34;&gt;使用感など&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/blog/2017/12/18/intro-new-moblie-pc/&#34;&gt;ICPC参加&lt;/a&gt;のためにつくばに行く2日ほど前に届きました。
とても軽い上に鞄に入れやすいサイズのため、持ち運びは明らかに便利になりました。
Xfceを入れたDebian 9.3とWindows10とのデュアルブート(ブートローダはGRUB)にしましたが、どちらも起動・終了が非常に速いので快適です。
Linuxとの相性は悪くなく、無線LANドライバなども全く問題なく動作していますが、搭載されている指紋センサだけはドライバが対応せず使えないようです。&lt;/p&gt;

&lt;p&gt;全体的に非常に使いやすいのでとても満足していますが、一点だけ挙げるとすればキーボードの右上にHome/Endキーが搭載されているため、Fnキー+左/右キーの組み合わせではHome/Endキーが使えません。
キー配置の慣れの問題かもしれませんが、HomeキーとEndキーは頻繁に使用するキーのため今の所やや不便です。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>ACM-ICPC2017アジアつくば大会に参加しました</title>
      <link>http://tatamo.81.la/blog/2017/12/18/icpc-2017-asia/</link>
      <pubDate>Mon, 18 Dec 2017 01:30:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/12/18/icpc-2017-asia/</guid>
      <description>
        &lt;p&gt;この記事は&lt;a href=&#34;https://adventar.org/calendars/2491&#34;&gt;Kobe University Advent Calendar 2017&lt;/a&gt;の18日の記事です。
なお私は当該大学の学部3年(2017年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://icpc.iisf.or.jp/2017-tsukuba/results/&#34;&gt;ICPC国内予選39位&lt;/a&gt;で神戸大学の第2チームとしてぎりぎり予選通過できたので、&lt;a href=&#34;https://icpc.iisf.or.jp/2017-tsukuba/&#34;&gt;アジア大会&lt;/a&gt;に参加しました。&lt;/p&gt;

&lt;p&gt;結果としては3問通して&lt;a href=&#34;http://icpc2017.yamagula.ic.i.u-tokyo.ac.jp/standings/&#34;&gt;39位&lt;/a&gt;でした。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;実績「座っているだけのお仕事」&lt;br&gt;解除条件：ICPCで一度たりとも競技用マシンに触れない&lt;br&gt;を達成しました💺💤&lt;/p&gt;&amp;mdash; Tatamo@Super-Srups (@&lt;strong&gt;tatamo&lt;/strong&gt;) &lt;a href=&#34;https://twitter.com/__tatamo__/status/942290374382383104?ref_src=twsrc%5Etfw&#34;&gt;2017年12月17日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
なにもしないをしました&lt;/p&gt;

&lt;h2 id=&#34;チーム構成-方針&#34;&gt;チーム構成・方針&lt;/h2&gt;

&lt;p&gt;私の所属するチームであるSuper-Srupsのメンバー構成は以下の通りです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/mmxsrup&#34;&gt;@mmxsrup&lt;/a&gt;氏

&lt;ul&gt;
&lt;li&gt;学部2年&lt;/li&gt;
&lt;li&gt;リーダー&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/kurenai3110&#34;&gt;@kurenai3110&lt;/a&gt;氏

&lt;ul&gt;
&lt;li&gt;学部2年&lt;/li&gt;
&lt;li&gt;実装担当&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/__tatamo__&#34;&gt;@__tatamo__&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;わたし 学部3年&lt;/li&gt;
&lt;li&gt;座っている担当&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;私は3人の中で最も実力が低く、かつここ数ヶ月のあいだ全くC++を書いていないという状態です。
つまり論理的結論として、私は一行もコードを書くべきではありません。
そのため私は英語で与えられる問題文の読解、他メンバーの補助および考察少しを担当しました。
他の2人はUSキーボードのEnterキーが空振りするとかgeditがつらいとかubuntuの使い方がわからないとか大変そうでした。&lt;/p&gt;

&lt;h2 id=&#34;解いた問題&#34;&gt;解いた問題&lt;/h2&gt;

&lt;p&gt;問題の内容については&lt;a href=&#34;https://storage.googleapis.com/icpcsec/icpc2017-regional/problems.pdf&#34;&gt;問題文&lt;/a&gt;を参照してください。&lt;/p&gt;

&lt;h3 id=&#34;a&#34;&gt;A&lt;/h3&gt;

&lt;p&gt;やるだけ問です。
問題文を読んで&lt;a href=&#34;https://twitter.com/kurenai3110&#34;&gt;@kurenai3110&lt;/a&gt;氏に投げたらよろしくやってくれました。&lt;/p&gt;

&lt;h3 id=&#34;c&#34;&gt;C&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/mmxsrup&#34;&gt;@mmxsrup&lt;/a&gt;氏と考察を担当し、実装は&lt;a href=&#34;https://twitter.com/kurenai3110&#34;&gt;@kurenai3110&lt;/a&gt;氏にやってもらいました。
値が負になるときの特殊ケースや変数の更新タイミングのミス等のちょっとした考察漏れ・実装ミスを3つほど同時に仕込んでしまって数十分ほど無駄に消費してしまったので反省点が多いです。&lt;/p&gt;

&lt;h3 id=&#34;i&#34;&gt;I&lt;/h3&gt;

&lt;p&gt;B問題・C問題で無限に時間を費やしているうちに他チームは問題をたくさん解いていたので、風船の浮かんでいる状況を見てI,F,G問題に解く対象を絞りました。
なお今年の問題の並び順は、A,B,C問題までが易しい順に並んでおりそれ以降の問題はランダムになっています。&lt;/p&gt;

&lt;p&gt;I問題は問題文を読んで&lt;a href=&#34;https://twitter.com/kurenai3110&#34;&gt;@kurenai3110&lt;/a&gt;氏に丸投げしたら見事に解いてくれました。&lt;/p&gt;

&lt;h2 id=&#34;解けなかった問題&#34;&gt;解けなかった問題&lt;/h2&gt;

&lt;h3 id=&#34;b&#34;&gt;B&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/mmxsrup&#34;&gt;@mmxsrup&lt;/a&gt;氏がメインで担当しました。
制限実行時間10秒の問題ですが、最初にすべての可能な傾きの同じ線分の集合を持ったりしていたらハマってしまって通せませんでした。
普通に全探索すれば解けるなどということを終了後に聞きましたが、全然通らなかったのでいっそ早めに放り投げるべきだったのかもしれません。&lt;/p&gt;

&lt;h3 id=&#34;f&#34;&gt;F&lt;/h3&gt;

&lt;p&gt;私はグラフは最短経路の超典型問ぐらいしか解けないので、問題を訳すだけして他の２人に投げました。
実装の最後の方まで行っていたようなのですが間に合いませんでした。&lt;/p&gt;

&lt;h3 id=&#34;g&#34;&gt;G&lt;/h3&gt;

&lt;p&gt;考察を担当しました。
座標変換で簡単になるというのは気付きませんでしたが、極座標→XY座標への変換をしてからdX=正三角形の辺の長さの半分, dY=正三角形の高さ で区切って場合分け2回ほどで数学的に求めて終わりです。&lt;/p&gt;

&lt;h2 id=&#34;結果&#34;&gt;結果&lt;/h2&gt;

&lt;p&gt;A問題解いた直後に沼にはまって時間を無為に費やし、終盤になってB,F,Gの解法が出揃ったが実装時間が圧倒的に足りないという状況に陥り、結局4問目を通せず3完でした。
予選と全く同じ順位の39位です。&lt;/p&gt;

&lt;p&gt;ICPCはやはりマシン1台のチーム戦ということで、特有の難しさがあるので事前の慣らしはもっとしておいたほうがよかったような気がします。
あとUSキーボードは思った以上に慣れない(らしい)のでこちらも事前準備が必要そうです。&lt;/p&gt;

&lt;p&gt;とはいえ、そもそも私は自力で問題を解けないので、問題文の和訳と考察補助とただ座っているぐらいしか仕事がない感じです。
こういう場にカジュアル勢が紛れ込んでしまって肩身が狭いというか申し訳無さです。&lt;/p&gt;

&lt;h2 id=&#34;雑事&#34;&gt;雑事&lt;/h2&gt;

&lt;p&gt;1日目は昼過ぎに集合で、参加受付+開会式+練習+懇親会だけで、解放される時間がなぜか20時です。
思うところがないでもありません。&lt;/p&gt;

&lt;p&gt;2日目についても、終了後の懇親会で2時間拘束されます。
こちらでは企業ブースがいくつかあり、物をもらったり話を聞いたりすることができました。&lt;a href=&#34;2017/09/17/indeed-austin-tour/&#34;&gt;ツアー&lt;/a&gt;で一緒だった某r(i)社の方々とまた会ったりしました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://proc-cpuinfo.fixstars.com/2017/12/in-house-procon-06-announcement/&#34;&gt;量子リバーシ&lt;/a&gt;なるクイズが出題されており、こういうのは&lt;a href=&#34;http://shogitter.com/rule/108&#34;&gt;量子将棋&lt;/a&gt;とか&lt;a href=&#34;http://uhyo.hatenablog.com/entry/2016/04/22/161011&#34;&gt;量子人狼&lt;/a&gt;とか&lt;a href=&#34;https://uhyohyo.net/quantum2048/&#34;&gt;量子2048&lt;/a&gt;とか作ってる人たちが周りにいるから見慣れてるんだよなあなどと思いつつ、順に確定させてから普通のオセロをシミュレートするだけのやるだけ問を3分ぐらいで解いたら驚かれました。&lt;/p&gt;

&lt;p&gt;また他のブースではよくわからないクイズを解くだけでANKERの10000mAhモバイルバッテリー(自分が持っている物の一つ下のモデル)をもらうことができました。&lt;/p&gt;

&lt;h2 id=&#34;つくば&#34;&gt;つくば&lt;/h2&gt;

&lt;p&gt;交通費補助が新幹線代程度出るものの、宿泊施設の提供なしで宿泊補助費は5000円しか出ないので新幹線で行くと大赤字です。
そこでLCCで飛んでいくことで交通費を浮かせて2泊するための宿泊費に充てました(これって書いていいんでしょうか)。&lt;/p&gt;

&lt;p&gt;宿泊施設が用意されなくなったのは今年からとのことですが、ICPC協賛の某企業の方に聞いた話によると、どうもスポンサー費用は例年上がっていく一方らしいです。
よくわかりません。&lt;/p&gt;

&lt;p&gt;そこそこ移動がつらく、朝6時頃には家を出て空港まで行ったかと思えば移動の間に2時間ぐらい待機する必要があったりしました。
また宿はできるだけ安いところを取りましたが、1日目は浴場の給湯器が故障していて使えず、2日目は浴場に入ることはできたものの、あまりにお湯がぬるいので仕方なくサウナで温まるなどすることになりました。&lt;/p&gt;

&lt;p&gt;1日目は部屋に備え付けの浴室を使いましたが、湯を張るために蛇口を開くと汚れの混じった赤っぽい水が出てきたので、無心でシャワーを浴びてそのまま何も考えずに寝ました。&lt;/p&gt;

&lt;h2 id=&#34;3日目&#34;&gt;3日目&lt;/h2&gt;

&lt;p&gt;エクスカーションや企業見学に参加する人に合わせて飛行機を取ったので、3日目は夜まで暇です。
ほとんどの人は企業見学に行ったので、残りの3人で東京観光に行きました。
大洗は非常に遠かったのでやめておいて、VRの体験や靖国神社に行ったりして所々で先輩におごってもらいました。
大荷物を持って長距離を移動した上に懇親会等で立ちっぱなしで疲労が蓄積していたので、夕方はカフェで休憩しながら時間を潰していました。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>Web技術ではじめるレポート・論文制作</title>
      <link>http://tatamo.81.la/blog/2017/12/06/web-dtp/</link>
      <pubDate>Wed, 06 Dec 2017 18:30:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/12/06/web-dtp/</guid>
      <description>
        &lt;p&gt;この記事は&lt;a href=&#34;https://adventar.org/calendars/2491&#34;&gt;Kobe University Advent Calendar 2017&lt;/a&gt;の6日の記事です。
なお私は当該大学の学部3年(2017年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;http://vivliostyle.com/ja/products/&#34;&gt;Vivliostyle&lt;/a&gt;やその他のWeb技術を用いて、HTMLとCSSで課題のレポートを書くための環境を作る話です。
あと「&lt;a href=&#34;https://pentapod.github.io/c92/&#34;&gt;CSSではじめる同人誌制作&lt;/a&gt;」を勝手に販促する記事でもあります。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;html-cssによる組版&#34;&gt;HTML+CSSによる組版&lt;/h2&gt;

&lt;p&gt;個人的にはWordもTeXもあまり得意ではない、というか、HTML+CSSで似たようなことができそうなのにわざわざWordやTeXを使うのが大変だと感じています(InDesignはよく知りません)。
文書構造の明確化という観点においては、構造と見た目が明確に分離しているHTML+CSSに勝るものはありません(筆者個人の主観です)。&lt;/p&gt;

&lt;p&gt;そこでWeb技術を用いてレポートや論文を書きたいなあと思っていたのですが、ちょうど&lt;a href=&#34;http://tatamo.81.la/blog/2017/08/27/seccamp-2017/&#34;&gt;セキュキャンの事前準備で行けなかった&lt;/a&gt;ときのコミケで、pentapodさんより「&lt;a href=&#34;https://pentapod.github.io/c92/&#34;&gt;CSSではじめる同人誌制作&lt;/a&gt;」が頒布されていたので、友人に頼んで確保しておいてもらいました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote&gt;内容については同人誌制作だけをターゲットに絞らず， できるだけ色々な場面で使えるような説明を心がけています．&lt;/blockquote&gt;
というあとがきの記述通り、CSS組版全般、また単にCSSの解説本としても読めるようになっており、本書を参考にしてレポートを書くための環境を整えることができました。
同人誌でもレポートでも論文でも、やりたいことは結局同じ組版であるため、整えるべき環境は変わりません。&lt;/p&gt;

&lt;h2 id=&#34;この記事で書くこと&#34;&gt;この記事で書くこと&lt;/h2&gt;

&lt;p&gt;CSSを用いた組版については、「&lt;a href=&#34;https://pentapod.github.io/c92/&#34;&gt;CSSではじめる同人誌制作&lt;/a&gt;」を直接読んでいただくのが一番早いため、今回はあまり詳しくは書きません。
&lt;a href=&#34;https://pentapod.booth.pm/items/601017&#34;&gt;300円というお手頃価格で電子版も出ている&lt;/a&gt;ので買ってください。
これは販促です。&lt;/p&gt;

&lt;p&gt;そこでこの記事では、本書を参考にしながら行った環境構築を中心に書いていきます。
構築した環境は &lt;a href=&#34;https://github.com/Tatamo/htmldtp&#34;&gt;https://github.com/Tatamo/htmldtp&lt;/a&gt; に上げていますが、「そもそもボイラープレートという単語を数日前にはじめて知った」レベルのためディレクトリ構成ひとつとっても正直褒められたものではないと感じています。
なのでまたちゃんと体裁を整えたいと思います。&lt;/p&gt;

&lt;h2 id=&#34;vivliostyle&#34;&gt;Vivliostyle&lt;/h2&gt;

&lt;p&gt;とはいえ、&lt;a href=&#34;http://vivliostyle.com/ja/products/&#34;&gt;Vivliostyle&lt;/a&gt;については触れておかないと話が始まりません。
これはWeb技術による組版を目的としたプロジェクトで、CSSの将来的な仕様を先取りすることで、より多彩なレイアウトを実現できるようにしているものです。
&lt;a href=&#34;http://vivliostyle.com/ja/samples/&#34;&gt;サンプル&lt;/a&gt;が充実しており、実際にCSSによってデザインされた本と、その生のHTMLを閲覧することができます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://vivliostyle.github.io/vivliostyle.js/samples/css-secrets-long/viewer/vivliostyle-viewer.html#x=../doc/&#34;&gt;こういうレベルのこと&lt;/a&gt;がCSSで既に可能となっているのです。&lt;/p&gt;

&lt;p&gt;Vivliostyleを用いた印刷を行う方法は何種類かありますが、&lt;a href=&#34;https://chrome.google.com/webstore/detail/vivliostyle/ffeiildjegeigkbobbakjjmfeacadbne&#34;&gt;Chrome拡張&lt;/a&gt;を用いるのが最も簡単だと思われます。
目的のHTMLファイルを表示した状態で拡張機能を有効化するとレイアウトが紙面向けのものに変換されるので、これをChromeの印刷機能を用いて紙面やPDFに印刷します。&lt;/p&gt;

&lt;p&gt;そのため、Vivliostyleに対応したCSSファイルと、それを適用するための原稿となるHTMLファイルを用意することが目的となります。
HTMLとCSSの状態からPDFを生成する作業を自動化する方法についても「&lt;a href=&#34;https://pentapod.github.io/c92/&#34;&gt;CSSではじめる同人誌制作&lt;/a&gt;」では解説されていますが、今回は省略するので本書を購入してください。&lt;/p&gt;

&lt;p&gt;恥ずかしい話ですが、最近のCSS3の仕様をしっかり追いかけているわけではないため、どこからどこまでがVivliostyleによって実現されている機能で、どこまでがブラウザの標準機能で既にサポートされている部分なのかがよくわかっていません。
このあたりは書けば書くほどボロが出るに違いないので適当にごまかします。&lt;/p&gt;

&lt;h2 id=&#34;フレームワーク選定&#34;&gt;フレームワーク選定&lt;/h2&gt;

&lt;p&gt;書籍ではPug+marked+Stylus+Prism.js+MathJax+Browsersync+Gulpの構成が紹介されていましたが、このあたりは好みだと思うので適当に選んでいきました。&lt;/p&gt;

&lt;p&gt;結論としては、Nunjucks+nunjucks-markdown+PostCSS(cssnext+stylelint)+highlight.js+MathJax+Browsersync+Gulpという構成になりました。&lt;/p&gt;

&lt;h3 id=&#34;nunjucks&#34;&gt;Nunjucks&lt;/h3&gt;

&lt;p&gt;まずはHTMLテンプレートエンジンを選びます。
変数を用いた操作や別のHTMLの継承などの機能を取り入れることで、HTMLをより書きやすくして開発の高速化・再利用の促進を図ります。&lt;/p&gt;

&lt;p&gt;今回は&lt;a href=&#34;https://mozilla.github.io/nunjucks/&#34;&gt;Nunjucks&lt;/a&gt;を使うことにしました。
昔Djangoを触ったことがあるので見慣れたテンプレートであるという点などが採用理由です。
他には以前使ったことのあるEJS、紹介されていたPug(Jade)なども候補に上がりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- template/_base.njk --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;ja&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;{{ title }}&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
{% block content %}
    &amp;lt;section&amp;gt;
        &amp;lt;p&amp;gt;default content&amp;lt;/p&amp;gt;
    &amp;lt;/section&amp;gt;
{% endblock %}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- index.njk --&amp;gt;
{% extends &amp;quot;template/_base.njk&amp;quot; %}
{% set title = &amp;quot;awesome-report&amp;quot; %}
{% block content %}
&amp;lt;section&amp;gt;
    &amp;lt;!-- awesome-report-content --&amp;gt;
&amp;lt;/section&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のような感じでHTMLにいろいろなものをくっつけていきながら書けるようになります。
Nunjucksで記述したHTMLは、.htmlのほかに.njkなどの拡張子を使ったりするらしいです。&lt;/p&gt;

&lt;h3 id=&#34;nunjucks-markdown&#34;&gt;nunjucks-markdown&lt;/h3&gt;

&lt;p&gt;ひたすら文章を書くのにいちいち&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;タグを書いたりしていられないので、Markdownを使えるようにすることが必要です。
Nunjucksを使うことにしたので、markedのNunjucks向けプラグインである&lt;a href=&#34;https://www.npmjs.com/package/nunjucks-markdown&#34;&gt;nunjucks-markdown&lt;/a&gt;を使うことにしました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% block content %}
&amp;lt;section&amp;gt;
    {% markdown %}
    ## PPAP
    I have a pen.
    I have an apple.
    ```js
    console.log(&amp;quot;Apple pen!&amp;quot;);
    ```
    {% endmarkdown %}
&amp;lt;/section&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように、&lt;code&gt;{% markdown %}&lt;/code&gt;で囲った部分をMarkdownとして書くことができようになります。&lt;/p&gt;

&lt;h3 id=&#34;postcss-cssnext-stylelint&#34;&gt;PostCSS(cssnext+stylelint)&lt;/h3&gt;

&lt;p&gt;HTMLだけでなくCSSも次世代仕様を使用できるようにしておくと便利です。
SassやStylusという選択肢もありますが、この次世代CSS過渡期において独自記法マシマシのcoffeeとあくまでES2015をもとにしたtsならどちらを使うかという話です。
一通り必要な機能が入ったプラグイン集である&lt;a href=&#34;http://cssnext.io/&#34;&gt;cssnext&lt;/a&gt;と、lintをしてくれる&lt;a href=&#34;https://stylelint.io/&#34;&gt;stylelint&lt;/a&gt;を入れていますが、この構成だとSassのように&lt;code&gt;@import&lt;/code&gt;できない点で不便さがあるので、CSSをモジュール化できるようにするためにpostcss-importも入れたほうが良いかもしれません。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;gulp-postcssを使っている際にstylelintでインデント幅をlintするよう指定している状態でAutoprefixerなどで右寄せしたprefixが追加された場合、なぜかsrc側のCSSのインデントが崩れているとしてstylelintに怒られてしまうので、plugin設定にはstylelintを一番先に置くべきという知見を得ました &lt;a href=&#34;https://t.co/IMnmqibetC&#34;&gt;pic.twitter.com/IMnmqibetC&lt;/a&gt;&lt;/p&gt;&amp;mdash; たたもさん@がんばらない (@&lt;strong&gt;tatamo&lt;/strong&gt;) &lt;a href=&#34;https://twitter.com/__tatamo__/status/928286264914145280?ref_src=twsrc%5Etfw&#34;&gt;2017年11月8日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
これは余談です。&lt;/p&gt;

&lt;h3 id=&#34;highlight-js&#34;&gt;highlight.js&lt;/h3&gt;

&lt;p&gt;プログラムリストを貼り付けることが求められることもあるので、シンタックスハイライターを用意します。
他の候補としてはPrism.jsなどがあります。
今回はこのブログで使ったりして使い慣れている&lt;a href=&#34;https://highlightjs.org/&#34;&gt;highlight.js&lt;/a&gt;を用いました。&lt;/p&gt;

&lt;h3 id=&#34;mathjax&#34;&gt;MathJax&lt;/h3&gt;

&lt;p&gt;TeX形式で書いた数式を表示するために必須です。
&lt;a href=&#34;https://www.mathjax.org/&#34;&gt;MathJax&lt;/a&gt;以外の選択肢は特にないと言っていいでしょう。
適当なスニペットを&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;タグ内に追加し、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;p&amp;gt;MathJax test: $E = mc^2$&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などと書くだけで数式部分が整形されて表示されます。&lt;/p&gt;

&lt;p&gt;どうでもいい余談ですが、個人的にはMicrosoft Officeの数式エディタは見た目もきれいですし非常に使いやすいと思っています。
これについてはあまり同意されたことがない気がします。&lt;/p&gt;

&lt;h3 id=&#34;browsersync&#34;&gt;Browsersync&lt;/h3&gt;

&lt;p&gt;ソースコードが更新され(、そしてそれを検知してビルドが走って&lt;code&gt;dist/&lt;/code&gt;ディレクトリが更新され)たことを検知し、&lt;a href=&#34;https://www.browsersync.io/&#34;&gt;Browsersync&lt;/a&gt;が自動でブラウザを再読み込みしてくれるようにします。
わざわざF5を押さなくても変更が反映され、ビルド結果がすぐにブラウザ上で見れて便利…… なのですが、今回はブラウザを更新したあとVivliostyleのChrome拡張を有効化しなければならず、結局F5相当の動作を手で行わなければならないという難点があります。&lt;/p&gt;

&lt;h3 id=&#34;gulp&#34;&gt;Gulp&lt;/h3&gt;

&lt;p&gt;ビルドを自動化してくれるようにするためのタスクランナーです。
&lt;a href=&#34;https://gulpjs.com/&#34;&gt;Gulp&lt;/a&gt;は使っていますがGruntは使ったことがないです。
タスクランナーとは、&lt;code&gt;hoge&lt;/code&gt;というパッケージと一緒に&lt;code&gt;gulp-hoge&lt;/code&gt;を入れなければならなくなってpackage.jsonの依存パッケージ数が2倍近くに膨れ上がるという、とても素敵なものです。&lt;/p&gt;

&lt;p&gt;最近は何でもかんでもnpm-scriptsでやろうという話があって、確かに一理あるなあという感じなのでGulpじゃなくてもよかったかもしれません。&lt;/p&gt;

&lt;h2 id=&#34;全部突っ込む&#34;&gt;全部突っ込む&lt;/h2&gt;

&lt;p&gt;JavaScriptから利用するためのパッケージを一つも入れていない、というかJavaScriptを書くつもりがない(gulpfile除く)のに依存パッケージ数が10を越えるのはどういうことなんだ、という感じですが、とりあえず上記のツールを全部組み合わせます。
highlight.jsとMathJaxに関しては、&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;タグで読み込むだけでいいので&lt;code&gt;npm install&lt;/code&gt;は不要です。
Nunjucksのテンプレート継承機能を用いて、これらの読み込み用のスニペットをモジュール化しておくのがいいでしょう。&lt;/p&gt;

&lt;p&gt;Nunjucks(+nunjucks-markdown)とPostCSSを用いて、それぞれHTMLファイルとCSSファイルを生成する処理が行われるので、これをGulpのタスクとしてまとめてしまいます。
あとはソースコードの更新を検知して自動的にこのビルド処理が走るようにしたり、ビルド完了のタイミングでBrowsersyncに更新を伝えたりする処理を&lt;a href=&#34;https://github.com/Tatamo/htmldtp/blob/master/gulpfile.js&#34;&gt;gulpfile.js&lt;/a&gt;に書いて終わりです。&lt;/p&gt;

&lt;h2 id=&#34;使ってみた&#34;&gt;使ってみた&lt;/h2&gt;

&lt;p&gt;大学でパーセプトロンの出力を求めるだけのレポート課題が出たので、構築した環境を用いてレポートを書いてみました。&lt;/p&gt;

&lt;p&gt;以下に、Vivliostyleを用いて出力されたPDF(のスクリーンショットにモザイクかけたただの画像)を示します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tatamo.81.la/blog/images/post/2017/12/06/output_report.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://tatamo.81.la/blog/images/post/2017/12/06/output_report.png&#34; alt=&#34;PDFに出力されたレポート&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;図はLibreOffice Drawで用意しましたがそのあたりは適当です。&lt;/p&gt;

&lt;p&gt;これに用いたCSSは、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;@page {
  size: A4;
  margin: 20mm;
  @bottom-center {
    content: counter(page);
  }
}

figcaption {
  counter-increment: fig;
}

figcaption::before {
  content: &amp;quot;図&amp;quot; counter(fig) &amp;quot;. &amp;quot;;
}

/* うまく動かない(後述) */
a.figref::after {
  content: &amp;quot;図&amp;quot; target-counter(attr(href), fig);
}

img {
  max-width: 100%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;だけであり、非常に簡潔なCSSで十分に見た目の整ったレポートを書くことができます。&lt;/p&gt;

&lt;p&gt;そういえば指定するのを忘れていましたが、当然&lt;code&gt;font-size&lt;/code&gt;でフォントサイズをポイント指定することも可能です。&lt;/p&gt;

&lt;h3 id=&#34;相互参照と問題点&#34;&gt;相互参照と問題点&lt;/h3&gt;

&lt;p&gt;図を示している部分のHTMLを抜粋すると、以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;section&amp;gt;
    {% markdown %}
    ## パーセプトロンの提示
    まず、パーセプトロンの修正後の重みを&amp;lt;a class=&amp;quot;figref&amp;quot; href=&amp;quot;#fig-nn&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;に示す。
    &amp;lt;figure&amp;gt;
        &amp;lt;img src=&amp;quot;perceptron.png&amp;quot;&amp;gt;
        &amp;lt;figcaption id=&amp;quot;fig-nn&amp;quot;&amp;gt;パーセプトロン&amp;lt;/figcaption&amp;gt;
    &amp;lt;/figure&amp;gt;
    簡単のため、パーセプトロンのそれぞれのノードに番号を付与した。
    {% endmarkdown %}
&amp;lt;/section&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;figcaption::before&lt;/code&gt;の&lt;code&gt;content&lt;/code&gt;に&lt;code&gt;counter(fig)&lt;/code&gt;を用いることで、自動的に図表番号を振ることができます。&lt;/p&gt;

&lt;p&gt;それに加えて、&lt;code&gt;figcaption&lt;/code&gt;の持つidに対するリンクのcontentに&lt;code&gt;target-counter(attr(href), fig)&lt;/code&gt;を指定しています。
これは&lt;code&gt;attr(href)&lt;/code&gt;&amp;mdash;つまりhrefの属性値、&lt;code&gt;&amp;quot;#fig-nn&amp;quot;&lt;/code&gt;&amp;mdash;の地点での&lt;code&gt;counter(fig)&lt;/code&gt;のカウンタの値を取得しており、つまりその図表に割り当てられた番号が得られます。&lt;/p&gt;

&lt;p&gt;これによって相互参照が実現できます。&lt;/p&gt;

&lt;p&gt;と言ってドヤ顔したいところなのですが、ここで致命的な問題が発生します。
なぜかChrome拡張のVivliostyleでは、この&lt;code&gt;target-counter()&lt;/code&gt;がうまく動かず、図表番号が&lt;code&gt;??&lt;/code&gt;で表示されます。&lt;/p&gt;

&lt;p&gt;他の手段であるVivliostyle FormatterやVivliostyle Viewerを使えば動かせはするのですが、その場合highlight.jsによるシンタックスハイライトが効かなかったり、MathJaxは対応しているもののMathML以外の記法を使えない、などの別の問題が生じてきます。&lt;/p&gt;

&lt;p&gt;なので現状、&lt;code&gt;a.figref::after&lt;/code&gt;に対するスタイル指定を削除し、&lt;code&gt;&amp;lt;a class=&amp;quot;figref&amp;quot; href=&amp;quot;#fig-nn&amp;quot;&amp;gt;図1&amp;lt;/a&amp;gt;&lt;/code&gt;などと直接書くしかないという本末転倒感があります。&lt;/p&gt;

&lt;p&gt;これについては今のところ解決策を見つけられていないので、もう少し調べてみて必要ならissueを飛ばすなりしようと思っています。&lt;/p&gt;

&lt;h2 id=&#34;おわり&#34;&gt;おわり&lt;/h2&gt;

&lt;p&gt;レポート・論文程度ならそこまで凝ったデザインである必要がないので、非常に短いCSSでそれなりの印刷が可能になります。
HTML+CSSを用いてレポートを書くというのは十分に実用の範囲内だと思ったので、これからも試していこうと思っています。&lt;/p&gt;

&lt;p&gt;しかしながら、やはり現状で相互参照が実現できないというのはレポート・論文執筆には致命的なところがあります。
&lt;code&gt;target-counter()&lt;/code&gt;は策定中の次期CSS仕様であることから、解決は時間の問題だとは思っているのですが、なんとかしたいところです。&lt;/p&gt;

&lt;p&gt;今の時代のCSSは、もはやWebページだけでなく紙面上のレイアウトも自在に操れるようになってきています。「&lt;a href=&#34;https://pentapod.github.io/c92/&#34;&gt;CSSではじめる同人誌制作&lt;/a&gt;」はCSSを使ったさまざまな紙面レイアウトについて書かれており、とてもおすすめなのでぜひ購入してみてください。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>ゲーム「じゃぱりうぉっち」を作りました</title>
      <link>http://tatamo.81.la/blog/2017/12/01/japari-watch/</link>
      <pubDate>Fri, 01 Dec 2017 17:35:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/12/01/japari-watch/</guid>
      <description>
        &lt;p&gt;この記事は&lt;a href=&#34;https://adventar.org/calendars/2491&#34;&gt;Kobe University Advent Calendar 2017&lt;/a&gt;の1日の記事です。
なお私は当該大学の学部3年(2017年12月現在)です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;ブラウザ上で動作するゲーム「&lt;a href=&#34;https://tatamo.github.io/japari-watch/&#34;&gt;じゃぱりうぉっち&lt;/a&gt;」を作ったので、開発記を書きます。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;じゃぱりうぉっち&#34;&gt;じゃぱりうぉっち&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://tatamo.github.io/japari-watch/&#34;&gt;https://tatamo.github.io/japari-watch/&lt;/a&gt; で公開しており、PCとモバイル端末のどちらでも遊ぶことができます。&lt;/p&gt;

&lt;h3 id=&#34;発端&#34;&gt;発端&lt;/h3&gt;

&lt;p&gt;期末試験前に現実逃避のためにTLを眺めていたところ、以下のツイートが流れてきました。
&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;フェネック「アライさんに似合いそうな帽子を見つけてきたよー」&lt;br&gt;アライグマ「ありがとうなのだ！」&lt;a href=&#34;https://twitter.com/hashtag/%E3%81%91%E3%82%82%E3%81%AE%E3%83%95%E3%83%AC%E3%83%B3%E3%82%BA?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#けものフレンズ&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/%E3%83%89%E3%83%83%E3%83%88%E7%B5%B5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#ドット絵&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/pixelart?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#pixelart&lt;/a&gt; &lt;a href=&#34;https://t.co/1VueMavObQ&#34;&gt;pic.twitter.com/1VueMavObQ&lt;/a&gt;&lt;/p&gt;&amp;mdash; 鬼雷 昇炎 (@kirai_s) &lt;a href=&#34;https://twitter.com/kirai_s/status/934412479597199361?ref_src=twsrc%5Etfw&#34;&gt;2017年11月25日&lt;/a&gt;&lt;/blockquote&gt;&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Version Upgrade Nanoda!! &lt;a href=&#34;https://t.co/IXSjV6A1PN&#34;&gt;pic.twitter.com/IXSjV6A1PN&lt;/a&gt;&lt;/p&gt;&amp;mdash; 鬼雷 昇炎 (@kirai_s) &lt;a href=&#34;https://twitter.com/kirai_s/status/934695920414765056?ref_src=twsrc%5Etfw&#34;&gt;2017年11月26日&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;作品としての完成度が高く、実際にゲームとして遊べそうに見えたので、これをゲーム化してみました。&lt;/p&gt;

&lt;h3 id=&#34;素材&#34;&gt;素材&lt;/h3&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;原寸(128*128px)なのだ &lt;a href=&#34;https://twitter.com/hashtag/%E3%81%91%E3%82%82%E3%81%AE%E3%83%95%E3%83%AC%E3%83%B3%E3%82%BA?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#けものフレンズ&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/%E3%83%89%E3%83%83%E3%83%88%E7%B5%B5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#ドット絵&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/pixelart?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#pixelart&lt;/a&gt; &lt;a href=&#34;https://t.co/BJ0Mc27vR5&#34;&gt;pic.twitter.com/BJ0Mc27vR5&lt;/a&gt;&lt;/p&gt;&amp;mdash; 鬼雷 昇炎 (@kirai_s) &lt;a href=&#34;https://twitter.com/kirai_s/status/934699058542678016?ref_src=twsrc%5Etfw&#34;&gt;2017年11月26日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;元画像が上がっていたので使わせていただきました。&lt;/p&gt;

&lt;p&gt;背景に相当する部分の画像がなかったので自分で加工したり、そのまま矩形状にスプライトを切り出すと被ってしまう部分があったのでいくつかのパーツに分けたりしました。&lt;/p&gt;

&lt;h2 id=&#34;製作期間&#34;&gt;製作期間&lt;/h2&gt;

&lt;p&gt;ゲーム本体の作成(アセットの用意・環境構築含む)： 一晩&lt;br /&gt;
公開のためのWebページデザインやTwitterカード、faviconの用意：半日&lt;br /&gt;
公開後の難易度調整+自動モード機能の追加：半日&lt;/p&gt;

&lt;h2 id=&#34;フレームワーク選定&#34;&gt;フレームワーク選定&lt;/h2&gt;

&lt;p&gt;ブラウザで動作するゲームを作ろうと思ったため、基本的にはNode環境で開発を進めていくことになります。
高速に開発するためにTypeScriptで記述することとしたうえで、使用するツールを選定していきました。&lt;/p&gt;

&lt;h3 id=&#34;pixi-js&#34;&gt;PIXI.js&lt;/h3&gt;

&lt;p&gt;PC・モバイル両方のブラウザで動作するゲームという方針のため、HTML5 Canvas系のライブラリを使うことにしました。
npm上で型定義が用意されているものを使いたかったので、今回は&lt;a href=&#34;http://www.pixijs.com/&#34;&gt;PIXI.js&lt;/a&gt;を選択しました。&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;shell&#34;&gt;$ npm install --save-dev @types/pixi.js&lt;/code&gt;で型定義ファイルをインストールし、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import * as PIXI from &amp;quot;pixi.js&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でPIXI.jsの型情報を使用可能になります。&lt;/p&gt;

&lt;h4 id=&#34;ビルドシステム&#34;&gt;ビルドシステム&lt;/h4&gt;

&lt;p&gt;また、今回はブラウザを動作対象とするため、jsファイルのバンドルとBabel化のためにwebpackを使用しました。
実際のところwebpackもBabelもこれまで使ったことがなかったのですが、なんとかts-loaderとbabel-loaderでTypeScriptのソースコードをBabel化してバンドルするところまでやりました。&lt;/p&gt;

&lt;p&gt;期末試験直前であまり学習コストをかけられず、これ以上webpackであれこれするのは怖くなったので、jsファイル以外の静的ファイルのコピーなどはrimrafやcpxを使い、npm scriptsでビルドすることにしました。
また開発中の自動コンパイルのために、chokidarとbrowser-syncを使いました。&lt;/p&gt;

&lt;h2 id=&#34;設計&#34;&gt;設計&lt;/h2&gt;

&lt;p&gt;一定時間ごとにゲームループをまわし、大元のゲームオブジェクトから各マネージャのupdateメソッドを呼び出して処理を行い、最後にレンダリングを行うという基本的な設計としています。&lt;/p&gt;

&lt;p&gt;今回は、エンティティを管理するエンティティマネージャ、スコアを管理するスコアマネージャ、エンティティとスコア以外のゲーム内表示を管理するエフェクトマネージャ、ユーザーからの入力を受け取るインプットマネージャを用意しました。
また、スコアマネージャはインスタンスを2つ生成してそれぞれ取得スコアとミス回数を管理するようにしています。&lt;/p&gt;

&lt;p&gt;ステートマシンを用いてゲーム状態の遷移を管理する方法もありますが、今回はタイトルとゲーム中とゲームオーバーの三状態しかなく、また各エンティティも決まった動きしかしないため不要と判断しました。&lt;/p&gt;

&lt;p&gt;エンティティごとにスプライトのテクスチャを用意しておく必要があり、これはstaticメンバとして各エンティティのクラスに紐付けることにしました。
このテクスチャの生成はアセットのローディングが終わった後に行う必要があるため、エンティティマネージャの初期化時に各staticメソッドを呼び出すことで初期化するようにしました。&lt;/p&gt;

&lt;h3 id=&#34;eventemitterによるメッセージング&#34;&gt;EventEmitterによるメッセージング&lt;/h3&gt;

&lt;p&gt;PIXI.jsで用意されているクラスは&lt;a href=&#34;https://github.com/primus/eventemitter3&#34;&gt;EventEmitter&lt;/a&gt;を継承しており、イベント駆動でのオブジェクト間のメッセージングが可能です。
たとえば&lt;code&gt;アライさん&lt;/code&gt;オブジェクトは&lt;code&gt;Hat&lt;/code&gt;コレクションに対する参照を持ちませんが、イベントの発火にフックしてエンティティマネージャがメソッド引数にコレクションの参照を流し込むことで、&lt;code&gt;アライさん&lt;/code&gt;オブジェクトは外部の参照を持つことなく&lt;code&gt;Hat&lt;/code&gt;コレクションにアクセスし、当たり判定の処理を行うことができます。
これにより、ゲーム内エンティティを表すオブジェクト同士を疎結合に保つことができます。
&lt;code&gt;Hat&lt;/code&gt;のように複数のインスタンスが生成される場合、そのたびにイベントの登録を行う必要があるので、このようなクラスはファクトリを通して実体化するようにします。&lt;/p&gt;

&lt;p&gt;その他にも、インプットマネージャがキーボード入力を受け取ったり、ゲーム画面上に配置されている透明のスプライトに対するクリック・タッチ入力を受け取った場合に、入力された動作に応じたイベントを発火することで、入力の種類を隠蔽したうえでそれにフックする処理を定義可能になります。&lt;/p&gt;

&lt;h2 id=&#34;はまりどころ&#34;&gt;はまりどころ&lt;/h2&gt;

&lt;p&gt;ちょっとしたミスなどですが、詰まった点について。&lt;/p&gt;

&lt;h3 id=&#34;エンティティの消去&#34;&gt;エンティティの消去&lt;/h3&gt;

&lt;p&gt;ループ中にループ対象の配列を変更するな、というのは基本ですが、ゲームの場合当たり判定がヒットしたエンティティを消去したいという場面は多いです。
&lt;code&gt;Hat&lt;/code&gt;コレクションに対してループを回して&lt;code&gt;update()&lt;/code&gt;を呼び出し、その処理の中で&lt;code&gt;Hat&lt;/code&gt;オブジェクトを消去してしまい、それ以降のオブジェクトの処理がおかしくなるというバグが発生しました。&lt;/p&gt;

&lt;p&gt;対処として、まずエンティティに&lt;code&gt;alive&lt;/code&gt;フラグを持たせておき、エンティティを消去したいときには以下のような処理を呼び出すだけにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;die() {
    this.alive = false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、全エンティティのupdate処理終了後に再度ループを回し、ここでaliveフラグがfalseとなっているエンティティをコレクションから取り除きます。
ただし、死んだはずのオブジェクトの当たり判定が残ったりすることを防ぐため、一度aliveフラグがfalseになったエンティティは処理から除外するようにしておく必要があります。
また、結局ループ中の配列を弄ることになるので、このループの中でおかしなことが起きるかもしれないので注意が必要です(とはいえ削除処理を別のループに分けていることで、最悪でもエンティティの削除が次回以降のフレームに引き延ばされてしまう程度の影響しか起きません)。&lt;/p&gt;

&lt;p&gt;ループ中に配列から安全に要素を取り除く方法としては、要素の削除時にイテレータをうまく調整したり、ループインデックスをずらして対処するなどといった方法がありますが、イテレータの仕様を正しく理解している必要があったり、削除処理のタイミングで自分の外側のループのことを考えないといけなかったりするため、処理がやや煩雑になりがちです。
そこで技巧的な方法として、ループのインデックスを配列の末尾から順に0に向けてデクリメントしていけば、途中で要素が取り除かれてもループに影響が出ない、といったものがあります。
ただし処理順は逆になってしまうので、それが気になるなら先述したエンティティ削除用のループでのみ行うなどする必要があります(エンティティの削除処理程度なら順序が変わっても影響が出ないため)。
最も単純なのはループ前にコレクションをコピーしてループを回すことですが、ゲームプログラムで毎フレームごとに配列のコピーを生成するのはパフォーマンス的に避けたいところでもあります。
なお今回は、&lt;code&gt;Hat&lt;/code&gt;オブジェクトは同時に10個も存在することはないため、毎回配列をコピーして削除用のループを回すことにしました。&lt;/p&gt;

&lt;h3 id=&#34;faviconの配信&#34;&gt;faviconの配信&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;favicon.ico&lt;/code&gt;を配信しようと思ったのですが、&lt;a href=&#34;https://tatamo.github.io/japari-watch/&#34;&gt;https://tatamo.github.io/japari-watch/&lt;/a&gt; というURLのルートパスは&lt;a href=&#34;https://tatamo.github.io/&#34;&gt;https://tatamo.github.io/&lt;/a&gt; であるため、&lt;a href=&#34;https://tatamo.github.io/japari-watch/&#34;&gt;https://tatamo.github.io/japari-watch/&lt;/a&gt; 直下にfaviconを配置しても正しく読み込ませることができません。
そのため、&lt;code&gt;&amp;lt;link rel=&amp;quot;shortcut icon href=&amp;quot;favicon.ico&amp;quot; type=&amp;quot;image/x-icon&amp;quot;&amp;quot;&amp;gt;&lt;/code&gt;などとして明示的にfavicon.icoの位置を示す必要がありました。&lt;/p&gt;

&lt;p&gt;また、&lt;code&gt;manifest.json&lt;/code&gt;を&lt;a href=&#34;https://tatamo.github.io/japari-watch/favicons/manifest.json&#34;&gt;https://tatamo.github.io/japari-watch/favicons/manifest.json&lt;/a&gt; に、同様にandroid用のアイコン画像を&lt;code&gt;favicons/&lt;/code&gt;ディレクトリに配置していました。
&lt;code&gt;manifest.json&lt;/code&gt;中の相対パスは基準となるディレクトリが&lt;code&gt;manifest.json&lt;/code&gt;自身となることを知らなかったので、srcパスを&lt;code&gt;&amp;quot;favicons\/android-icon-***.png&amp;quot;&lt;/code&gt;としたところ、&lt;code&gt;favicons/favicons/&lt;/code&gt;が読まれてしまって正しくアイコンを配信できなかったりしました。&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.pixijs.com/&#34;&gt;PIXI.js&lt;/a&gt;はチュートリアルだけは読んだことがあるという状態で、一度実際に使ってみたいと思っていたので使用することができて良かったです。
ドキュメントをろくに読み込まずに使いたい機能だけ調べて使うといった感じでしたが、かなり高速にゲーム開発ができたので非常に便利でした。
またwebpackやBabel、npm scriptsをメインに用いたビルドなどもはじめてだったのですがいい感じにできました。&lt;/p&gt;

&lt;p&gt;使用した画像については作者である&lt;a href=&#34;https://twitter.com/kirai_s&#34;&gt;@kirai_s&lt;/a&gt;さんに確認を得ないまま加工して作り始めてしまったのですが、使用を快く承諾していただけました。
この場を借りてお礼申し上げます。&lt;/p&gt;
      </description>
    </item>
    
    <item>
      <title>ブログのシンタックスハイライトを改善しました</title>
      <link>http://tatamo.81.la/blog/2017/11/08/syntax-highlight-improvement/</link>
      <pubDate>Wed, 08 Nov 2017 18:00:00 +0900</pubDate>
      
      <guid>http://tatamo.81.la/blog/2017/11/08/syntax-highlight-improvement/</guid>
      <description>
        &lt;p&gt;このブログのシンタックスハイライトには&lt;a href=&#34;https://highlightjs.org/&#34;&gt;highlight.js&lt;/a&gt;を使用していますが、使い勝手を上げるために調整を行いました。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;コードの強調は不要だがhighlight-jsのテーマは使いたい&#34;&gt;コードの強調は不要だがhighlight.jsのテーマは使いたい&lt;/h2&gt;

&lt;p&gt;プログラムの実行結果など、プログラムそのもの以外を&lt;code class=&#34;html&#34;&gt;&amp;lt;code&amp;gt;&lt;/code&gt;タグで囲いたくなる場合が何度かありました。
class要素に&lt;code&gt;nohighlight&lt;/code&gt;を指定すればハイライトは行われなくなりますが、highlight.jsのCSSテーマも適用されなくなります。&lt;/p&gt;

&lt;h2 id=&#34;インライン要素のハイライトをデフォルトで無効化したい&#34;&gt;インライン要素のハイライトをデフォルトで無効化したい&lt;/h2&gt;

&lt;p&gt;さらに、インライン要素のハイライトを行う場合、対象となるコードが短いために言語の自動検出がうまく働かないことが多いです。
ブロック要素ではMarkdownでcode部分を囲う際に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;```javascript
/* code */
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とすることで言語注釈をつけることができますが、インラインの場合はこれができないため言語を明示的に指定する場合には直接codeタグを書く必要があります。&lt;/p&gt;

&lt;h2 id=&#34;解決策&#34;&gt;解決策&lt;/h2&gt;

&lt;p&gt;今のところ&lt;code class=&#34;html&#34;&gt;&amp;lt;code&amp;gt;&lt;/code&gt;で囲った部分はすべてhighlight.jsのテーマを適用してしまって問題はないので、&lt;code&gt;nohighlight&lt;/code&gt;を指定した場合でもCSSテーマが適用されるようにします。
また、インライン要素の場合はデフォルトで&lt;code&gt;nohighlight&lt;/code&gt;にしてしまって、必要がある場合のみHTMLタグを記述して明示的に言語を指定することとしました。
&lt;a href=&#34;http://tatamo.81.la/blog/2015/12/12/apply-highlightjs-to-inline/&#34;&gt;highlight.jsをインライン要素にも適用できるようにした&lt;/a&gt; で書いたコードを、さらに手直しします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// hljs.initHighlightingOnLoad();
window.addEventListener(&amp;quot;DOMContentLoaded&amp;quot;, () =&amp;gt; {
	const elements = document.getElementsByTagName(&amp;quot;code&amp;quot;);
	for (const el of elements) {
		if (el.parentNode.tagName != &amp;quot;PRE&amp;quot;) {
			// インライン要素
			el.style.display = &amp;quot;inline&amp;quot;;
			el.style.margin = &amp;quot;0 2px&amp;quot;;
			el.style.padding = &amp;quot;1px 3px&amp;quot;;
			if (el.classList.length == 0) {
				// classが指定されていない場合はnohighlightとする
				el.classList.add(&amp;quot;nohighlight&amp;quot;);
			}
		}
		hljs.highlightBlock(el);
		// nohighlightでもテーマは適用する
		if (el.classList.contains(&amp;quot;nohighlight&amp;quot;) ||
			el.classList.contains(&amp;quot;lang-nohighlight&amp;quot;) ||
			el.classList.contains(&amp;quot;language-nohighlight&amp;quot;)) {
			el.classList.add(&amp;quot;hljs&amp;quot;);
		}
	}
}, false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、&lt;code class=&#34;html&#34;&gt;&amp;lt;code&amp;gt;&lt;/code&gt;タグでclassの指定が明示的に行われていない場合は自動的に&lt;code&gt;nohighlight&lt;/code&gt;クラスを追加しています。
この処理はhighlight.jsでのハイライト化の処理を行う前に持ってきました。
スタイルの適用も同じように前に持ってきましたが、特に問題はないようです。
次に、&lt;code&gt;nohighlight&lt;/code&gt;が指定されていてハイライトが行われていない要素に対して、classにhighlight.jsで使用されているクラスである&lt;code&gt;hljs&lt;/code&gt;を指定することでテーマの適用を行っています。&lt;/p&gt;

&lt;p&gt;あとは既存の記事をこの変更に合わせて修正しました。
ところどころ不自然なハイライトが行われていた箇所がありましたが、これで改善されました。&lt;/p&gt;
      </description>
    </item>
    
  </channel>
</rss>